/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/black-engine/dist/black-engine.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/black-engine/dist/black-engine.module.js ***!
  \***************************************************************/
/*! exports provided: Acceleration, AlphaOverLife, AnchorOverLife, AnimationController, AnimationInfo, Arcade, Asset, AssetLoader, AssetManager, AssetManagerState, AssetType, AtlasTexture, AtlasTextureAsset, BVGAsset, BVGParser, BVGStyle, BindingType, BitmapFontAsset, BitmapFontCharData, BitmapFontData, BitmapTextField, BitmapTextRenderer, BitmapTextRendererCanvas, Black, BlendMode, BoxCollider, BoxToBoxPair, BoxToCirclePair, BroadPhase, Camera, CanvasDriver, CanvasRenderTexture, CapsStyle, Circle, CircleCollider, CircleToCirclePair, Collider, ColorHelper, ColorOverLife, ColorScatter, ColorScatterBase, Component, Curve, Debug, Device, DisplayObject, DisplayObjectRendererCanvas, DistortionEffect, Ease, Emitter, EmitterRendererCanvas, EmitterSortOrder, EmitterState, Engine, FillRule, FloatCurveScatter, FloatScatter, FloatScatterBase, FontAlign, FontAsset, FontFaceAssetLoader, FontMetrics, FontStyle, FontVerticalAlign, FontWeight, GameObject, Glob, Graphics, GraphicsCommand, GraphicsCommandType, GraphicsData, GraphicsGradient, GraphicsLinearGradient, GraphicsPath, GraphicsPattern, GraphicsRenderer, GraphicsRendererCanvas, HSV, ImageAssetLoader, InitialAnchor, InitialColor, InitialLife, InitialMass, InitialPosition, InitialRotation, InitialScale, InitialTexture, InitialVelocity, Input, InputComponent, Interpolation, JSONAsset, JointStyle, Key, KeyInfo, Line, LoaderType, MapMap, MasterAudio, MathEx, Matrix, Message, MessageBinding, MessageDispatcher, MessageType, Modifier, ObjectPool, Orientation, Oriented, Pair, ParserBase, Particle, Perlin, Polygon, Projection, RGB, RadialScatter, Range, Rectangle, RenderSession, RenderTarget, RenderTargetCanvas, Renderer, ReverbEffect, RigidBody, RotationOverLife, ScaleOverLife, Scatter, SimpleEQ, Sound, SoundAsset, SoundAtlasAsset, SoundAtlasClip, SoundChannel, SoundClip, SoundEffect, SoundInstance, SoundListener, SoundState, Spine, SplashScreen, Sprite, SpriteRendererCanvas, Stage, StageScaleMode, StereoPanner, System, TextField, TextMetricsData, TextMetricsEx, TextRenderer, TextRendererCanvas, TextSegmentMetricsData, TextStyle, Texture, TextureAsset, TextureOverLife, TilingInfo, Time, Timer, Tween, Vector, VectorCurveScatter, VectorField, VectorScatter, VectorScatterBase, VectorTextureAsset, VideoNullDriver, Viewport, XHRAssetLoader, XMLAsset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Acceleration", function() { return Acceleration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaOverLife", function() { return AlphaOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnchorOverLife", function() { return AnchorOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationController", function() { return AnimationController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationInfo", function() { return AnimationInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arcade", function() { return Arcade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Asset", function() { return Asset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetLoader", function() { return AssetLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetManager", function() { return AssetManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetManagerState", function() { return AssetManagerState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetType", function() { return AssetType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AtlasTexture", function() { return AtlasTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AtlasTextureAsset", function() { return AtlasTextureAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BVGAsset", function() { return BVGAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BVGParser", function() { return BVGParser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BVGStyle", function() { return BVGStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BindingType", function() { return BindingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapFontAsset", function() { return BitmapFontAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapFontCharData", function() { return BitmapFontCharData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapFontData", function() { return BitmapFontData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapTextField", function() { return BitmapTextField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapTextRenderer", function() { return BitmapTextRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BitmapTextRendererCanvas", function() { return BitmapTextRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Black", function() { return Black; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlendMode", function() { return BlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxCollider", function() { return BoxCollider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxToBoxPair", function() { return BoxToBoxPair; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxToCirclePair", function() { return BoxToCirclePair; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BroadPhase", function() { return BroadPhase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasDriver", function() { return CanvasDriver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderTexture", function() { return CanvasRenderTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CapsStyle", function() { return CapsStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleCollider", function() { return CircleCollider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleToCirclePair", function() { return CircleToCirclePair; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collider", function() { return Collider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorHelper", function() { return ColorHelper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorOverLife", function() { return ColorOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorScatter", function() { return ColorScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorScatterBase", function() { return ColorScatterBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Debug", function() { return Debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Device", function() { return Device; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayObject", function() { return DisplayObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayObjectRendererCanvas", function() { return DisplayObjectRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistortionEffect", function() { return DistortionEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ease", function() { return Ease; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Emitter", function() { return Emitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmitterRendererCanvas", function() { return EmitterRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmitterSortOrder", function() { return EmitterSortOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EmitterState", function() { return EmitterState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Engine", function() { return Engine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FillRule", function() { return FillRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatCurveScatter", function() { return FloatCurveScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatScatter", function() { return FloatScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatScatterBase", function() { return FloatScatterBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontAlign", function() { return FontAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontAsset", function() { return FontAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontFaceAssetLoader", function() { return FontFaceAssetLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontMetrics", function() { return FontMetrics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontStyle", function() { return FontStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontVerticalAlign", function() { return FontVerticalAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontWeight", function() { return FontWeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameObject", function() { return GameObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Glob", function() { return Glob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Graphics", function() { return Graphics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsCommand", function() { return GraphicsCommand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsCommandType", function() { return GraphicsCommandType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsData", function() { return GraphicsData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsGradient", function() { return GraphicsGradient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsLinearGradient", function() { return GraphicsLinearGradient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsPath", function() { return GraphicsPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsPattern", function() { return GraphicsPattern; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsRenderer", function() { return GraphicsRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphicsRendererCanvas", function() { return GraphicsRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSV", function() { return HSV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageAssetLoader", function() { return ImageAssetLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialAnchor", function() { return InitialAnchor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialColor", function() { return InitialColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialLife", function() { return InitialLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialMass", function() { return InitialMass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialPosition", function() { return InitialPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialRotation", function() { return InitialRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialScale", function() { return InitialScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialTexture", function() { return InitialTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitialVelocity", function() { return InitialVelocity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return Input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputComponent", function() { return InputComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolation", function() { return Interpolation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONAsset", function() { return JSONAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JointStyle", function() { return JointStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Key", function() { return Key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyInfo", function() { return KeyInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderType", function() { return LoaderType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapMap", function() { return MapMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MasterAudio", function() { return MasterAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathEx", function() { return MathEx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Message", function() { return Message; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageBinding", function() { return MessageBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageDispatcher", function() { return MessageDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageType", function() { return MessageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Modifier", function() { return Modifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectPool", function() { return ObjectPool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Orientation", function() { return Orientation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Oriented", function() { return Oriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pair", function() { return Pair; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParserBase", function() { return ParserBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Perlin", function() { return Perlin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projection", function() { return Projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB", function() { return RGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RadialScatter", function() { return RadialScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rectangle", function() { return Rectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderSession", function() { return RenderSession; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderTarget", function() { return RenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderTargetCanvas", function() { return RenderTargetCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer", function() { return Renderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverbEffect", function() { return ReverbEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RigidBody", function() { return RigidBody; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotationOverLife", function() { return RotationOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleOverLife", function() { return ScaleOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scatter", function() { return Scatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleEQ", function() { return SimpleEQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sound", function() { return Sound; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundAsset", function() { return SoundAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundAtlasAsset", function() { return SoundAtlasAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundAtlasClip", function() { return SoundAtlasClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundChannel", function() { return SoundChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundClip", function() { return SoundClip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundEffect", function() { return SoundEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundInstance", function() { return SoundInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundListener", function() { return SoundListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SoundState", function() { return SoundState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spine", function() { return Spine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplashScreen", function() { return SplashScreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteRendererCanvas", function() { return SpriteRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stage", function() { return Stage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StageScaleMode", function() { return StageScaleMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoPanner", function() { return StereoPanner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextField", function() { return TextField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextMetricsData", function() { return TextMetricsData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextMetricsEx", function() { return TextMetricsEx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextRenderer", function() { return TextRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextRendererCanvas", function() { return TextRendererCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextSegmentMetricsData", function() { return TextSegmentMetricsData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextStyle", function() { return TextStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureAsset", function() { return TextureAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureOverLife", function() { return TextureOverLife; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TilingInfo", function() { return TilingInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Time", function() { return Time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorCurveScatter", function() { return VectorCurveScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorField", function() { return VectorField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorScatter", function() { return VectorScatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorScatterBase", function() { return VectorScatterBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorTextureAsset", function() { return VectorTextureAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoNullDriver", function() { return VideoNullDriver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewport", function() { return Viewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRAssetLoader", function() { return XHRAssetLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XMLAsset", function() { return XMLAsset; });
/**
 * @preserve
 * Blacksmith 2D v0.5.11
 * 
 * SIMPLIFIED BSD LICENSE
 * ======================
 * 
 * Copyright 2019 Borna Technology Ltd. All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY BORNA TECHNOLOGY "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BORNA TECHNOLOGY OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Borna Technology.
 */

// @ifdef DEBUG
/**
 * Utility class for logging and debugging.
 *
 * @cat core
 */
class Debug {
  constructor() {
    Debug.assert(false, 'Static class.');
  }

  static isNumber(...values) {
    values.forEach(x => {
      if (typeof x === 'number' && isNaN(parseFloat(x)) === false && isFinite(x) === true)
        return;

      let message = 'Not a number.';

      if (Debug.logOnFail)
        console.error('[ASSERT]', message);

      if (Debug.throwOnFail)
        throw new Error(message);
    });
  }

  static assert(value, message) {
    if (value === true)
      return;

    message = message == null ? 'Assertion failed.' : message;

    if (Debug.logOnFail)
      console.error('[ASSERT]', message);

    if (Debug.throwOnFail)
      throw new Error(message);
  }

  static assertWarn(value, message) {
    if (value === true)
      return;

    message = message == null ? 'Assertion warning.' : message;
    Debug.warn(message);
  }

  static assertInfo(value, message) {
    if (value === true)
      return;

    message = message == null ? 'Assertion info.' : message;
    Debug.info(message);
  }

  /**
   * Outputs a message to the console
   * 
   * @param  {...string} message
   */
  static log(...message) {
    console.info('%c%s', 'color: #000000', 'LOG:', ...message);
  }

  /**
   * Outputs a info message to the console
   * 
   * @param  {...string} message
   */
  static info(...message) {
    console.info('%c%s', 'color: #003bd2', 'INFO:', ...message);
  }

  /**
   * Outputs a warning message to the console
   * 
   * @param  {...string} message
   */
  static warn(...message) {
    console.info('%c%s', 'color: #f67400', 'WARN:', ...message);
  }

  /**
   * Outputs a error message to the console
   * 
   * @param  {...string} message
   */
  static error(...message) {
    console.info('%c%s', 'color: #d50000', 'ERROR:', ...message);
  }

  /**
   * 
   * @param {string} name 
   */
  static time(name) {
    Debug.timeProfiles[name] = performance.now();
  }

  /**
   * 
   * @param {string} name 
   */
  static timeEnd(name) {
    Debug.timeProfiles[name] = performance.now() - Debug.timeProfiles[name];
  }
}

Debug.throwOnFail = true;
Debug.logOnFail = false;
Debug.timeProfiles = {};
// @endif

/**
 * Set of math helper functions.
 *
 * @cat core
 * @static
 */
class MathEx {
  /**
   * Generates a random number in given range.
   *
   * @param {number} a A lower value.
   * @param {number} b A greater value.
   * @return {number}
   */
  static randomBetween(a, b) {
    return Math.floor(Math.random() * (b - a + 1) + a);
  }

  /**
   * Clamps given value to min max range.
   *
   * @param {number} value A value to clamp.
   * @param {number} min A lower threshold.
   * @param {number} max A greater threshold.
   * @return {number}
   */
  static clamp(value, min, max) {
    return (value < min) ? min : (value > max) ? max : value;
  }

  /**
   * Calculates distance between two points.
   * 
   * @param  {number} x1 First point x-coordinate.
   * @param  {number} y1 First point y-coordinate.
   * @param  {number} x2 Second point x-coordinate.
   * @param  {number} y2 Second point y-coordinate.
   * @return {number}
   */
  static distance(x1, y1, x2, y2) {
    let x = x1 - x2;
    let y = y1 - y2;

    return Math.sqrt((x * x) + (y * y));
  }

  /**
   * Calculates squared distance between two points.
   * 
   * @param  {number} x1 First point x-coordinate.
   * @param  {number} y1 First point y-coordinate.
   * @param  {number} x2 Second point x-coordinate.
   * @param  {number} y2 Second point y-coordinate.
   * @return {number}
   */
  static distanceSqr(x1, y1, x2, y2) {
    let x = x1 - x2;
    let y = y1 - y2;

    return (x * x) + (y * y);
  }

  /**
   * Calculates angle in radians between two points.
   * 
   * @param  {number} x1 First point x-coordinate.
   * @param  {number} y1 First point y-coordinate.
   * @param  {number} x2 Second point x-coordinate.
   * @param  {number} y2 Second point y-coordinate.
   * @return {number}
   */
  static angleBetween(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }

  /**
   * Maps one range onto another.
   *
   * @param  {number} value A value to map.
   * @param  {number} fromA Lower value from first range.
   * @param  {number} fromB Greater value from first range.
   * @param  {number} toA Lower value from second range.
   * @param  {number} toB Greater value from second range.
   * @return {number}
   */
  static mapRange(value, fromA, fromB, toA, toB) {
    return toA + (toB - toA) * (value - fromA) / (fromB - fromA);
  }

  /**
   * Linearly interpolates a number.
   *
   * @param {number} a First value.
   * @param {number} b Second value.
   * @param {number} t A value between 0 and 1.
   * @return {number}
   */
  static lerp(a, b, t) {
    return a + t * (b - a);
  }

  /**
   * Compares two numbers using given epsilon value.
   *
   * @param {number} a First value.
   * @param {number} b Second value.
   * @param {number} epsilon Comparison threshold.
   * @returns {boolean}
   */
  static equals(a, b, epsilon = Number.EPSILON) {
    return (a - epsilon < b) && (a + epsilon > b);
  }
}

/**
 * Pi divided by 4.
 * @type {number}
 */
MathEx.PI_Q = Math.PI / 4;

/**
 * PI multiplied by 2.
 * @type {number}
 */
MathEx.PI2 = Math.PI * 2;

/**
 * Degrees to radians constant.
 * @const
 * @type {number}
 */
MathEx.DEG2RAD = 0.01745329251994329576923690768489;

/**
 * Radians to degrees constant.
 * @type {number}
 */
MathEx.RAD2DEG = 57.295779513082320876798154814105;

class Perlin {
  constructor(repeat = 0) {
    this.mRepeat = 0;
    this.mPerm = [];
    
    for (let x = 0; x < 512; x++)
      this.mPerm.push(Perlin.__permutation[x % 256]);
  }

  __perlin(x, y, z) {
    if (this.mRepeat > 0) {
      x = x % this.mRepeat;
      y = y % this.mRepeat;
      z = z % this.mRepeat;
    }

    let p = this.mPerm;

    const xi = ~~x & 255;
    const yi = ~~y & 255;
    const zi = ~~z & 255;
    const xf = x - ~~x;
    const yf = y - ~~y;
    const zf = z - ~~z;
    const u = xf * xf * xf * (xf * (xf * 6 - 15) + 10);
    const v = yf * yf * yf * (yf * (yf * 6 - 15) + 10);
    const w = zf * zf * zf * (zf * (zf * 6 - 15) + 10);

    const aaa = p[p[p[xi] + yi] + zi];
    const aba = p[p[p[xi] + this.inc(yi)] + zi];
    const aab = p[p[p[xi] + yi] + this.inc(zi)];
    const abb = p[p[p[xi] + this.inc(yi)] + this.inc(zi)];
    const baa = p[p[p[this.inc(xi)] + yi] + zi];
    const bba = p[p[p[this.inc(xi)] + this.inc(yi)] + zi];
    const bab = p[p[p[this.inc(xi)] + yi] + this.inc(zi)];
    const bbb = p[p[p[this.inc(xi)] + this.inc(yi)] + this.inc(zi)];

    let x1 = this.lerp(this.grad(aaa, xf, yf, zf), this.grad(baa, xf - 1, yf, zf), u);
    let x2 = this.lerp(this.grad(aba, xf, yf - 1, zf), this.grad(bba, xf - 1, yf - 1, zf), u);
    let y1 = this.lerp(x1, x2, v);

    x1 = this.lerp(this.grad(aab, xf, yf, zf - 1), this.grad(bab, xf - 1, yf, zf - 1), u);
    x2 = this.lerp(this.grad(abb, xf, yf - 1, zf - 1), this.grad(bbb, xf - 1, yf - 1, zf - 1), u);
    let y2 = this.lerp(x1, x2, v);

    return (this.lerp(y1, y2, w) + 1) * 0.5;
  }

  perlin(x, y, z, octaves = 1, persistence = 1) {
    if (octaves === 1 && persistence === 1)
      return this.__perlin(x, y, z);

    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;
    for (let i = 0; i < octaves; i++) {
      total += this.__perlin(x * frequency, y * frequency, z * frequency) * amplitude;

      maxValue += amplitude;

      amplitude *= persistence;
      frequency *= 2;
    }

    return total / maxValue;
  }

  inc(num) {
    num++;
    if (this.mRepeat > 0)
      num %= this.mRepeat;

    return num;
  }

  grad(hash, x, y, z) {
    const b = hash & 15;

    switch (b) {
      case 0: return x + y;
      case 1: return -x + y;
      case 2: return x - y;
      case 3: return -x - y;
      case 4: return x + z;
      case 5: return -x + z;
      case 6: return x - z;
      case 7: return -x - z;
      case 8: return y + z;
      case 9: return -y + z;
      case 10: return y - z;
      case 11: return -y - z;
      case 12: return y + x;
      case 13: return -y + z;
      case 14: return y - x;
      case 15: return -y - z;
    }
  }

  lerp(a, b, t) {
    return a + t * (b - a);
  }
}

Perlin.__permutation = [151, 160, 137, 91, 90, 15,
  131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
  190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
  88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
  77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
  102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
  135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
  5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
  223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
  129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
  251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
  49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
  138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
];

/**
 * A double key map.
 * @cat utils
 */
class MapMap {
  constructor() {
    this.mMap = new Map();
  }

  /**
   * Returns true if value found.
   * 
   * @param {string} key1 
   * @param {string} key2 
   */
  has(key1, key2) {
    return this.mMap.has(key1) && this.mMap.get(key1).has(key2);
  }

  /**
   * Sets or updates value by given keys.
   * 
   * @param {string} key1 
   * @param {string} key2 
   * @param {*} value 
   */
  set(key1, key2, value) {
    let map = this.mMap.get(key1);

    if (map == null) {
      map = new Map();
      this.mMap.set(key1, map);
    }
    map.set(key2, value);
  }

  /**
   * Returns value by given keys.
   * 
   * @param {string} key1 
   * @param {string} key2 
   * @returns {*}
   */
  get(key1, key2) {
    let map = this.mMap.get(key1);
    if (map != null) {
      return this.mMap.get(key1) && this.mMap.get(key1).get(key2);
    }
    return null;
  }
}

/**
 * A simple object pool class. Used to avoid GC.
 * 
 * @cat utils
 */
class ObjectPool {
  /**
   * Creates new ObjectPool instance.
   * @param {Function} type 
   * @param {number} capacity 
   */
  constructor(type, capacity = 100) {
    /** 
     * @ignore
     * @type {Array<*>} 
     */
    this.mReleased = [];

    /** 
     * @ignore 
     * @type {number} 
     */
    this.mCapacity = capacity;

    /** 
     * @ignore 
     * @type {Function} 
     */
    this.mType = type;
  }

  /**
   * Gets/Sets capacity of the pool.
   * 
   * @returns {number}
   */
  get capacity() {
    return this.mCapacity;
  }

  /**
   * @param {number} value
   */
  set capacity(value) {
    Debug.assert(value !== 0, 'Capacity cannot be equal to zero.');
    Debug.assert(value > -1, 'Capacity cannot be smaller then -1.');

    this.mCapacity = value;

    if (this.mCapacity > this.mReleased.length)
      this.mReleased.splice(0, this.mReleased.length - this.mCapacity);
  }

  /**
   * Releases all objects from the pool.
   */
  releaseAll() {
    this.mReleased.splice(0, this.mReleased.length);
  }

  /**
   * Returns new object instance or an object from the pool.
   */
  get() {
    return this.mReleased.length > 0 ? this.mReleased.pop() : new this.mType();
  }

  /**
   * Releases given object.
   * 
   * @param {*} object 
   */
  release(object) {
    if (this.mCapacity === -1 || this.mReleased.length < this.mCapacity)
      this.mReleased.push(object);
  }
}

/**
 * RGB helper struct.
 * 
 * @cat utils
 */
class RGB {
  /**
   * Creates new RGB instance.
   * 
   * @param {number} r 
   * @param {number} g 
   * @param {number} b 
   */
  constructor(r = 0, g = 0, b = 0) {
    /** 
     * @ignore 
     * @type {number} 
     * */
    this.r = r;

    /** 
     * @ignore 
     * @type {number} 
     * */
    this.g = g;

    /** 
     * @ignore 
     * @type {number} 
     * */
    this.b = b;
  }
}

/**
 * Hue, saturation, lightness helper class.
 * 
 * @cat utils
 */
class HSV {
  /**
   * Creates new HSV instance.
   * 
   * @param {number} h
   * @param {number} s 
   * @param {number} v 
   */
  constructor(h = 0, s = 0, v = 0) {
    /** 
     * @ignore 
     * @type {number} 
     */
    this.h = h;

    /** 
     * @ignore 
     * @type {number} 
     */
    this.s = s;

    /** 
     * @ignore 
     * @type {number} 
     */
    this.v = v;
  }
}

/** 
 * Set of methods related to color transformations.
 * 
 * @cat utils
 * @static
*/
class ColorHelper {
  /**
   * Converts number color to RGB object.
   *
   * @param {number} hex The color to convert.
   * @returns {black-engine~RGB} The resulting string.
   */
  static hex2rgb(hex) {
    return new RGB(hex >> 16 & 255, hex >> 8 & 255, hex & 255);
  }

  /**
   * Converts RGB object into number color.
   *
   * @param {black-engine~RGB} rgb The object, which contains 'r', 'g' and 'b' properties.
   * @returns {number} The resulting uint.
   */
  static rgb2hex(rgb) {
    return rgb.r << 16 | rgb.g << 8 | rgb.b;
  }

  /**
   * Converts HSV object into RGB object.
   *
   * @param {black-engine~HSV} hsv The object, which contains 'h', 's' and 'v' properties.
   * @returns {black-engine~RGB} The resulting RGB object.
   */
  static hsv2rgb(hsv) {
    let { h, s, v } = hsv;
    let r = 0;
    let g = 0;
    let b = 0;

    let i = Math.floor(h * 6);
    let f = h * 6 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0: r = v; g = t; b = p; break;
      case 1: r = q; g = v; b = p; break;
      case 2: r = p; g = v; b = t; break;
      case 3: r = p; g = q; b = v; break;
      case 4: r = t; g = p; b = v; break;
      case 5: r = v; g = p; b = q; break;
    }

    r *= 255;
    g *= 255;
    b *= 255;

    return new RGB(r, g, b);
  }

  /**
   * Converts RGB object into HSV object.
   *
   * @param {black-engine~RGB} rgb The object, which contains 'r', 'g' and 'b' properties.
   * @returns {black-engine~HSV} The resulting HSV object.
   */
  static rgb2hsv(rgb) {
    let { r, g, b } = rgb;
    r /= 255;
    g /= 255;
    b /= 255;

    let max = Math.max(r, g, b);
    let min = Math.min(r, g, b);

    let h = 0;
    let s = 0;
    let v = max;

    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }

      h /= 6;
    }

    return new HSV(h, s, v);
  }

  /**
   * Linearly interpolates between two colors within HSV model.
   * 
   * @param {number} hex1 First color number
   * @param {number} hex2 Second color number 
   * @param {number} factor A value between 0 and 1
   */
  static lerpHSV(hex1, hex2, factor = 0.5) {
    let c1 = ColorHelper.rgb2hsv(ColorHelper.hex2rgb(hex1));
    let c2 = ColorHelper.rgb2hsv(ColorHelper.hex2rgb(hex2));

    let h = 0;
    let d = c2.h - c1.h;

    if (c1.h > c2.h) {
      let h3 = c2.h;
      c2.h = c1.h;
      c1.h = h3;
      d = -d;
      factor = 1 - factor;
    }

    if (d > 0.5) {
      c1.h = c1.h + 1;
      h = (c1.h + factor * (c2.h - c1.h)) % 1;
    }

    if (d <= 0.5)
      h = c1.h + factor * d;

    let s = c1.s + factor * (c2.s - c1.s);
    let v = c1.v + factor * (c2.v - c1.v);

    return ColorHelper.rgb2hex(ColorHelper.hsv2rgb(new HSV(h, s, v)));
  }

  /**
   * Converts number color to hex string.
   *
   * @param {number} color The color to convert.
   * @returns {string} The resulting hex string.
   */
  static hexColorToString(color) {
    let parsedColor = color.toString(16);
    return '#000000'.substring(0, 7 - parsedColor.length) + parsedColor;
  }

  /**
   * Converts number color to RGBA string.
   *
   * @param {number} color The color to convert.
   * @param {number} [alpha=1] Alpha to use in RGBA string
   * @returns {string} The resulting string.
   */
  static intToRGBA(color, alpha = 1) {
    const r = (color >> 16) & 255;
    const g = (color >> 8) & 255;
    const b = color & 255;

    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
}

/**
 * @private
 * @ignore
 */
const patterns = { '*': '[^/]+', '**': '.+/?[^/]+', '**/': '.+/?' };

/**
 * Helper glob matching class.
 * 
 * @cat utils
 */
class Glob {
  /**
   * Creates new Glob instance.
   * 
   * @param {string} pattern 
   */
  constructor(pattern) {
    this.mRegExp = new RegExp(`^${pattern.replace(/\./g, '\\.').replace(/\*\*$/g, '.+').replace(/(?:\*\*\/|\*\*|\*)/g, s => { return patterns[s]; })}$`);
  }

  /**
   * Tests whenever string matches the glob.
   * 
   * @param {string} string 
   * @returns {boolean}
   */
  test(string) {
    return this.mRegExp.test(string);
  }
}

/**
 * Mathematical representation of a vector.
 *
 * @cat geom
 */
class Vector {
  /**
   * Creates new Vector instance.
   *
   * @param  {number=} [x=0] X-component.
   * @param  {number=} [y=0] y-component.
   */
  constructor(x = 0, y = 0) {
    Debug.isNumber(x, y);
    
    /** 
     * @type {number} X coordinate of a point in the space. 
     */
    this.x = x;

    /** 
     * @type {number} Y coordinate of a point in the space. 
     */
    this.y = y;
  }

  /**
   * Updates values of this vector with a given.
   *
   * @param {number=} [x=0] X-component.
   * @param {number=} [y=0] y-component
   * @return {black-engine~Vector} This.
   */
  set(x = 0, y = 0) {
    Debug.isNumber(x, y);

    this.x = x;
    this.y = y;

    return this;
  }

  /**
   * Adds two vectors.
   *
   * @param {black-engine~Vector} vector The vector object to be added to this.
   * @return {black-engine~Vector} This.
   */
  add(vector) {
    this.x += vector.x;
    this.y += vector.y;

    return this;
  }

  /**
   * Subtract two vectors.
   *
   * @param {black-engine~Vector} vector The vector object to be subtracted.
   * @return {black-engine~Vector} This.
   */
  subtract(vector) {
    this.x -= vector.x;
    this.y -= vector.y;

    return this;
  }

  /**
   * Returns distance between two vectors.
   *
   * @param {black-engine~Vector} vector Second vector to check distance with.
   * @return {number} The distance between two vectors.
   */
  distance(vector) {
    let x = this.x - vector.x;
    let y = this.y - vector.y;

    return Math.sqrt((x * x) + (y * y));
  }

  /**
   * Returns the squared distance between two vectors.
   *
   * @param {black-engine~Vector} vector Second vector to check distance with.
   * @return {number} The distance between two vectors.
   */
  distanceSqr(vector) {
    let x = this.x - vector.x;
    let y = this.y - vector.y;

    return (x * x) + (y * y);
  }

  /**
   * Multiplies two vectors.
   *
   * @param {black-engine~Vector} vector A second vector to multiply with.
   * @return {black-engine~Vector} This.
   */
  multiply(vector) {
    this.x *= vector.x;
    this.y *= vector.y;

    return this;
  }

  /**
   * Multiplies this vector by scalar value.
   *
   * @param {number} scalar The values to mul by.
   * @return {black-engine~Vector} This.
   */
  multiplyScalar(scalar) {
    Debug.isNumber(scalar);

    this.x *= scalar;
    this.y *= scalar;

    return this;
  }

  /**
   * Find dot product between two vectors.
   *
   * @param {black-engine~Vector} vector Second vector to find angle with.
   * @return {number} A scalar value representing dot product.
   */
  dot(vector) {
    return this.x * vector.x + this.y * vector.y;
  }

  /**
   * Returns the length of this vector.
   *
   * @return {number} The length of the vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  /**
   * Returns the squared length of this vector.
   *
   * @return {number} Squared length.
   */
  lengthSqr() {
    return this.x * this.x + this.y * this.y;
  }

  /**
   * Creates unit vector out of this one.
   *
   * @returns {black-engine~Vector} This.
   */
  normalize() {
    let sum = this.lengthSqr();

    if (sum > 0) {
      sum = Math.sqrt(sum);
      this.x /= sum;
      this.y /= sum;
    } else {
      this.x = 0;
      this.y = 0;
    }

    return this;
  }

  /**
   * Clamps values of this vector to given range.
   *
   * @param {number} min Min value.
   * @param {number} max Max value.
   * @return {black-engine~Vector} This.
   */
  clamp(min, max) {
    Debug.isNumber(min, max);

    this.x = MathEx.clamp(this.x, min, max);
    this.y = MathEx.clamp(this.y, min, max);

    return this;
  }

  /**
   * Clamps vector length of this vector to given range.
   *
   * @param {number} min Min value.
   * @param {number} max Max value.
   * @return {black-engine~Vector} This.
   */
  clampLength(min, max) {
    Debug.isNumber(min, max);

    let length = MathEx.clamp(this.length(), min, max);
    this.normalize();
    this.multiplyScalar(length);
    return this;
  }

  /**
   * Linearly interpolates between two vectors.
   *
   * @param {black-engine~Vector} vector The second vector to interpolate values between.
   * @param {number} t      Alpha value.
   * @return {black-engine~Vector} This.
   */
  lerp(vector, t) {
    Debug.isNumber(t);

    this.x = MathEx.lerp(this.x, vector.x, t);
    this.y = MathEx.lerp(this.y, vector.y, t);

    return this;
  }

  /**
   * Copies this vector values into given vector.
   *
   * @param {black-engine~Vector} vector The vector to store values in.
   * @return {black-engine~Vector} Given vector.
   */
  copyTo(vector) {
    vector.x = this.x;
    vector.y = this.y;

    return vector;
  }

  /**
   * Copies values from given vector into this.
   *
   * @param {black-engine~Vector} vector The vector to copy values from.
   * @return {black-engine~Vector} This.
   */
  copyFrom(vector) {
    this.x = vector.x;
    this.y = vector.y;

    return this;
  }

  /**
   * Clones this vector object.
   *
   * @return {black-engine~Vector} New Vector instance.
   */
  clone() {
    return new Vector(this.x, this.y);
  }

  /**
   * Compares two vectors for equality.
   *
   * @param {black-engine~Vector} vector Second vector to compare with.
   * @param {number=} epsilon Threshold.
   * @return {boolean} True if equal.
   */
  equals(vector, epsilon = Number.EPSILON) {
    return vector !== null && (Math.abs(vector.x - this.x) < epsilon) && (Math.abs(vector.y - this.y) < epsilon);
  }

  /**
   * Checks if this vector is empty.
   *
   * @return {boolean} True if both components equal to zero.
   */
  isEmpty() {
    return this.x === 0 && this.y === 0;
  }

  /**
   * Rotates this vector around specified point.
   *
   * @param {black-engine~Vector} vector Center vector.
   * @param {number} rotation Angle in radians.
   * @return {black-engine~Vector} This rotated vector.
   */
  setRotationFrom(vector, rotation) {
    Debug.isNumber(rotation);

    return this
      .subtract(vector)
      .setRotation(rotation)
      .add(vector);
  }

  /**
   *  Rotates this vector around zero vector.
   *
   * @param {number} rotation Angle in radians.
   * @return {black-engine~Vector} This rotated vector.
   */
  setRotation(rotation) {
    Debug.isNumber(rotation);

    let cos = Math.cos(rotation);
    let sin = Math.sin(rotation);

    return this.set(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
  }

  /**
   * Calculates angle in radians within this and specified vectors.
   *
   * @param {black-engine~Vector} vector Second vector.
   * @return {number} Angle in radians.
   */
  angleBetween(vector) {
    return Math.atan2(vector.y - this.y, vector.x - this.x);
  }

  /**
   * Calculates vector angle in radians. Same as heading.
   *
   * @return {number} Angle in radians.
   */
  angle() {
    return Math.atan2(this.y, this.x);
  }

  /**
   * Rotates this vector to normal.
   *
   * @return {black-engine~Vector} This vector.
   */
  perp() {
    return this.set(this.y, -this.x);
  }

  /**
   * Creates new Vector from given angle in radians.
   *
   * @param {number} angle Angle.
   * @param {black-engine~Vector=} outVector Vector to be returned.
   * @return {black-engine~Vector} New Vector object.
   */
  static fromAngle(angle, outVector) {
    Debug.isNumber(angle);

    outVector = outVector || new Vector();
    return outVector.set(Math.cos(angle), Math.sin(angle));
  }
  
  /**
   * Returns random number within this rectangle.
   * @returns {number}
   */
  get random() {
    return MathEx.randomBetween(this.x, this.y);
  }

  /**
   * @ignore
   * @param {black-engine~Vector} vectorMin
   * @param {black-engine~Vector} vectorMax
   * @param {black-engine~Vector=} outVector
   * @return {black-engine~Vector}
   */
  static randomRange(vectorMin, vectorMax, outVector) {
    outVector = outVector || new Vector();

    outVector.x = Math.random() * (vectorMax.x - vectorMin.x) + vectorMin.x;
    outVector.y = Math.random() * (vectorMax.y - vectorMin.y) + vectorMin.y;

    return outVector;
  }

  // @ifdef DEBUG
  /**
   * @ignore
   * @param {number=} [digits=2] Description
   * @return {string} Description
   */
  toString(digits = 2) {
    return `Vector: { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)} }`;
  }
  // @endif
}

/**
 * @ignore
 * @type {black-engine~Vector}
 * @nocollapse
 */
Vector.__cache = new Vector();

/**
 * Recycled vectors pool.
 *
 * @type {black-engine~ObjectPool}
 * @nocollapse
 */
Vector.pool = new ObjectPool(Vector);

/**
 * Mathematical representation of a bezier curve.
 *
 * @cat geom
 */
class Line {
  /**
   * Creates new Line instance.
   * @param  {black-engine~Vector} start Start point.
   * @param  {black-engine~Vector} end End point.
   */
  constructor(start, end) {
    /** @type {black-engine~Vector} The start point coordinates */
    this.start = start;

    /** @type {black-engine~Vector} The end point coordinates */
    this.end = end;
  }

  /**
   * set - Sets new line properties
   *
   * @param  {black-engine~Vector} start Start point.
   * @param  {black-engine~Vector} end End point.
   *
   * @return {black-engine~Line} This circle.
   */
  set(start, end) {
    this.start = start;
    this.end = end;

    return this;
  }

  /**
   * Clones this line.
   *
   * @return {black-engine~Line} Created line.
   */
  clone() {
    return new Line(this.start.clone(), this.end.clone());
  }

  /**
   * Copy this properties to another line.
   *
   * @param {black-engine~Line} line Object to copy to.
   *
   * @return {black-engine~Line} Passed line.
   */
  copyTo(line) {
    return line.set(this.start.clone(), this.end.clone());
  }

  /**
   * Copy another line properties to this.
   *
   * @param {black-engine~Line} line Object to copy from.
   *
   * @return {black-engine~Line} This circle.
   */
  copyFrom(line) {
    return this.set(line.start.clone(), line.end.clone());
  }

  /**
   * Shows whether lines are identical.
   *
   * @param {black-engine~Line} line Object to comparison.
   * @param {number=} epsilon Compare precision.
   *
   * @return {boolean} True if lines are identical.
   */
  equals(line, epsilon = Number.EPSILON) {
    return (this.start.equals(line.start, epsilon) && this.end.equals(line.end, epsilon)) ||
      (this.start.equals(line.end, epsilon) && this.end.equals(line.start, epsilon));
  }

  /**
   * Finds left X position.
   *
   * @return {number} Left X position.
   */
  get left() {
    return Math.min(this.start.x, this.end.x);
  }

  /**
   * Finds right X position.
   *
   * @return {number} Right X position.
   */
  get right() {
    return Math.max(this.start.x, this.end.x);
  }

  /**
   * Finds top Y position.
   *
   * @return {number} Top Y position.
   */
  get top() {
    return Math.min(this.start.y, this.end.y);
  }

  /**
   * Finds bottom Y position.
   *
   * @return {number} Bottom Y position.
   */
  get bottom() {
    return Math.max(this.start.y, this.end.y);
  }

  /**
   * Replace line start and end points.
   *
   * @return {black-engine~Line} This line.
   */
  reverse() {
    let start = this.start;
    this.start = this.end;
    this.end = start;

    return this;
  }

  /**
   * Change line's length to one. Moves end point.
   *
   * @return {black-engine~Line} This line.
   */
  normalize() {
    this.end
      .subtract(this.start)
      .normalize()
      .add(this.start);

    return this;
  }

  /**
   * Change line's length to scaled. Moves end point.
   *
   * @return {black-engine~Line} This line.
   */
  scale(multiplier) {
    this.end
      .subtract(this.start)
      .multiplyScalar(multiplier)
      .add(this.start);

    return this;
  }

  /**
   * Returns zero length line at zero position.
   *
   * @return {black-engine~Line} Description
   */
  zero() {
    return this.set(new Vector(), new Vector());
  }

  /**
   * Length of this line.
   *
   * @return {number} length.
   */
  length() {
    return this.start.distance(this.end);
  }

  /**
   * Represents center as vector.
   *
   * @param {black-engine~Vector=} outVector Object for result.
   *
   * @return {black-engine~Vector} Center point.
   */
  center(outVector = undefined) {
    outVector = outVector || new Vector();
    return outVector.set((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }

  /**
   * Returns 'line'.
   *
   * @return {string} Description
   */
  get type() {
    return 'Line';
  }

  /**
   * Shows whether point is on line.
   *
   * @param {number} x Point position x.
   * @param {number} y Point position y.
   *
   * @return {boolean} True if line contains point.
   */
  containsXY(x, y) {
    return this.contains(new Vector(x, y));
  }

  /**
   * Shows whether point is on line.
   *
   * @param {black-engine~Vector} vector Point to check.
   *
   * @return {boolean} True if line contains point.
   */
  contains(vector) {
    return this.start.distance(vector) + this.end.distance(vector) === this.length();
  }

  /**
   * Shows whether this line intersects another.
   *
   * @param {black-engine~Line} line Line to check.
   *
   * @return {boolean} True if intersects.
   */
  intersects(line) {
    let start1 = this.start;
    let end1 = this.end;
    let start2 = line.start;
    let end2 = line.end;

    let denominator = ((end2.y - start2.y) * (end1.x - start1.x)) - ((end2.x - start2.x) * (end1.y - start1.y));

    if (denominator === 0) {
      return false;
    }

    let a = start1.y - start2.y;
    let b = start1.x - start2.x;
    let numerator1 = ((end2.x - start2.x) * a) - ((end2.y - start2.y) * b);
    let numerator2 = ((end1.x - start1.x) * a) - ((end1.y - start1.y) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    return a >= 0 && a <= 1 && b > 0 && b < 1;
  }

  /**
   * Shows whether this line intersects circle.
   *
   * @param {black-engine~Circle} circle Circle to check.
   *
   * @return {boolean} True if intersects.
   */
  intersectsCircle(circle) {
    let start = this.start;
    let end = this.end;

    if (circle.contains(start) || circle.contains(end)) {
      return true;
    }

    let distance = start.distance(end);
    let directionX = (end.x - start.x) / distance;
    let directionY = (end.y - start.y) / distance;

    let t = directionX * (circle.x - start.x) + directionY * (circle.y - start.y);

    let nearest = new Vector((t * directionX) + start.x, (t * directionY) + start.y);
    let nearestDistance = nearest.distance(new Vector(circle.x, circle.y));

    if (nearestDistance < circle.r) {
      let dt = Math.sqrt(Math.pow(circle.r, 2) - Math.pow(nearestDistance, 2));

      let x1 = ((t - dt) * directionX + start.x);
      let y1 = ((t - dt) * directionY + start.y);
      let x2 = ((t + dt) * directionX + start.x);
      let y2 = ((t + dt) * directionY + start.y);

      return this.__isInBoundsXY(x1, y1) || this.__isInBoundsXY(x2, y2);
    }

    return false;
  }

  __isInBoundsXY(x, y) {
    let x1 = this.start.x;
    let y1 = this.start.y;
    let x2 = this.end.x;
    let y2 = this.end.y;

    return x > Math.min(x1, x2) && x < Math.max(x1, x2) && y > Math.min(y1, y2) && y < Math.max(y1, y2);
  }

  // @ifdef DEBUG
  /**
   * toString - String representation of this line.
   *
   * @param {number=} [digits=2] Number of digits after float point.
   *
   * @return {string} Description.
   */
  toString(digits = 2) {
    return `Line { start: ${this.start.toString(digits)}, end: ${this.end.toString(digits)} }`;
  }
  // @endif
}

/**
 * @type {black-engine~Line}
 * @nocollapse
 * @ignore
 */
Line.__cache = new Line(new Vector(), new Vector());

/**
 * Mathematical representation of a rectangle.
 *
 * @cat geom
 */
class Rectangle {
  /**
   * Creates new instance of Rectangle.
   *
   * @param  {number=} [y=0] X-component.
   * @param  {number=} [x=0] Y-component.
   * @param  {number=} [w=0] The width.
   * @param  {number=} [h=0] The height.
   */
  constructor(x = 0, y = 0, w = 0, h = 0) {
    Debug.isNumber(x, y, w, h);

    /** 
     * @type {number} The x coordinate of the rectangle. 
     */
    this.x = x;

    /** 
     * @type {number} The y coordinate of the rectangle. 
     */
    this.y = y;

    /** 
     * @type {number} The width of the rectangle. 
     */
    this.width = w;

    /** 
     * @type {number} The height of the rectangle. 
     */
    this.height = h;
  }

  /**
   * Update rectangle values with a given.
   *
   * @param {number} x X-component.
   * @param {number} y Y-component.
   * @param {number} w The width.
   * @param {number} h The height.
   * @return {black-engine~Rectangle} This.
   */
  set(x, y, w, h) {
    Debug.isNumber(x, y, w, h);

    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h;

    return this;
  }

  /**
   * Copies values from given rectangle into this one.
   *
   * @param {black-engine~Rectangle} rect The Rectangle to copy values from.
   * @return {black-engine~Rectangle} This.
   */
  copyFrom(rect) {
    this.x = rect.x;
    this.y = rect.y;
    this.width = rect.width;
    this.height = rect.height;

    return this;
  }

  /**
   * Copies values from this rectangle into given rectangle.
   *
   * @param {black-engine~Rectangle} rect The destination rect.
   * @return {black-engine~Rectangle} Given rect object.
   */
  copyTo(rect) {
    rect.x = this.x;
    rect.y = this.y;
    rect.width = this.width;
    rect.height = this.height;

    return rect;
  }

  /**
   * Get/Sets the leftmost point of this rectangle.
   *
   * @return {number}
   */
  get left() {
    return this.x;
  }

  /**
   * @param {number} left
   */
  set left(left) {
    Debug.isNumber(left);
    this.x = left;
  }

  /**
   * Get/Sets the rightmost point of this rectangle.
   *
   * @return {number}
   */
  get right() {
    return this.x + this.width;
  }

  /**
   * @param {number} right
   */
  set right(right) {
    Debug.isNumber(right);
    this.x = right - this.width;
  }

  /**
   * Get/Sets the topmost point of this rectangle.
   *
   * @return {number}
   */
  get top() {
    return this.y;
  }

  /**
   * @param {number} top
   */
  set top(top) {
    Debug.isNumber(top);
    this.y = top;
  }

  /**
   * Get/Sets the bottommost point of this rectangle.
   *
   * @return {number}
   */
  get bottom() {
    return this.y + this.height;
  }

  /**
   * @param {number} bottom
   */
  set bottom(bottom) {
    Debug.isNumber(bottom);

    this.y = bottom - this.height;
  }

  /**
   * Get/Sets the top left point for this rectangle.
   *
   * @return {black-engine~Vector}
   */
  get topLeft() {
    return new Vector(this.x, this.y);
  }

  /**
   * @param {black-engine~Vector} vector
   */
  set topLeft(vector) {
    this.left = vector.x;
    this.top = vector.y;
  }

  /**
   * Get/Sets the top right point for this rectangle.
   *
   * @return {black-engine~Vector}
   */
  get topRight() {
    return new Vector(this.right, this.y);
  }

  /**
   * @param {black-engine~Vector} vector
   */
  set topRight(vector) {
    this.right = vector.x;
    this.top = vector.y;
  }

  /**
   * Get/Sets the top left point for this rectangle.
   *
   * @return {black-engine~Vector}
   */
  get bottomRight() {
    return new Vector(this.right, this.bottom);
  }

  /**
   * @param {black-engine~Vector} vector
   */
  set bottomRight(vector) {
    this.right = vector.x;
    this.bottom = vector.y;
  }

  /**
   * Get/Sets the top left point for this rectangle.
   *
   * @return {black-engine~Vector}
   */
  get bottomLeft() {
    return new Vector(this.x, this.bottom);
  }

  /**
   * @param {black-engine~Vector} vector
   */
  set bottomLeft(vector) {
    this.x = vector.x;
    this.bottom = vector.y;
  }

  /**
   * Creates a new Rectangle instance with width and height equal to current instance.
   *
   * @param {black-engine~Vector=} outVector Resulting rect to save values in.
   * @return {black-engine~Vector} New Rectangle instance or `outVector` if passed.
   */
  size(outVector = undefined) {
    outVector = outVector || new Vector();
    return outVector.set(this.width, this.height);
  }

  /**
   * Sets all components of this Rectangle to zero.
   *
   * @return {black-engine~Rectangle} This.
   */
  zero() {
    return this.set(0, 0, 0, 0);
  }

  /**
   * Compares this Rectangle with a given one.
   *
   * @param {black-engine~Rectangle} rect Rect to compare values with.
   * @param {number} [epsilon=Number.EPSILON] Comparison threshold.
   * @return {boolean} True if rectangles are equal.
   */
  equals(rect, epsilon = Number.EPSILON) {
    return rect !== null && (Math.abs(this.x - rect.x) < epsilon) && (Math.abs(this.y - rect.y) < epsilon) &&
      (Math.abs(this.width - rect.width) < epsilon) && (Math.abs(this.height - rect.height) < epsilon);
  }


  /**
   * Checks if a given point is inside this rectangle.
   *
   * @param {number} x The x-component of a point.
   * @param {number} y The y-component of a point.
   * @return {boolean} True if point is inside.
   */
  containsXY(x, y) {
    return x >= this.x && x <= this.right && y >= this.y && y <= this.bottom;
  }


  /**
   * Checks if a given rectangle is inside this rect.
   *
   * @param {black-engine~Rectangle} rect Rectangle to check with.
   * @return {boolean} True if given rectangle is inside this one.
   */
  contains(rect) {
    return rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom;
  }

  /**
   * Checks if this rect intersects with a given rectangle.
   *
   * @param {black-engine~Rectangle} rect The rect to check intersection with.
   * @return {boolean} True if intersects.
   */
  intersects(rect) {
    return rect.right > this.x && rect.bottom > this.y &&
      rect.x < this.right && rect.y < this.bottom;
  }

  /**
   * Makes rectangle, which represents intersection between this and passed rectangles.
   *
   * @param {black-engine~Rectangle} toIntersect Rectangle to intersect with.
   * @param {black-engine~Rectangle=} outRect Rectangle to be returned.
   * @returns {black-engine~Rectangle}
   */
  intersection(toIntersect, outRect) {
    outRect = outRect || new Rectangle();

    let x0 = this.x < toIntersect.x ? toIntersect.x : this.x;
    let x1 = this.right > toIntersect.right ? toIntersect.right : this.right;

    if (x1 <= x0)
      return new Rectangle();

    let y0 = this.y < toIntersect.y ? toIntersect.y : this.y;
    let y1 = this.bottom > toIntersect.bottom ? toIntersect.bottom : this.bottom;

    if (y1 <= y0)
      return new Rectangle();

    outRect.set(x0, y0, x1 - x0, y1 - y0);
    return outRect;
  }


  /**
   * Adds given rectangle into this.
   *
   * @param {black-engine~Rectangle} toUnion A rectangle object to add to this rect.
   * @return {black-engine~Rectangle} New rectangle object that is the union.
   */
  union(toUnion) {
    let x0 = this.x > toUnion.x ? toUnion.x : this.x;
    let x1 = this.right < toUnion.right ? toUnion.right : this.right;
    let y0 = this.y > toUnion.y ? toUnion.y : this.y;
    let y1 = this.bottom < toUnion.bottom ? toUnion.bottom : this.bottom;

    return this.set(x0, y0, x1 - x0, y1 - y0);
  }

  /**
   * Returns volume of this Rectangle.
   *
   * @return {number}
   */
  get volume() {
    return this.width * this.height;
  }

  /**
   * Expands this rectangle object by given values.
   *
   * @param {number} x      X-component.
   * @param {number} y      Y-component
   * @param {number} width  The width.
   * @param {number} height The height.
   * @return {black-engine~Rectangle} This.
   */
  expand(x, y, width, height) {
    Debug.isNumber(x, y, width, height);

    if (this.volume === 0)
      return this.set(x, y, width, height);

    let cacheRight = this.right;
    let cacheBottom = this.bottom;

    if (this.x > x) {
      this.x = x;
      this.width = cacheRight - x;
    }

    if (this.y > y) {
      this.y = y;
      this.height = cacheBottom - y;
    }

    if (cacheRight < x + width)
      this.width = x + width - this.x;

    if (cacheBottom < y + height)
      this.height = y + height - this.y;

    return this;
  }

  /**
   * Expands this rectangle with a given point.
   * 
   * @param {number} x 
   * @param {number} y 
   * @returns {black-engine~Rectangle}
   */
  expandXY(x, y) {
    if (x < this.x) {
      this.width += this.x - x;
      this.x = x;
    }

    if (y < this.y) {
      this.height += this.y - y;
      this.y = y;
    }

    if (x > this.x + this.width)
      this.width = x - this.x;

    if (y > this.y + this.height)
      this.height = y - this.y;

    return this;
  }

  /**
   * Increases the size of this rectangle by given x- and y- values.
   *
   * @param {number=} [x=0] X-component.
   * @param {number=} [y=0] Y-component.
   * @return {black-engine~Rectangle} This.
   */
  inflate(x = 0, y = 0) {
    Debug.isNumber(x, y);

    this.x -= x;
    this.y -= y;
    this.width += 2 * x;
    this.height += 2 * y;

    return this;
  }

  /**
   * Clones this Rectangle object into new one.
   *
   * @return {black-engine~Rectangle} New rectangle object.
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }

  /**
   * Gets rectangle perimeter.
   *
   * @return {number}
   */
  get perimeter() {
    return 2 * (this.width + this.height);
  }


  /**
   * Returns the center point of this rectangle.
   *
   * @param {black-engine~Vector=} outVector The out-Vector to store values in.
   * @return {black-engine~Vector} New rectangle object.
   */
  center(outVector = undefined) {
    outVector = outVector || new Vector();
    return outVector.set(this.x + this.width * 0.5, this.y + this.height * 0.5);
  }

  /**
   *  Scales this rectangle.
   *
   * @param {number} x Width multiplier.
   * @param {number} y Height multiplier.
   * @return {black-engine~Rectangle} This rectangle.
   */
  scale(x, y) {
    this.width *= x;
    this.height *= y;

    return this;
  }

  /**
   * Checks if rectangle has area.
   *
   * @return {boolean} True if has.
   */
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }

  /**
   * Gets a list of lines, which make up this rectangle.
   *
   * @returns {Array<black-engine~Line>}
   */
  get lines() {
    return [
      new Line(this.topLeft, this.topRight),
      new Line(this.topRight, this.bottomRight),
      new Line(this.bottomRight, this.bottomLeft),
      new Line(this.bottomLeft, this.topLeft)
    ];
  }

  /**
   * Returns random number within this rectangle.
   * @returns {Vector}
   */
  get random() {
    const rx = MathEx.randomBetween(this.x, this.width);
    const ry = MathEx.randomBetween(this.y, this.height);

    return new Vector(rx, ry);
  }

  /**
   * Calculates a bonding box enclosing the given list of points.
   * 
   * @param {Array<Vector>} points 
   * @returns {black-engine~Rectangle}
   */
  static fromPoints(points) {
    let result = new Rectangle();

    if (points.length === 0)
      return result;

    let length = points.length;
    let minX = points[0].x;
    let minY = points[0].y;
    let maxX = points[0].x;
    let maxY = points[0].y;

    for (let i = 1; i < length; i++) {
      let p = points[i];
      let x = p.x;
      let y = p.y;

      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }

    result.x = minX;
    result.y = minY;
    result.width = maxX - minX;
    result.height = maxY - minY;
    return result;
  }

  /**
   * Calculates a bonding box enclosing the given list of x-y pairs.
   * 
   * @param {Array<number>} points 
   * @returns {black-engine~Rectangle}
   */
  static fromPointsXY(points) {
    let result = new Rectangle();

    if (points.length < 2)
      return result;

    let length = points.length;
    let minX = points[0];
    let minY = points[1];
    let maxX = points[0];
    let maxY = points[1];

    for (let i = 2; i < length; i += 2) {
      let x = points[i];
      let y = points[i + 1];

      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }

    result.x = minX;
    result.y = minY;
    result.width = maxX - minX;
    result.height = maxY - minY;
    return result;
  }

  // @ifdef DEBUG
  /**
   * @ignore
   * @param {number=} [digits=2] Description
   * @return {string} Description
   */
  toString(digits = 2) {
    return `Rectangle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, width: ${this.width.toFixed(digits)}, height: ${this.height.toFixed(digits)} }`;
  }
  // @endif
}

/**
 * @ignore
 * @type {black-engine~Rectangle}
 * @nocollapse
 */
Rectangle.__cache = new Rectangle();

/**
 * Recycled rectangles pool.
 *
 * @type {black-engine~ObjectPool}
 * @nocollapse
 */
Rectangle.pool = new ObjectPool(Rectangle);

/**
 * A 2x3 matrix allows you to transform objects in space.
 *
 * @cat geom
 */
class Matrix {
  /**
   * Creates new Matrix instance.
   *
   * @param  {number} [a=1]  A-component.
   * @param  {number} [b=0]  B-component.
   * @param  {number} [c=0]  C-component.
   * @param  {number} [d=1]  D-component.
   * @param  {number} [tx=0] TX-component.
   * @param  {number} [ty=0] TY-component.
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    /** 
     * @private 
     * @type {Float32Array} 
     */
    this.data = new Float32Array(6);
    this.set(a, b, c, d, tx, ty);
  }

  /**
   * Sets components of this matrix to the given values.
   *
   * @param  {number} a  A-component.
   * @param  {number} b  B-component.
   * @param  {number} c  C-component.
   * @param  {number} d  D-component.
   * @param  {number} tx TX-component.
   * @param  {number} ty TY-component.
   * @return {black-engine~Matrix} This.
   */
  set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    Debug.isNumber(a, b, c, d, tx, ty);

    let m = this.data;

    m[0] = a;
    m[1] = b;
    m[2] = c;
    m[3] = d;
    m[4] = tx;
    m[5] = ty;

    return this;
  }

  /**
   * Translates the matrix by x and y axes.
   *
   * @param {number} dx Amount along x-axis.
   * @param {number} dy Amount along y-axis.
   * @return {black-engine~Matrix} This.
   */
  translate(dx, dy) {
    Debug.isNumber(dx, dy);

    let a = this.data;

    let /** @type {number} */ a0 = a[0]; // a
    let /** @type {number} */ a1 = a[1]; // b
    let /** @type {number} */ a2 = a[2]; // c
    let /** @type {number} */ a3 = a[3]; // d
    let /** @type {number} */ a4 = a[4]; // tx
    let /** @type {number} */ a5 = a[5]; // ty

    this.data[4] = a0 * dx + a2 * dy + a4;
    this.data[5] = a1 * dx + a3 * dy + a5;

    return this;
  }

  /**
   * Sets tx and ty components to given values.
   *
   * @param {number} x The tx component to update.
   * @param {number} y The ty component to update.
   * @return {black-engine~Matrix} This.
   */
  setTranslation(x, y) {
    Debug.isNumber(x, y);

    this.data[4] = x;
    this.data[5] = y;

    return this;
  }

  /**
   * Sets absolute rotation of this matrix to specified angle.
   *
   * @param  {number} theta     Theta value.
   * @param  {number} scale = 1 Scale value.
   * @return {black-engine~Matrix} This.
   */
  setRotation(theta, scale = 1) {
    Debug.isNumber(theta, scale);

    let m = this.data;
    m[0] = Math.cos(theta) * scale;
    m[2] = Math.sin(theta) * scale;
    m[1] = -m[2];
    m[3] = m[0];

    return this;
  }

  /**
   * Applies rotation to this matrix.
   *
   * @param  {number} angle Angle in radians.
   * @return {black-engine~Matrix} This.
   */
  rotate(angle) {
    Debug.isNumber(angle);

    let a = this.data;
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    let a0 = a[0];
    let a2 = a[2];
    let a4 = a[4];

    a[0] = a0 * cos - a[1] * sin;
    a[1] = a0 * sin + a[1] * cos;
    a[2] = a2 * cos - a[3] * sin;
    a[3] = a2 * sin + a[3] * cos;
    a[4] = a4 * cos - a[5] * sin;
    a[5] = a4 * sin + a[5] * cos;

    return this;
  }

  /**
   * Scales current matrix.
   *
   * @param {number} sx Abscissa of the scaling vector.
   * @param {number} sy Ordinate of the scaling vector.
   * @return {black-engine~Matrix} This.
   */
  scale(sx, sy) {
    Debug.isNumber(sx, sy);

    let a = this.data;
    let /** @type {number} */ a0 = a[0]; // a
    let /** @type {number} */ a1 = a[1]; // b
    let /** @type {number} */ a2 = a[2]; // c
    let /** @type {number} */ a3 = a[3]; // d
    let /** @type {number} */ a4 = a[4]; // tx
    let /** @type {number} */ a5 = a[5]; // ty

    this.data[0] = a0 * sx;
    this.data[1] = a1 * sx;
    this.data[2] = a2 * sy;
    this.data[3] = a3 * sy;

    return this;
  }

  skew(sx, sy) {
    let sinX = Math.sin(sx);
    let cosX = Math.cos(sx);
    let sinY = Math.sin(sy);
    let cosY = Math.cos(sy);
    let d = this.data;

    this.set(
      d[0] * cosY - d[1] * sinX,
      d[0] * sinY + d[1] * cosX,
      d[2] * cosY - d[3] * sinX,
      d[2] * sinY + d[3] * cosX,
      d[4] * cosY - d[5] * sinX,
      d[4] * sinY + d[5] * cosX);
  }

  /**
   * Resets current matrix to identity state.
   *
   * @return {black-engine~Matrix} This.
   */
  identity() {
    return this.set(1, 0, 0, 1, 0, 0);
  }

  /**
   * Specifies if current matrix is identity.
   *
   * @returns {boolean}
   */
  get isIdentity() {
    return this.exactEquals(Matrix.__identity);
  }

  /**
   * Concatenates a given matrix with the current one.
   *
   * @param  {black-engine~Matrix} b The matrix to be concatenated.
   * @return {black-engine~Matrix}   This.
   */
  prepend(b) {
    let a = this.data;
    let bv = b.data;

    let /** @type {number} */ a0 = a[0]; // a
    let /** @type {number} */ a1 = a[1]; // b
    let /** @type {number} */ a2 = a[2]; // c
    let /** @type {number} */ a3 = a[3]; // d
    let /** @type {number} */ a4 = a[4]; // tx
    let /** @type {number} */ a5 = a[5]; // ty

    let /** @type {number} */ b0 = bv[0]; // a
    let /** @type {number} */ b1 = bv[1]; // b
    let /** @type {number} */ b2 = bv[2]; // c
    let /** @type {number} */ b3 = bv[3]; // d
    let /** @type {number} */ b4 = bv[4]; // tx
    let /** @type {number} */ b5 = bv[5]; // ty

    if (b0 !== 1 || b1 !== 0 || b2 !== 0 || b3 !== 1) {
      let a11 = (a0 * b0 + a1 * b2);
      a[1] = a0 * b1 + a1 * b3;
      a[0] = a11;

      let c11 = (a2 * b0 + a3 * b2);
      a[3] = a2 * b1 + a3 * b3;
      a[2] = c11;
    }


    let tx11 = (a4 * b0 + a5 * b2 + b4);
    a[5] = a4 * b1 + a5 * b3 + b5;
    a[4] = tx11;
    return this;
  }

  /**
   * Appends values to this matrix.
   *
   * @param  {black-engine~Matrix} b The matrix to be appended.
   * @return {black-engine~Matrix} This.
   */
  append(b) {
    let a = this.data;
    let bv = b.data;

    let /** @type {number} */ a0 = a[0];
    let /** @type {number} */ a1 = a[1];
    let /** @type {number} */ a2 = a[2];
    let /** @type {number} */ a3 = a[3];
    let /** @type {number} */ a4 = a[4];
    let /** @type {number} */ a5 = a[5];
    let /** @type {number} */ b0 = bv[0];
    let /** @type {number} */ b1 = bv[1];
    let /** @type {number} */ b2 = bv[2];
    let /** @type {number} */ b3 = bv[3];
    let /** @type {number} */ b4 = bv[4];
    let /** @type {number} */ b5 = bv[5];

    a[0] = a0 * b0 + a2 * b1;
    a[1] = a1 * b0 + a3 * b1;
    a[2] = a0 * b2 + a2 * b3;
    a[3] = a1 * b2 + a3 * b3;
    a[4] = a0 * b4 + a2 * b5 + a4;
    a[5] = a1 * b4 + a3 * b5 + a5;
    return this;
  }

  /**
   * Transforms given and x- and y- components of a point from a local space to world space.
   *
   * @param  {number} x          The x- component of a point.
   * @param  {number} y          The y- component of a point.
   * @param  {black-engine~Vector=} outVector If given stores resulting values in it.
   * @return {black-engine~Vector} Transformed Vector object.
   */
  transformXY(x, y, outVector) {
    Debug.isNumber(x, y);

    outVector = outVector || new Vector();
    let m = this.data;

    outVector.x = m[0] * x + m[2] * y + m[4];
    outVector.y = m[1] * x + m[3] * y + m[5];

    return outVector;
  }

  /**
   * Transforms given point from a local space to world space without applying scaling.
   *
   * @param  {number} x          The x- component.
   * @param  {number} y          The y- component.
   * @param  {black-engine~Vector=} outVector If given stores results in it.
   * @return {black-engine~Vector} Just transformed Vector object.
   */
  transformDirectionXY(x, y, outVector) {
    Debug.isNumber(x, y);

    let m = this.data;
    outVector = outVector || new Vector();

    outVector.x = m[0] * x + m[2] * y;
    outVector.y = m[1] * x + m[3] * y;

    return outVector;
  }

  /**
   * Transforms vector by current matrix object.
   *
   * @param  {black-engine~Vector} vector     Vector to apply transformation on.
   * @param  {black-engine~Vector=} outVector Out Vector to store results in.
   * @return {black-engine~Vector} New transformed vector.
   */
  transformVector(vector, outVector) {
    outVector = outVector || new Vector();
    const m = this.data;

    const x = m[0] * vector.x + m[2] * vector.y + m[4];
    const y = m[1] * vector.x + m[3] * vector.y + m[5];

    return outVector.set(x, y);
  }

  /**
   * Transforms rectangle by current matrix object.
   *
   * @param  {black-engine~Rectangle} rect         Rectangle to apply transformation on.
   * @param  {black-engine~Rectangle|null} outRect When given stores results in it.
   * @return {black-engine~Rectangle} Transformed  Rectangle object.
   */
  transformRect(rect, outRect) {
    outRect = outRect || new Rectangle();

    let minX = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let m = this.data;
    let tmpVector = Vector.pool.get();

    /** @type {Array<number>} */
    let points = [rect.x, rect.y, rect.x + rect.width, rect.y, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height];

    for (let i = 0; i < points.length; i += 2) {
      tmpVector.x = m[0] * points[i] + m[2] * points[i + 1] + m[4];
      tmpVector.y = m[1] * points[i] + m[3] * points[i + 1] + m[5];

      if (minX > tmpVector.x)
        minX = tmpVector.x;
      if (maxX < tmpVector.x)
        maxX = tmpVector.x;
      if (minY > tmpVector.y)
        minY = tmpVector.y;
      if (maxY < tmpVector.y)
        maxY = tmpVector.y;
    }

    Vector.pool.release(tmpVector);

    return outRect.set(minX, minY, maxX - minX, maxY - minY);
  }

  /**
   * Inverts current matrix.
   *
   * @return {black-engine~Matrix} This.
   */
  invert() {
    let a = this.data;

    let aa = a[0];
    let ab = a[1];
    let ac = a[2];
    let ad = a[3];
    let atx = a[4];
    let aty = a[5];

    let det = aa * ad - ab * ac;
    if (det === 0) {
      a[0] = a[1] = a[2] = a[3] = 0;
      a[4] = -atx;
      a[5] = -aty;
      return this;
    }
    det = 1.0 / det;

    a[0] = ad * det;
    a[1] = -ab * det;
    a[2] = -ac * det;
    a[3] = aa * det;
    a[4] = (ac * aty - ad * atx) * det;
    a[5] = (ab * atx - aa * aty) * det;

    return this;
  }

  /**
   * TODO: remove or finish
   * @ignore
   * @returns {Array<number>} Description
   */
  __decompose() {
    let m = this.data;
    let a = m[0];
    let b = m[1];
    let c = m[2];
    let d = m[3];
    let tx = m[4];
    let ty = m[5];

    let skewX = -Math.atan2(-c, d);
    let skewY = Math.atan2(b, a);

    let delta = Math.abs(skewX + skewY);

    let r_rotation = 0;
    let r_skewX = 0;
    let r_skewY = 0;
    let r_scaleX = 0;
    let r_scaleY = 0;
    let r_x = 0;
    let r_y = 0;

    if (delta < 0.00001) {
      r_rotation = skewY;

      if (a < 0 && d >= 0)
        r_rotation += (r_rotation <= 0) ? Math.PI : -Math.PI;
    } else {
      r_skewX = skewX;
      r_skewY = skewY;
    }

    r_scaleX = Math.sqrt((a * a) + (b * b));
    r_scaleY = Math.sqrt((c * c) + (d * d));

    r_x = tx;
    r_y = ty;

    return [r_x, r_y, r_rotation, r_scaleX, r_scaleY, r_skewX, r_skewY];
  }

  /**
   * Clones the current matrix and returns new cloned object.
   *
   * @return {black-engine~Matrix} New cloned object.
   */
  clone() {
    let m = new Matrix();
    let v = this.data;
    m.set(v[0], v[1], v[2], v[3], v[4], v[5]);
    return m;
  }

  /**
   * Copies values to given matrix.
   *
   * @param  {black-engine~Matrix} matrix The destination matrix.
   * @return {black-engine~Matrix} This.
   */
  copyTo(matrix) {
    let a = this.data;
    let b = matrix.data;

    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];

    return matrix;
  }

  /**
   * Copies values from given matrix into this.
   *
   * @param  {black-engine~Matrix} matrix The matrix to copy values from.
   * @return {black-engine~Matrix} This.
   */
  copyFrom(matrix) {
    return matrix.copyTo(this);
  }

  /**
   * Compares this matrix values with given matrix and checks if they are the same.
   *
   * @param {black-engine~Matrix} matrix Matrix object to compare with.
   * @returns {boolean}
   */
  exactEquals(matrix) {
    if (!matrix)
      return false;

    let a = this.data;
    let b = matrix.data;

    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }

  /**
   * Compares this matrix values with given matrix and checks if they are the same.
   *
   * @param  {black-engine~Matrix} matrix                   Matrix object to compare with.
   * @param  {number} epsilon = Number.EPSILON Comparison threshold.
   * @return {boolean} True if equal.
   */
  equals(matrix, epsilon = Number.EPSILON) {
    if (!matrix)
      return false;

    let a = this.data;
    let b = matrix.data;

    return (Math.abs(a[0] - b[0]) < epsilon) && (Math.abs(a[1] - b[1]) < epsilon) && (Math.abs(a[2] - b[2]) < epsilon) &&
      (Math.abs(a[3] - b[3]) < epsilon) && (Math.abs(a[4] - b[4]) < epsilon) && (Math.abs(a[5] - b[5]) < epsilon);
  }

  /**
   * Returns array of values representing this matrix object.
   *
   * @return {Float32Array}
   */
  get value() {
    return this.data;
  }

  // @ifdef DEBUG
  /**
   * @ignore
   * @param  {number=} digits = 2
   * @return {string}
   */
  toString(digits = 2) {
    return `        | ${this.value[0].toFixed(digits)} | ${this.value[1].toFixed(digits)} | ${this.value[4].toFixed(digits)} |
Matrix: | ${this.value[2].toFixed(digits)} | ${this.value[3].toFixed(digits)} | ${this.value[5].toFixed(digits)} |`;
  }
  // @endif
}

/**
 * @ignore
 * @type {black-engine~Matrix}
 * @nocollapse
 */
Matrix.__cache = new Matrix();

/**
 * @ignore
 * @type {black-engine~Matrix}
 * @nocollapse
 */
Matrix.__identity = new Matrix();

/**
 * Recycled matrices pool.
 *
 * @type {black-engine~ObjectPool}
 * @nocollapse
 */
Matrix.pool = new ObjectPool(Matrix);

/**
 * Mathematical representation of a circle.
 *
 * @cat geom
 */
class Circle {
  /**
   * Creates new Circle instance.
   * 
   * @param  {number=} [x = 0] Position x.
   * @param  {number=} [y = 0] Position y.
   * @param  {number=} [r = 1] Radius.
   */
  constructor(x = 0, y = 0, r = 1) {

    /** 
     * @private 
     * @type {number} 
     */
    this.x = x;

    /** 
     * @private 
     * @type {number} 
     */
    this.y = y;

    /** 
     * @private 
     * @type {number} 
     */
    this.r = r;
  }

  /**
   * Sets new circle properties
   *
   * @param {number} x Position x.
   * @param {number} y Position y.
   * @param {number} r Radius.
   * @return {Circle} This circle.
   */
  set(x, y, r) {
    this.x = x;
    this.y = y;
    this.r = r;

    return this;
  }

  /**
   * Clones this circle.
   *
   * @return {black-engine~Circle} Created circle.
   */
  clone() {
    return new Circle(this.x, this.y, this.r);
  }

  /**
   * Copy this properties to another circle.
   *
   * @param {black-engine~Circle} circle Object to copy to.
   * @return {black-engine~Circle} Passed circle.
   */
  copyTo(circle) {
    return circle.set(this.x, this.y, this.r);
  }

  /**
   * Copy another circle properties to this.
   *
   * @param {black-engine~Circle} circle Object to copy from.
   * @return {black-engine~Circle} This circle.
   */
  copyFrom(circle) {
    return this.set(circle.x, circle.y, circle.r);
  }

  /**
   * Shows whether circles are identical.
   *
   * @param {black-engine~Circle} circle Object to comparison.
   * @param {number=} epsilon Compare precision.
   * @return {boolean} True if circles are identical.
   */
  equals(circle, epsilon = Number.EPSILON) {
    return circle !== null && (Math.abs(this.x - circle.x) < epsilon) && (Math.abs(this.y - circle.y) < epsilon) &&
      (Math.abs(this.r - circle.r) < epsilon);
  }

  /**
   * Shows whether point is in circle.
   *
   * @param {number} x Point position x.
   * @param {number} y Point position y.
   * @return {boolean} True if circle contains point.
   */
  containsXY(x, y) {
    return this.contains(new Vector(x, y));
  }

  /**
   * Shows whether point is in circle.
   *
   * @param {black-engine~Vector} vector Point to check.
   * @return {boolean} True if circle contains point.
   */
  contains(vector) {
    // TODO: remove new Vector init
    return new Vector(this.x, this.y).subtract(vector).length() <= this.r;
  }

  /**
   * Resets all values to zero.
   *
   * @return {black-engine~Circle} Returns this.
   */
  zero() {
    return this.set(0, 0, 0);
  }

  /**
   * Shows whether this circle intersects another.
   *
   * @param {black-engine~Circle} circle Circle to check.
   * @return {boolean} True if intersects.
   */
  intersects(circle) {
    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));
    return d <= this.r + circle.r && d >= this.r - circle.r;
  }

  /**
   * Shows whether this circle collide with another.
   *
   * @param {black-engine~Circle} circle Circle to check.
   * @return {boolean} True if collide.
   */
  collide(circle) {
    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));
    return d <= this.r + circle.r;
  }

  /**
   * Shows whether this circle overlap another.
   *
   * @param {black-engine~Circle} circle Circle to check.
   * @return {boolean} True if overlap.
   */
  overlap(circle) {
    if (this.r < circle.r) {
      return false;
    }

    let d = new Vector(this.x, this.y).distance(new Vector(circle.x, circle.y));
    return d <= this.r - circle.r;
  }


  /**
   * Represents center as vector.
   *
   * @param {black-engine~Vector=} outVector Object for result.
   * @return {black-engine~Vector} Center point.
   */
  center(outVector = undefined) {
    outVector = outVector || new Vector();
    return outVector.set(this.x, this.y);
  }

  static getCircumferencePoint(x, y, r, angle, outVector = undefined) {
    outVector = outVector || new Vector();
    outVector.set(x + r * Math.sin(angle), y + r * -Math.cos(angle));
    return outVector;
  }

  /**
   * Returns area of this circle.
   *
   * @return {number} area.
   */
  get volume() {
    return Math.PI * this.r * this.r;
  }

  /**
   * Returns perimeter of this circle.
   *
   * @return {number} perimeter.
   */
  get perimeter() {
    return 2 * Math.PI * this.r;
  }

  /**
   * Finds left X position.
   *
   * @return {number} Left X position.
   */
  get left() {
    return this.x - this.r;
  }

  /**
   * Finds right X position.
   *
   * @return {number} Right X position.
   */
  get right() {
    return this.x + this.r;
  }

  /**
   * Finds top Y position.
   *
   * @return {number} Top Y position.
   */
  get top() {
    return this.y - this.r;
  }

  /**
   * Finds bottom Y position.
   *
   * @return {number} Bottom Y position.
   */
  get bottom() {
    return this.y + this.r;
  }

  /**
   * Returns top point of this circle.
   *
   * @return {black-engine~Vector}
   */
  get topPoint() {
    return new Vector(this.x, this.top);
  }

  /**
   * Returns bottom point of this circle.
   *
   * @return {black-engine~Vector}
   */
  get bottomPoint() {
    return new Vector(this.x, this.bottom);
  }

  // @ifdef DEBUG
  /**
   * String representation of this circle.
   *
   * @ignore
   * @param {number=} [digits=2] Number of digits after float point.
   * @return {string} Returns string representation of this circle.
   */
  toString(digits = 2) {
    return `Circle { x: ${this.x.toFixed(digits)}, y: ${this.y.toFixed(digits)}, r: ${this.r.toFixed(digits)} }`;
  }
  // @endif
}

/**
 * @ignore
 * @type {black-engine~Circle}
 * @nocollapse
 */
Circle.__cache = new Circle();

/**
 * @cat geom
 */
class Polygon {
  /**
   * Creates new Polygon instance.
   *
   * @param  {Array<black-engine~Vector>} vertices = [] Array of vertex points;
   */
  constructor(vertices = []) {

    /** 
     * @private 
     * @type {Array<black-engine~Vector>} 
     */
    this.mVertices = vertices;

    /** 
     * @private 
     * @type {Array<black-engine~Line>} 
     */
    this.mLines = [];

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mBounds = new Rectangle();

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mCenter = new Vector();

    if (vertices.length > 2)
      this.refresh();
  }

  /**
   * Sets new vertices.
   *
   * @param {Array<black-engine~Vector>} vertices New points.
   * @return {black-engine~Polygon} This polygon.
   */
  set(vertices) {
    this.mVertices = vertices;
    this.refresh();
    return this;
  }

  /**
   * Copies this properties to another polygon.
   *
   * @param {black-engine~Polygon} polygon Object to copy to.
   * @return {black-engine~Polygon} Passed polygon.
   */
  copyTo(polygon) {
    let len = this.mVertices.length;
    let vertices = [];

    for (let i = 0; i < len; i++) {
      vertices.push(this.mVertices[i].clone());
    }

    return polygon.set(vertices);
  }

  /**
   * Copies another polygon properties to this.
   *
   * @param {black-engine~Polygon} polygon Object to copy from.
   * @return {black-engine~Polygon} This polygon.
   */
  copyFrom(polygon) {
    let polygonVertices = polygon.mVertices;
    let len = polygonVertices.length;
    let vertices = [];

    for (let i = 0; i < len; i++) {
      vertices.push(polygonVertices[i].clone());
    }

    return this.set(vertices);
  }

  /**
   * Clones this polygon.
   *
   * @return {black-engine~Polygon} Created polygon.
   */
  clone() {
    let thisVertices = this.mVertices;
    let len = thisVertices.length;
    let vertices = [];

    for (let i = 0; i < len; i++) {
      vertices.push(thisVertices[i].clone());
    }

    return new Polygon(vertices);
  }

  /**
   * Gets the width of this polygon.
   *
   * @readonly
   * @returns {number}
   */
  get width() {
    return this.mBounds.width;
  }

  /**
   * Gets the height of this polygon.
   *
   * @readonly
   * @returns {number}
   */
  get height() {
    return this.mBounds.height;
  }

  /**
   * Shows whether point is within polygon area.
   *
   * @param {number} x Point position x.
   * @param {number} y Point position y.
   * @return {boolean} True if polygon contains point.
   */
  containsXY(x, y) {
    return this.contains(new Vector(x, y));
  }

  /**
   * Shows whether point is within polygon area.
   *
   * @param {black-engine~Vector} vector Point to check.
   * @return {boolean} True if polygon contains point.
   */
  contains(vector) {
    let center = this.mCenter;
    let lines = this.mLines;
    let len = lines.length;

    if (center.equals(vector)) {
      return true;
    }

    let intersectionLine = new Line(vector, center.clone());
    let intersects = 0;
    intersectionLine.scale((this.width + this.height) / intersectionLine.length());

    for (let i = 0; i < len; i++) {
      intersects += lines[i].intersects(intersectionLine) ? 1 : 0;
    }

    return intersects % 2 !== 0;
  }

  /**
   * Perimeter of this polygon.
   *
   * @return {number} perimeter.
   */
  get perimeter() {
    let thisLines = this.mLines;
    let len = thisLines.length;
    let perimeter = 0;

    for (let i = 0; i < len; i++) {
      perimeter += thisLines[i].length();
    }

    return perimeter;
  }

  /**
   * Checks collision between two polygons.
   *
   * @param {black-engine~Polygon} polygon Object to check.
   * @return {boolean} True if polygon collides with another polygon.
   */
  collide(polygon) {
    if (!this.mBounds.intersects(polygon.mBounds)) {
      return false;
    }

    let thisLines = this.mLines;
    let thisLen = thisLines.length;
    let polygonLines = polygon.mLines;
    let polygonLen = polygonLines.length;

    for (let i = 0; i < thisLen; i++) {
      for (let j = 0; j < polygonLen; j++) {
        if (thisLines[i].intersects(polygonLines[j])) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Checks collision between this polygon and circle.
   *
   * @param {black-engine~Circle} circle Object to check.
   * @return {boolean} True if polygon collides with circle.
   */
  collideCircle(circle) {
    let bounds = this.mBounds;
    let lines = this.mLines;

    if (bounds.left > circle.right || bounds.right < circle.left || bounds.top > circle.bottom || bounds.bottom < circle.top) {
      return false;
    }

    let len = lines.length;
    for (let i = 0; i < len; i++) {
      if (lines[i].intersectsCircle(circle)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Checks collision between this polygon and rectangle.
   *
   * @param {black-engine~Rectangle} rectangle Object to check.
   * @return {boolean} True if polygon collides with rectangle.
   */
  collideRectangle(rectangle) {
    if (!this.mBounds.intersects(rectangle)) {
      return false;
    }

    let thisLines = this.mLines;
    let thisLen = thisLines.length;
    let rectangleLines = rectangle.lines;
    let rectangleLen = rectangleLines.length;

    for (let i = 0; i < thisLen; i++) {
      for (let j = 0; j < rectangleLen; j++) {
        if (thisLines[i].intersects(rectangleLines[j])) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Checks if this polygon overlaps another.
   *
   * @param {black-engine~Polygon} polygon Object to check.
   * @return {boolean} True if polygon overlaps second.
   */
  overlap(polygon) {
    if (this.mBounds.width < polygon.mBounds.width || this.mBounds.height < polygon.mBounds.height) {
      return false;
    }

    if (!this.contains(polygon.mCenter)) {
      return false;
    }

    let thisLines = this.mLines;
    let thisLen = thisLines.length;
    let polygonLines = polygon.mLines;
    let polygonLen = polygonLines.length;

    for (let i = 0; i < thisLen; i++) {
      for (let j = 0; j < polygonLen; j++) {
        if (thisLines[i].intersects(polygonLines[j])) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Checks if this polygon overlaps passed circle.
   *
   * @param {black-engine~Circle} circle Object to check.
   * @return {boolean} True if polygon overlaps circle.
   */
  overlapCircle(circle) {
    if (!this.containsXY(circle.x, circle.y)) {
      return false;
    }

    let thisLines = this.mLines;
    let len = thisLines.length;

    for (let i = 0; i < len; i++) {
      if (thisLines[i].intersectsCircle(circle)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Checks if this polygon overlaps given rectangle.
   *
   * @param {black-engine~Rectangle} rectangle Object to check.
   * @return {boolean} True if polygon overlaps rectangle.
   */
  overlapRectangle(rectangle) {
    if (!this.contains(rectangle.center())) {
      return false;
    }

    let thisLines = this.mLines;
    let thisLen = thisLines.length;
    let rectangleLines = rectangle.lines;
    let rectangleLen = rectangleLines.length;

    for (let i = 0; i < thisLen; i++) {
      for (let j = 0; j < rectangleLen; j++) {
        if (thisLines[i].intersects(rectangleLines[j])) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Calculates center, bounds, and edges of this polygon.
   *
   * @return {black-engine~Polygon} This polygon.
   */
  refresh() {
    let center = this.mCenter;
    let bounds = this.mBounds;
    let vertices = this.mVertices;
    let lines = this.mLines = [];
    center.set(0, 0);

    // bounds
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;

    for (let i = 0; i < vertices.length; i++) {
      let vector = vertices[i];
      center.add(vector);

      // bounds
      let {
        x,
        y
      } = vector;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;

      lines.push(new Line(vector, vertices[i + 1] || vertices[0]));
    }

    center.multiplyScalar(1 / vertices.length);
    bounds.set(minX, minY, maxX - minX, maxY - minY);

    return this;
  }

  /**
   * Calculates center of this polygon.
   *
   * @return {black-engine~Polygon} This polygon.
   */
  refreshCenter() {
    let center = this.mCenter;
    let vertices = this.mVertices;
    let len = vertices.length;
    center.set(0, 0);

    for (let i = 0; i < len; i++) {
      center.add(vertices[i]);
    }

    center.multiplyScalar(1 / vertices.length);

    return this;
  }

  /**
   * Calculates bounds of this polygon.
   *
   * @return {black-engine~Polygon} This polygon.
   */
  refreshBounds() {
    let bounds = this.mBounds;
    let vertices = this.mVertices;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let len = vertices.length;
    let x;
    let y;

    for (let i = 0; i < len; i++) {
      x = vertices[i].x;
      y = vertices[i].y;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
    }

    bounds.set(minX, minY, maxX - minX, maxY - minY);

    return this;
  }

  /**
   * Calculates edges of this polygon.
   *
   * @return {black-engine~Polygon} This polygon.
   */
  refreshLines() {
    let vertices = this.mVertices;
    let lines = this.mLines = [];

    for (let i = 0; i < vertices.length; i += 2) {
      lines.push(new Line(vertices[i], vertices[i + 1] || vertices[0]));
    }

    return this;
  }

  /**
   * Creates instance of Polygon.
   *
   * @param {string} path Numbers x y divided with space.
   * @return {black-engine~Polygon} Created polygon.
   */
  static fromPath(path) {
    let vertices = [];
    let path2 = path.split(' ');

    for (let i = 0; i < path2.length; i += 2) {
      vertices.push(new Vector(Number(path2[i]), Number(path2[i + 1])));
    }

    return new Polygon(vertices);
  }

  /**
   * Sets rotation. Rotates this polygon around it center.
   *
   * @param {number} rotation Angle in radians.
   * @return {black-engine~Polygon} This polygon.
   */
  setRotation(rotation) {
    let center = this.mCenter;
    let vertices = this.mVertices;
    let cos = Math.cos(rotation);
    let sin = Math.sin(rotation);

    for (let i = 0, len = vertices.length; i < len; i++) {
      let vector = vertices[i];
      vector
        .subtract(center)
        .set(vector.x * cos - vector.y * sin, vector.x * sin + vector.y * cos)
        .add(center);
    }

    return this.refresh();
  }

  /**
   * Translates this polygon to specified position.
   *
   * @param {black-engine~Vector} point Translation vector.
   * @return {black-engine~Polygon} This vertices.
   */
  setTranslation(point) {
    let center = this.mCenter;
    let vertices = this.mVertices;
    let len = vertices.length;
    point.subtract(center);

    for (let i = 0; i < len; i++) {
      vertices[i].add(point);
    }

    return this.refresh();
  }

  /**
   * Returns array of vertices.
   * 
   * @returns {Array<black-engine~Vector>}
   */
  get vertices() {
    return this.mVertices;
  }

  /**
   * Returns center points of this polygon.
   * @returns {black-engine~Vector}
   */
  get center() {
    return this.mCenter;  
  }

  // @ifdef DEBUG
  /**
   * String representation of this polygon.
   *
   * @ignore
   * @param {number=} [digits=2] Number of digits after float point.
   * @return {string} Description.
   */
  toString(digits = 2) {
    let thisLines = this.mLines;
    let thisVertices = this.mVertices;
    let len = thisLines.length;
    let vertices = '';
    let lines = '';

    for (let i = 0; i < len; i++) {
      lines += thisLines[i].toString(digits);
    }

    len = thisVertices.length;
    for (let i = 0; i < len; i++) {
      vertices += thisVertices[i].toString(digits);
    }

    return `Polygon { vertices: ${vertices}, bounds: ${this.mBounds.toString(digits)}, center: ${this.mCenter.toString()}, lines: ${lines} }`;
  }

  // @endif
}

/**
 * @ignore
 * @type {black-engine~Polygon}
 * @nocollapse
 */
Polygon.__cache = new Polygon();

/**
 * Mathematical representation of a bezier curve.
 *
 * @cat geom
 */
class Curve {
  /**
   * Creates new Curve instance.
   */
  constructor() {
    /** 
     * @private 
     * @type {Array<number>} 
     */
    this.mPoints = [];

    /** 
     * @private 
     * @type {Array<black-engine~Vector>} 
     */
    this.mLookup = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mBaked = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStep = 1 / 60;

    /** 
     * @private 
     * @type {Array<number>} 
     */
    this.mEachT = [];
  }

  /**
   * Sets new points coordinates.
   *
   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...
   * @return {black-engine~Curve} This curve.
   */
  set(...points) {
    this.mPoints = this.__initPoints(points);
    this.__refreshEachT();

    if (this.mBaked)
      this.__refreshCache();

    return this;
  }


  /**
   * Enables or disables interpolation from cache (lookup).
   * Returns true or false depending on baked is enabled or not.
   *
   * @return {boolean}
   */
  get baked() {
    return this.mBaked;
  }

  /**
   * @param  {boolean} label
   */
  set baked(label) {
    this.mBaked = label;

    if (!this.mLookup && this.mPoints) {
      this.__refreshCache();
    }
  }

  /**
   * Wides points array. Sets first point for next bezier same as last of previous.
   *
   * @private
   * @param  {Array<number>} points Array of points coordinates.
   * @return {Array<number>} Points coordinates array.
   */
  __initPoints(points) {
    let res = [];

    for (let i = 6; i < points.length; i += 6) {
      res = res.concat(points.slice(i - 6, i + 2));
    }

    return res;
  }

  /**
   * Refresh cache (lookup) for fast interpolations.
   *
   * @private
   * @return {black-engine~Curve} This curve.
   */
  __refreshCache() {
    let lookup = this.mLookup = [];
    let getFullLength = this.getFullLength();
    let points = this.mPoints;
    let pointsLen = points.length;

    for (let i = 0; i < pointsLen; i += 8) {
      let length = Curve.getLength(...points.slice(i, i + 8));
      let step = this.mStep * getFullLength / length;

      for (let t = step; t < 1; t += step)
        lookup.push(Curve.lerp(t, ...points.slice(i, i + 8)));
    }

    return this;
  }


  /**
   * Refresh local interpolation kof for each bezier in curve.
   *
   * @ignore
   * @private
   * @return {black-engine~Curve} This curve.
   */
  __refreshEachT() {
    let points = this.mPoints;
    let eachT = this.mEachT = [];
    let pointsLen = points.length;
    let eachLength = [];

    for (let i = 0; i < pointsLen; i += 8)
      eachLength.push(Curve.getLength(...points.slice(i, i + 8)));

    let length = this.getFullLength();
    let s = 0;
    for (let i = 0; i < pointsLen; i += 8) {
      s += eachLength[i / 8];
      eachT.push(s / length);
    }

    return this;
  }

  /**
   * Interpolates single bezier on t position.
   *
   * @param  {number} t Interpolation position (0...1).
   * @param  {number} startX
   * @param  {number} startY
   * @param  {number} cpStartX
   * @param  {number} cpStartY
   * @param  {number} cpEndX
   * @param  {number} cpEndY
   * @param  {number} endX
   * @param  {number} endY
   * @param  {black-engine~Vector=} outVector
   * @return {black-engine~Vector} Position on bezier.
   */
  static lerp(t, startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY, outVector) {
    let u = 1 - t;
    let tt = t * t;
    let uu = u * u;
    let uuu = uu * u;
    let ttt = tt * t;

    let p = outVector || new Vector();
    p.set(startX, startY);
    p.x *= uuu;
    p.y *= uuu;

    // first
    p.x += 3 * uu * t * cpStartX;
    p.y += 3 * uu * t * cpStartY;

    // second
    p.x += 3 * u * tt * cpEndX;
    p.y += 3 * u * tt * cpEndY;

    // third
    p.x += ttt * endX;
    p.y += ttt * endY;

    return p;
  }

  /**
   * Interpolates across whole curve.
   *
   * @param  {number} t Interpolation position (0...1).
   * @param  {black-engine~Vector=} outVector Vector to be returned.
   * @return {black-engine~Vector} Position on curve.
   */
  interpolate(t, outVector) {
    let res = outVector || new Vector();
    let lookup = this.mLookup;

    if (this.mBaked) {
      let i = Math.ceil((lookup.length - 1) * t);
      let p = lookup[i];
      res.copyFrom(p);

      return res;
    }

    // not backed
    let { mEachT, mPoints } = this;
    let i = 0;

    while (mEachT[i] < t)
      i++;

    let minT = mEachT[i - 1] || 0;
    let maxT = mEachT[i];
    let bezier = mPoints.slice(i * 8, i * 8 + 8);

    return Curve.lerp((t - minT) / (maxT - minT), ...bezier, res);
  }

  /**
   * Returns single bezier length.
   *
   * @param  {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX, endY
   * @return {number} Length.
   */
  static getLength(...points) {
    let p0 = new Vector(points[0], points[1]);
    let p1 = new Vector(points[2], points[3]);
    let p2 = new Vector(points[4], points[5]);
    let p3 = new Vector(points[6], points[7]);

    return (p3.distance(p0) + p0.distance(p1) + p1.distance(p2) + p2.distance(p3)) / 2;
  }

  /**
   * Returns this curve length.
   *
   * @return {number} Length.
   */
  getFullLength() {
    let points = this.mPoints;
    let mPointsLen = points.length;
    let res = 0;

    for (let i = 0; i < mPointsLen; i += 8)
      res += Curve.getLength(...points.slice(i, i + 8));

    return res;
  }
}

/**
 * @ignore
 * @type {black-engine~Curve}
 * @nocollapse
 */
Curve.__cache = new Curve();

/**
 * The type of the message. 
 * @cat core
 * @static
 * @constant
 * @enum {string}
 */
const MessageType = {
  DIRECT: 'direct',
  BUBBLE: 'bubble'
};

/**
 * The type of the binding. 
 * @cat core
 * @static
 * @constant
 * @enum {string}
 */
const BindingType = {
  REGULAR: 'regular',
  OVERHEARD: 'overheard'
};

/**
 * Message holds all information about dispatched event. This is a pooled object.
 *
 * @cat core
 */
class Message {
  constructor() {
    /** @type {black-engine~MessageDispatcher} The `MessageDispatcher` object, which posted this message. */
    this.sender = null;

    /** @type {string} The name of message. */
    this.name = '';

    /** @type {Object} `GameObject` which receives this message. */
    this.target = null;

    /** @type {Object} The point from which sending is begun. */
    this.origin = null;

    /** @type {boolean} Specifies if invocation of this message was canceled. */
    this.canceled = false;

    /** @type {black-engine~MessageType} Message type. See `MessageType` enum. */
    this.type = MessageType.DIRECT;
  }

  /**
   * Cancels message invocation.
   *
   * @return {void}
   */
  cancel() {
    this.canceled = true;
  }

  // @ifdef DEBUG
  /**
   * Generates message string representation.
   *
   * @return {string}
   */
  toString() {
    let name = this.sender.name !== undefined ? this.sender.name : '';
    return `MESSAGE: { name: '${this.name}', sender: '${name}', target: '${this.target.name}', path: '${this.path}' }`;
  }
  // @endif

  /**
   * @ignore
   * @returns {black-engine~Message}
   */
  __reset() {
    this.sender = null;
    this.name = '';
    this.target = null;
    this.canceled = false;
    this.type = MessageType.DIRECT;
    return this;
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get PROGRESS() {
    return 'progress';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get COMPLETE() {
    return 'complete';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get ERROR() {
    return 'error';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get CHANGE() {
    return 'change';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get READY() {
    return 'ready';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get UPDATE() {
    return 'update';
  }

  /** 
   * @const 
   * @public 
   * @type {string} 
   */
  static get RESIZE() {
    return 'resize';
  }

  static get pool() {
    return pool;
  }
}

/**
 * Pool for messages.
 *
 * @type {black-engine~ObjectPool}
 * @nocollapse
 *
 */
const pool = new ObjectPool(Message);

/**
 * A bridge between callback and context.
 * 
 * @cat core
 */
class MessageBinding {
  /**
   * @param {black-engine~MessageDispatcher} owner                The owner of this binding.
   * @param {string} name                            Name of the message.
   * @param {Function} callback                      Callback function.
   * @param {boolean} isOnce                         Indicates whenever this binding should be auto destroyed after first execution.
   * @param {*=} [context=null]                      Optional context (usually this).
   * @param {black-engine~BindingType} [type=BindingType.REGULAR] Type of the binding.
   * @param {?string} [pathPattern=null]             Glob pattern to filter sender by name.
   */
  constructor(owner, name, callback, isOnce, context = null, type = BindingType.REGULAR, pathPattern = null) {
    /** 
     * @ignore 
     * @type {black-engine~MessageDispatcher} 
     */
    this.owner = owner;

    /** 
     * @ignore 
     * @type {string} 
     */
    this.name = name;

    /** 
     * @ignore 
     * @type {Function} 
     */
    this.callback = callback;

    /** 
     * @ignore 
     * @type {boolean} 
     */
    this.isOnce = isOnce;

    /** 
     * @ignore 
     * @type {*} 
     */
    this.context = context;

    /** 
     * @ignore 
     * @type {?string} 
     */
    this.pathPattern = pathPattern;

    /** 
     * @ignore 
     * @type {black-engine~Glob|null} 
     */
    this.glob = pathPattern == null ? null : new Glob(pathPattern);

    /** 
     * @ignore 
     * @type {black-engine~BindingType} 
     */
    this.type = type;
  }

  /**
   * Destroys this binding.
   */
  off() {
    this.owner.__off(this);
  }

  /**
   * @ignore
   * @returns {black-engine~MessageBinding}
   */
  __reset() {
    this.owner = null;
    this.pathPattern = null;
    return this;
  }
}

var mInstance = null;

/**
 * Connects all the dots.
 * 
 * @static
 * @staticClass
 */
class Black {
  constructor() {
    mInstance = this;

    /**
     * @private
     * @type {black-engine~Engine}
     */
    this.mEngine = null;

    /**
     * @private
     * @type {black-engine~Input}
     */
    this.mInput = null;

    /**
     * @private
     * @type {black-engine~MasterAudio}
     */
    this.mAudio = null;

    /**
     * @private
     * @type {black-engine~Time}
     */
    this.mTime = null;

    /**
     * @private
     * @type {black-engine~Device}
     */
    this.mDevice = null;

    /**
     * @private
     * @type {black-engine~AssetManager}
     */
    this.mAssets = null;

    /**
     * Active camera instance.
     * 
     * @private
     * @type {black-engine~Camera}
     */
    this.mCamera = null;
  }
  
  /**
   * Returns current Black Engine instance.
   * 
   * @returns {black-engine~Engine}
   */
  static get engine() {
    return mInstance.mEngine;
  }

  /**
   * Sets new Engine instance.
   * @param {black-engine~Engine} value
   */
  static set engine(value) {
    mInstance.mEngine = value;
  }

  /**
   * Returns current active Input System instance.
   * 
   * @returns {black-engine~Input}
   */
  static get input() {
    return mInstance.mInput;
  }

  /**
   * Sets new Input System.
   * @param {black-engine~Input} value
   */
  static set input(value) {
    mInstance.mInput = value;
  }

  /**
   * Returns current active Audio System instance.
   * 
   * @returns {black-engine~MasterAudio}
   */
  static get audio() {
    return mInstance.mAudio;
  }

  /**
   * Sets new Audio System.
   * @param {black-engine~MasterAudio} value
   */
  static set audio(value) {
    mInstance.mAudio = value;
  }
  
  /**
   * Returns current Time management instance.
   * 
   * @returns {black-engine~Time}
   */
  static get time() {
    return mInstance.mTime;
  }

  /**
   * Sets new Time instance.
   * @param {black-engine~Time} value
   */
  static set time(value) {
    mInstance.mTime = value;
  }  

  /**
   * Returns current Device instance.
   * 
   * @returns {black-engine~Device}
   */
  static get device() {
    return mInstance.mDevice;
  }

  /**
   * Sets new Device instance.
   * @param {black-engine~Device} value
   */
  static set device(value) {
    mInstance.mDevice = value;
  }

  /**
   * Default AssetManager instance. Sprite and other classes uses this instance to find textures by name.
   * It will be automatically re-assigned when new AssetManager is created.
   * 
   * @returns {black-engine~AssetManager}
   */
  static get assets() {
    return mInstance.mAssets;
  }

  /**
   * Sets new AssetManager.
   * @param {black-engine~AssetManager} value
   */
  static set assets(value) {
    mInstance.mAssets = value;
  }

  /**
   * Returns current stage.
   *
   * @readonly
   * @returns {black-engine~Stage}
   */
  static get stage() {
    return mInstance.mEngine.mStage;
  }

  /**
   * Returns current video driver.
   *
   * @readonly
   * @returns {black-engine~VideoNullDriver}
   */
  static get driver() {
    return mInstance.mEngine.mVideo;
  }

  /**
   * Returns active camera instance.
   * 
   * @returns {black-engine~Camera}
   */
  static get camera() {
    if (mInstance.mCamera !== null && mInstance.mCamera.mAdded === true)
      return mInstance.mCamera;

    return null;
  }

  /**
   * Sets default camera;
   * @param {black-engine~Camera} value
   */
  static set camera(value) {
    mInstance.mCamera = value;
  }

  /**
   * @readonly
   * @returns {number}
   */
  static get magic() {
    return Math.random();
  }
}

new Black();

/**
 * The MessageDispatcher class is the base class for all classes that posts messages.
 *
 * Global messages will not be dispatched on non GameObject objects.
 *
 * @cat core
 */
class MessageDispatcher {
  /**
   * Creates new MessageDispatcher instance
   * @param {boolean} [checkForStage=false]
   */
  constructor(checkForStage = false) {
    this.mBindings = null;
    this.checkForStage = checkForStage;
  }

  /**
   * Adds listener by given name and callback.
   *
   * @public
   * @param {string} name       Message name.
   * @param {Function} callback Function to be called on message send.
   * @param {*} [context=null]  Object to be used as `this` in callback function.
   * @return {black-engine~MessageBinding}
   */
  on(name, callback, context) {
    return this.__on(name, callback, false, context);
  }

  /**
   * Removes all bindings by given message name.
   * 
   * @public
   * @param {...string} names One or more message name.
   * @returns {void}
   */
  off(...names) {
    for (let i = 0; i < names.length; i++) {
      const name = names[i];

      let earIndex = name.indexOf('@');
      if (earIndex !== -1) {
        Debug.error('Removing overheard bindings is not allowed.');
        return;
      }

      if (this.mBindings !== null && this.mBindings.hasOwnProperty(name) === true) {
        let bindings = this.mBindings[name].slice();

        for (let i = 0; i < bindings.length; i++)
          this.__off(bindings[i]);
      }
    }
  }

  /**
   * Adds listener by given name and callback. Binding will be automatically removed after first execution.
   *
   * @public
   * @param {string} name       Message name.
   * @param {Function} callback Function to be called on message send.
   * @param {*} [context=null]  Object to be used as `this` in callback function.
   * @return {black-engine~MessageBinding}
   */
  once(name, callback, context) {
    return this.__on(name, callback, true, context);
  }

  /**
   * Posts message with a given params.
   * 
   * Adding `~` character to the begging of the name will bubble message to the top of the tree.
   *
   * @public
   * @param {string} name  The name of a message
   * @param {...*} params  A list of params to send
   * @return {void}
   */
  post(name, ...params) {
    let message = this.__draftMessage(name);

    if (message.type === MessageType.DIRECT)
      this.__invoke(this, message, ...params);
    else if (message.type === MessageType.BUBBLE)
      this.__postBubbles(this, message, true, ...params);

    if (message.canceled === false)
      this.__invokeOverheard(this, message, ...params);

    Message.pool.release(message);
  }

  /**
   * Returns parent MessageDispatcher.
   * 
   * @readonly
   * @return {black-engine~MessageDispatcher|null}
   */
  get parent() {
    return null;
  }

  /**
   * Returns the stage Game Object to which this belongs to or null if not added onto stage.
   *
   * @readonly
   * @return {black-engine~Stage|null}
   */
  get stage() {
    return null;
  }

  /**
   * Returns string representing a url like path to this object in the display
   * tree.
   *
   * @readonly
   * @return {string|null}
   */
  get path() {
    return null;
  }

  /**
   * @private
   * @ignore
   * @param {string} name
   * @param {Function} callback
   * @param {boolean} [isOnce=false]
   * @param {*} [context=null]
   * @return {black-engine~MessageBinding}
   */
  __on(name, callback, isOnce = false, context = null) {
    Debug.assert(name !== null, 'name cannot be null.');
    Debug.assert(name.trim().length > 0, 'name cannot be null.');
    Debug.assert(!(name.indexOf('~') === 0), 'Using `~` is not tot allowed here.');
    Debug.assert(callback !== null, 'callback cannot be null.');

    let earIndex = name.indexOf('@');
    if (earIndex !== -1) {
      let messageName = name.substring(0, earIndex);
      let pathPattern = name.substring(earIndex + 1);
      let global = MessageDispatcher.mOverheardHandlers;

      if (global.hasOwnProperty(messageName) === false)
        global[messageName] = [];

      let bindings = global[messageName];
      let binding = new MessageBinding(this, messageName, callback, isOnce, context, BindingType.OVERHEARD, pathPattern);
      bindings.push(binding);
      return binding;
    }

    if (this.mBindings === null)
      this.mBindings = {};

    if (this.mBindings.hasOwnProperty(name) === false)
      this.mBindings[name] = [];

    let binding = new MessageBinding(this, name, callback, isOnce, context, BindingType.REGULAR);
    this.mBindings[name].push(binding);

    return binding;
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~MessageBinding} binding 
   */
  __off(binding) {
    if (binding.type === BindingType.REGULAR) {
      if (this.mBindings === null)
        return;

      if (this.mBindings.hasOwnProperty(binding.name) === false)
        return;

      let bindings = this.mBindings[binding.name];
      const ix = bindings.indexOf(binding);
      if (ix === -1)
        return;

      bindings.splice(ix, 1);
    } else if (binding.type === BindingType.OVERHEARD) {
      let global = MessageDispatcher.mOverheardHandlers;
      if (global.hasOwnProperty(binding.name) === false)
        return;

      let bindings = global[binding.name];

      const ix = bindings.indexOf(binding);
      if (ix === -1)
        return;

      bindings.splice(ix, 1);
    }
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~MessageDispatcher} sender 
   * @param {black-engine~Message} message 
   * @param {...*} params 
   * @return {void}
   */
  __invoke(sender, message, ...params) {
    if (message.canceled === true)
      return;

    if (this.mBindings === null)
      return;

    if (this.checkForStage === true && this !== Black.stage && this.stage === null)
      return;

    let bindings = (this.mBindings[message.name]);

    if (bindings === undefined || bindings.length === 0)
      return;

    let cloned = bindings.slice(0);

    for (let i = 0; i < cloned.length; i++) {
      message.target = this;

      let binding = cloned[i];

      if (this.checkForStage === true && binding.owner.stage === Black.stage && binding.owner.stage === null)
        continue;

      binding.callback.call(binding.context, message, ...params);

      if (binding.isOnce === true)
        this.__off(binding);

      if (message.canceled === true)
        return;
    }
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~MessageDispatcher}  sender
   * @param {black-engine~Message}  message
   * @param {...*} params
   * @return {void}
   */
  __invokeOverheard(sender, message, ...params) {
    if (message.canceled === true)
      return;

    let bindings = MessageDispatcher.mOverheardHandlers[message.name];

    if (bindings === undefined || bindings.length === 0)
      return;

    let cloned = bindings.slice(0);

    for (let i = 0; i < cloned.length; i++) {
      let binding = cloned[i];

      if (this.checkForStage === true && binding.owner.stage === Black.stage && binding.owner.stage === null)
        continue;

      if (!this.__checkPath(sender.path, binding))
        continue;

      message.target = this;
      binding.callback.call(binding.context, message, ...params);

      if (binding.isOnce === true)
        this.__off(binding);

      if (message.canceled === true)
        return;
    }
  }

  /**
   * Message will always reach the stage even if some of the middle nodes were removed during process of invocation.
   * 
   * @private
   * @ignore
   * @param {*}  sender
   * @param {Message}  message
   * @param {boolean}  toTop
   * @param {...*} params
   * @return {void}
   */
  __postBubbles(sender, message, toTop, ...params) {
    message.origin = this;

    let list = [this];

    let current = this;
    while (current.parent !== null) {
      list.push(current.parent);
      current = current.parent;
    }

    for (let i = 0; i < list.length; i++) {
      let dispatcher = list[i];
      dispatcher.__invoke(sender, message, ...params);

      if (message.canceled === true)
        return;
    }
  }

  /**
   * @private
   * @ignore
   * 
   * @param {string} name 
   * @returns {black-engine~Message}
   */
  __draftMessage(name) {
    const message = Message.pool.get();
    message.__reset();

    message.sender = this;

    if (name.charAt(0) === '~') {
      message.name = name.substr(1);
      message.type = MessageType.BUBBLE;
    } else {
      message.name = name;
    }

    return message;
  }

  /**
   * @ignore
   * @private
   * @param {string|null} path
   * @param {black-engine~MessageBinding} binding
   * @returns {boolean}
   */
  __checkPath(path, binding) {
    if (path === null || binding.pathPattern === null)
      return false;

    if (path === binding.pathPattern)
      return true;

    if (binding.pathPattern.indexOf('*') === -1)
      return path === binding.pathPattern;

    return binding.glob.test(path);
  }

  static dispose() {
    MessageDispatcher.mOverheardHandlers = {};
  }
}

/**
 * @private
 * @type {Object.<string, Array>}
 */
MessageDispatcher.mOverheardHandlers = {};

/**
 * @cat display.text
 * @static
 * @constant
 * @enum {string}
 */
const FontStyle = {
  NORMAL: 'normal',
  ITALIC: 'italic'
};

/**
 * @cat display.text
 * @static
 * @constant
 * @enum {string}
 */
const FontWeight = {
  NORMAL: '400',
  BOLD: '700'
};

/**
 * @private
 * @ignore
 * @type {TextStyle|null}
 */
let defaultStyle = null;

/**
 * Holds TextField's style details.
 *
 * @cat display.text
 */
class TextStyle {
  /**
   * Creates instance of TextStyle.
   * @param  {string=} family                                             Font name
   * @param  {number=} [color=0x0]                                        Text color as hexadecimal number eg 0xff0000 (total red)
   * @param  {number=} [size=14]                                          Text size
   * @param  {black-engine~FontStyle=} [style=FontStyle.NORMAL]                        Text style eg italic
   * @param  {black-engine~FontWeight=} [weight=FontWeight.NORMAL]                     Font thickness. The value is set from 100 to 900 in increments of 100.
   * @param  {number=} [strokeThickness=0]                                Thickness of the stroke. 0 means that no stroke
   * @param  {number=} [strokeColor=0xffffff]                             Stroke color as hexadecimal number eg 0x00ff00 (total green)
   */
  constructor(family = 'sans-serif', color = 0x000000, size = 14, style = FontStyle.NORMAL, weight = FontWeight.NORMAL, strokeThickness = 0, strokeColor = 0xffffff) {
    /** @type {string} */
    this.name = 'def';

    /** @type {string} */
    this.family = family;

    /** @type {number} */
    this.size = size;

    /** @type {number} */
    this.color = color;

    /** @type {number} */
    this.alpha = 1;

    /** @type {black-engine~FontStyle} */
    this.style = style;

    /** @type {black-engine~FontWeight} */
    this.weight = weight;

    /** @type {number} */
    this.strokeThickness = strokeThickness;

    /** @type {number} */
    this.strokeColor = strokeColor;

    /** @type {number} */
    this.strokeAlpha = 1;

    /** @type {boolean} */
    this.dropShadow = false;

    /** @type {number} */
    this.shadowDistanceX = 0;

    /** @type {number} */
    this.shadowDistanceY = 0;

    /** @type {number} */
    this.shadowColor = 0x0;

    /** @type {number} */
    this.shadowAlpha = 1;

    /** @type {number} */
    this.shadowBlur = 0;
  }

  /**
   * @deprecated
   */
  clone(family = null, color = NaN, size = NaN, style = null, weight = null, strokeThickness = NaN, strokeColor = NaN) {
    let ret = new TextStyle();
    ret.family = family === null ? this.family : family;
    ret.size = isNaN(size) ? this.size : size;
    ret.color = isNaN(color) ? this.color : color;
    ret.style = style === null ? this.style : style;
    ret.weight = weight === null ? this.weight : weight;
    ret.strokeThickness = isNaN(strokeThickness) ? this.strokeThickness : strokeThickness;
    ret.strokeColor = isNaN(strokeColor) ? this.strokeColor : strokeColor;

    ret.dropShadow = this.dropShadow;
    ret.shadowAlpha = this.shadowAlpha;
    ret.shadowBlur = this.shadowBlur;
    ret.shadowColor = this.shadowColor;
    ret.shadowDistanceX = this.shadowDistanceX;
    ret.shadowDistanceY = this.shadowDistanceY;

    return ret;
  }

  /**
   * Returns default TextStyle instance.
   * 
   * @returns {black-engine~TextStyle}
   */
  static get default() {
    if (defaultStyle === null)
      defaultStyle = new TextStyle('sans-serif', 0x0, 14, FontStyle.NORMAL, FontWeight.NORMAL, 0, 0x0);

    return defaultStyle;
  }
}

/** 
 * @ignore 
 * @static 
 * @private
 */
let CACHE = {};

/** 
 * @ignore 
 * @static 
 * @private
 */
let CONTEXT = null;

/** 
 * @ignore 
 * @static 
 * @private
 * @type {HTMLCanvasElement|OffscreenCanvas}
 */
let CANVAS = null;

let useOffscreenCanvas = false;

/**
 * Font measurement tools.
 *
 * @cat display.text
 */
class FontMetrics {
  /**
   * Creates new instance of FontMetrics. Do not use constructor directly instead use {@link FontMetrics#get} method.
   *
   * @ignore
   * @private
   * @param {black-engine~TextStyle} style Default text info with 24 font size.
   */
  constructor(style) {
    if (CONTEXT === null) {
      if (typeof OffscreenCanvas !== 'undefined' && useOffscreenCanvas === true) {
        CANVAS = new OffscreenCanvas(10, 200);
        CONTEXT = CANVAS.getContext('2d');
      } else {
        CANVAS = /** @type {HTMLCanvasElement} */(document.createElement('canvas'));
        CONTEXT = CANVAS.getContext('2d');

        CANVAS.width = 10;
        CANVAS.height = 200;
      }
    }

    style.size = 24;

    /** @private */
    this.mCanvas = CANVAS;

    /** @private */
    this.mCtx = CONTEXT;

    /** 
     * @private 
     * @type {black-engine~TextStyle} 
     */
    this.mStyle = style;

    const drawY = Math.floor(CANVAS.height * 0.7766);
    this.mCtx.clearRect(0, 0, this.mCanvas.width, this.mCanvas.height);
    this.mCtx.font = `${style.weight} ${style.size}px ${style.family}`;
    this.mCtx.fillText('x', 0, drawY, 1);

    let data = this.mCtx.getImageData(0, 0, 1, this.mCanvas.height).data;

    const xHeight = this.__getBottom(data) - this.__getTop(data);

    for (let i = 32; i <= 126; i++) {
      this.mCtx.fillText(String.fromCharCode(i), 0, drawY, 1);
    }

    data = this.mCtx.getImageData(0, 0, 1, this.mCanvas.height).data;

    const top = this.__getTop(data);
    const bottom = this.__getBottom(data);
    const baseLine = drawY - top;
    const height = bottom - top;

    /**
     * The line upon which most letters "sit" and below which descender extend.
     * @public
     * @type {number}
     */
    this.baseline = baseLine;

    /**
     * The maximum y position for the lowest glyph in the font.
     * @public
     * @type {number}
     */
    this.bottom = height;

    /**
     * The recommended distance above the mean line (top of lower case characters) for singled spaced text.
     * @public
     * @type {number}
     */
    this.ascent = baseLine - xHeight;

    /**
     * The recommended distance below the baseline for singled spaced text.
     * @public
     * @type {number}
     */
    this.descent = height - baseLine;

    /**
      * The distance between the baseline and the mean line of lower-case letters, i.e height of `x` character.
      * @public
      * @type {number}
      */
    this.xHeight = xHeight;

    /**
     * The height of a capital letter above the baseline.
     * @public
     * @type {number}
     */
    this.capHeight = baseLine;
  }

  /**
   * Gets/sets if OffscreenCanvas should be used to measure text width. Usefull when running Black Engine inside worker.
   * @returns {boolean}
   */
  static get useOffscreenCanvas() {
    return useOffscreenCanvas;
  }

  /**
   * @param {boolean} value
   * @returns {void}
   */
  static set useOffscreenCanvas(value) {
    useOffscreenCanvas = value;
  }

  /**
   * `capHeight` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get capHeightNormalized() {
    return this.capHeight / this.mStyle.size;
  }

  /**
   * `xHeight` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get xHeightNormalized() {
    return this.xHeight / this.mStyle.size;
  }

  /**
   * `ascent` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get ascentNormalized() {
    return this.ascent / this.mStyle.size;
  }

  /**
   * `descent` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get descentNormalized() {
    return this.descent / this.mStyle.size;
  }

  /**
   * `baseline` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get baselineNormalized() {
    return this.baseline / this.mStyle.size;
  }

  /**
   * `bottom` normalized.
   *
   * @readonly
   * @public
   * @returns {number}
   */
  get bottomNormalized() {
    return this.bottom / this.mStyle.size;
  }

  /**
   * @ignore
   * @private
   * @param {Uint8ClampedArray} data
   * @returns {number}
   */
  __getTop(data) {
    for (let i = 3, n = data.length; i < n; i += 4) {
      if (data[i] > 0) {
        return (i - 3) / 4;
      }
    }

    return data.length / 4;
  }

  /**
   * @ignore
   * @private
   * @param {Uint8ClampedArray} data
   * @returns {number}
   */
  __getBottom(data) {
    for (let i = data.length - 1; i > 0; i -= 4) {
      if (data[i] > 0) {
        return (i + 1) / 4;
      }
    }

    return 0;
  }

  /**
   * Use this method instead of constructor.
   *
   * @static
   * @param {string} fontName Name of font.
   * @returns {black-engine~FontMetrics}
   */
  static get(fontName) {
    let cache = CACHE[fontName];

    if (cache == null) {
      let style = new TextStyle(fontName, 0, 24);
      cache = new FontMetrics(style);
      CACHE[fontName] = cache;
    }

    return cache;
  }
}

/**
 * Object representing text measurement result.
 * 
 * @cat display.text
 */
class TextMetricsData {
  constructor() {

    /**
     * Array of TextSegmentMetricsData objects containing style, bounds and other metrics information for each segment,
     * @type {Array<black-engine~TextSegmentMetricsData>}
     */
    this.segments = []; // TextPartMetricsData

    /**
     * The sum bounds, including all segments.
     * @type {black-engine~Rectangle}
     */
    this.bounds = new Rectangle();

    /**
     * Bounds plus stroke size.
     * @type {black-engine~Rectangle}
     */
    this.strokeBounds = null;

    /**
     * Bounds of text shadow.
     * @type {black-engine~Rectangle}
     */
    this.shadowBounds = null;

    /**
     * Array if widths for each line.
     * @type {Array<number>}
     */
    this.lineWidth = [];
  }
}

/**
 * Object representing text segment measurement result.
 * 
 * @cat display.text
 */
class TextSegmentMetricsData {
  constructor(text, style, lineIndex, bounds) {

    /**
     * Text value for this segment.
     * @type {string}
     */
    this.text = text;

    /**
     * The style of this segment.
     * @type {black-engine~TextStyle}
     */
    this.style = style;

    /**
     * The line index for this segment.
     * @type {number}
     */
    this.lineIndex = lineIndex;

    /**
     * The bounds of this segment.
     * @type {black-engine~Rectangle}
     */
    this.bounds = bounds;
  }
}


/**
 * @ignore
 * @private
 * @static
 * @type {HTMLElement|Element|null}
 */
let canvasElement = null;
let context = null;

/**
 * Provides native text measurement tools
 * 
 * @cat display.text
 * @static
 */
class TextMetricsEx {
  constructor() {
    throw new Error('Singleton');
  }

  /**
   * Measures the area of provided text. In case style is not defined the default style will be used. Text is vertically
   * aligned by its baseline. 
   * 
   * @static
   * @param {string} text                            The text to measure.
   * @param {number} lineHeight                      The height of the line.
   * @param {...black-engine~TextStyle} styles The TextStyle object representing text properties and formatting.
   * 
   * @returns {black-engine~TextMetricsData} Object representing bounds for each rich text part.
   */
  static measure(text, lineHeight, ...styles) {
    let parts = [];

    const regex = /(~{([^}]+)}|^)(.+?(?=~{.+}|$|^))|(\n)/gm;

    let m;
    let currTag = 'def';
    let lineIx = 0;

    while ((m = regex.exec(text)) !== null) {
      if (m[4])
        lineIx++;

      if (m[2])
        currTag = m[2];

      if (m[3])
        parts.push({ tag: currTag, text: m[3], style: styles.filter(x => x.name === currTag)[0], lineIndex: lineIx });
    }

    let data = new TextMetricsData();
    let defaultStyle = styles.filter(x => x.name === 'def')[0] || TextStyle.default;
    let lineHeightPx = defaultStyle.size * lineHeight;
    let sumBounds = new Rectangle();
    let sumStrokeBounds = new Rectangle();
    let sumShadowBounds = null;

    let lastLineIndex = -1;
    let currentX = 0;
    let currentY = 0;

    let defaultFontMetrics = FontMetrics.get(defaultStyle.family);
    let defaultBaseline = defaultFontMetrics.baselineNormalized * defaultStyle.size;

    for (let i = 0; i < parts.length; i++) {
      let part = parts[i];
      let style = part.style;
      let bounds = TextMetricsEx.__measure(part.text, style);
      let baseline = FontMetrics.get(style.family).baselineNormalized * style.size;

      if (lastLineIndex !== part.lineIndex) {
        data.lineWidth[part.lineIndex] = 0;
        currentX = 0;
      }

      currentY = (lineHeightPx * part.lineIndex) + defaultBaseline - baseline;

      bounds.x = currentX + 2;
      bounds.y = currentY + 2;

      currentX += bounds.width;

      lastLineIndex = part.lineIndex;

      part.bounds = bounds;
      data.lineWidth[part.lineIndex] += bounds.width;

      sumBounds.union(bounds);
      sumStrokeBounds.union(bounds.clone().inflate(style.strokeThickness, style.strokeThickness));

      if (style.dropShadow === true) {
        let shadowBounds = bounds.clone();
        shadowBounds.inflate(style.shadowBlur, style.shadowBlur);
        shadowBounds.x += style.shadowDistanceX;
        shadowBounds.y += style.shadowDistanceY;
        sumShadowBounds = sumShadowBounds || shadowBounds;
        sumShadowBounds.union(shadowBounds);
      }

      data.segments.push(new TextSegmentMetricsData(part.text, style, part.lineIndex, part.bounds));
    }

    data.bounds = sumBounds;
    data.strokeBounds = sumStrokeBounds;
    data.shadowBounds = sumShadowBounds || new Rectangle();

    return data;
  }

  /**
   * Measures the area of provided text. Multiline is not supported.
   * 
   * @static
   * @param {string} text         The text to measure.
   * @param {black-engine~TextStyle} style     The TextStyle object representing text properties and formatting.
   * @param {?black-engine~Rectangle} [outBounds=null] Out param into which bounds of the text will be stored.
   * @returns {black-engine~Rectangle} Bounds of the text;
   */
  static __measure(text, style, outBounds = null) {
    Debug.assert(style != null, 'Style cannot be null');

    outBounds = outBounds || new Rectangle();
    outBounds.zero();

    let fontMetrics = FontMetrics.get(style.family);

    if (canvasElement === null) {
      if (typeof OffscreenCanvas !== 'undefined' && FontMetrics.useOffscreenCanvas === true) {
        // this is only for worker
        canvasElement = new OffscreenCanvas(0, 0);
        context = canvasElement.getContext('2d');
      } else {
        canvasElement = document.createElement('canvas');
        context = canvasElement.getContext('2d');
      }
    }

    let extraX = 0;
    if (style.style === FontStyle.ITALIC)
      extraX = (fontMetrics.bottomNormalized * style.size) / 4;

    context.font = `${style.weight} ${style.style} ${style.size}px ${style.family}`;
    let width = Math.ceil(context.measureText(text).width);

    return outBounds.set(0, fontMetrics.baselineNormalized * style.size, width + 2 + extraX, fontMetrics.bottomNormalized * style.size + 2);
  }

  /**
   * Measures the area of provided text
   * 
   * @static
   * @param {string} text 
   * @param {black-engine~BitmapFontData} data 
   * @param {number} lineHeight 
   * @param {black-engine~Rectangle} outBounds 
   * @returns {black-engine~Rectangle}
   */
  static measureBitmap(text, data, lineHeight, outBounds) {
    outBounds = outBounds || new Rectangle();

    let prevCharCode = -1;
    let cx = 0;
    let cy = 0;

    let maxHeight = 0;
    let maxWidth = 0;

    for (let i = 0; i < text.length; i++) {
      let charCode = text.charCodeAt(i);

      if (/(?:\r\n|\r|\n)/.test(text.charAt(i))) {
        cx = 0;
        cy += data.lineHeight * lineHeight;
        prevCharCode = -1;
        continue;
      }

      let charData = data.chars[charCode];

      if (charData == null)
        continue;

      if (prevCharCode >= 0 && charData.kerning[prevCharCode])
        cx += charData.kerning[prevCharCode];

      cx += charData.xAdvance;

      maxWidth = Math.max(maxWidth, cx + charData.xOffset);
      maxHeight = Math.max(maxHeight, cy + charData.height + charData.yOffset);

      prevCharCode = charCode;
    }

    return outBounds.set(0, 0, maxWidth, maxHeight);
  }
}

/**
 * Provides time related methods.
 *
 * @cat core
 * 
 * @static
 */
class Time {
  constructor() {
    /** 
     * @private
     * @type {number} 
     */
    this.mTime = 0;

    /** 
     * @private
     * @type {number} 
     */
    this.mActualTime = 0;

    /** 
     * @private
     * @type {number} 
     */
    this.mDeltaTimeMs = 1000 / 60;

    /** 
     * @private
     * @type {number} 
     */
    this.mDeltaTime = (1000 / 60) * 0.001;

    /** 
     * @private
     * @type {number} 
     */
    this.mScale = 1;

    /** 
     * @private
     * @type {number} 
     */
    this.mAlphaTime = 0;

    /** 
     * @private
     * @type {number} 
     */
    this.mRenderOffset = 0;
  }

  /**
   * Time since start in seconds.
   * 
   * @static
   * @returns {number}
   */
  get now() {
    return this.mTime;
  }

  /**
   * Time since last frame.
   * 
   * @static
   * @returns {number}
   */
  get dt() {
    return this.mDeltaTime * this.mScale;
  }

  /**
   * Time since last update.
   * 
   * @static
   * @returns {number}
   */
  get alpha() {
    return this.mAlphaTime;
  }

  /**
   * Time since last frame.
   * 
   * @static
   * @returns {number}
   */
  get delta() {
    return this.mDeltaTime * this.mScale;
  }

  /**
   * Gets/Sets timescale for engine
   * 
   * @returns {number}
   */
  get scale() {
    return this.mScale;
  }

  /**
   * @param {number} value
   */
  set scale(value) {
    Debug.assert(value >= 0, 'Time scale must be >= 0.');

    this.mScale = value;
  }
}

/**
 * Base class for custom systems. System is used to listen scene changes.
 *
 * @cat core
 * @extends black-engine~MessageDispatcher
 */
class System extends MessageDispatcher {
  constructor() {
    super();
  }

  /**
   * Called when engine is paused.
   *
   * @public
   * @return {void} 
   */
  onPause() { }

  /**
   * Called when engine is resumed.
   *
   * @public
   * @return {void} 
   */
  onResume() { }

  /**
   * onUpdate
   *
   * @protected
   * @return {void} 
   */
  onUpdate() { }

  /**
   * onPostUpdate
   *
   * @protected
   * @return {void}
   */
  onPostUpdate() { }

  /**
   * onRender
   *
   * @protected
   * @return {void}
   */
  onRender() { }

  /**
   * onChildrenAdded
   *
   * @protected
   * @param {black-engine~GameObject} gameObject GameObject instance.
   * @return {void}
   */
  onChildrenAdded(gameObject) { }

  /**
   * onChildrenRemoved
   *
   * @protected
   * @param {black-engine~GameObject} gameObject GameObject instance.
   * @return {void}
   */
  onChildrenRemoved(gameObject) { }

  /**
   * onChildrenRemoved
   *
   * @protected
   * @param {black-engine~GameObject} gameObject GameObject instance.
   * @return {void}
   */
  onChildrenChanged(gameObject) { }

  /**
   * onComponentAdded
   *
   * @protected
   * @param {black-engine~GameObject} child GameObject instance.
   * @param {black-engine~Component} component Component instance added to game object.
   * @return {void} 
   */
  onComponentAdded(child, component) { }

  /**
   * onComponentRemoved
   *
   * @protected
   * @param {black-engine~GameObject} child GameObject instance.
   * @param {black-engine~Component} component Component instance removed from game object.
   * @return {void}
   */
  onComponentRemoved(child, component) { }

  /**
   * Disposes all allocated resources.
   */
  dispose() { }
}

/**
 * Orientation
 * @cat display
 * @enum {string}
 * @static
 * @constant
 */
const Orientation = {
  /** Automatically detects orientation and switches width and height depending on device orientation. */
  UNIVERSAL: 'universal',
  LANDSCAPE: 'landscape',
  PORTRAIT: 'portrait'
};

/**
 * Manages viewport, handles DOM container resize events and updates internal data.
 * When firing `resize` event stage bounds will be not up to date. Listen for stage's `resize` message instead.
 *
 * @cat core
 * @fires Viewport#resize
 * @extends black-engine~MessageDispatcher
 */
class Viewport extends MessageDispatcher {
  /**
   * constructor
   * @param {HTMLElement|null} containerElement The native HTML element.
   * @return {void}
   */
  constructor(containerElement = null) {
    super();

    /** 
     * @private 
     * @type {HTMLElement|null} 
     */
    this.mContainerElement = containerElement;

    /** 
     * @private 
     * @type {HTMLElement|Element|null} 
     */
    this.mViewportElement = null;

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mSize = new Rectangle();

    /** 
     * @private 
     * @type {boolean} 
     */
    this.isTransparent = true;

    /** 
     * @private 
     * @type {number} 
     */
    this.backgroundColor = 0x000000;

    /** 
     * @private 
     * @type {number} 
     */
    this.mChecksLeftSeconds = 0;

    /** 
     * @private 
     * @type {black-engine~Orientation} 
     */
    this.mOrientation = Orientation.UNIVERSAL;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mOrientationLock = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mRotation = 0;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsPrimary = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mReflect = false;

    /**
     * @private
     * @type {Function}
     */
    this.mBoundResize;

    this.__initialize();
  }

  /**
   * @ignore
   */
  __initialize() {
    this.mViewportElement = /** @type {HTMLElement} */ (document.createElement('div'));
    this.mViewportElement.style.position = 'relative';
    this.mContainerElement.appendChild(this.mViewportElement);

    let style = this.mContainerElement.style;
    style.userSelect = 'none';
    style.touchAction = 'none';
    style.cursor = 'auto';
    style.WebkitTapHighlightColor = 'rgba(0, 0, 0, 0)';

    let size = this.mContainerElement.getBoundingClientRect();
    this.mSize.set(size.left, size.top, size.width, size.height);

    this.mIsPrimary = this.isPrimary();

    this.__onResize();

    this.mBoundResize = x => this.__onResize();
    window.addEventListener('resize', this.mBoundResize);
  }

  isPrimary() {
    const orientation = screen.msOrientation || (screen.orientation || screen.mozOrientation || {}).type;

    if (orientation === 'landscape-primary' || orientation === 'portrait-primary')
      return true;
    else if (orientation === 'landscape-secondary' || orientation === 'portrait-secondary')
      return false;

    Debug.warn('The orientation API isn\'t supported in this browser');

    return true;
  }

  /**
   * Gets/Sets stage orientation.
   *
   * @returns {black-engine~Orientation}
   */
  get orientation() {
    return this.mOrientation;
  }

  /**
   * @param {black-engine~Orientation} value
   * @returns {void}
   */
  set orientation(value) {
    this.mOrientation = value;
    this.__onResize();
  }

  /**
   * Gets/sets whenever stage orientation should be locked. If false and orientation is not universal stage will remain same size in both orientation.
   * @returns {boolean}
   */
  get orientationLock() {
    return this.mOrientationLock;
  }

  /**
   * @param {boolean} value
   * @returns {void}
   */
  set orientationLock(value) {
    this.mOrientationLock = value;
    this.__onResize();
  }

  /**
   * @private
   * @ignore
   */
  __update() {
    if (this.mChecksLeftSeconds <= 0)
      return;

    this.__onResize();

    this.mChecksLeftSeconds -= Black.time.delta;
  }

  /**
   * Refreshes viewport size and posts Message.RESIZE message. Make sure to refresh stage too in case container has changed its size.
   */
  refresh() {
    this.__onResize();
  }

  /**
   * @private
   * @ignore
   */
  __onResize() {
    const viewportElementStyle = this.mViewportElement.style;
    const size = this.mContainerElement.getBoundingClientRect();
    const deviceOrientation = size.width > size.height ? Orientation.LANDSCAPE : Orientation.PORTRAIT;

    const dispatchSize = Rectangle.pool.get().copyFrom(size);
    const wasPrimary = this.mIsPrimary;
    this.mIsPrimary = this.isPrimary();

    if (this.mIsPrimary !== wasPrimary)
      this.mReflect = !this.mReflect;

    if (this.mOrientationLock && this.mOrientation !== deviceOrientation) {
      this.mRotation = this.mReflect ? -1 : 1;

      viewportElementStyle.transform = this.mReflect ? 'rotate(-90deg)' : 'rotate(90deg)';
      viewportElementStyle.left = (size.width - size.height) * 0.5 + 'px';
      viewportElementStyle.top = (size.height - size.width) * 0.5 + 'px';
      viewportElementStyle.width = size.height + 'px';
      viewportElementStyle.height = size.width + 'px';

      dispatchSize.width = size.height;
      dispatchSize.height = size.width;
    } else {
      this.mRotation = 0;

      this.mReflect = false;
      viewportElementStyle.transform = 'rotate(0deg)';
      viewportElementStyle.left = '0px';
      viewportElementStyle.top = '0px';
      viewportElementStyle.width = size.width + 'px';
      viewportElementStyle.height = size.height + 'px';
    }

    if (this.mSize.equals(dispatchSize) === true)
      return;

    this.mSize.copyFrom(dispatchSize);

    /**
     * Posted every time viewport size has changed.
     * @event Viewport#resize
     */
    this.post(Message.RESIZE, dispatchSize);

    this.mChecksLeftSeconds = 1;
    Rectangle.pool.release(dispatchSize);
  }

  dispose() {
    this.mViewportElement.remove();
    window.removeEventListener('resize', this.mBoundResize);
  }

  /**
   * Returns the size of a viewport.
   *
   * @return {black-engine~Rectangle}
   */
  get size() {
    return this.mSize;
  }

  /**
   * Returns the HTML container element the viewport runs in.
   *
   * @return {Element}
   */
  get nativeElement() {
    return this.mViewportElement;
  }

  /**
   * Returns viewport orientation. 
   * 
   * -1 is for -90 degrees
   * 0 is for 0 degrees
   * 1 is for 90 degrees
   * 
   * @returns {number}
   */
  get rotation() {
    return this.mRotation;
  }
  // TODO: dispose, remove resize event

  /**
   * Returns true if device is in landscape orientation.
   * 
   * @public
   * @readonly
   * @returns {boolean}
   */
  get isLandscape() {
    return this.size.width >= this.size.height;
  }

  /**
   * Returns true if device is in portrait orientation.
   * 
   * @public
   * @readonly
   * @returns {boolean}
   */
  get isPortrait() {
    return !this.isLandscape;
  }
}

/**
 * @ignore
 * @type {number}
 */
let ID = 0;

/**
 * A base class for custom components.
 *
 * @cat core
 * @unrestricted
 * @extends black-engine~MessageDispatcher
 */
class Component extends MessageDispatcher {
  /**
   * Creates new Component instance.
   */
  constructor() {
    super(true);

    /** 
     * @private 
     * @type {number} 
     */
    this.mId = ++ID;

    /** 
     * @private 
     * @type {black-engine~GameObject|null} 
     */
    this.mGameObject = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mAdded = false;

    /**
     * Indicates whenever this modifier is enabled or not.
     * 
     * @type {boolean}
     */
    this.enabled = true;
  }

  /**
   * Called when attached to GameObject.
   *
   * @protected
   * @param  {black-engine~GameObject} gameObject The owner of this component.
   * @return {void}
   */
  onAdded(gameObject) { }

  /**
   * Called when detached from GameObject.
   *
   * @protected
   * @param  {black-engine~GameObject} gameObject The owner of this component.
   * @return {void}
   */
  onRemoved(gameObject) { }

  /**
   * Called at every update.
   *
   * @protected
   * @return {void}
   */
  onUpdate() { }

  /**
   * Called after all updates have been executed but before DisplayObject's onRender. GameObject itself does not have onRender method so Component#onRender will not be called on GameObjects.
   * This method can be used to interpolate/extrapolate values when low `Black#ups` value is used.
   *
   * @protected
   * @return {void}
   */
  onRender() { }

  /**
   * Detaches this Component from its parent GameObject.
   *
   * @returns {void}
   */
  removeFromParent() {
    if (this.mGameObject === null)
      return;

    this.mGameObject.removeComponent(this);
  }

  /**
   * Returns owner of this component.
   *
   * @readonly
   * @returns {black-engine~GameObject}
   */
  get gameObject() {
    return this.mGameObject;
  }
  
  /**
   * Returns this Component owner GameObject.
   * @readonly
   * @return {black-engine~GameObject|null}
   */
  get parent() {
    return this.mGameObject;
  }

  /**
   * Returns the stage Game Object to which this component belongs to or null if not on the stage.
   *
   * @override
   * @readonly
   * @return {black-engine~Stage|null}
   */
  get stage() {
    if (this.mGameObject === null)
      return null;

    return this.mGameObject.stage;
  }

  /**
   * Returns string representing a url like path to this object in the display tree.
   *
   * @override
   * @readonly
   * @return {string|null}
   */
  get path() {
    if (this.mGameObject !== null)
      return this.mGameObject.path + '#' + this.constructor.name;

    return this.constructor.name;
  }
}

/**
 * A blend mode enum.
 * @cat drivers
 * @static
 * @constant
 * @enum {string}
 */
const BlendMode = {
  /** Inherits blend mode from parent display object */
  AUTO       : 'auto',
  NORMAL     : 'normal',
  ADD        : 'add',
  MULTIPLY   : 'multiply',
  SCREEN     : 'screen',
  OVERLAY    : 'overlay',
  DARKEN     : 'darken',
  LIGHTEN    : 'lighten',
  COLOR_DODGE: 'colorDodge',
  COLOR_BURN : 'colorBurn',
  HARD_LIGHT : 'hardLight',
  SOFT_LIGHT : 'softLight',
  DIFFERENCE : 'difference',
  EXCLUSION  : 'exclusion',
  HUE        : 'hue',
  SATURATE   : 'saturate',
  COLOR      : 'color',
  LUMINOSITY : 'luminosity',
  MASK       : 'mask',
  MASK_INV   : 'maskInv'
};

/** 
 * @static 
 * @constant 
 * @dict
 * @private
 */
const CanvasBlendMode = {
  'auto'       : 'auto',
  'normal'     : 'source-over',
  'add'        : 'lighter',
  'multiply'   : 'multiply',
  'screen'     : 'screen',
  'overlay'    : 'overlay',
  'darken'     : 'darken',
  'lighten'    : 'lighten',
  'colorDodge' : 'color-dodge',
  'colorBurn'  : 'color-burn',
  'hardLight'  : 'hard-light',
  'softLight'  : 'soft-light',
  'difference' : 'difference',
  'exclusion'  : 'exclusion',
  'due'        : 'hue',
  'saturate'   : 'saturate',
  'color'      : 'color',
  'luminosity' : 'luminosity',
  'mask'       : 'source-in',
  'maskInv'    : 'source-out'
};

/**
 * @private
 * @type {number}
 * @nocollapse
 */
let __ID = 0;

/**
 * A base texture class.
 *
 * @cat textures
 */
class Texture {
  /**
   * Creates new instance of texture.
   *
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} nativeElement The native element to get image data from.
   * @param {black-engine~Rectangle=} [region=null]                                          The area of texture to be drawn.
   * @param {black-engine~Rectangle=} [untrimmedRegion=null]                                 The original area of texture.
   * @param {number=} [scale=1]                                                 Inverted scale factor.
   * @param {black-engine~Vector=} [registrationPoint=null]                                  Default anchor for newly created sprites with the texture.
   * @param {black-engine~Rectangle=} [slice9borders=null]                                   Default slice 9 grid for newly created sprites with the texture.
   */
  constructor(nativeElement, region = null, untrimmedRegion = null, scale = 1, registrationPoint = null, slice9borders = null) {
    this.mId = ++__ID;

    /** 
     * @private 
     * @type {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} */
    this.mNative = nativeElement;

    /** 
     * @private 
     * @type {boolean} */
    this.mValid = false;

    /** 
     * @private 
     * @type {black-engine~Rectangle} */
    this.mRegion = new Rectangle();

    /** 
     * @private 
     * @type {black-engine~Rectangle} */
    this.mUntrimmedRegion = new Rectangle();

    /** 
     * @private 
     * @type {number} */
    this.mNativeWidth = 0;

    /** 
     * @private 
     * @type {number} */
    this.mNativeHeight = 0;

    /** 
     * @private 
     * @type {number} */
    this.mDisplayWidth = 0;

    /** 
     * @private 
     * @type {number} */
    this.mDisplayHeight = 0;

    /** 
     * @private 
     * @type {number} */
    this.mRenderWidth = 0;

    /** 
     * @private 
     * @type {number} */
    this.mRenderHeight = 0;

    /** 
     * @private 
     * @type {number} */
    this.mScale = scale;

    /** 
     * @private 
     * @type {black-engine~Vector|null} */
    this.mRegistrationPoint = registrationPoint;

    /** 
     * @private 
     * @type {black-engine~Rectangle|null} */
    this.mSlice9borders = slice9borders;

    this.set(nativeElement, region, untrimmedRegion, scale);
  }

  /**
   * Updates this texture with new native element.
   *
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} nativeElement The native element to get image data from.
   * @param {black-engine~Rectangle=} [region=null]                                          The area of texture to be drawn.
   * @param {black-engine~Rectangle=} [untrimmedRegion=null]                                 The original area of texture.
   * @param {number=} [scale=1]                                                 Inverted scale factor.
   */
  set(nativeElement, region = null, untrimmedRegion = null, scale = 1) {
    Debug.assert(nativeElement != null, 'nativeElement cannot be null');
    Debug.assert(!isNaN(scale), 'scale cannot be NaN');

    this.mScale = scale;
    this.mNative = nativeElement;

    this.mNativeWidth = nativeElement.naturalWidth || nativeElement.videoWidth || nativeElement.width;
    this.mNativeHeight = nativeElement.naturalHeight || nativeElement.videoHeight || nativeElement.height;

    this.mRegion = region || this.mRegion.set(0, 0, this.mNativeWidth, this.mNativeHeight);
    this.mUntrimmedRegion = untrimmedRegion || this.mUntrimmedRegion.set(0, 0, this.mRegion.width, this.mRegion.height);

    this.mDisplayWidth = Math.ceil(this.mUntrimmedRegion.width * this.mScale);
    this.mDisplayHeight = Math.ceil(this.mUntrimmedRegion.height * this.mScale);

    this.mRenderWidth = Math.ceil(this.mRegion.width * this.mScale);
    this.mRenderHeight = Math.ceil(this.mRegion.height * this.mScale);

    this.mValid = nativeElement != null && this.mDisplayWidth > 0 && this.mDisplayHeight > 0;
  }

  /**
   * @ignore
   * @param {string} name
   * @returns {number}
   */
  static getScaleFactorFromName(name) {
    let ixStart = name.indexOf('@');
    if (ixStart === -1)
      return 1;

    let ixEnd = name.indexOf('x', ixStart);
    return parseFloat(name.substring(ixStart + 1, ixEnd));
  }

  /**
   * @ignore
   * @param {string} name
   * @returns {string}
   */
  static removeScaleFactorFromName(name) {
    let ixStart = name.indexOf('@');
    if (ixStart === -1)
      return name;

    let ixEnd = name.indexOf('x', ixStart);
    return name.substring(0, ixStart) + name.substring(ixEnd + 1);
  }

  /**
   * Creates new texture from Base64 string.
   *
   * @param {string} string Base64 string.
   * @returns {black-engine~Texture}
   */
  static fromBase64String(string) {
    let imgElement = new Image();
    imgElement.src = string;
    return new Texture(imgElement);
  }

  /**
   * @ignore
   * @param {Element} canvas
   * @param {string} type
   * @param {number} quality
   * @returns {black-engine~Texture}
   */
  static fromCanvasAsImage(canvas, type = 'image/png', quality = 1) {
    let imgElement = new Image();
    imgElement.src = /** @type {HTMLCanvasElement} */(canvas).toDataURL(type, quality);

    return new Texture(imgElement);
  }

  /**
   * @ignore
   * @param {HTMLCanvasElement} canvas
   * @returns {black-engine~Texture|null}
   */
  static fromCanvas(canvas) {
    return Black.driver.getTextureFromCanvas(canvas);
  }

  /**
   * Original width of the texture multiplied by scale.
   *
   * @readonly
   * @returns {number}
   */
  get width() {
    return this.mDisplayWidth;
  }

  /**
   * Original height of the texture multiplied by scale.
   *
   * @readonly
   * @returns {number}
   */
  get height() {
    return this.mDisplayHeight;
  }

  /**
   * Texture scale.
   *
   * @readonly
   * @returns {number}
   */
  get scale() {
    return this.mScale;
  }

  /**
   * The area of the texture to be drawn.
   *
   * @readonly
   * @returns {black-engine~Rectangle}
   */
  get region() {
    return this.mRegion;
  }

  /**
   * The original area of the texture.
   *
   * @readonly
   * @returns {black-engine~Rectangle}
   */
  get untrimmedRegion() {
    return this.mUntrimmedRegion;
  }

  /**
   * Original width of the texture.
   *
   * @readonly
   * @returns {number}
   */
  get nativeWidth() {
    return this.mNativeWidth;
  }

  /**
   * Original height of the texture.
   *
   * @readonly
   * @returns {number}
   */
  get nativeHeight() {
    return this.mNativeHeight;
  }

  /**
   * The same as Texture.width
   *
   * @readonly
   * @returns {number}
   */
  get displayWidth() {
    return this.mDisplayWidth;
  }

  /**
   * The same as Texture.height
   *
   * @readonly
   * @returns {number}
   */
  get displayHeight() {
    return this.mDisplayHeight;
  }

  /**
   * Renderable width of the texture multiplied by scale.
   *
   * @readonly
   * @returns {number}
   */
  get renderWidth() {
    return this.mRenderWidth;
  }

  /**
   * Renderable height of the texture multiplied by scale.
   *
   * @readonly
   * @returns {number}
   */
  get renderHeight() {
    return this.mRenderHeight;
  }

  /**
   * Determines if the texture can be drawn.
   *
   * @readonly
   * @returns {boolean}
   */
  get isValid() {
    return this.mValid;
  }

  /**
   * Anchor of the texture.
   * 
   * @returns {black-engine~Vector|null}
   */
  get registrationPoint() {
    return this.mRegistrationPoint;
  }

  /**
   * Returns slice 9 borders for this texture.
   * 
   * @returns {black-engine~Rectangle|null}
   */
  get slice9borders() {
    return this.mSlice9borders;
  }

  /**
   * Native HTML element.
   *
   * @readonly
   * @returns {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement}
   */
  get native() {
    return this.mNative;
  }

  get id() {
    return this.mId;
  }
}

/**
 * Base class for representing rendering surface.
 *
 * @cat drivers
 */
class RenderTarget {
  /**
   * Creates new instance fo RenderTarget.
   *
   * @param {number} width  The width of the surface.
   * @param {number} height The height of the surface.
   */
  constructor(width, height) {
    /** 
     * @private 
     * @type {number} 
     */
    this.mWidth = Math.ceil(width);

    /** 
     * @private 
     * @type {number} 
     */
    this.mHeight = Math.ceil(height);
  }

  /**
   * Resizes surface to the given size.
   *
   * @param {number} width The width of the surface.
   * @param {number} height The height of the surface.
   */
  resize(width, height) {
    this.mWidth = width;
    this.mHeight = height;
  }

  /**
   * Clears whole surface.
   */
  clear() {
  }

  /**
   * The width of the surface.
   *
   * @returns {number}
   */
  get width() {
    return this.mWidth;
  }

  /**
   * @param {number} value
   * @returns {void}
   */
  set width(value) {
    this.mWidth = value;
  }

  /**
   * The height of the surface.
   *
   * @returns {number}
   */
  get height() {
    return this.mHeight;
  }

  /**
   * @param {number} value
   * @returns {void}
   */
  set height(value) {
    this.mHeight = value;
  }
}

/**
 * Canvas rendering surface.
 *
 * @extends black-engine~RenderTarget
 * @cat drivers.canvas
 */
class RenderTargetCanvas extends RenderTarget {
  /**
   * Creates new instance of RenderTargetCanvas.
   *
   * @param {number} width  The width of the surface.
   * @param {number} height The height of the surface.
   */
  constructor(width, height) {
    super(width, height);

    /** 
     * @ignore 
     * @private 
     * @type {HTMLCanvasElement} 
     */
    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));

    /** 
     * @ignore 
     * @private 
     * @type {CanvasRenderingContext2D} 
     */
    this.mCtx = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext('2d'));

    this.resize(width, height);
  }

  /**
   * @inheritDoc
   */
  resize(width, height) {
    this.mCanvas.width = Math.ceil(width);
    this.mCanvas.height = Math.ceil(height);
  }

  /**
   * @inheritDoc
   */
  clear() {
    this.mCtx.setTransform(1, 0, 0, 1, 0, 0);
    this.mCtx.clearRect(0, 0, this.mCanvas.width, this.mCanvas.height);
  }

  /**
   * The width of the surface.
   * @override
   * 
   * @returns {number}
   */
  get width() {
    return this.mCanvas.width;
  }

  /**
   * @override
   * 
   * @param {number} value
   * @returns {void}
   */
  set width(value) {
    this.mCanvas.width = value;
  }

  /**
   * The height of the surface.
   * @override
   *
   * @returns {number}
   */
  get height() {
    return this.mCanvas.height;
  }

  /**
   * @override
   * 
   * @param {number} value
   * @returns {void}
   */
  set height(value) {
    this.mCanvas.height = value;
  }

  /**
   * HTML canvas element.
   *
   * @returns {HTMLCanvasElement}
   */
  get native() {
    return this.mCanvas;
  }

  /**
   * Canvas rendering context.
   *
   * @returns {CanvasRenderingContext2D}
   */
  get context() {
    return this.mCtx;
  }
}

/**
 * A render unit. Base class for all renderables.
 *
 * @cat drivers
 */
class Renderer {
  /**
   * Creates new instance of Renderer.
   */
  constructor() {
    /** @type {black-engine~DisplayObject|null} */
    this.gameObject = null;

    /** @type {black-engine~Renderer|null} */
    this.parent = null;

    /** 
     * @ignore 
     * @type {boolean} 
     */
    this.skipChildren = false;

    /** 
     * @ignore 
     * @type {boolean} 
     */
    this.skipSelf = false;

    /** 
     * @ignore 
     * @type {boolean} 
     */
    this.endPassRequired = false;

    /** 
     * @ignore 
     * @type {number} 
     */
    this.endPassRequiredAt = -1;

    /** 
     * @ignore 
     * @type {number} 
     */
    this.alpha = 1;

    /** 
     * @ignore 
     * @type {black-engine~BlendMode} 
     */
    this.blendMode = BlendMode.NORMAL;

    /** 
     * @ignore 
     * @type {number|null} 
     */
    this.color = null;
  }

  /**
   * Called when this renderer needs to be rendered.
   *
   * @param {black-engine~VideoNullDriver} driver Active video driver.
   * @param {black-engine~RenderSession} session Active session.
   * @returns {void}
   */
  preRender(driver, session) {
    this.endPassRequired = this.gameObject.mClipRect !== null && this.gameObject.mClipRect.isEmpty === false;

    this.skipChildren = !(this.gameObject.mAlpha > 0 && this.gameObject.mVisible === true);
    this.skipSelf = this.skipChildren;
  }

  /**
   * Called after `preRender` but before `GameObject#onRender`. Used to compute world alpha, color and blend mode.
   * @param {black-engine~VideoNullDriver} driver 
   * @param {black-engine~RenderSession} session 
   */
  begin(driver, session) {
    this.alpha = this.gameObject.mAlpha * this.parent.alpha;
    this.color = this.gameObject.mColor === null ? this.parent.color : this.gameObject.mColor;
    this.blendMode = this.gameObject.mBlendMode === BlendMode.AUTO ? this.parent.blendMode : this.gameObject.mBlendMode;
  }

  /**
   * Called if `skipSelf` equals to false. Used to upload everything onto gpu.
   * 
   * @param {black-engine~VideoNullDriver} driver 
   * @param {black-engine~RenderSession} session 
   */
  upload(driver, session) {
    let gameObject = /** @type {DisplayObject} */ (this.gameObject);
    let transform = gameObject.worldTransformation;

    driver.setSnapToPixels(gameObject.snapToPixels);
    driver.setGlobalAlpha(this.alpha);
    driver.setGlobalBlendMode(this.blendMode);
    driver.setTransform(transform);

    if (this.endPassRequired === true)
      driver.beginClip(gameObject.mClipRect, gameObject.mPivotX, gameObject.mPivotY);
  }

  /**
   * Called if `skipSelf` equals to false.
   *
   * @param {black-engine~VideoNullDriver} driver Active video driver.
   * @param {black-engine~RenderSession} session
   * @returns {void}
   */
  render(driver, session) {
  }

  /**
   * Called after all children objects got rendered.
   * 
   * @param {black-engine~VideoNullDriver} driver 
   * @param {black-engine~RenderSession} session 
   */
  end(driver, session) {
    driver.endClip();

    this.endPassRequiredAt = -1;
    this.endPassRequired = false;
  }

  /**
   * Tints given texture with a given color.
   * 
   * @param {black-engine~Texture} texture 
   * @param {number|null} color 
   * @returns {black-engine~Texture}
   */
  static getColoredTexture(texture, color) {
    if (color === 0xFFFFFF || color === null)
      return texture;

    let colorString = color.toString();
    if (Renderer.__colorCache.has(texture.id, colorString))
      return /** @type {Texture}*/ (Renderer.__colorCache.get(texture.id, colorString));

    let region = texture.region;
    let w = region.width;
    let h = region.height;

    let rt = new RenderTargetCanvas(w, h);
    let ctx = rt.context;

    ctx.fillStyle = ColorHelper.hexColorToString(color);
    ctx.fillRect(0, 0, w, h);

    ctx.globalCompositeOperation = 'multiply';
    ctx.drawImage(texture.native, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);

    ctx.globalCompositeOperation = 'destination-atop';
    ctx.drawImage(texture.native, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);

    let t = new Texture(rt.native, null, texture.untrimmedRegion.clone(), texture.scale);
    Renderer.__colorCache.set(texture.id, colorString, t);

    return t;
  }
}

/**
 * @ignore
 * @private
 * @static
 * @type {black-engine~MapMap}
 */
Renderer.__colorCache = new MapMap();

/**
 * Used to optimize battery-life on static scenes.
 * @private
 * @type {boolean}
 * @nocollapse
 */
Renderer.__dirty = true;

/**
 * Indicates whenever engine should render the stage if nothing were changed in this frame. Default is false.
 * @type {boolean}
 */
Renderer.skipUnchangedFrames = false;

/**
 * Base class for collider component.
 *
 * @cat colliders
 * @extends black-engine~Component
 */
class Collider extends Component {
  /**
   * Creates new instance for Collider.
   *
   * @ignore
   */
  constructor() {
    super();

    /**
     * Dirty flag.
     * 
     * @private 
     * @type {boolean}
     */
    this.mChanged = true;

    /**
     * Global in stage coordinates center.
     * 
     * @private 
     * @type {black-engine~Vector}
     */
    this.mCenter = new Vector();

    /**
     * Global in stage coordinates min x and y vertex.
     * 
     * @private 
     * @type {black-engine~Vector}
     */
    this.mMin = new Vector();

    /**
     * Global in stage coordinates max x and y vertex. 
     * 
     * @private 
     * @type {black-engine~Vector} */
    this.mMax = new Vector();
  }

  /**
   * Checks if given global coordinates are located within collider's area.
   *
   * @public
   * @param {black-engine~Vector} point Global coordinates.
   * @returns {boolean}
   */
  containsPoint(point) {
    Debug.error('Abstract method.');
    return false;
  }

  /**
   * Updates min, max, center of this collider, to prepare to collision test
   *
   * @public
   * @param {black-engine~Matrix} transform Game object world transformation with zero position.
   * @param {black-engine~Vector} position  Rigid body position.
   */
  refresh(transform, position) { }
}

/**
 * This component will allow you to subscribe for some input messages.
 *
 * @cat input
 * @extends black-engine~Component
 */
class InputComponent extends Component {
  /**
   * @return {void}
   */
  constructor() {
    super();

    /** @type {boolean} Specifies whether the component is active. */
    this.touchable = true;

    /* INTERNAL */
    /** 
     * @ignore 
     * @type {boolean} 
     */
    this.mPointerInDispatched = false;
  }
}

/**
 * @cat core
 * @enum {number}
 */
const DirtyFlag = {
  CLEAN: 0,         // Object is 100% cached
  LOCAL: 1,         // Local transformation is dirty 
  WORLD: 2,         // World transformation is dirty 
  WORLD_INV: 4,     // Inverted world transformation is dirty 
  RENDER: 8,        // Object needs to be rendered 
  RENDER_CACHE: 16, // In case object renders to bitmap internally, bitmap needs to be updated
  ANCHOR: 32,       // 
  BOUNDS: 64,       // Parent-relative bounds needs update
  DIRTY: 0xffffff,  // Everything is dirty, you, me, everything!
  WIRB: 78
};

let ID$1 = 0;

/**
 * Building block in Black Engine.
 *
 * @cat core
 * @unrestricted
 * @extends black-engine~MessageDispatcher
 */
class GameObject extends MessageDispatcher {
  /**
   * Creates new instance of GameObject.
   */
  constructor() {
    super(true);

    /** 
     * @private 
     * @type {number} 
     */
    this.mId = ++ID$1;

    /** 
     * @private 
     * @type {string|null} 
     */
    this.mName = null;

    /** 
     * @private 
     * @type {Array<black-engine~Component>} 
     */
    this.mComponents = [];

    /** 
     * @protected 
     * @type {Array<black-engine~GameObject>} 
     */
    this.mChildren = [];

    /** 
     * @private 
     * @type {number} 
     */
    this.mX = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mY = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mScaleX = 1;

    /** 
     * @private 
     * @type {number} 
     */
    this.mScaleY = 1;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mPivotX = 0;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mPivotY = 0;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mSkewX = 0;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mSkewY = 0;

    /** 
     * @protected 
     * @type {number|null} 
     */
    this.mAnchorX = null;

    /** 
     * @protected 
     * @type {number|null} 
     */
    this.mAnchorY = null;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mPivotOffsetX = 0;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mPivotOffsetY = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mRotation = 0;

    /** 
     * @protected 
     * @type {black-engine~Rectangle} 
     */
    this.mBoundsCache = new Rectangle();

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.mLocalTransform = new Matrix();

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.mWorldTransform = new Matrix();

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.mWorldTransformInverted = new Matrix();

    /** 
     * @private 
     * @type {black-engine~DirtyFlag} 
     */
    this.mDirty = DirtyFlag.DIRTY;

    /** 
     * @protected 
     * @type {black-engine~GameObject} 
     */
    this.mParent = null;

    /** 
     * @private 
     * @type {string|null} 
     */
    this.mTag = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mAdded = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mNumChildrenRemoved = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mNumComponentsRemoved = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDirtyFrameNum = 0;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mSuspendDirty = false;

    // cache all colliders for fast access
    /** 
     * @private 
     * @type {Array<black-engine~Collider>} 
     */
    this.mCollidersCache = [];

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mChildOrComponentBeenAdded = false;

    /** 
     * @private 
     * @type {Array<black-engine~GameObject>} 
     */
    this.mChildrenClone = null;

    /** 
     * @private 
     * @type {Array<black-engine~Component>} 
     */
    this.mComponentClone = null;
  }

  make(values) {
    // can be helpful if there are many children
    this.mSuspendDirty = true;

    for (let property in values) {
      if (values.hasOwnProperty(property)) {
        this[property] = values[property];
      }
    }

    this.mSuspendDirty = false;
    this.setTransformDirty();

    return this;
  }

  /**
   * Returns unique object id.
   *
   * @returns {number}
   */
  get id() {
    return this.mId;
  }

  /**
   * Returns true if object was clean for at least 1 update.
   * 
   * Note: Make sure to apply all changes to this game object before checking for static.
   * 
   * @param {boolean} [includeChildren=true]
   * @returns {boolean}
   */
  checkStatic(includeChildren = true) {
    if (includeChildren === false)
      return this.mDirtyFrameNum < Black.engine.frameNum;

    let isDynamic = false;
    GameObject.forEach(this, x => {
      if (x.mDirtyFrameNum >= Black.engine.frameNum) {
        isDynamic = true;
        return true;
      }
    });

    return !isDynamic;
  }

  /**
   * This method called each time object added to stage.
   *
   * @action
   * @return {void}
   */
  onAdded() { }

  /**
   * Called when object is removed from stage.
   *
   * @action
   * @return {void}
   */
  onRemoved() { }

  /**
   * Sugar method for adding child `GameObjects` or `Components` in a simple manner.
   *
   * @param {...(black-engine~GameObject|black-engine~Component)} gameObjectsAndOrComponents A `GameObject` or `Component` to add.
   * @return {black-engine~GameObject} This game object
   */
  add(...gameObjectsAndOrComponents) {
    for (let i = 0; i < gameObjectsAndOrComponents.length; i++) {
      let gooc = gameObjectsAndOrComponents[i];

      if (gooc instanceof GameObject)
        this.addChild( /** @type {!GameObject} */(gooc));
      else
        this.addComponent( /** @type {!Component} */(gooc));
    }

    return this;
  }

  /**
   * Adds a child `GameObject` instance to this `GameObject` instance. The child is added to the top of all other 
   * children in this GameObject instance.
   *
   * @param  {black-engine~GameObject} child The GameObject instance to add as a child of this GameObject instance.
   * @return {black-engine~GameObject}
   */
  addChild(child) {
    return this.addChildAt(child, this.mChildren.length);
  }

  /**
   * Adds a child `GameObject` instance to this `GameObject` instance. The child is added to the top of all other 
   * children in this GameObject instance.
   *
   * @param  {black-engine~GameObject} child The GameObject instance to add as a child of this GameObject instance.
   * @param  {number=} [index=0] The index position to which the child is added.
   * @return {black-engine~GameObject} The GameObject instance that you pass in the child parameter.
   */
  addChildAt(child, index = 0) {
    Debug.assert(child instanceof GameObject, 'Type error.');

    let numChildren = this.mChildren.length;

    if (index < 0 || index > numChildren)
      throw new Error('Child index is out of bounds.');

    if (child.mParent === this)
      return this.setChildIndex(child, index);

    // this operation should be atomic. since __setParent can throw exception.
    this.mChildren.splice(index, 0, child);

    child.removeFromParent();
    child.__setParent(this);

    Black.engine.onChildrenAdded(child, this);

    this.mChildOrComponentBeenAdded = true;

    return child;
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~GameObject} value
   * @return {boolean}
   */
  __setParent(value) {
    let p = value;

    while (p !== null && p !== this)
      p = p.mParent;

    if (p === this)
      throw new Error('Object cannot be a child to itself.');

    this.mParent = value;
    this.setTransformDirty();
    return true;
  }

  /**
   * Sets the index (layer) of the specified `GameObject` to the specified index (layer).
   *
   * @param {black-engine~GameObject} child The `GameObject` instance to change index for.
   * @param {number} index Desired index.
   * @returns {black-engine~GameObject} The `GameObject` instance that you pass in the child parameter.
   */
  setChildIndex(child, index) {
    let ix = this.mChildren.indexOf(child);

    if (ix < 0)
      throw new Error('Given child element was not found in children list.');

    if (ix === index)
      return child;

    // NOTE: systems needs to know when trees changes
    this.mChildren.splice(ix, 1);
    this.mChildren.splice(index, 0, child);

    if (this.stage !== null)
      Black.engine.onChildrenChanged(child);

    this.setTransformDirty();

    return child;
  }

  /**
   * Removes this `GameObject` instance from its parent.
   *
   * @return {black-engine~GameObject}
   */
  removeFromParent() {
    if (this.mParent !== null)
      this.mParent.removeChild(this);

    this.setTransformDirty();
    return this;
  }

  /**
   * Removes specified child `GameObject` instance from children.
   *
   * @param {black-engine~GameObject} child `GameObject` instance to remove.
   * @return {black-engine~GameObject} The `GameObject` instance that you pass in the child parameter.
   */
  removeChild(child) {
    let ix = this.mChildren.indexOf(child);

    if (ix < 0)
      return null;

    return this.removeChildAt(ix);
  }


  /**
   * Finds children by name.
   *
   * @param {string} name Name of the child object to find.
   * @return {black-engine~GameObject|null} GameObject instance or null if not found.
   */
  getChildByName(name) {
    for (let i = 0; i < this.mChildren.length; i++) {
      if (this.mChildren[i].name === name)
        return this.mChildren[i];
    }

    return null;
  }

  /**
   * Removes `GameObjects` instance from specified index.
   *
   * @param {number} index Index of child. Negative index will remove object from it end.
   * @return {black-engine~GameObject|null} The removed `GameObject` instance or null if not found.
   */
  removeChildAt(index) {
    let child = this.mChildren.splice(index, 1)[0];
    if (child == null)
      return null;

    let hadRoot = this.stage !== null;

    child.__setParent(null);

    if (hadRoot === true)
      Black.engine.onChildrenRemoved(child);

    this.setTransformDirty();
    this.mNumChildrenRemoved++;

    return child;
  }

  /**
   * Removes all children objects.
   * @returns {black-engine~GameObject} Returns this.
   */
  removeAllChildren() {
    while (this.mChildren.length > 0)
      this.removeChildAt(0);

    return this;
  }

  /**
   * Returns `GameObject` at specified index.
   *
   * @param {number} index The index of child `GameObject`.
   * @return {black-engine~GameObject} The `GameObject` at specified index.
   */
  getChildAt(index) {
    return this.mChildren[index];
  }

  /**
   * Adds Component instance to the end of the list.
   *
   * @throws {Error}
   * @param  {black-engine~Component} component The instances of Component to be added,
   * @return {black-engine~Component} The `Component` instance you pass in the instances parameter.
   */
  addComponent(component) {
    return this.addComponentAt(component, this.mComponents.length);
  }

  /**
   * Adds Component to the list at given position.
   * 
   * @throws {Error}
   * @param {black-engine~Component} component The instances of Component to be added,
   * @param {number} [index=0] Position in the list.
   * @returns {black-engine~Component} The `Component` instance you pass in the instances parameter.
   */
  addComponentAt(component, index = 0) {
    Debug.assert(component instanceof Component, 'Type error.');

    if (component.gameObject)
      throw new Error('Component cannot be added to two game objects at the same time.');

    let numComponents = this.mComponents.length;

    if (index < 0 || index > numComponents)
      throw new Error('Component index is out of bounds.');

    this.mComponents.splice(index, 0, component);
    component.mGameObject = this;

    if (component instanceof Collider)
      this.mCollidersCache.push(component);

    if (this.stage !== null || Black.stage === this)
      Black.engine.onComponentAdded(this, component);

    this.mChildOrComponentBeenAdded = true;

    return component;
  }

  /**
   * Removes component at given index.
   * 
   * @param {number} index Negative index will remove component from the end.
   * @returns {black-engine~Component|null} Returns removed component of null.
   */
  removeComponentAt(index) {
    let instance = this.mComponents.splice(index, 1)[0];

    if (instance == null)
      return null;

    // detach game object after or before?
    instance.mGameObject = null;

    if (instance instanceof Collider) {
      let colliderIx = this.mCollidersCache.indexOf(instance);
      if (colliderIx > -1)
        this.mCollidersCache.splice(colliderIx, 1);
    }

    if (this.stage !== null || Black.stage === this)
      Black.engine.onComponentRemoved(this, instance);

    this.mNumComponentsRemoved++;

    return instance;
  }

  /**
   * Remove specified component.
   *
   * @param {black-engine~Component} instance The `Component` instance.
   * @returns {black-engine~Component|null} Returns removed component of null.
   */
  removeComponent(instance) {
    if (instance == null)
      return null;

    Debug.assert(instance instanceof Component, 'Type error.');

    let index = this.mComponents.indexOf(instance);
    if (index > -1)
      return this.removeComponentAt(index);

    return null;
  }

  /**
   * Removes all components.
   * @returns {black-engine~GameObject} Returns this.
   */
  removeAllComponents() {
    while (this.mComponents.length > 0)
      this.removeComponentAt(0);

    return this;
  }

  /**
   * Get component by type.
   *
   * @param {Function} typeName The component type.
   * @return {black-engine~Component|null} The `Component` instance or null if not found.
   */
  getComponent(typeName) {
    for (let i = 0; i < this.mComponents.length; i++) {
      let c = this.mComponents[i];
      if (c instanceof typeName)
        return c;
    }

    return null;
  }

  /**
   * Returns number of component's of this GameObject.
   *
   * @return {number}
   */
  get numComponents() {
    return this.mComponents.length;
  }

  /**
   * Retrieves `Component` at given index.
   *
   * @param {number} index Index of component.
   * @return {black-engine~Component|null}
   */
  getComponentAt(index) {
    if (index >= 0 && index < this.mComponents.length)
      return this.mComponents[index];

    return null;
  }

  /**
   * Returns local transformation `Matrix`
   *
   * @return {black-engine~Matrix}
   */
  get localTransformation() {
    if (this.mDirty & DirtyFlag.LOCAL) {
      this.mDirty ^= DirtyFlag.LOCAL;

      if (this.mSkewX === 0.0 && this.mSkewY === 0.0) {
        if (this.mRotation === 0) {
          return this.mLocalTransform.set(this.mScaleX, 0, 0, this.mScaleY, this.mX - this.mPivotX * this.mScaleX, this.mY - this.mPivotY * this.mScaleY);
        } else {
          let cos = Math.cos(this.mRotation);
          let sin = Math.sin(this.mRotation);
          let a = this.mScaleX * cos;
          let b = this.mScaleX * sin;
          let c = this.mScaleY * -sin;
          let d = this.mScaleY * cos;
          let tx = this.mX - this.mPivotX * a - this.mPivotY * c;
          let ty = this.mY - this.mPivotX * b - this.mPivotY * d;
          return this.mLocalTransform.set(a, b, c, d, tx, ty);
        }
      } else {
        this.mLocalTransform.identity();
        this.mLocalTransform.scale(this.mScaleX, this.mScaleY);
        this.mLocalTransform.skew(this.mSkewX, this.mSkewY);
        this.mLocalTransform.rotate(this.mRotation);

        let a = this.mLocalTransform.data[0];
        let b = this.mLocalTransform.data[1];
        let c = this.mLocalTransform.data[2];
        let d = this.mLocalTransform.data[3];
        let tx = this.mX;
        let ty = this.mY;

        if (this.mPivotX !== 0.0 || this.mPivotY !== 0.0) {
          tx = this.mX - a * this.mPivotX - c * this.mPivotY;
          ty = this.mY - b * this.mPivotX - d * this.mPivotY;
        }

        this.mLocalTransform.data[4] = tx;
        this.mLocalTransform.data[5] = ty;
      }
    }

    return this.mLocalTransform;
  }

  /**
   * @param {black-engine~Matrix} value
   * @return {void}
   */
  set localTransformation(value) {
    const PI_Q = Math.PI / 4.0;

    let a = value.data[0];
    let b = value.data[1];
    let c = value.data[2];
    let d = value.data[3];
    let tx = value.data[4];
    let ty = value.data[5];

    this.mPivotOffsetX = this.mPivotOffsetY = 0;
    this.mAnchorX = this.mAnchorX = null;
    this.mX = tx;
    this.mY = ty;

    let skewX = Math.atan(-c / d);
    let skewY = Math.atan(b / a);

    if (skewX != skewX)
      skewX = 0.0;
    if (skewY != skewY)
      skewY = 0.0;

    this.mScaleY = (skewX > -PI_Q && skewX < PI_Q) ? d / Math.cos(skewX) : -c / Math.sin(skewX);
    this.mScaleX = (skewY > -PI_Q && skewY < PI_Q) ? a / Math.cos(skewY) : b / Math.sin(skewY);

    if (MathEx.equals(skewX, skewY)) {
      this.mRotation = skewX;
      this.mSkewX = this.mSkewY = 0;
    } else {
      this.mRotation = 0;
      this.mSkewX = skewX;
      this.mSkewY = skewY;
    }

    this.setTransformDirty();
  }

  /**
   * Gets cloned Matrix object which represents object orientation in world space.
   *
   * @return {black-engine~Matrix}
   */
  get worldTransformation() {
    if (this.mDirty & DirtyFlag.ANCHOR && (this.mAnchorX !== null || this.mAnchorY !== null)) {
      this.mDirty ^= DirtyFlag.ANCHOR;

      this.__updatePivots(this);

      this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.LOCAL | DirtyFlag.WIRB), true);
    }

    if (this.mDirty & DirtyFlag.WORLD) {
      this.mDirty ^= DirtyFlag.WORLD;

      if (this.mParent !== null)
        this.mParent.worldTransformation.copyTo(this.mWorldTransform).append(this.localTransformation);
      else
        this.localTransformation.copyTo(this.mWorldTransform);
    }
    return this.mWorldTransform;
  }

  /**
   * Returns cloned and inverted Matrix object which represents object orientation in world space
   *
   * @readonly
   * @return {black-engine~Matrix}
   */
  get worldTransformationInverted() {
    if ((this.mDirty & DirtyFlag.WORLD_INV)) {
      this.mDirty ^= DirtyFlag.WORLD_INV;

      this.worldTransformation.copyTo(this.mWorldTransformInverted).invert();
    }

    return this.mWorldTransformInverted;
  }

  /**
   * @ignore
   * @private
   * @return {void}
   */
  __update() {
    this.onUpdate();

    if (this.mChildOrComponentBeenAdded === false)
      return;

    if (this.mComponents.length > 0) {
      this.mComponentClone = this.mComponents.slice();

      for (let k = 0; k < this.mComponentClone.length; k++) {
        if (this.mAdded === false)
          break;

        let c = this.mComponentClone[k];

        if (c.mAdded === false || c.enabled === false)
          continue;

        c.onUpdate();
      }
    }

    if (this.mChildren.length > 0) {
      this.mChildrenClone = this.mChildren.slice();

      for (let i = 0; i < this.mChildrenClone.length; i++) {
        let child = this.mChildrenClone[i];

        if (child.mAdded === true)
          child.__update();
      }
    }
  }

  /**
   * Called at every engine update. The execution order of onFixedUpdate, onUpdate and onPostUpdate is
   * going from top to bottom of the display list.
   * 
   * @action
   * @protected
   * @return {void}
   */
  onUpdate() { }

  /**
   * Override this method if you need to specify GameObject size. Should be always be a local coordinates.
   *
   * @action
   * @protected
   * @param {black-engine~Rectangle=} [outRect=undefined] Rectangle to be returned.
   * @return {black-engine~Rectangle} bounds in local space without taking care about transformation matrix
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();
    return outRect.set(0, 0, 0, 0);
  }

  /**
   * Returns world bounds of this object and all children if specified (true by default).
   * 
   * `object.getBounds()` - relative to parent (default).<br>
   * `object.getBounds(object)` - local bounds.<br>
   * `object.getBounds(object.parent)` - relative to parent.<br>
   * `object.getBounds(objectB)` - relative to objectB space.<br>
   *
   * @param {black-engine~GameObject} [space=null] The `GameObject` relative to.
   * @param {boolean} [includeChildren=true] Specifies if include children in calculations.
   * @param {black-engine~Rectangle=} [outRect=null] Rectangle to be returned.
   * @return {black-engine~Rectangle} Returns bounds of the object with/without all children.
   */
  getBounds(space = null, includeChildren = true, outRect = undefined) {
    outRect = outRect || new Rectangle();

    this.onGetLocalBounds(outRect);

    if (space == null)
      space = this.mParent;

    if (space == this) ; else if (space == this.mParent) {
      if (includeChildren === false) {
        let matrix = Matrix.pool.get();
        matrix.copyFrom(this.localTransformation);
        matrix.transformRect(outRect, outRect);
        Matrix.pool.release(matrix);
      }
      else if (includeChildren === true && this.mDirty & DirtyFlag.BOUNDS) {
        let matrix = Matrix.pool.get();
        matrix.copyFrom(this.localTransformation);
        matrix.transformRect(outRect, outRect);
        Matrix.pool.release(matrix);
      } else {
        outRect.copyFrom(this.mBoundsCache);
        return outRect;
      }
    } else {
      let matrix = Matrix.pool.get();
      matrix.copyFrom(this.worldTransformation);
      matrix.prepend(space.worldTransformationInverted);
      matrix.transformRect(outRect, outRect);
      Matrix.pool.release(matrix);
    }

    if (includeChildren === true) {
      let childBounds = Rectangle.pool.get();

      for (let i = 0; i < this.mChildren.length; i++) {
        childBounds.zero();

        this.mChildren[i].getBounds(space, includeChildren, childBounds);
        outRect.union(childBounds);
      }

      Rectangle.pool.release(childBounds);

      if (space == this.mParent && this.mDirty & DirtyFlag.BOUNDS) {
        this.mBoundsCache.copyFrom(outRect);
        this.mDirty ^= DirtyFlag.BOUNDS;
      }
    }

    return outRect;
  }

  /**
   * Returns stage relative bounds of this object excluding it's children;
   * 
   * @param {black-engine~Rectangle=} [outRect=null] Rectangle to be store resulting bounds in.
   * @returns {black-engine~Rectangle} 
   */
  getStageBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    this.onGetLocalBounds(outRect);

    let matrix = Matrix.pool.get();
    matrix.copyFrom(this.worldTransformation);
    matrix.prepend(this.stage.worldTransformationInverted); // 120ms
    matrix.transformRect(outRect, outRect); // 250ms
    Matrix.pool.release(matrix);

    return outRect;
  }

  /**
   * Evaluates whether the game object or one of its children intersects with the given point
   *
   * @param {black-engine~Vector} localPoint Coordinates vector.
   * @return {black-engine~GameObject|null}
   */
  hitTest(localPoint) {
    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent));
    let touchable = c !== null && c.touchable;
    let insideMask = this.onHitTestMask(localPoint);

    if (touchable === false || insideMask === false)
      return null;

    let target = null;
    let numChildren = this.mChildren.length;

    for (let i = numChildren - 1; i >= 0; --i) {
      let child = this.mChildren[i];

      target = child.hitTest(localPoint);

      if (target !== null)
        return target;
    }

    if (this.onHitTest(localPoint) === true)
      return this;

    return null;
  }

  /**
   * @action
   * @protected
   * @param {black-engine~Vector} localPoint 
   * @return {boolean}
   */
  onHitTest(localPoint) {
    let contains = false;

    // BEGINOF: WTF
    let tmpVector = /** @type {Vector}*/ (Vector.pool.get());
    this.worldTransformationInverted.transformVector(localPoint, tmpVector);
    // ENDOF: WTF

    if (this.mCollidersCache.length > 0) {
      for (let i = 0; i < this.mCollidersCache.length; i++) {
        let collider = this.mCollidersCache[i];

        contains = collider.containsPoint(tmpVector);
        if (contains === true)
          return true;
      }
    } else {
      contains = this.localBounds.containsXY(tmpVector.x, tmpVector.y);
    }

    Vector.pool.release(tmpVector);
    return contains;
  }

  /**
   * @action
   * @protected
   * @param {black-engine~Vector} localPoint 
   * @return {boolean}
   */
  onHitTestMask(localPoint) {
    return true;
  }

  /**
   * Returns local bounds of this object (without children).
   * @returns {black-engine~Rectangle}
   */
  get localBounds() {
    return this.getBounds(this, false);
  }

  /**
   * Returns parent-relative bounds (including children).
   * @returns {black-engine~Rectangle}
   */
  get bounds() {
    return this.getBounds(this.mParent, true);
  }

  /**
   * Sets the object transform in one line.
   *
   * @param {number} [x=0]       Cord X.
   * @param {number} [y=0]       Cord Y.
   * @param {number} [r=0]       Rotation.
   * @param {number} [scaleX=1]  Scale X.
   * @param {number} [scaleY=1]  Scale Y.
   * @param {number} [anchorX=0] Anchor X.
   * @param {number} [anchorY=0] Anchor Y.
   * @param {boolean} [includeChildren=true] Include children when adjusting pivot?
   *
   * @return {black-engine~GameObject} This.
   */
  setTransform(x = 0, y = 0, r = 0, scaleX = 1, scaleY = 1, anchorX = 0, anchorY = 0, includeChildren = true) {
    this.mX = x;
    this.mY = y;
    this.mRotation = r;
    this.mScaleX = scaleX;
    this.mScaleY = scaleY;
    this.mAnchorX = anchorX;
    this.mAnchorY = anchorY;

    this.setTransformDirty();
    return this;
  }

  /**
   * Calculates GameObject's position relative to another GameObject.
   *
   * @param {black-engine~GameObject} gameObject Coordinates vector.
   * @param {black-engine~Vector|null} [outVector=null] Vector to be returned.
   * @return {black-engine~Vector}
   */
  relativeTo(gameObject, outVector = null) {
    outVector = outVector || new Vector();
    outVector.set(this.x, this.y);

    if (this.parent == null || gameObject == null)
      return outVector;

    this.parent.localToGlobal(outVector, outVector);
    gameObject.globalToLocal(outVector, outVector);
    return outVector;
  }

  /**
   * Calculate global position of the object.
   *
   * @param {black-engine~Vector} localPoint Coordinates vector.
   * @param {black-engine~Vector|null} [outVector=null] Vector to be returned.
   * @return {black-engine~Vector}
   */
  localToGlobal(localPoint, outVector = null) {
    return this.worldTransformation.transformVector(localPoint, outVector);
  }

  /**
   * Calculate local position of the object
   *
   * @param {black-engine~Vector} globalPoint Coordinates vector.
   * @param {black-engine~Vector|null} [outVector=null] Vector to be returned.
   * @return {black-engine~Vector}
   */
  globalToLocal(globalPoint, outVector = null) {
    return this.worldTransformationInverted.transformVector(globalPoint, outVector);
  }
  /**
   * Gets a count of children elements.
   *
   * @return {number}
   */
  get numChildren() {
    return this.mChildren.length;
  }

  /**
   * Gets/Sets the name of this GameObject instance.
   *
   * @return {string|null}
   */
  get name() {
    return this.mName;
  }

  /**
   * @param {string|null} value
   * @return {void}
   */
  set name(value) {
    this.mName = value;
  }

  /**
   * Gets/Sets the x coordinate of the GameObject instance relative to the local coordinates of the parent GameObject.
   * @return {number}
   */
  get x() {
    return this.mX;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set x(value) {
    if (this.mX == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mX = value;
    this.setTransformDirty();
  }

  /**
   * Gets/Sets the y coordinate of the GameObject instance relative to the local coordinates of the parent GameObject.
   *
   * @return {number}
   */
  get y() {
    return this.mY;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set y(value) {
    if (this.mY == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mY = value;
    this.setTransformDirty();
  }
  
  /**
   * Gets/sets object position.
   * 
   * NOTE: setting individual values on this vector will give zero results.
   * @returns {black-engine~Vector}
   */
  get xy() {
    return new Vector(this.mX, this.mY);
  }

  /**
   * Gets/sets object position.
   * 
   * @param {black-engine~Vector} value
   * @returns {void}
   */
  set xy(value) {
    if (this.mX === value.x && this.mY === value.y)
      return;

    this.mX = value.x;
    this.mY = value.y;

    this.setTransformDirty();
  }

  /**
   * Gets/Sets the x coordinate of the object's origin in its local space in pixels.
   *
   * @return {number}
   */
  get pivotOffsetX() {
    return this.mPivotOffsetX;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set pivotOffsetX(value) {
    if (this.mPivotOffsetX === value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mPivotOffsetX = value;

    this.__updatePivots(this);
    this.setTransformDirty();
  }

  /**
   * Gets/Sets the y coordinate of the object's origin in its local space in pixels.
   *
   * @return {number}
   */
  get pivotOffsetY() {
    return this.mPivotOffsetY;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set pivotOffsetY(value) {
    if (this.mPivotOffsetY === value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mPivotOffsetY = value;

    this.__updatePivots(this);
    this.setTransformDirty();
  }

  /**
   * Gets/Sets the x-coordinate of the object's origin in its local space in percent.
   * 
   * @param {number|null} value
   * @return {void}
   */
  set anchorX(value) {
    if (this.mAnchorX === value)
      return;

    Debug.assert(value !== null && !isNaN(value), 'Value cannot be NaN');

    this.mAnchorX = value;

    this.setTransformDirty();
  }

  /**
   * Gets/Sets the y-coordinate of the object's origin in its local space in percent.
   * 
   * @param {number|null} value
   * @return {void}
   */
  set anchorY(value) {
    if (this.mAnchorY === value)
      return;

    Debug.assert(value !== null && !isNaN(value), 'Value cannot be NaN');

    this.mAnchorY = value;

    this.setTransformDirty();
  }

  /**
   * Returns current anchor-x value in range from 0 to 1.
   * 
   * @returns {number|null}
   */
  get anchorX() {
    return this.mAnchorX;
  }

  /**
   * Returns current anchor-y value in range from 0 to 1.
   * 
   * @returns {number|null}
   */
  get anchorY() {
    return this.mAnchorY;
  }

  /**
   * Returns current pivot-x value in range from 0 to 1.
   * 
   * @returns {number}
   */
  get pivotX() {
    return this.mPivotX;
  }

  /**
   * Returns current pivot-y value in range from 0 to 1.
   * 
   * @returns {number}
   */
  get pivotY() {
    return this.mPivotY;
  }

  /**
   * Sets the origin point relatively to its bounds. For example, setting x and y value to 0.5 will set origin to the 
   * center of the object.
   *
   * @param {number}  [ax=0.5]               Align along x-axis.
   * @param {number}  [ay=0.5]               Align along y-axis.
   *
   * @return {black-engine~GameObject} This.
   */
  alignAnchor(ax = 0.5, ay = 0.5) {
    Debug.isNumber(ax, ay);

    this.mAnchorX = ax;
    this.anchorY = ay;

    return this;
  }

  /**
   * Sets anchor point to given position. See `alignPivotOffset`.
   * 
   * @deprecated
   *
   * @param {number}  [ax=0.5]               Align along x-axis.
   * @param {number}  [ay=0.5]               Align along y-axis.
   * @return {black-engine~GameObject} This.
   */
  alignPivot(ax = 0.5, ay = 0.5) {
    return this.alignPivotOffset(ax, ay);
  }

  /**
   * Sets the origin point offset from current anchor value. For example, setting anchor-x value to 0.5 and pivotOffsetX
   * to 10 will center object by x-axis and will shift object to the left by 10 pixels from half of the width.
   *
   * @param {number}  [ax=0.5]               Align along x-axis.
   * @param {number}  [ay=0.5]               Align along y-axis.
   * @param {boolean} [includeChildren=true] Include children elements when calculating bounds?
   *
   * @return {black-engine~GameObject} This.
   */
  alignPivotOffset(ax = 0.5, ay = 0.5, includeChildren = true) {
    Debug.isNumber(ax, ay);

    this.getBounds(this, includeChildren, Rectangle.__cache.zero());

    this.mPivotOffsetX = (Rectangle.__cache.width * ax) + Rectangle.__cache.x;
    this.mPivotOffsetY = (Rectangle.__cache.height * ay) + Rectangle.__cache.y;

    this.__updatePivots(this);

    this.setTransformDirty();

    return this;
  }

  /**
   * Gets/Sets the scale factor of this object along x-axis.
   *
   * @return {number}
   */
  get scaleX() {
    return this.mScaleX;
  }

  /**
   * @param {number} value
   *
   * @return {void}
   */
  set scaleX(value) {
    if (this.mScaleX == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mScaleX = value;
    this.setTransformDirty();
  }

  /**
   * Gets/Sets the scale factor of this object along y-axis.
   *
   * 
   * @return {number}
   */
  get scaleY() {
    return this.mScaleY;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set scaleY(value) {
    if (this.mScaleY == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mScaleY = value;
    this.setTransformDirty();
  }

  /**
   * Gets/sets both `scaleX` and `scaleY`. Getter will return `scaleX` value;
   * @returns {number}
   */
  get scale() {
    return this.scaleX;
  }

  /**
   * @param {number} value
   * 
   * @returns {void}
   */
  set scale(value) {
    if (this.mScaleX == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mScaleX = this.mScaleY = value;
    this.setTransformDirty();
  }

  /**
   * Gets/sets horizontal skew angle in radians.
   * @returns {number}
   */
  get skewX() {
    return this.mSkewX;
  }

  /**
   * @param {number} value
   * 
   * @returns {void}
   */
  set skewX(value) {
    if (this.mSkewX == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mSkewX = value;
    this.setTransformDirty();
  }

  /**
   * Gets/sets vertical skew angle in radians.
   * @returns {number}
   */
  get skewY() {
    return this.mSkewY;
  }

  /**
   * @param {number} value
   * 
   * @returns {void}
   */
  set skewY(value) {
    if (this.mSkewY == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mSkewY = value;
    this.setTransformDirty();
  }

  /**
   * Gets/Sets rotation in radians.
   *
   * 
   * @return {number}
   */
  get rotation() {
    return this.mRotation;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set rotation(value) {
    if (this.mRotation == value)
      return;

    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.mRotation = value;
    this.setTransformDirty();
  }

  /**
   * Returns this GameObject parent GameObject or null.
   * @readonly
   * @return {black-engine~GameObject|null}
   */
  get parent() {
    return this.mParent;
  }

  /**
   * Returns top most parent object or this if there is no parents.
   * 
   * @readonly
   * @return {black-engine~GameObject}
   */
  get root() {
    let current = this;

    while (current.mParent != null)
      current = current.mParent;

    return current;
  }

  /**
   * Returns the stage Game Object to which this game object belongs to or null if not added on stage.
   *
   * @override
   * @readonly
   * @return {black-engine~Stage|null}
   */
  get stage() {
    return this.mAdded === true ? Black.stage : null;
  }

  /**
   * Gets/sets the width of this object.
   *
   * @return {number}
   */
  get width() {
    return this.getBounds(this.mParent).width;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set width(value) {
    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.scaleX = 1;
    const currentWidth = this.width;

    if (currentWidth != 0.0)
      this.scaleX = value / currentWidth;
  }

  /**
   * Gets/sets the height of this object.
   *
   * @return {number}
   */
  get height() {
    return this.getBounds(this.mParent).height;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set height(value) {
    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    this.scaleY = 1;
    const currentHeight = this.height;

    if (currentHeight != 0)
      this.scaleY = value / currentHeight;
  }

  /**
   * Returns width of this GameObject in local space without including children
   * elements.
   *
   * @readonly
   * @return {number}
   */
  get localWidth() {
    return this.getBounds(this, false).width;
  }

  /**
   * Returns height of this GameObject in local space without including children
   * elements.
   *
   * @readonly
   * @return {number}
   */
  get localHeight() {
    return this.getBounds(this, false).height;
  }

  // TODO: precache
  /**
   * Returns string representing a url like path to this object in the display
   * tree.
   *
   * @override
   * @readonly
   * @return {string|null}
   */
  get path() {
    if (this.mParent !== null)
      return this.mParent.path + '/' + this.mName;

    return this.mName;
  }

  /**
  * Gets/Sets tag of this GameObject.
  *
  * @return {string|null}
  */
  get tag() {
    return this.mTag;
  }

  /**
   * @param {string|null} value
   * @return {void}
   */
  set tag(value) {
    if (this.mTag === value)
      return;

    /** @type {string|null} */
    let old = this.mTag;
    this.mTag = value;

    if (this.mAdded)
      Black.engine.onTagUpdated(this, old, value);
  }

  /**
   * Starts coroutine.
   *
   * @param {Function} gen  Generator function.
   * @param {*=} [ctx=null] Context for Generator function.
   * @return {*}
   */
  spawn(gen, ctx = null) {
    let iter = gen.apply(ctx == null ? this : ctx);

    function step(it) {
      if (it.done)
        return;

      if (typeof it.value === 'function')
        it.value(x => step(iter.next(x)));
      else
        step(iter.next(it.value));
    }

    step(iter.next());
    return iter;
  }

  /**
   * Waits for given amount of seconds before processing.
   *
   * @param {number} [seconds=1] Duration
   * @return {function(*):*}
   */
  wait(seconds = 1) {
    return cb => setTimeout(cb.bind(this, (/** @type {number} */(seconds) * 1000)), (/** @type {number} */(seconds) * 1000));
  }

  /**
   * Waits for a specific message.
   *
   * @param {string} message The name of the message to wait for.
   * @return {function(*):*}
   */
  waitMessage(message) {
    return cb => this.once(message, cb.bind(this));
  }

  /**
   * Marks this GameObject and/or its children elements as dirty.
   *
   * @param {black-engine~DirtyFlag} flag The flag or flag bit mask.
   * @param {boolean} [includeChildren=true] Specifies if the flag needed for all children.
   * @return {void}
   */
  setDirty(flag, includeChildren = true) {
    if (includeChildren) {
      GameObject.forEach(this, x => {
        x.mDirty |= flag;
        x.mDirtyFrameNum = Black.engine.frameNum;
      });
    } else {
      this.mDirty |= flag;
      this.mDirtyFrameNum = Black.engine.frameNum;
    }

    Renderer.__dirty = true;
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~GameObject} go 
   */
  __updatePivots(go) {
    go.getBounds(go, true, Rectangle.__cache.zero());

    go.mPivotX = go.mAnchorX === null ? go.mPivotOffsetX : go.mPivotOffsetX + (Rectangle.__cache.width * go.mAnchorX) + Rectangle.__cache.x;
    go.mPivotY = go.mAnchorY === null ? go.mPivotOffsetY : go.mPivotOffsetY + (Rectangle.__cache.height * go.mAnchorY) + Rectangle.__cache.y;
  }

  /**
   * Marks the GameObject's parent as dirty.
   *
   * @param {black-engine~DirtyFlag} flag The flag or flag bit mask.
   * @return {void}
   */
  setParentDirty(flag) {
    let current = this;
    while (current != null) {
      current.mDirty |= flag;
      current.mDirtyFrameNum = Black.engine.frameNum;
      current = current.mParent;
    }

    Renderer.__dirty = true;
  }

  /**
   * Marks this GameObject as Local dirty and all children elements as World dirty.
   *
   * @returns {void}
   */
  setTransformDirty() {
    if (this.mSuspendDirty === true)
      return;

    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.LOCAL | DirtyFlag.BOUNDS), false);
    this.setDirty(DirtyFlag.WIRB, true);

    this.setParentDirty(/** @type {DirtyFlag} */(DirtyFlag.BOUNDS | DirtyFlag.ANCHOR));
  }

  /**
   * Marks this GameObject with Render dirty flag if it is not suspended for dirty.
   *
   * @returns {void}
   */
  setRenderDirty() {
    if (this.mSuspendDirty === true)
      return;

    this.setDirty(DirtyFlag.RENDER, true);
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set touchable(value) {
    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent));

    if (value === true) {
      if (c === null)
        this.addComponent(new InputComponent());
      else
        c.touchable = true;
    } else {
      if (c !== null)
        this.removeComponent(c);
    }
  }

  /**
   * Gets/Sets whether the object will listen for user input messages.
   *
   * @return {boolean}
   */
  get touchable() {
    let c = /** @type {InputComponent} */ (this.getComponent(InputComponent));
    return c !== null && c.touchable === true;
  }

  // TODO: rename method
  /**
   * @ignore
   *
   * @param {Array<number>} points
   * @param {black-engine~Matrix} worldTransformation
   * @param {black-engine~Rectangle=} outRect
   * @return {black-engine~Rectangle}
   */
  static getBoundsWithPoints(points, worldTransformation, outRect) {
    outRect = outRect || new Rectangle();

    let minX = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let tmpVector = new Vector();

    for (let i = 0; i < points.length; i += 2) {
      worldTransformation.transformXY(points[i], points[i + 1], tmpVector);

      if (minX > tmpVector.x)
        minX = tmpVector.x;

      if (maxX < tmpVector.x)
        maxX = tmpVector.x;

      if (minY > tmpVector.y)
        minY = tmpVector.y;

      if (maxY < tmpVector.y)
        maxY = tmpVector.y;
    }

    outRect.set(minX, minY, maxX - minX, maxY - minY);
    return outRect;
  }

  /**
   * Returns whenever a given GameObject intersects with a point.
   *
   * @param {black-engine~GameObject} gameObject GameObject to test.
   * @param {black-engine~Vector} point A point to test.
   * @return {boolean} True if intersects.
   */
  static intersects(gameObject, point) {
    let tmpVector = new Vector();
    let inv = gameObject.worldTransformationInverted;

    inv.transformVector(point, tmpVector);

    return gameObject.localBounds.containsXY(tmpVector.x, tmpVector.y);
  }

  /**
   * Returns a point where intersection were made in local space.
   *
   * @param {black-engine~GameObject} gameObject GameObject to test intersection with.
   * @param {black-engine~Vector} point The point to test.
   * @param {black-engine~Vector=} outVector If passed point of intersection will be stored in it.
   * @return {boolean} True if intersects.
   */
  static intersectsAt(gameObject, point, outVector = undefined) {
    outVector = outVector || new Vector();

    Vector.__cache.set();

    gameObject.worldTransformationInverted.transformVector(point, Vector.__cache);
    let contains = gameObject.localBounds.containsXY(Vector.__cache.x, Vector.__cache.y);

    if (contains === false)
      return false;

    outVector.x = Vector.__cache.x - gameObject.localBounds.x;
    outVector.y = Vector.__cache.y - gameObject.localBounds.y;
    return true;
  }

  /**
   * Checks if GameObject or any of its children elements intersects the given point.
   *
   * @param {black-engine~GameObject} gameObject GameObject to test.
   * @param {black-engine~Vector} point Point to test.
   * @return {black-engine~GameObject|null} Intersecting object or null.
   */
  static intersectsWith(gameObject, point) {
    let obj = null;
    for (let i = gameObject.numChildren - 1; i >= 0; --i) {
      let child = gameObject.mChildren[i];

      obj = GameObject.intersectsWith(child, point);
      if (obj != null)
        return obj;

      let inside = GameObject.intersects(child, point);
      if (inside) {
        obj = child;
        break;
      }
    }

    if (obj === null && GameObject.intersects(gameObject, point))
      return gameObject;

    return null;
  }

  /**
   * Returns all GameObject with given tag.
   *
   * @param {string} tag Tag to find.
   * @returns {Array<black-engine~GameObject>|null} Array of GameObject or null if not found.
   */
  static findWithTag(tag) {
    if (Black.engine.mTagCache.hasOwnProperty(tag) === false)
      return null;

    return Black.engine.mTagCache[tag];
  }

  /**
   * Returns a list of Components.
   *
   * @param {black-engine~GameObject} gameObject GameObject to start search from.
   * @param {function (new:black-engine~Component)} type Type of Component.
   * @return {Array<black-engine~Component>} Array of Component or empty array.
   */
  static findComponents(gameObject, type) {
    Debug.assert(gameObject !== null, 'gameObject cannot be null.');
    Debug.assert(type !== null, 'type cannot be null.');

    /** @type {Array<Component>} */
    let list = [];

    /** @type {function(GameObject, function(new:Component)):void} */
    let f = function (gameObject, type) {
      for (let i = 0; i < gameObject.mComponents.length; i++) {
        let c = gameObject.mComponents[i];
        if (c instanceof type)
          list.push(c);
      }

      for (let i = 0; i < gameObject.mChildren.length; i++)
        f(gameObject.mChildren[i], type);
    };

    f(gameObject, type);

    return list;
  }

  /**
   * Runs action across all GameObjects.
   *
   * @param {black-engine~GameObject} gameObject GameObject to start iteration from.
   * @param {function(black-engine~GameObject)} action The function to be executed on every GameObject.
   * @return {void}
   */
  static forEach(gameObject, action) {
    if (gameObject == null)
      gameObject = Black.stage;

    let r = action(gameObject);
    if (r === true)
      return;

    for (let i = 0; i < gameObject.mChildren.length; i++) {
      r = GameObject.forEach(gameObject.mChildren[i], action);
      if (r === true)
        return;
    }
  }


  /**
   * Finds object by its name. If node is not passed the root will be taken as
   * starting point.
   *
   * @param {string} name      Name to search.
   * @param {black-engine~GameObject=} node Starting GameObject.
   *
   * @return {black-engine~GameObject} GameObject or null.
   */
  static find(name, node) {
    if (node == null)
      node = Black.stage;

    if (node.name === name)
      return node;

    for (let i = 0; i < node.numChildren; i++) {
      let r = GameObject.find(name, node.getChildAt(i));
      if (r != null)
        return r;
    }

    return null;
  }

  /**
   * Finds object by its id property. If node is not passed the root will be taken as
   * starting point.
   *
   * @param {number} id         Id to search.
   * @param {black-engine~GameObject=} node  Starting GameObject or null.
   *
   * @return {black-engine~GameObject} GameObject or null.
   */
  static findById(id, node) {
    if (node == null)
      node = Black.stage;

    if (node.id === id)
      return node;

    for (let i = 0; i < node.numChildren; i++) {
      let r = GameObject.findById(id, node.getChildAt(i));
      if (r !== null)
        return r;
    }

    return null;
  }
}

/**
 * Stage scale mode.
 * 
 * Make sure to to have viewport meta tag in your HTML file.
 * 
 * @example
 * <meta name="viewport" content="initial-scale=1 maximum-scale=1 user-scalable=0" />
 * 
 * @cat display
 * @static
 * @constant
 * @enum {string}
 */
const StageScaleMode = {
  /** The stage size will be the same no matter what DPI is */
  NORMAL: 'normal',
  /** The stage size will be affected by dpi */
  NO_SCALE: 'noScale',
  /** The stage size tries to stay inside requested size. default is 960x640 */
  FIXED: 'fixed',
  /** The stage size will be equal to requested size, position will be centered */
  LETTERBOX: 'letterBox',
  /** The stage size will be equal to requested size, position will be centered, and cover the viewport */
  COVER: 'cover'
};

/**
 * Holds information about keyboard event.
 *
 * @cat input
 */
class KeyInfo {

  /**
   * Create new instance of KeyInfo
   *
   * @param {KeyboardEvent} nativeEvent Native touch event.
   * @return {void}
   */
  constructor(nativeEvent) {
    this.keyCode = nativeEvent.keyCode;
    this.code = nativeEvent.code;
    this.char = nativeEvent.key;
    this.shiftKey = nativeEvent.shiftKey;
    this.altKey = nativeEvent.altKey;
    this.ctrlKey = nativeEvent.ctrlKey;
  }
}

/**
 * Contains system functions.
 * @static
 * @cat system
 */
class Device {
  constructor() {
    /**
     * @type {number|null}
     * @private
     */
    this.mPixelRatioCache = null;
  }

  /**
   * Returns current OS name.
   * 
   * @return {string}
   */
  get os() {
    let userAgent = navigator.userAgent || navigator.vendor || window.opera;

    if (/windows phone/i.test(userAgent))
      return 'Windows Phone';

    if (/android/i.test(userAgent))
      return 'Android';

    if (/iPad|iPhone|iPod/.test(userAgent)/* && !window.MSStream*/)
      return 'iOS';

    return 'unknown';
  }

  /**
   * Returns True if touch screen is present.
   *
   * @return {boolean}
   */
  get isTouch() {
    let hasEvent = 'ontouchstart' in window;
    if (hasEvent)
      return true;

    if (navigator.maxTouchPoints > 0)
      return true;

    return false;
  }

  /**
   * Returns True if engine is running on mobile device.
   *
   * @return {boolean}
   */
  get isMobile() {
    return /Mobi/.test(navigator.userAgent);
  }

  /**
   * Returns screen pixel ratio.
   *
   * @return {number}
   */
  get pixelRatio() {
    if (this.mPixelRatioCache === null)
      this.mPixelRatioCache = this.getDevicePixelRatio();

    return this.mPixelRatioCache;
  }

  /**
   * Returns true if web audio is supported.
   *
   * @return {boolean}
   */
  get webAudioSupported() {
    return window['AudioContext'] != null || window['webkitAudioContext'] != null;
  }

  /**
   * Returns device pixel ratio.
   *
   * @suppress {missingProperties}
   * @return {number} Description
   */
  getDevicePixelRatio() {
    if (window.screen.systemXDPI !== undefined && window.screen.logicalXDPI !== undefined && window.screen.systemXDPI > window.screen.logicalXDPI)
      return window.screen.systemXDPI / window.screen.logicalXDPI;
    else if (window.devicePixelRatio !== undefined)
      return window.devicePixelRatio;

    return 1;
  }
}

/**
 * The base class for all renderable objects. Adds `alpha` and `visible` properties to GameObject.
 *
 * @cat display
 * @extends black-engine~GameObject
 */
class DisplayObject extends GameObject {
  constructor() {
    super();

    /** 
     * @protected 
     * @type {number} 
     */
    this.mAlpha = 1;

    /** 
     * @protected 
     * @type {black-engine~BlendMode} 
     */
    this.mBlendMode = BlendMode.AUTO;

    /** 
     * @protected 
     * @type {boolean} 
     */
    this.mVisible = true;

    /** 
     * @protected 
     * @type {black-engine~Rectangle} 
     */
    this.mClipRect = null;

    /** 
     * @protected 
     * @type {black-engine~Renderer|null} 
     */
    this.mRenderer = this.getRenderer();

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mCacheAsBitmap = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mCacheAsBitmapDynamic = true;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mCacheAsBitmapDirty = true;

    /** 
     * @private 
     * @type {black-engine~Matrix|null} 
     */
    this.mCacheAsBitmapMatrixCache = null;

    /** 
     * @private 
     * @type {black-engine~CanvasRenderTexture|null} 
     */
    this.mCache = null;

    /** 
     * @private 
     * @type {black-engine~Rectangle|null} 
     */
    this.mCacheBounds = null;

    /** 
     * @protected 
     * @type {?number} 
     */
    this.mColor = null;

    /** 
     * @protected 
     * @type {boolean} 
     */
    this.mSnapToPixels = false;
  }

  /**
   * Called at the end of the loop, all renderers are already collected and this object and its children will be
   * rendered. Should be used to interpolate between last and current state. 
   * 
   * NOTE: Adding, removing or changing children elements inside onRender method can lead to unexpected behavior.
   * 
   * @protected
   * @return {void}
   */
  onRender() { }

  /**
   * Factory method returns concrete renderer for this Game Object.
   * 
   * @returns {black-engine~Renderer}
   */
  getRenderer() {
    return Black.driver.getRenderer('DisplayObject', this);
  }

  /**
   * @inheritDoc
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    if (this.mClipRect !== null) {
      this.mClipRect.copyTo(outRect);
      return outRect;
    }

    return outRect.set(0, 0, 0, 0);
  }

  /**
   * @inheritDoc
   */
  getBounds(space = undefined, includeChildren = true, outRect = undefined) {
    outRect = outRect || new Rectangle();

    let localBounds = this.onGetLocalBounds();

    if (space == null)
      space = this.mParent;

    if (space == this) ; else if (space == this.mParent) {
      if (includeChildren === false || this.mClipRect !== null) {
        let matrix = Matrix.pool.get();
        matrix.copyFrom(this.localTransformation);
        matrix.transformRect(localBounds, outRect);
        Matrix.pool.release(matrix);
      }
      else if (includeChildren === true && this.mDirty & DirtyFlag.BOUNDS) {
        let matrix = Matrix.pool.get();
        matrix.copyFrom(this.localTransformation);
        matrix.transformRect(localBounds, outRect);
        Matrix.pool.release(matrix);
      } else {
        // Return cached
        outRect.copyFrom(this.mBoundsCache);
        return outRect;
      }
    } else {
      let matrix = Matrix.pool.get();
      matrix.copyFrom(this.worldTransformation);
      matrix.prepend(space.worldTransformationInverted);
      matrix.transformRect(localBounds, outRect);
      Matrix.pool.release(matrix);
    }

    if (space !== this) {
      if (this.mClipRect !== null) {
        outRect.x += this.mPivotX;
        outRect.y += this.mPivotY;
      }
    } else {
      localBounds.copyTo(outRect);
    }

    if (this.mClipRect !== null)
      return outRect;

    if (includeChildren === true) {
      let childBounds = Rectangle.pool.get();

      for (let i = 0; i < this.mChildren.length; i++) {
        childBounds.zero();

        this.mChildren[i].getBounds(space, includeChildren, childBounds);
        outRect.union(childBounds);
      }

      Rectangle.pool.release(childBounds);

      if (space == this.mParent && this.mDirty & DirtyFlag.BOUNDS) {
        this.mBoundsCache.copyFrom(outRect);
        this.mDirty ^= DirtyFlag.BOUNDS;
      }
    }

    return outRect;
  }

  /**
   * @inheritDoc
   */
  hitTest(localPoint) {
    let c = /** @type {InputComponent}*/ (this.getComponent(InputComponent));
    let touchable = c !== null && c.touchable;
    let insideMask = this.onHitTestMask(localPoint);

    if (this.visible === false || touchable === false || insideMask === false)
      return null;

    let target = null;
    let numChildren = this.mChildren.length;

    for (let i = numChildren - 1; i >= 0; --i) {
      let child = this.mChildren[i];

      target = child.hitTest(localPoint);

      if (target !== null)
        return target;
    }

    if (this.onHitTest(localPoint) === true)
      return this;

    return null;
  }

  /**
  * @inheritDoc
  */
  onHitTestMask(localPoint) {
    if (this.mClipRect === null)
      return true;

    let tmpVector = Vector.pool.get();
    this.worldTransformationInverted.transformVector(localPoint, tmpVector);

    let contains = this.mClipRect.containsXY(tmpVector.x - this.mPivotX, tmpVector.y - this.mPivotY);
    Vector.pool.release(tmpVector);

    return contains;
  }

  /**
   * Gets/Sets tinting color of the object. Pass `null` to disable tinting. Tinting color will be applied to all children
   * objects. You can override tint color for children by setting custom value or `null` to inherit color from parent.
   * @returns {?number}
   */
  get color() {
    return this.mColor;
  }

  /**
   * @param {?number} value
   * @return {void}
   */
  set color(value) {
    if (this.mColor === value)
      return;

    this.mColor = value;
    this.setRenderDirty();
  }

  /**
   * Gets/Sets whether this container and all it's children should be baked into bitmap. Setting `cacheAsBitmap` onto
   * Sprites,, TextField's or any other inherited classes will give zero effect.
   *
   * @return {boolean} 
   */
  get cacheAsBitmap() {
    return this.mCacheAsBitmap;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set cacheAsBitmap(value) {
    if (value === this.mCacheAsBitmap)
      return;

    this.mCacheAsBitmap = value;

    if (value === false) {
      this.mCache = null;
      this.mCacheAsBitmapDirty = true;
      this.mCacheAsBitmapMatrixCache = null;
      this.mCacheBounds = null;

      this.setTransformDirty();
    }
  }

  /**
   * Gets/sets whenever cache as bitmap should be automatically refreshed.
   * 
   * @returns {boolean}
   */
  get cacheAsBitmapDynamic() {
    return this.mCacheAsBitmapDynamic;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set cacheAsBitmapDynamic(value) {
    this.mCacheAsBitmapDynamic = value;
  }

  /**
   * Gets/Sets the opacity of the object.
   * Baked objects may change behavior.
   *
   * @return {number}
   */
  get alpha() {
    return this.mAlpha;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set alpha(value) {
    Debug.assert(!isNaN(value), 'Value cannot be NaN');

    if (this.mAlpha === MathEx.clamp(value, 0, 1))
      return;

    this.mAlpha = MathEx.clamp(value, 0, 1);
    this.setRenderDirty();
  }

  /**
   * Gets/Sets visibility of the object.
   *
   * @return {boolean}
   */
  get visible() {
    return this.mVisible;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set visible(value) {
    if (this.mVisible === value)
      return;

    this.mVisible = value;
    this.setRenderDirty();
  }

  /**
   * Gets/Sets blend mode for the object.
   *
   * @return {black-engine~BlendMode}
   */
  get blendMode() {
    return this.mBlendMode;
  }

  /**
   * @param {black-engine~BlendMode} value
   * @return {void}
   */
  set blendMode(value) {
    if (this.mBlendMode === value)
      return;

    this.mBlendMode = value;
    this.setRenderDirty();
  }

  /**
   * Gets/Sets clipping area for the object.
   *
   * @return {black-engine~Rectangle}
   */
  get clipRect() {
    return this.mClipRect;
  }

  /**
   * @param {black-engine~Rectangle} value
   * @return {void}
   */
  set clipRect(value) {
    this.mClipRect = value;
    this.setRenderDirty();
  }

  /**
   * Gets/sets whenever this object x and y value should be rounded.
   * @returns {boolean}
   */
  get snapToPixels() {
    return this.mSnapToPixels;
  }

  /**
   * @param {boolean} value
   */
  set snapToPixels(value) {
    this.mSnapToPixels = value;
  }
}

/**
 * The base class for all renderable objects. Adds `alpha` and `visible` properties to GameObject.
 *
 * @cat display
 * @extends black-engine~DisplayObject
 */
class Camera extends DisplayObject {
  constructor() {
    super();

    Black.camera = this;
  }

  get worldTransformation() {
    let wt = super.worldTransformation.clone();
    wt.prepend(this.stage.worldTransformationInverted);

    return wt;
  }
}

/**
 * A input system class is responsible for mouse, touch and keyboard input events.
 * Pointer events works for a single target only.
 * Global Input messages has higher priority.
 *
 * When GameObject gets a `pointerDown` message it gets target locked. Other
 * objects will not receive `pointerMove` or `pointerUp` messages. Target locked
 * object will receive `pointerUp` message even if pointer is outside of its
 * bounds.
 * 
 * Every object in the display list should be `touchable` in order to receive input messages.
 *
 * @cat input
 * @fires Input#pointerMove
 * @fires Input#pointerDown
 * @fires Input#pointerUp
 * 
 * @fires GameObject#pointerMove
 * @fires GameObject#pointerDown
 * @fires GameObject#pointerUp
 * 
 * @extends black-engine~System
 */
class Input extends System {
  /**
   * Private constructor.
   */
  constructor() {
    super();

    Debug.assert(this.constructor.instance == null, 'Only single instance is allowed');

    Black.input = this;

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mViewportPosition = new Vector();

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mPointerPosition = new Vector();

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mStagePosition = new Vector();

    /** 
     * @private 
     * @type {Element|null} 
     */
    this.mDom = null;

    /** 
     * @private 
     * @type {Array<string>} 
     */
    this.mEventList = null;

    /** 
     * @private 
     * @type {Array<string>} 
     */
    this.mKeyEventList = null;

    /** 
     * @private 
     * @type {Array<{name: String, listener: Function}>} 
     */
    this.mBoundListeners = [];

    /** 
     * @private 
     * @type {Array<{e: Event, x: number, y:number}>} 
     */
    this.mPointerQueue = [];

    /** 
     * @private 
     * @type {Array<KeyboardEvent>} 
     */
    this.mKeyQueue = [];

    /** 
     * @private 
     * @type {Array<number>} 
     */
    this.mPressedKeys = [];

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsPointerDown = false;

    // NOTE: we need guarantee that keys are not going to change theirs order when iterating.
    /** 
     * @private 
     * @type {Map} 
     */
    this.mInputListeners = new Map();

    /** 
     * @private 
     * @type {black-engine~GameObject} 
     */
    this.mTarget = null;

    /** 
     * @private 
     * @type {black-engine~Component} 
     */
    this.mTargetComponent = null;

    /** 
     * @private 
     * @type {black-engine~GameObject} 
     */
    this.mLockedTarget = null;

    /** 
     * @private 
     * @type {black-engine~Component} 
     */
    this.mLastInTargetComponent = null;

    this.__initialize();
  }

  /**
   * @ignore
   */
  __initialize() {
    this.mDom = Black.engine.viewport.nativeElement;

    this.__initListeners();
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __initListeners() {
    this.mKeyEventList = mKeyEventList;
    let isMouseDevice = false;

    if (window.PointerEvent) {
      this.mEventList = mPointerEventList;
      isMouseDevice = true;
    }
    else if (Black.device.isTouch && Black.device.isMobile) {
      this.mEventList = mTouchEventList;
    }
    else {
      this.mEventList = mMouseEventList;
      isMouseDevice = true;
    }

    for (let i = 0; i < 3; i++)
      this.mDom.addEventListener(this.mEventList[i], e => this.__onPointerEvent(e), false);

    let addBoundsListener = (target, name, action) => {
      const listener = e => action.call(this, e);

      this.mBoundListeners.push({ name: name, listener: listener });
      target.addEventListener(name, listener);
    };

    addBoundsListener(document, this.mEventList[IX_POINTER_MOVE], this.__onPointerEventDoc);
    addBoundsListener(document, this.mEventList[IX_POINTER_UP], this.__onPointerEventDoc);

    if (isMouseDevice === true)
      addBoundsListener(window, 'wheel', this.__onPointerEventDoc);

    // handle keyboard listeners
    for (let i = 0; i < this.mKeyEventList.length; i++)
      addBoundsListener(document, this.mKeyEventList[i], this.__onKeyEvent);
  }

  /**
   * @ignore
   * @private
   * @param {KeyboardEvent} e
   * @returns {boolean}
   */
  __onKeyEvent(e) {
    if (Black.engine.isPaused === true)
      return false;

    this.mKeyQueue.push(e);
    return true;
  }

  /**
   * @ignore
   * @private
   * @param {Event} e
   * @returns {void}
   */
  __onPointerEventDoc(e) {
    if (Black.engine.isPaused === true)
      return;

    let over = false;

    // IE11 does not have support for `path`
    let element = e.target;
    while (element) {
      if (element === this.mDom) {
        over = true;
        break;
      }
      element = element.parentElement;
    }

    if (e.type === 'wheel') {
      if (over === true)
        this.__pushEvent(e);
    } else {
      if (over === false && this.mIsPointerDown === true)
        this.__pushEvent(e);
    }
  }

  /**
   * @ignore
   * @private
   * @param {Event} e
   * @returns {boolean}
   */
  __onPointerEvent(e) {
    if (Black.engine.isPaused === true)
      return false;

    e.preventDefault();

    this.__pushEvent(e);
    return true;
  }

  /**
   * @ignore
   * @private
   * @param {Event} e
   * @returns {void}
   */
  __pushEvent(e) {
    let /** @type {Vector|null} */ p = null;
    if (e.type.indexOf('touch') === 0)
      p = this.__getTouchPos(this.mDom, /** @type {TouchEvent} */(e));
    else
      p = this.__getPointerPos(this.mDom, e);

    this.mPointerQueue.push({ e: e, x: p.x, y: p.y });
  }

  /**
   * @ignore
   * @private
   * @param {Element} canvas
   * @param {Event} evt
   * @returns {black-engine~Vector}
   */
  __getPointerPos(canvas, evt) {
    let rect = canvas.getBoundingClientRect();

    const rotation = Black.engine.viewport.rotation;

    let scaleX = (rotation === 0 ? canvas.clientWidth : canvas.clientHeight) / rect.width;
    let scaleY = (rotation === 0 ? canvas.clientHeight : canvas.clientWidth) / rect.height;

    return new Vector((evt.clientX - rect.left) * scaleX, (evt.clientY - rect.top) * scaleY);
  }

  /**
   * @ignore
   * @private
   * @param {Element} canvas
   * @param {TouchEvent} evt
   * @returns {black-engine~Vector}
   */
  __getTouchPos(canvas, evt) {
    let rect = canvas.getBoundingClientRect();

    /** @type {Touch} */
    let touch = evt.changedTouches[0]; // ios? what about android?
    let x = touch.clientX;
    let y = touch.clientY;

    const rotation = Black.engine.viewport.rotation;
    let scaleX = (rotation === 0 ? canvas.clientWidth : canvas.clientHeight) / rect.width;
    let scaleY = (rotation === 0 ? canvas.clientHeight : canvas.clientWidth) / rect.height;

    return new Vector((x - rect.left) * scaleX, (y - rect.top) * scaleY);
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    // omg, who gave you keyboard?
    this.__updateKeyboard();

    const size = Black.engine.viewport.size;
    const rotation = Black.engine.viewport.rotation;

    let stage = Black.stage;

    while (this.mPointerQueue.length > 0) {
      const nativeEvent = this.mPointerQueue.shift();

      const x = nativeEvent.x;
      const y = nativeEvent.y;

      if (rotation === 1) {
        nativeEvent.x = y;
        nativeEvent.y = size.height - x;
      } else if (rotation === -1) {
        nativeEvent.x = size.width - y;
        nativeEvent.y = x;
      }

      // update to the latest position
      this.mPointerPosition.x = nativeEvent.x;
      this.mPointerPosition.y = nativeEvent.y;

      this.mViewportPosition.copyFrom(this.mPointerPosition);

      if (Black.camera !== null)
        Black.camera.worldTransformation.transformVector(this.mPointerPosition, this.mPointerPosition);

      this.mStagePosition.copyFrom(this.mPointerPosition);

      let inv = stage.worldTransformationInverted;
      inv.transformVector(this.mStagePosition, this.mStagePosition);

      let eventType = mInputEventsLookup[this.mEventList.indexOf(nativeEvent.e.type)];

      this.__findTarget(this.mPointerPosition);
      this.__processNativeEvent(nativeEvent, this.mPointerPosition, eventType);
    }
  }

  /**
   * @ignore
   * @private
   * @param {black-engine~Vector} pos
   */
  __findTarget(pos) {
    let obj = Black.stage.hitTest(pos);

    if (obj === null) {
      this.mTarget = null;
      this.mTargetComponent = null;
      return;
    }

    this.mTarget = obj;
    this.mTargetComponent = obj.getComponent(InputComponent);
  }

  /**
   * @ignore
   * @private
   * @param {Object} nativeEvent
   * @param {black-engine~Vector} pos
   * @param {string} type
   */
  __processNativeEvent(nativeEvent, pos, type) {
    if (type === Input.POINTER_DOWN) {
      this.mIsPointerDown = true;
    }
    else if (type === Input.POINTER_UP) {
      this.mIsPointerDown = false;
    }

    let delta = 0;
    if (type === Input.WHEEL)
      delta = nativeEvent.e.deltaY > 0 ? 1 : -1;

    const info = new PointerInfo(this.mTarget, pos.x, pos.y, nativeEvent.e.button, delta);
    this.post(type, info);

    if (this.mTarget === null && this.mLockedTarget === null)
      return;

    if (type === Input.POINTER_DOWN) {
      this.mLockedTarget = this.mTarget;
    }
    else if (type === Input.POINTER_UP && this.mLockedTarget !== null) {
      this.mLockedTarget.post('~pointerUp', info);
      this.mLockedTarget = null;
      return;
    }

    let sameTarget = this.mTarget === this.mLockedTarget;

    if (this.mLockedTarget === null) {
      if (this.mTarget !== null)
        this.mTarget.post('~' + type, info);
    } else {
      if (sameTarget === true)
        this.mLockedTarget.post('~' + type, info);
      else {
        if (this.mLockedTarget.mParent !== null && this.mTarget !== null)
          this.mLockedTarget.mParent.post('~' + type, info);
      }
    }
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __updateKeyboard() {
    while (this.mKeyQueue.length > 0) {
      let nativeEvent = this.mKeyQueue.shift();

      let ix = this.mKeyEventList.indexOf(nativeEvent.type);
      let pIx = this.mPressedKeys.indexOf(nativeEvent.keyCode);
      let fnName = mKeyEventsLookup[ix];

      if (fnName === 'keyUp' && pIx !== -1)
        this.mPressedKeys.splice(pIx, 1);

      else if (fnName === 'keyDown' && pIx === -1) {
        this.mPressedKeys.push(nativeEvent.keyCode);
        fnName = 'keyPress';
      }

      this.post(fnName, new KeyInfo(nativeEvent), nativeEvent);
    }
  }

  /**
   * @override
   */
  dispose() {
    super.dispose();

    while (this.mBoundListeners.length > 0) {
      let keyValue = this.mBoundListeners.pop();
      document.removeEventListener(keyValue.name, keyValue.listener);
    }

    Black.input = null;
  }

  /**
   * Indicates if mouse or touch in down at this moment.
   *
   * @returns {boolean}
   */
  get isPointerDown() {
    return this.mIsPointerDown;
  }

  /**
   * Returns mouse or touch pointer x-component.
   *
   * @returns {number}
   */
  get pointerX() {
    return this.mPointerPosition.x;
  }

  /**
   * Returns mouse or touch pointer x-component.
   *
   * @returns {number}
   */
  get pointerY() {
    return this.mPointerPosition.y;
  }

  /**
   * Returns mouse or touch pointer x-component relative to stage.
   *
   * @returns {number}
   */
  get stageX() {
    return this.mStagePosition.x;
  }

  /**
   * Returns mouse or touch pointer x-component  relative to stage.
   *
   * @returns {number}
   */
  get stageY() {
    return this.mStagePosition.y;
  }

  /**
   * Returns mouse or touch pointer position relative to viewport.
   *
   * @returns {black-engine~Vector}
   */
  get viewportPosition() {
    return this.mViewportPosition;
  }

  /**
   * Returns mouse or touch pointer position including active camera transformation.
   *
   * @returns {black-engine~Vector}
   */
  get pointerPosition() {
    return this.mPointerPosition;
  }

  /**
   * Returns pointer position relative to the stage.
   * 
   * @returns {black-engine~Vector}
   */
  get stagePosition() {
    return this.mStagePosition;
  }

  /**
   * Returns list of pressed keys.
   *
   * @returns {Array<number>}
   */
  get pressedKeys() {
    return this.mPressedKeys;
  }

  /**
   * @type {string}
   * @const
   */
  static get POINTER_DOWN() { return 'pointerDown'; }

  /**
   * @type {string}
   * @const
   */
  static get POINTER_MOVE() { return 'pointerMove'; }

  /**
   * @type {string}
   * @const
   */
  static get POINTER_UP() { return 'pointerUp'; }

  /**
   * @type {string}
   * @const
   */
  static get WHEEL() { return 'wheel'; }
}


/**
 * @private
 * @type {number}
 * @const
 */
const IX_POINTER_MOVE = 0;

/**
 * @private
 * @type {number}
 * @const
 */
const IX_POINTER_UP = 2;

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mKeyEventList = ['keydown', 'keyup'];

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mKeyEventsLookup = ['keyDown', 'keyUp', 'keyPress'];

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mInputEventsLookup = ['pointerMove', 'pointerDown', 'pointerUp', 'pointerIn', 'pointerOut', 'wheel'];

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mPointerEventList = ['pointermove', 'pointerdown', 'pointerup', 'pointerenter', 'pointerleave', 'wheel'];

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mMouseEventList = ['mousemove', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'wheel'];

/**
 * @private
 * @type {Array<string>}
 * @const
 */
const mTouchEventList = ['touchmove', 'touchstart', 'touchend', 'touchenter', 'touchleave'];

/**
 * Posts when mouse down or touch down event happened.
 * @event Input#pointerDown
 */

/**
 * Posts when mouse up or touch up event happened.
 * @event Input#pointerUp
 */

/**
 * Posts when mouse move or touch move event happened.
 * @event Input#pointerMove
 */

/**
* Posts when mouse down or touch down event happened.
* @event GameObject#pointerDown
*/

/**
 * Posts when mouse up or touch up event happened.
 * @event GameObject#pointerUp
 */

/**
 * Posts when mouse move or touch move event happened.
 * @event GameObject#pointerMove
 */

/**
 * Stores additional information about pointer events.
 *
 * @ignore
 * @cat input
 */
class PointerInfo {
  /**
   * Creates new PointerInfo instance. For internal use only.
   *
   * @param {black-engine~GameObject} activeObject `GameObject` the cursor is above.
   * @param {number} x x-coordinate
   * @param {number} y y-coordinate
   * @param {number} button active pressed button
   */
  constructor(activeObject, x, y, button, delta = 0) {

    /** 
     * @private 
     * @type {black-engine~GameObject} 
     */
    this.mActiveObject = activeObject;

    /** 
     * @private 
     * @type {number} 
     */
    this.mX = x;

    /** 
     * @private 
     * @type {number} 
     */
    this.mY = y;

    /** 
     * @private 
     * @type {number} 
     */
    this.mButton = button;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDelta = delta;
  }

  /**
   * Retruns normalized wheel delta value.
   * @returns {number}
   */
  get delta() {
    return this.mDelta;
  }

  /**
   * Retruns current pressed button.
   * @returns {number}
   */
  get button() {
    return this.mButton;
  }

  /**
   * Returns the object under cursor right now.
   *
   * @readonly
   * @returns {black-engine~GameObject}
   */
  get activeObject() {
    return this.mActiveObject;
  }

  /**
   * X-coordinate.
   *
   * @readonly
   * @returns {number}
   */
  get x() {
    return this.mX;
  }

  /**
   * Y-coordinate.
   *
   * @readonly
   * @returns {number}
   */
  get y() {
    return this.mY;
  }
}

/**
 * The root container for all renderable objects
 *
 * @cat display
 * @fires Stage#resize
 * @extends black-engine~GameObject
 */
class Stage extends GameObject {
  constructor() {
    super();

    /** 
     * @private 
     * @type {string} 
     */
    this.mName = 'stage';

    /** 
     * @private 
     * @type {black-engine~StageScaleMode} 
     */
    this.mScaleMode = StageScaleMode.NORMAL;

    /** 
     * @private 
     * @type {number} 
     */
    this.mWidth = 960;
    /** 
     * @private 
     * @type {number} 
     */
    this.mHeight = 640;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStageWidth = 0;
    /** 
     * @private 
     * @type {number} 
     */
    this.mStageHeight = 0;
    /** 
     * @private 
     * @type {number} 
     */
    this.mStageScaleFactor = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mCacheWidth = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mCacheHeight = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDPR = Black.device.getDevicePixelRatio();

    this.mAdded = true;

    // Fake 
    if (Black.engine.hasSystem(Input)){
      let c = new InputComponent();
      c.mAdded = true;
      this.addComponent(c);
    }
  }

  /**
   * Sets stage size by given width and height.
   *
   * @param {number} width New stage width.
   * @param {number} height New stage height.
   * @returns {void}
   */
  setSize(width, height) {
    this.mWidth = width;
    this.mHeight = height;

    this.__refresh();
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    let size = Black.engine.viewport.size;

    if (this.mCacheWidth !== size.width || this.mCacheHeight !== size.height) {
      this.mCacheWidth = size.width;
      this.mCacheHeight = size.height;

      this.__refresh();
    }
  }

  /**
   * Refreshes stage size. Call this method only if you are changing the size of the container manually. 
   */
  refresh() {
    this.__refresh();
  }

  /**
   * @private
   * @ignore
   * @returns {void}
   */
  __refresh() {
    const size = Black.engine.viewport.size;
    const windowWidth = size.width;
    const windowHeight = size.height;

    if (this.mScaleMode === StageScaleMode.FIXED) {
      const mw = windowWidth * this.mHeight / windowHeight;
      const mh = windowHeight * this.mWidth / windowWidth;
      const sc = Math.max(mw / windowWidth, mh / windowHeight);
      const width = windowWidth * sc;
      const height = windowHeight * sc;

      this.mStageWidth = width;
      this.mStageHeight = height;

      this.mScaleX = this.mScaleY = this.mStageScaleFactor = Math.min(windowWidth / width, windowHeight / height);
    } else if (this.mScaleMode === StageScaleMode.LETTERBOX || this.mScaleMode === StageScaleMode.COVER) {
      const sc = this.mScaleMode === StageScaleMode.COVER ?
        Math.max(windowWidth / this.mWidth, windowHeight / this.mHeight) :
        Math.min(windowWidth / this.mWidth, windowHeight / this.mHeight);

      this.mX = (windowWidth - this.mWidth * sc) / 2;
      this.mY = (windowHeight - this.mHeight * sc) / 2;

      this.mStageWidth = this.mWidth;
      this.mStageHeight = this.mHeight;

      this.mScaleX = this.mScaleY = this.mStageScaleFactor = sc;
    } else if (this.mScaleMode === StageScaleMode.NORMAL) {
      this.mStageWidth = windowWidth;
      this.mStageHeight = windowHeight;
      this.mScaleX = this.mScaleY = this.mStageScaleFactor = 1;
    } else if (this.mScaleMode === StageScaleMode.NO_SCALE) {
      this.mStageWidth = (windowWidth * this.mDPR);
      this.mStageHeight = (windowHeight * this.mDPR);

      this.mScaleX = this.mScaleY = this.mStageScaleFactor = 1 / this.mDPR;
    } else {
      Debug.error('Not supported stage scale mode.');
    }

    this.mStageWidth = Math.round(this.mStageWidth);
    this.mStageHeight = Math.round(this.mStageHeight);
    this.mX = Math.round(this.mX);
    this.mY = Math.round(this.mY);

    // TODO: i don't like this line
    // TODO: me neither
    // TODO: but its setting Renderer.__dirty which is good
    // TODO: replace with priority message?
    Black.driver.__onResize(null, null);

    this.setTransformDirty();

    this.mLocalTransform.set(this.mScaleX, 0, 0, this.mScaleY, this.mX, this.mY);

    /**
     * Posts every time stage size is changed.
     * @event Stage#resize
     */
    this.post(Message.RESIZE);
  }

  /**
   * Gets/Sets stage scale mode.
   *
   * @return {black-engine~StageScaleMode}
   */
  get scaleMode() {
    return this.mScaleMode;
  }

  /**
   * @param {black-engine~StageScaleMode} value
   * @returns {void}
   */
  set scaleMode(value) {
    this.mScaleMode = value;
    this.__refresh();
  }

  /**
   * Stage scale factor.
   *
   * @public
   * @readonly
   * @returns {number}
   */
  get scaleFactor() {
    return this.mStageScaleFactor;
  }

  /**
   * Original stage width multiplied by device pixel ratio and stage scale factor.
   *
   * @public
   * @readonly
   * @returns {number}
   */
  get renderWidth() {
    return this.mStageWidth * this.mDPR * this.mStageScaleFactor;
  }

  /**
   * Original stage height multiplied by device pixel ratio and stage scale factor.
   *
   * @public
   * @readonly
   * @returns {number}
   */
  get renderHeight() {
    return this.mStageHeight * this.mDPR * this.mStageScaleFactor;
  }

  /**
   * Gets stage center coordinate along X-axis.
   *
   * @public
   * @readonly
   * @returns {number}
   */
  get centerX() {
    return this.mStageWidth * 0.5;
  }

  /**
   * Gets stage center coordinate along Y-axis.
   *
   * @public
   * @readonly
   * @returns {number}
   */
  get centerY() {
    return this.mStageHeight * 0.5;
  }

  /**
   * @inheritDoc
   */
  getBounds(space = undefined, includeChildren = true, outRect = undefined) {
    outRect = outRect || new Rectangle();
    return outRect.set(-this.mX / this.mStageScaleFactor, -this.mY / this.mStageScaleFactor, this.mStageWidth + 2 * this.mX / this.mStageScaleFactor, this.mStageHeight + 2 * this.mY / this.mStageScaleFactor);
  }

  /**
   * @override
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();
    return outRect.set(0, 0, this.mStageWidth, this.mStageHeight);
  }

  /**
   * Returns local transformation `Matrix`
   *
   * @override
   * @return {black-engine~Matrix}
   */
  get localTransformation() {
    return this.mLocalTransform;
  }

  /**
   * @override
   * @param {black-engine~Matrix} value
   * @return {void}
   */
  set localTransformation(value) {
    Debug.error('Not allowed.');
  }

  removeFromParent() { Debug.error('Not allowed.'); }

  set scaleX(value) { Debug.error('Not allowed.'); }
  get scaleX() { return 1; }

  set scaleY(value) { Debug.error('Not allowed.'); }
  get scaleY() { return 1; }

  set pivotOffsetX(value) { Debug.error('Not allowed.'); }
  get pivotOffsetX() { return 0; }

  set pivotOffsetY(value) { Debug.error('Not allowed.'); }
  get pivotOffsetY() { return 0; }

  set anchorX(value) { Debug.error('Not allowed.'); }
  get anchorX() { return 0; }

  set anchorY(value) { Debug.error('Not allowed.'); }
  get anchorY() { return 0; }

  set x(value) { Debug.error('Not allowed.'); }
  get x() { return this.mX / this.mStageScaleFactor; } // GG ES6

  set y(value) { Debug.error('Not allowed.'); }
  get y() { return this.mY / this.mStageScaleFactor } // GG ES6

  set rotation(value) { Debug.error('Not allowed.'); }
  get rotation() { return 0; } // GG ES6

  set width(value) { Debug.error('Not allowed.'); }
  get width() { return this.mStageWidth; }

  set height(value) { Debug.error('Not allowed.'); }
  get height() { return this.mStageHeight; }

  set name(value) { Debug.error('Not allowed.'); }
  get name() { return this.mName }
}

/**
 * Collider with rectangle shape.
 *
 * @cat colliders
 * @extends black-engine~Collider
 */
class BoxCollider extends Collider {
  /**
   * Creates instance of BoxCollider.
   *
   * @param {number} x      X-coordinate.
   * @param {number} y      Y-coordinate.
   * @param {number} width  Rectangle width.
   * @param {number} height Rectangle height.
   */
  constructor(x, y, width, height) {
    super();

    const normals = [];
    const vertices = [];

    for (let i = 0; i < 4; i++) {
      normals.push(new Vector());
      vertices.push(new Vector());
    }

    /**
     * Local to gameObject. 
     * 
     * @private 
     * @type {black-engine~Rectangle}
     */
    this.mRect = new Rectangle();

    /**
     * Local to rigid body normals. 
     * 
     * @private 
     * @type {Array<black-engine~Vector>}
     */
    this.mNormals = normals;

    /**
     * Local to rigid body vertices. 
     * 
     * @private 
     * @type {Array<black-engine~Vector>} */
    this.mVertices = vertices;

    /**
     * Local to rigid body min x and y vertex. 
     * 
     * @private 
     * @type {black-engine~Vector} */
    this.mLocalMin = new Vector();

    /**
     * Local to rigid body max x and y vertex 
     * 
     * @private 
     * @type {black-engine~Vector}
     */
    this.mLocalMax = new Vector();

    /**
     * Local to rigid body center  
     * 
     * @private 
     * @type {black-engine~Vector}
     */
    this.mLocalCenter = new Vector();

    this.set(x, y, width, height);
  }

  /**
   * Updates this collider with a new given values.
   *
   * @public
   * @param {number} x      X-coordinate.
   * @param {number} y      Y-coordinate.
   * @param {number} width  Rectangle width.
   * @param {number} height Rectangle height.
   * @returns {black-engine~BoxCollider}
   */
  set(x, y, width, height) {
    this.mRect.set(x, y, width, height);
    this.mChanged = true;
    return this;
  }

  /**
   * @inheritDoc
   */
  refresh(transform, position) {
    const localMin = this.mLocalMin;
    const localMax = this.mLocalMax;
    const min = this.mMin;
    const max = this.mMax;
    const localCenter = this.mLocalCenter;
    const center = this.mCenter;

    if (this.mChanged) {
      const vertices = this.mVertices;
      const normals = this.mNormals;
      const rect = this.mRect;
      const vec = Vector.pool.get();

      transform.transformVector(vec.set(0, -1), normals[0]);
      transform.transformVector(vec.set(1, 0), normals[1]);
      transform.transformVector(vec.set(0, 1), normals[2]);
      transform.transformVector(vec.set(-1, 0), normals[3]);

      for (let i = 0; i < 4; i++) {
        normals[i].normalize();
      }

      transform.transformVector(vec.set(rect.x, rect.y), vertices[0]);
      transform.transformVector(vec.set(rect.x + rect.width, rect.y), vertices[1]);
      transform.transformVector(vec.set(rect.x + rect.width, rect.y + rect.height), vertices[2]);
      transform.transformVector(vec.set(rect.x, rect.y + rect.height), vertices[3]);

      localCenter.set((vertices[0].x + vertices[2].x) / 2, (vertices[0].y + vertices[2].y) / 2);
      localMin.x = Math.min(vertices[0].x, vertices[1].x, vertices[2].x, vertices[3].x);
      localMin.y = Math.min(vertices[0].y, vertices[1].y, vertices[2].y, vertices[3].y);
      localMax.x = Math.max(vertices[0].x, vertices[1].x, vertices[2].x, vertices[3].x);
      localMax.y = Math.max(vertices[0].y, vertices[1].y, vertices[2].y, vertices[3].y);

      Vector.pool.release(vec);
    }

    min.x = localMin.x + position.x;
    min.y = localMin.y + position.y;
    max.x = localMax.x + position.x;
    max.y = localMax.y + position.y;

    center.x = localCenter.x + position.x;
    center.y = localCenter.y + position.y;
  }

  /**
   * Checks if given global coordinates are located within collider's area.
   *
   * @public
   * @param {black-engine~Vector} point Global coordinates.
   *
   * @return {boolean}
   */
  containsPoint(point) {
    return this.mRect.containsXY(point.x, point.y);
  }

  // /**
  //  * Draw this
  //  *
  //  * @public
  //  * @param {Graphics} graphics   Drawing place
  //  * @param {Vector} bodyPosition This parent global position
  //  *
  //  * @return {void}
  //  */
  // debug(graphics, bodyPosition) {
  //   const vertices = this.mVertices;
  //
  //   graphics.beginPath();
  //   graphics.moveTo(bodyPosition.x + vertices[0].x, bodyPosition.y + vertices[0].y);
  //   graphics.lineTo(bodyPosition.x + vertices[1].x, bodyPosition.y + vertices[1].y);
  //   graphics.lineTo(bodyPosition.x + vertices[2].x, bodyPosition.y + vertices[2].y);
  //   graphics.lineTo(bodyPosition.x + vertices[3].x, bodyPosition.y + vertices[3].y);
  //   graphics.lineTo(bodyPosition.x + vertices[0].x, bodyPosition.y + vertices[0].y);
  //   graphics.stroke();
  // }
}

/**
 * Collider with circle shape.
 *
 * @cat colliders
 * @extends black-engine~Collider
 */
class CircleCollider extends Collider {
  /**
   * Creates new instance of CircleCollider.
   *
   * @param {number} x      Center coordinate within X-axis.
   * @param {number} y      Center coordinate within Y-axis.
   * @param {number} radius Radius of the circle.
   */
  constructor(x, y, radius) {
    super();

    /** 
     * @private 
     * @type {black-engine~Circle} */
    this.mCircle = new Circle(x, y, radius);  // local to sprite

    /**
     * Local to rigid body center.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mLocalCenter = new Vector();

    /**
     * Local to rigid body min x and y vertex.
     * @private 
     * @type {black-engine~Vector} */
    this.mLocalMin = new Vector();

    /**
     * Local to rigid body max x and y vertex 
     * @private 
     * @type {black-engine~Vector}
     */
    this.mLocalMax = new Vector();

    /**
     * Global in stage coordinates radius 
     * @private 
     * @type {number}
     */
    this.mRadius = 0;

    this.set(x, y, radius);
  }

  /**
   * Updates this collider with a new given values.
   *
   * @public
   * @param {number} x      Center coordinate within X-axis.
   * @param {number} y      Center coordinate within Y-axis.
   * @param {number} radius Radius of the circle.
   * @returns {black-engine~CircleCollider}
   */
  set(x, y, radius) {
    this.mCircle.set(x, y, radius);
    this.mChanged = true;
    return this;
  }

  /**
   * @inheritDoc
   */
  refresh(transform, position) {
    const localMin = this.mLocalMin;
    const localMax = this.mLocalMax;
    const min = this.mMin;
    const max = this.mMax;
    const localCenter = this.mLocalCenter;
    const center = this.mCenter;

    if (this.mChanged) {
      const circle = this.mCircle;
      const scale = Math.sqrt(transform.data[0] * transform.data[0] + transform.data[1] * transform.data[1]);
      const radius = circle.r * scale;

      transform.transformXY(circle.x, circle.y, localCenter);
      this.mRadius = radius;

      localMin.x = localCenter.x - radius;
      localMin.y = localCenter.y - radius;
      localMax.x = localCenter.x + radius;
      localMax.y = localCenter.y + radius;
    }

    min.x = localMin.x + position.x;
    min.y = localMin.y + position.y;
    max.x = localMax.x + position.x;
    max.y = localMax.y + position.y;

    center.x = localCenter.x + position.x;
    center.y = localCenter.y + position.y;
  }

  /**
   * Checks if given global coordinates are located within collider's area.
   *
   * @public
   * @param {black-engine~Vector} point Global coordinates.
   * @returns {boolean}
   */
  containsPoint(point) {
    if (this.gameObject === null) {
      return false;
    }

    const circle = this.mCircle;
    const vec = Vector.pool.get();
    const distance = vec.set(circle.x, circle.y).distance(point);
    Vector.pool.release(vec);

    return distance <= circle.r;
  }

  // /**
  //  * Draw this
  //  *
  //  * @public
  //  * @param {Graphics} graphics Drawing place
  //  */
  // debug(graphics) {
  //   graphics.beginPath();
  //   graphics.circle(this.mCenter.x, this.mCenter.y, this.mRadius);
  //   graphics.stroke();
  // }
}

/**
 * A texture allowing game objects to be rendered onto it.
 *
 * @cat textures
 * @extends black-engine~Texture
 */
class CanvasRenderTexture extends Texture {
  /**
   * Creates new CanvasRenderTexture instance with given size and scale.
   *
   * @param {number} width  The width of the texture in stage space.
   * @param {number} height The height of the texture in stage space.
   * @param {number} scale  The scale factor of the internal texture
   */
  constructor(width, height, scale) {
    const renderTarget = new RenderTargetCanvas(width * scale, height * scale);

    super(renderTarget.native);
    this.set(renderTarget.native, null, null, 1 / scale);

    this.renderTarget = renderTarget;
  }

  /**
   * Updates this instance with given size and scale.
   *
   * @param {number} width  The width of the texture in stage space.
   * @param {number} height The height of the texture in stage space.
   * @param {number} scale  The scale factor of the internal texture
   */
  resize(width, height, scale) {
    this.renderTarget.resize(width * scale, height * scale);
    this.set(this.renderTarget.native, null, null, 1 / scale);
  }

  __dumpToDocument() {
    let img = new Image();
    img.style.position = 'fixed';
    img.style.top = '0px';
    img.style.left = '0px';
    img.style.background = '#333';
    img.style.width = '256px';
    img.style.height = 'auto';
    //img.style.border = '1px solid crimson';
    img.src = /** @type {HTMLCanvasElement} */(this.mNative).toDataURL('image/png');
    document.body.appendChild(img);
  }
}

/**
 * A texture atlas.
 *
 * @cat textures
 * @extends black-engine~Texture
 */
class AtlasTexture extends Texture {
  constructor(nativeElement, jsonObject, scale = 1) {
    super(nativeElement, null, null, scale);

    /** 
     * @private 
     * @type {Object.<string, black-engine~Texture>} 
     */
    this.mSubTextures = {};

    this.__parseAtlasData(jsonObject, scale);
  }

  /**
   * @ignore
   * @private
   * @param {{meta: *, frames: Object}} o
   * @param {number} scale
   * @return {void}
   */
  __parseAtlasData(o, scale) {
    for (let key in o.frames) {
      const data = /** @type {Array<number>} */ (o.frames[key]);
      const region = new Rectangle(data[0], data[1], data[2], data[3]);
      const untrimmedRect = new Rectangle(data[4], data[5], data[6], data[7]);

      let registrationPoint = null;
      let slice9borders = null;

      if (data.length === 8 + 2) {
        // we got pivots
        registrationPoint = new Vector(data[8], data[9]);
      } else if (data.length === 8 + 4) {
        // we got 9 slice but no pivots
        slice9borders = new Rectangle(data[8], data[9], data[10], data[11]);
      } else if (data.length === 8 + 6) {
        // we got both pivots and 9 slice
        registrationPoint = new Vector(data[8], data[9]);
        slice9borders = new Rectangle(data[10], data[11], data[12], data[13]);
      }
      
      this.mSubTextures[key] = new Texture(this.native, region, untrimmedRect, scale, registrationPoint, slice9borders);
    }
  }

  /**
   * Returns the texture by a given name.
   *
   * @param {string} name The name of the texture to find.
   * @return {black-engine~Texture} The Texture or null if not found.
   */
  getTexture(name) {
    /** @type {Texture} */
    let t = this.mSubTextures[name];
    Debug.assertWarn(t !== undefined, `Texture '${name}' was not found`);

    return /** @type {Texture} */ (t);
  }

  /**
   * Returns array of Texture by given name or wildcard mask.
   * If `nameMask` is null then all textures will be returned.
   * This method sorts all resulting textures using neutral sort algorith.
   *
   * @param {string|null} [nameMask=null] The mask to filter by.
   * @param {Array<black-engine~Texture>|null}         outTextures If passed will be overwritten by result object.
   * @return {Array<black-engine~Texture>}             The list of found textures.
   */
  getTextures(nameMask = null, outTextures = null) {
    let out = outTextures || [];
    if (nameMask === null) {
      for (let key in this.mSubTextures)
        out.push(this.mSubTextures[key]);

      return /** @type {Array<Texture>} */ (out);
    }

    let names = [];

    // TODO: make helper wild function
    let re = new RegExp("^" + nameMask.split("*").join(".*") + "$");
    for (let key in this.mSubTextures)
      if (re.test(key))
        names.push(key);

    //names.sort(AtlasTexture.__naturalComparer);
    AtlasTexture.naturalSort(names);

    for (let i = 0; i < names.length; i++)
      out.push(this.mSubTextures[names[i]]);

    return out;
  }

  /**
   * Gets dictionary of sub textures.
   *
   * @returns {Object} The list of sub textures.
   */
  get subTextures() {
    return this.mSubTextures;
  }

  /**
   * Sorts set of data in natural order
   *
   * @ignore
   * @param {Array<Object>} dataset
   * @param {string|null} [field=null]
   */
  static naturalSort(dataset, field = null) {
    dataset.sort(AtlasTexture.__naturalComparer(field));
  }

  /**
   * @ignore
   * @private
   * @param {string|null} field
   * @param {boolean} useAbs
   * @returns {function(?, ?):number}
   */
  static __naturalComparer(field = null, useAbs = true) {
    return function (a, b) {
      const NUMBER_GROUPS = /(-?\d*\.?\d+)/g;
      let aa = String(field == null ? a : a[field]).split(NUMBER_GROUPS);
      let bb = String(field == null ? b : b[field]).split(NUMBER_GROUPS);
      let min = Math.min(aa.length, bb.length);

      for (let i = 0; i < min; i++) {
        let x = 0;
        let y = 0;

        if (useAbs) {
          x = Math.abs(parseFloat(aa[i])) || aa[i].toLowerCase();
          y = Math.abs(parseFloat(bb[i])) || bb[i].toLowerCase();
        } else {
          x = parseFloat(aa[i]) || aa[i].toLowerCase();
          y = parseFloat(bb[i]) || bb[i].toLowerCase();
        }

        if (x < y)
          return -1;
        else if (x > y)
          return 1;
      }

      return 0;
    }
  }
}

/**
 * Asset type enum.
 * @cat assets
 * @static
 * @constant
 * @enum {string}
 */
const AssetType = {
  TEXTURE              : 'texture',
  TEXTURE_ATLAS        : 'textureAtlas',
  VECTOR_TEXTURE       : 'vectorTexture',
  VECTOR_TEXTURE_ATLAS : 'vectorTextureAtlas',
  FONT                 : 'font',
  BITMAP_FONT          : 'bitmapFont',
  XML                  : 'xml',
  JSON                 : 'json',
  VECTOR_GRAPHICS      : 'vectorGraphics',
  SOUND                : 'sound',
  SOUND_ATLAS          : 'soundAtlas'
};

/**
 * Loader type enum.
 * @cat assets
 * @static
 * @constant
 * @enum {string}
 */
const LoaderType = {
  FONT_FACE : 'fontFace',
  IMAGE     : 'image',
  XHR       : 'xhr'
};

/**
 * Base class for loaders.
 *
 * @cat assets.loaders
 * @extends black-engine~MessageDispatcher
 */
class AssetLoader extends MessageDispatcher {
  /**
   * Creates new AssetLoader instance.
   * 
   * @param {string} url
   */
  constructor(url) {
    super();

    /** 
     * @protected 
     * @type {string} 
     */
    this.mUrl = url;

    /** 
     * @protected 
     * @type {*|null} 
     */
    this.mData = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsLoaded = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mNumOwners = 0;
  }

  /**
   * When overridden loads data. Should not be called directly.
   * 
   * @public
   */
  load() { }

  /**
   * When overridden aborts loading process. Should not be called directly.
   * 
   * @returns {void}
   */
  abort() {
    // more than one owner means this loader was used by two assets, eg two assets has same url.
    if (this.mNumOwners > 1)
      return;

    this.onAbort();
  }

  /**
   * @protected
   * @returns {void}
   */
  onAbort() { }

  /**
   * @protected
   */
  onLoad() {
    this.mIsLoaded = true;
    this.post(Message.COMPLETE);
  }

  /**
   * @protected
   */
  onError() {
    this.mIsLoaded = false;
    this.post(Message.ERROR);
  }

  /**
   * Returns native loaded data object associated with this loader.
   *
   * @return {*}
   */
  get data() {
    return this.mData;
  }

  get url() {
    return this.mUrl;
  }
}

var alternativeUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA5JREFUeNpiYmBgAAgwAAAMAAMjcmNcAAAAAElFTkSuQmCC';

/**
 * Responsible for loading images.
 *
 * @cat assets.loaders
 * @extends black-engine~AssetLoader
 */
class ImageAssetLoader extends AssetLoader {
  /**
   * Creates new ImageAssetLoader instance.
   * @param {string} url 
   */
  constructor(url) {
    super(url);

    /** 
     * @private 
     * @type {Image} 
     */
    this.mImageElement = new Image();
    this.mImageElement.crossOrigin = 'anonymous';
  }

  /**
   * @inheritDoc
   */
  load() {
    this.mData = this.mImageElement;
    
    this.mImageElement.onload = () => this.onLoad();
    this.mImageElement.onerror = () => this.onError();
    this.mImageElement.src = this.mUrl;
  }

  /**
   * @inheritDoc
   */
  onAbort() {
    this.mImageElement.onload = this.mImageElement.onabort = this.mImageElement.onerror = function () { };
    this.mImageElement.src = alternativeUrl;
  }
}

/**
 * XHRAssetLoader responsible for loading data via XMLHttpRequest.
 *
 * @cat assets.loaders
 * @extends black-engine~AssetLoader
 */
class XHRAssetLoader extends AssetLoader {
  constructor(url) {
    super(url);

    /** 
     * @protected 
     * @type {XMLHttpRequest} 
     */
    this.mRequest = new XMLHttpRequest();

    /** 
     * @type {string|undefined} 
     */
    this.mimeType = undefined;

    /** 
     * @type {string} 
     */
    this.responseType = '';
  }

  /**
   * @inheritDoc
   */
  load() {
    this.mRequest.open('GET', this.mUrl, true);

    if (this.responseType != '')
      this.mRequest.responseType = this.responseType;

    if (this.mRequest.overrideMimeType != undefined && this.mimeType)
      this.mRequest.overrideMimeType(this.mimeType);

    this.mRequest.onreadystatechange = () => {
      if (this.mRequest.readyState === 4) {
        if ((this.mRequest.status === 200) || ((this.mRequest.status === 0) && this.mRequest.responseText)) {
          if (this.responseType === '' || this.responseType === 'text')
            this.mData = this.mRequest.responseText;
          else
            this.mData = this.mRequest.response;

          this.onLoad();
        }
        else
          this.onError();
      }
    };

    this.mRequest.send(null);
  }

  /**
   * @inheritDoc
   */
  onAbort() {
    this.mRequest.abort();
  }
}

/**
 * Responsible for loading local or Google fonts.
 *
 * @cat assets.loaders
 * @extends black-engine~AssetLoader
 */
class FontFaceAssetLoader extends AssetLoader {
  /**
   * Creates new FontFaceAssetLoader instance.
   *
   * @param {string} name     The custom name of the font
   * @param {string} url      The path to the font
   * @param {boolean} isLocal Pass `true` if font is local otherwise Google Fonts service is used.
   */
  constructor(name, url, isLocal) {
    super(url);

    /** 
     * @private 
     * @type {string} 
     */
    this.mName = name;

    /** 
     * @private 
     * @type {string} 
     */
    this.mTestingFontName = 'Courier New';

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsLocal = isLocal;

    /** 
     * @private 
     * @type {string} 
     */
    this.mTestingString = '~ GHBDTN,.#$Mlck';

    /** 
     * @private 
     * @type {number} 
     */
    this.mCheckDelay = 50;

    /** 
     * @private 
     * @type {HTMLElement} 
     */
    this.mTestingElement = this.__getTestingElement();

    /** 
     * @private 
     * @type {black-engine~FontMetrics|null} 
     */
    this.metrics = null;

    /** 
     * @private 
     * @type {Element} 
     */
    this.mLoaderElement = this.__getLoaderElement(this.mIsLocal);
    this.mTestingElement.style.fontFamily = this.mTestingFontName;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDefaultFontWidth = this.mTestingElement.offsetWidth;
    this.mTestingElement.style.fontFamily = name + ',' + this.mTestingFontName;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTimeoutHandle = -1;
  }

  load() {
    if (this.mIsLocal)
      this.mLoaderElement.innerHTML += (`\n @font-face {font-family: ${this.mName}; src: url(${this.mUrl});}`);
    else
      this.mLoaderElement.href = this.mUrl;

    this.__checkLoadingStatus();
  }

  onAbort() {
    clearTimeout(this.mTimeoutHandle);
    this.mTestingElement.parentNode.removeChild(this.mTestingElement);
  }

  /**
   * @ignore
   * @private
   * @return {Element}
   */
  __getLoaderElement(local) {
    let loaderElement = document.createElement(local ? 'style' : 'link');
    loaderElement.type = 'text/css';
    loaderElement.media = 'all';
    loaderElement.rel = 'stylesheet';
    loaderElement.onerror = () => { this.onError(); };
    document.getElementsByTagName('head')[0].appendChild(loaderElement);
    return loaderElement;
  }

  /**
   * @ignore
   * @private
   * @return {HTMLElement}
   */
  __getTestingElement() {
    let testingElement = /** @type {HTMLElement}*/ (document.createElement('span'));
    testingElement.style.position = 'absolute';
    testingElement.style.top = '-9999px';
    testingElement.style.left = '-9999px';
    testingElement.style.visibility = 'hidden';
    testingElement.style.fontSize = '250px';
    testingElement.innerHTML = this.mTestingString;
    document.body.appendChild(testingElement);

    return testingElement;
  }

  /**
   * @private
   * @return {void}
   */
  __checkLoadingStatus() {
    if (this.mDefaultFontWidth === this.mTestingElement.offsetWidth) {
      this.mTimeoutHandle = setTimeout(this.__checkLoadingStatus.bind(this), this.mCheckDelay);
      return;
    }

    this.metrics = FontMetrics.get(this.mName);
    this.mTestingElement.parentNode.removeChild(this.mTestingElement);

    this.onLoad();
  }
}

/**
 * This is abstract class for custom assets. For example Asset can be used to load video or other data files.
 * Holds information about external assets.
 *
 * @fires Asset#error
 * @fires Asset#complete
 * 
 * @cat assets
 * @extends black-engine~MessageDispatcher
 */
class Asset extends MessageDispatcher {
  /**
   * Creates new Asset instance.
   *
   * @param  {string} name Name of asset.
   */
  constructor(type, name) {
    super();

    /** 
     * @protected 
     * @type {string} 
     */
    this.mType = type;

    /** 
     * @protected 
     * @type {string} 
     */
    this.mName = name;

    /** 
     * @protected 
     * @type {Object|null} 
     */
    this.mData = null;

    /** 
     * @protected 
     * @type {Array<black-engine~AssetLoader>} 
     */
    this.mLoaders = [];

    /** 
     * @private 
     * @type {number} 
     */
    this.mNumLoaded = 0;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsReady = false;

    /** 
     * @private 
     * @type {Array<black-engine~MessageBinding>} 
     */
    this.mBindings = [];
  }

  /**
   * Adds given loader to the list. Loader cannot be added to multiply Assets.
   * 
   * @param {black-engine~AssetLoader} loader Loader to add.
   * @returns {black-engine~AssetLoader}
   */
  addLoader(loader) {
    this.mLoaders.push(loader);

    loader.mNumOwners++;

    this.mBindings.push(loader.on(Message.COMPLETE, this.__onLoaderComplete, this));
    this.mBindings.push(loader.on(Message.ERROR, this.__onLoaderError, this));

    return loader;
  }

  /**
   * Called when AssetManager is about to request loaders for this asset.
   * @param {black-engine~LoaderFactory} factory 
   */
  onLoaderRequested(factory) { }

  /**
   * @private
   * @param {Message} m 
   * @returns {void}
   */
  __onLoaderComplete(m) {
    this.mNumLoaded++;

    if (this.mNumLoaded === this.mLoaders.length) {
      this.mBindings.forEach(x => x.off());

      this.onAllLoaded();
    }
  }

  /**
   * @private
   * @param {black-engine~Message} m 
   */
  __onLoaderError(m) {
    this.abort();

    /**
     * Posted when error occurred during loading this asset. 
     * @event Asset#error
     */
    this.post(Message.ERROR);
  }

  /**
   * @protected
   */
  onAllLoaded() { }

  /**
   * Aborts loading of this asset.
   * @public
   */
  abort() {
    this.mNumLoaded = 0;

    this.mBindings.forEach(x => x.off());

    for (let i = 0; i < this.mLoaders.length; i++) {
      const loader = this.mLoaders[i];
      loader.abort();
    }
  }

  /**
   * Protected method used to notify AssetManager about completion of loading this asset.
   * 
   * @protected
   * @param {Object=} data
   * @returns {void}
   */
  ready(data) {
    this.mData = data;
    this.mIsReady = true;

    /**
     * Posted when asset finished loading.
     * @event Asset#complete
     */
    this.post(Message.COMPLETE);
  }

  /**
   * Returns the type of this asset.
   *
   * @return {string}
   */
  get type() {
    return this.mType;
  }

  /**
   * Returns the name of this asset.
   *
   * @return {string}
   */
  get name() {
    return this.mName;
  }

  /**
   * Returns loaded data object associated with this asset.
   *
   * @return {*}
   */
  get data() {
    return this.mData;
  }

  /**
   * Returns `true` if this asset is loaded.
   *
   * @return {boolean}
   */
  get isReady() {
    return this.mIsReady;
  }

  /**
   * Returns array of loaders.
   * 
   * @returns {Array<black-engine~AssetLoader>}
   */
  get loaders() {
    return this.mLoaders;
  }
}

/**
 * Single Texture file asset class responsible for loading images file and
 * converting them into Textures.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class TextureAsset extends Asset {
  /**
   * Creates TextureAsset instance.
   *
   * @param {string} name Asset name.
   * @param {string} url  URL to load image from.
   */
  constructor(name, url) {
    super(AssetType.TEXTURE, name);

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** @type {number} */
    this.mScale = 1 / Texture.getScaleFactorFromName(url);

    /** 
     * @private 
     * @type {black-engine~ImageAssetLoader|null} 
     */
    this.mImageLoader = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mImageLoader = factory.get(LoaderType.IMAGE, this.mUrl);
    this.addLoader(this.mImageLoader);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    super.ready(new Texture(this.mImageLoader.data, null, null, this.mScale));
  }
}

/**
 * Single JSON file asset class responsible for loading json file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class JSONAsset extends Asset {
  /**
   * Creates new JSONAsset instance.
   *
   * @param {string} name The name of asset.
   * @param {string} url  URL to the json file.
   * @return {void}
   */
  constructor(name, url) {
    super(AssetType.JSON, name);

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mXHR = factory.get(LoaderType.XHR, this.mUrl);
    this.mXHR.mimeType = 'application/json';
    this.mXHR.responseType = 'json';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    super.ready(/** @type {!Object}*/(this.mXHR.data));
  }
}

/**
 * Single JSON file asset class responsible for loading json file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class XMLAsset extends Asset {
  /**
   * Creates new JSONAsset instance.
   *
   * @param {string} name The name of asset.
   * @param {string} url  URL to the json file.
   * @return {void}
   */
  constructor(name, url) {
    super(AssetType.XML, name);

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mXHR = factory.get(LoaderType.XHR, this.mUrl);
    this.mXHR.mimeType = 'text/xml';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    super.ready(new DOMParser().parseFromString(/** @type {string} */(this.mXHR.data), 'text/xml'));
  }
}

/**
 * Font file asset class responsible for loading local font files.
 *
 * Note: this class need a body to work properly.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class FontAsset extends Asset {
  /**
   * Creates new instance of FontAsset.
   *
   * @param {string} name     The custom name of the font
   * @param {string} url      The path to the font
   * @param {boolean} isLocal Pass `true` if font is local otherwise Google Fonts service is used.
   */
  constructor(name, url, isLocal) {
    super(AssetType.FONT, name);

    if (isLocal === false)
      url = 'https://fonts.googleapis.com/css?family=' + name.replace(new RegExp(' ', 'g'), '+');

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /**
     * @private
     * @type {boolean}
     */
    this.mIsLocal = isLocal;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    // We are not doing actual loading since loading is handled by browser. Just fake it.
    const loader = factory.get(LoaderType.FONT_FACE, this.mName, this.mUrl, this.mIsLocal);
    this.addLoader(loader);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    super.ready();
  }
}

/**
 * Texture Atlas asset responsible for loading Image file and corresponding Json
 * file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class AtlasTextureAsset extends Asset {
  /**
   * Creates new AtlasTextureAsset instance.
   *
   * @param {string} name     Name of the asset.
   * @param {string} imageUrl Image URL.
   * @param {string} dataUrl  Json URL.
   */
  constructor(name, imageUrl, dataUrl) {
    super(AssetType.TEXTURE_ATLAS, name);

    /**
     * @private
     * @type {string}
     */
    this.mImageUrl = imageUrl;

    /**
     * @private
     * @type {string}
     */
    this.mDataUrl = dataUrl;

    /** 
     * @private 
     * @type {number} 
     */
    this.mScale = 1 / Texture.getScaleFactorFromName(imageUrl);

    /** 
     * @private 
     * @type {black-engine~ImageAssetLoader|null} 
     */
    this.mImageLoader = null;

    /** 
     * @private 
     * @type {XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mImageLoader = factory.get(LoaderType.IMAGE, this.mImageUrl);
    this.addLoader(this.mImageLoader);

    this.mXHR = factory.get(LoaderType.XHR, this.mDataUrl);
    this.mXHR.mimeType = 'application/json';
    this.mXHR.responseType = 'json';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    super.ready(new AtlasTexture(this.mImageLoader.data, this.mXHR.data, this.mScale));
  }
}

/**
 * Bitmap Font Asset responsible for loading font image file and corresponding xml file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class BitmapFontAsset extends Asset {
  /**
   * Creates new AtlasTextureAsset instance.
   *
   * @param {string} name     Name of the asset.
   * @param {string} imageUrl Image URL.
   * @param {string} xmlUrl   XML URL.
   */
  constructor(name, imageUrl, xmlUrl) {
    super(AssetType.BITMAP_FONT, name);

    /**
     * @private
     * @type {string}
     */
    this.mImageUrl = imageUrl;

    /**
     * @private
     * @type {string}
     */
    this.mXmlUrl = xmlUrl;

    /** @type {number} */
    this.mScale = 1 / Texture.getScaleFactorFromName(imageUrl);

    /** 
     * @private 
     * @type {black-engine~ImageAssetLoader|null}
     */
    this.mImageLoader = null;

    /** 
     * @private 
     * @type {XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mImageLoader = factory.get(LoaderType.IMAGE, this.mImageUrl);
    this.addLoader(this.mImageLoader);

    this.mXHR = factory.get(LoaderType.XHR, this.mXmlUrl);
    this.mXHR.mimeType = 'text/xml';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    let xml = new DOMParser().parseFromString(/** @type {string} */(this.mXHR.data), 'text/xml');
    let texture = new Texture(this.mImageLoader.data, null, null, this.mScale);

    super.ready(BitmapFontAsset.parse(xml, texture));
  }

  /**
   *
   * @param {Document} xml
   * @param {black-engine~Texture} texture
   * @returns {black-engine~BitmapFontData}
   */
  static parse(xml, texture) {
    let data = new BitmapFontData();
    data.texture = texture;
    data.xml = xml;

    let info = xml.getElementsByTagName('info')[0];
    let common = xml.getElementsByTagName('common')[0];

    data.name = info.getAttribute('face');
    data.size = parseInt(info.getAttribute('size'), 10);
    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
    data.baseline = parseInt(common.getAttribute('base'), 10);
    data.chars = {};

    let letters = xml.getElementsByTagName('char');

    for (let i = 0; i < letters.length; i++) {
      let letter = letters[i];
      let charCode = parseInt(letter.getAttribute('id'), 10);
      let x = parseInt(letter.getAttribute('x'), 10) + texture.region.x;
      let y = parseInt(letter.getAttribute('y'), 10) + texture.region.y;
      let w = parseInt(letter.getAttribute('width'), 10);
      let h = parseInt(letter.getAttribute('height'), 10);
      let xo = parseInt(letter.getAttribute('xoffset'), 10);
      let yo = parseInt(letter.getAttribute('yoffset'), 10);
      let xa = parseInt(letter.getAttribute('xadvance'), 10);
      let textureRect = new Rectangle(x, y, w, h);

      let charData = new BitmapFontCharData();
      charData.texture = new Texture(texture.native, textureRect);
      charData.xOffset = xo;
      charData.yOffset = yo;
      charData.width = w;
      charData.height = h;
      charData.xAdvance = xa;

      data.chars[charCode] = charData;
    }

    let kernings = xml.getElementsByTagName('kerning');

    for (let i = 0; i < kernings.length; i++) {
      let kerning = kernings[i];
      let first = parseInt(kerning.getAttribute('first'), 10);
      let second = parseInt(kerning.getAttribute('second'), 10);
      let amount = parseInt(kerning.getAttribute('amount'), 10);

      if (data.chars[second])
        data.chars[second].kerning[first] = amount;
    }

    return data;
  }
}

class BitmapFontData {
  constructor() {
    /** @type {Texture} */
    this.texture = null;

    /** @type {Document} */
    this.xml = null;

    /** @type {string} */
    this.name = '';

    /** @type {number} */
    this.size = 0;

    /** @type {number} */
    this.lineHeight = 0;

    /** @type {Object.<number, BitmapFontCharData>} */
    this.chars = {};

    /** @type {number} */
    this.baseline = 0;
  }
}

class BitmapFontCharData {
  constructor() {
    /** @type {Texture} */
    this.texture = null;

    /** @type {number} */
    this.xOffset = 0;

    /** @type {number} */
    this.yOffset = 0;

    /** @type {number} */
    this.width = 0;

    /** @type {number} */
    this.height = 0;

    /** @type {number} */
    this.xAdvance = 0;

    /** @type {Object.<number, number>} */
    this.kerning = {};
  }
}

/**
 * Sound states.
 * @ignore
 * @constant
 * @cat audio
 * @enum {string}
 */
const SoundState = {
  NEWBORN: 'newborn',
  PLAYING: 'playing',
  PAUSED: 'paused',
  STOPPED: 'stopped',
  COMPLETED: 'completed'
};

/**
 * The sound effect interface. Implementations can be attached to sound channel.
 * 
 * @cat audio
 */
class SoundEffect {

  /**
   * Creates new instance of SoundEffect.
   */
  constructor() {
    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mInputNode = null;

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mOutputNode = null;
  }

  /**
   * @ignore
   * @return {AudioNode}
   */
  get _inputNode() {
    Debug.assert(this.mInputNode != null, 'Input node must be specified in descendant class');
    return this.mInputNode;
  }

  /**
   * @ignore
   * @return {AudioNode}
   */
  get _outputNode() {
    Debug.assert(this.mOutputNode != null, 'Output node must be specified in descendant class');
    return this.mOutputNode;
  }
}

/**
 * Allows to distribute sound between left and right channel.
 * 
 * @cat audio.effects
 * @extends {black-engine~SoundEffect}
 */
class StereoPanner extends SoundEffect {
  /**
   * Creates new instance of StereoPan.
   */
  constructor() {
    super();

    /** 
     * @private 
     * @type {GainNode} 
     */
    this.mGainL = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {GainNode} 
     */
    this.mGainR = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {ChannelSplitterNode} 
     */
    this.mSplitter = Black.audio.context.createChannelSplitter(2);
    
    /** 
     * @private 
     * @type {ChannelMergerNode} 
     */
    this.mMerger = Black.audio.context.createChannelMerger(2);

    this.mSplitter.connect(this.mGainL, 0);
    this.mSplitter.connect(this.mGainR, 1);
    this.mGainL.connect(this.mMerger, 0, 0);
    this.mGainR.connect(this.mMerger, 0, 1);

    /** 
     * @private 
     * @type {number} 
     */
    this.mValue = 0;

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mInputNode = this.mSplitter;

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mOutputNode = this.mMerger;
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set pan(value) {
    this.mValue = MathEx.clamp(value, -1, 1);
    this.mGainL.gain.setValueAtTime(1 - MathEx.clamp(this.mValue, 0, 1), 0);
    this.mGainR.gain.setValueAtTime(1 + MathEx.clamp(this.mValue, -1, 0), 0);
  }

  /**
   * Sets/Gets stereo panning value
   * 
   * @public
   * @returns {number}
   */
  get pan() {
    return this.mValue;
  }
}

/**
 * @ignore
 * @private
 */
let ID$2 = 0;

/**
 * The sound
 * 
 * @cat audio
 * @extends {black-engine~MessageDispatcher}
 */
class SoundInstance extends MessageDispatcher {
  /**
   * Creates instance
   * @param {black-engine~SoundClip} sound `SoundClip` instance taken from `AssetManager`.
   */
  constructor(sound) {
    super();

    /** 
     * @private 
     * @type {number} 
     */
    this.mId = ++ID$2;

    /** 
     * @private 
     * @type {black-engine~SoundClip} 
     */
    this.mSound = sound;

    /** 
     * @private 
     * @type {black-engine~SoundState} 
     */
    this.mState = SoundState.NEWBORN;

    /** 
     * @private 
     * @type {string} 
     */
    this.mChannel = 'master';

    /** 
     * @private 
     * @type {number} 
     */
    this.mVolume = 1;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mLoop = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStartTime = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mPausePosition = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStopPosition = 0;

    /** 
     * @private 
     * @type {AudioBufferSourceNode} 
     */
    this.mSrc = null;

    /** 
     * @private 
     * @type {GainNode} 
     */
    this.mGainNode = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {AudioNode} The node to connect audio source 
     */
    this.mFirstNode = this.mGainNode;

    /** 
     * @private 
     * @type {AudioNode} The node the source is connected to 
     */
    this.mPlayNode = null;

    /** 
     * @private 
     * @type {PannerNode} 
     */
    this.mSpatialPanner = null;

    /** 
     * @private 
     * @type {StereoPanner} 
     */
    this.mStereoPanner = null;

    /** 
     * @private 
     * @type {AnalyserNode} 
     */
    this.mAnalyser = null;
  }

  /**
   * Enables spatial effect if not enabled previously.
   * 
   * @public
   * @returns {PannerNode}
   */
  enableSpacePan() {
    if (this.mSpatialPanner == null) {
      this.mSpatialPanner = Black.audio.context.createPanner();
      if (this.mFirstNode) {
        this.mSpatialPanner.connect(this.mFirstNode);
        this.mFirstNode = this.mSpatialPanner;
      }
      this.__reconnectSource();
    }
    return this.mSpatialPanner;
  }

  /**
   * Enables stereo panning effect if not enabled previously.
   * 
   * @public
   * @returns {StereoPanner}
   */
  enableStereoPan() {
    if (this.mStereoPanner == null) {
      this.mStereoPanner = new StereoPanner();
      if (this.mFirstNode) {
        this.mStereoPanner._outputNode.connect(this.mFirstNode);
        this.mFirstNode = this.mStereoPanner._inputNode;
      }
      this.__reconnectSource();
    }
    return this.mStereoPanner;
  }

  /**
   * Enables analyser node if not enabled previously.
   * 
   * @public
   * @returns {AnalyserNode}
   */
  enableAnalyser() {
    if (this.mAnalyser == null) {
      this.mAnalyser = Black.audio.context.createAnalyser();
      if (this.mFirstNode) {
        this.mAnalyser.connect(this.mFirstNode);
        this.mFirstNode = this.mAnalyser;
      }
      this.__reconnectSource();
    }
    return this.mAnalyser;
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __reconnectSource() {
    if (this.mSrc != null && this.mPlayNode != null && this.mFirstNode != null) {
      this.mSrc.disconnect(this.mPlayNode);
      this.mSrc.connect(this.mFirstNode);
      this.mPlayNode = this.mFirstNode;
    }
  }

  /**
   * @ignore
   * @returns {black-engine~SoundInstance}
   */
  _play() {
    if (this.mState === SoundState.PLAYING)
      return this;

    this.mState = SoundState.PLAYING;

    let duration = this.mSound.isSubClip && !this.mLoop ? this.mSound.duration - this.mPausePosition : undefined;
    this.mGainNode.gain.setValueAtTime(this.mVolume, 0);

    let src = Black.audio.context.createBufferSource();
    src.buffer = this.mSound.native;
    src.loop = this.mLoop;
    src.onended = () => this.__onComplete();
    this.mFirstNode && src.connect(this.mFirstNode);
    this.mPlayNode = this.mFirstNode;
    this.mStartTime = Black.audio.context.currentTime - this.mPausePosition;

    if (this.mLoop && this.mSound.isSubClip) {
      src.loopStart = this.mSound.offset;
      src.loopEnd = this.mSound.offset + this.mSound.duration;
    }

    src.start(Black.audio.context.currentTime, this.mSound.offset + this.mPausePosition, duration);
    Black.audio._resolveChannel(this);
    this.mSrc = src;

    return this;
  }

  /**
   * Stops playing.
   * 
   * @public
   * @param {number=} [duration=0] Time offset in seconds specifying when the sound will completely stop.
   * @returns {void}
   */
  stop(duration = 0) {
    if (this.mState === SoundState.PLAYING) {
      this.mStopPosition = this.currentPosition;

      this.mGainNode.gain.cancelScheduledValues(0);
      this.mSrc.stop(Black.audio.context.currentTime + duration);

      this.mState = SoundState.STOPPED;
    }
  }

  /**
   * Pauses current sound.
   * 
   * @public
   * @returns {void}
   */
  pause() {
    if (this.mState === SoundState.PLAYING) {
      this.mPausePosition = this.currentPosition;
      this.stop();
      
      this.mState = SoundState.PAUSED;
    }
  }

  /**
   * Resumes current sound, if it has been paused.
   * 
   * @public
   * @returns {void}
   */
  resume() {
    if (this.mState === SoundState.PAUSED)
      this._play();
  }

  /**
   * Changes the volume of sound in given time.
   * 
   * @param {number} from            Initial volume level.
   * @param {number} to              Target volume level.
   * @param {number=} [duration=0]   In seconds. If '0' changes the volume instantly.
   * @param {string} [type='linear'] Possible types: 'linear', 'exp'.
   */
  fade(from, to, duration = 0, type = 'linear') {
    if (duration <= 0) {
      this.mGainNode.gain.setValueAtTime(to, 0);
    } else {
      this.mGainNode.gain.setValueAtTime(from, 0);
      if (type === 'exp')
        this.mGainNode.gain.exponentialRampToValueAtTime(Math.max(to, 0.01), Black.audio.context.currentTime + duration);
      else
        this.mGainNode.gain.linearRampToValueAtTime(to, Black.audio.context.currentTime + duration);
    }
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __onComplete() {
    this.mSrc = null;

    if (this.mState !== SoundState.PAUSED) {
      this.mStartTime = 0;
      this.mState = SoundState.COMPLETED;
      this.post(Message.COMPLETE);
    }
  }

  /**
   * Gets current position of sound in seconds.
   * 
   * @public
   * @readonly
   * @returns {number}
   */
  get currentPosition() {
    switch (this.mState) {
      case SoundState.PLAYING:
        return (Black.audio.context.currentTime - this.mStartTime) % (this.mSound.duration + 0.01);
      case SoundState.PAUSED:
        return this.mPausePosition;
      case SoundState.COMPLETED:
        return this.mSound.duration;
      case SoundState.STOPPED:
        return this.mStopPosition;
    }
    
    return 0;
  }

  /**
   * @ignore
   * @readonly
   * @returns {AudioNode}
   */
  get _outputNode() {
    return this.mGainNode;
  }

  /**
   * Gets/Sets current channel to play by name.
   * 
   * @public
   * @returns {string}
   */
  get channel() {
    return this.mChannel;
  }

  /**
   * @public
   * @param {string} value
   * @returns {void}
   */
  set channel(value) {
    if (this.mChannel === value)
      return;
    this.mChannel = value;
    if (this.mState === SoundState.PLAYING) {
      Black.audio._resolveChannel(this);
    }
  }

  /**
   * Gets/Sets sound volume. Ranging from 0 to 1.
   * 
   * @public
   * @returns {number}
   */
  get volume() {
    return this.mVolume;
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set volume(value) {
    this.mVolume = value;
    this.mGainNode.gain.setValueAtTime(this.mVolume, 0);
  }

  /**
   * Gets/Sets whether the sound will be looped.
   * 
   * @public
   * @returns {boolean}
   */
  get loop() {
    return this.mLoop;
  }

  /**
   * @public
   * @param {boolean} value
   * @returns {void}
   */
  set loop(value) {
    this.mLoop = value;
  }

  /**
   * Gets/Sets pan stereo effect. Ranging from -1 (left) to 1 (right).
   * 
   * @public
   * @returns {number}
   */
  get pan() {
    return this.mStereoPanner.pan;
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set pan(value) {
    if (value !== 0 && this.mStereoPanner == null)
      this.enableStereoPan();

    if (this.mStereoPanner)
      this.mStereoPanner.pan = value;
  }

  /**
   * Gets whether sound is playing.
   * 
   * @public
   * @readonly
   * @returns {boolean}
   */
  get isPlaying() {
    return this.mState === SoundState.PLAYING;
  }

  /**
   * Gets total duration of sound clip.
   * 
   * @public
   * @readonly
   * @returns {number}
   */
  get duration() {
    return this.mSound.duration;
  }
}

/**
 * Sound channel
 * 
 * @cat audio
 */
class SoundChannel {
  /**
   * Creates instance of SoundChannel with specific name
   * 
   * @param {string} name The name of the channel.
   */
  constructor(name) {

    /** 
     * @private 
     * @type {string} 
     */
    this.mName = name;

    /** 
     * @private 
     * @type {!GainNode} 
     */
    this.mGain = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {Array<black-engine~SoundInstance>} 
     */
    this.mSounds = [];

    /** 
     * @private 
     * @type {Array<black-engine~SoundEffect>} 
     */
    this.mEffects = [];
  }

  /**
   * Allows the sound to be played on this channel
   * 
   * @public
   * @param {black-engine~SoundInstance} soundInstance Concrete SoundInstance.
   * @returns {void}
   */
  attachSound(soundInstance) {
    Debug.assert(soundInstance != null, 'Sound cannot be null');

    soundInstance._outputNode.connect(this._inputNode);
    this.mSounds.push(soundInstance);

    soundInstance.on(Message.COMPLETE, () => {
      this.mSounds.splice(this.mSounds.indexOf(soundInstance), 1);
      soundInstance._outputNode.disconnect(0);
    });
  }

  /**
   * Removes given sound instance from this channel
   * 
   * @public
   * @param {black-engine~SoundInstance} soundInstance Concrete SoundInstance.
   * @returns {void}
   */
  detachSound(soundInstance) {
    Debug.assert(soundInstance != null, 'Sound cannot be null');

    let ix = this.mSounds.indexOf(soundInstance);
    if (ix > -1) {
      this.mSounds.splice(ix, 1);
      soundInstance._outputNode.disconnect(0);
    }
  }

  /**
   * Stops all sounds on this channel
   * 
   * @public
   * @returns {void}
   */
  stopAll() {
    for (let snd = this.mSounds[0]; this.mSounds.length; snd = this.mSounds.shift()) {
      snd.stop();
    }
  }

  /**
   * Pauses all sounds on this channel.
   * 
   * @public
   * @returns {void}
   */
  pauseAll() {
    for (let i = 0; i < this.mSounds.length; i++)
      this.mSounds[i].pause();
  }

  /**
   * Resumes all paused sounds on this channel.
   * 
   * @public
   * @returns {void}
   */
  resumeAll() {
    for (let i = 0; i < this.mSounds.length; i++)
      this.mSounds[i].resume();
  }

  /**
   * Adds sound effect to this channel
   * 
   * @public
   * @param {black-engine~SoundEffect} effect SoundEffect instance.
   * @returns {black-engine~SoundEffect}
   */
  addEffect(effect) {
    Debug.assert(effect != null, 'Effect cannot be null');

    effect._outputNode.connect(this._inputNode);
    this.mEffects.unshift(effect);
    this.__reconnectSounds();
    return effect;
  }

  /**
   * Removes sound effect from this channel
   * 
   * @public
   * @param {black-engine~SoundEffect} effect SoundEffect instance.
   * @returns {black-engine~SoundEffect}
   */
  removeEffect(effect) {
    Debug.assert(effect != null, 'Effect cannot be null');

    effect._outputNode.disconnect(0);
    this.mEffects.splice(this.mEffects.indexOf(effect), 1);
    this.__reconnectSounds();
    return effect;
  }

  /**
   * Removes all sound effect from this channel
   * 
   * @public
   * @returns {void}
   */
  removeAllEffects() {
    for (; this.mEffects.length; this.mEffects.shift()) {
      this.mEffects[0]._outputNode.disconnect(0);
    }
    this.__reconnectSounds();
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __reconnectSounds() {
    this.mSounds.forEach(x => {
      x._outputNode.disconnect(0);
      x._outputNode.connect(this._inputNode);
    });
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set volume(value) {
    this.mGain.gain.setValueAtTime(value, 0);
  }

  /**
   * Gets/Sets the volume for this channel
   * 
   * @public
   * @returns {number}
   */
  get volume() {
    return this.mGain.gain.value;
  }

  /**
   * @ignore
   * @readonly
   * @returns {!AudioNode}
   */
  get _inputNode() {
    return this.mEffects.length ? /** @type {!AudioNode} */ (this.mEffects[0]._inputNode) : this.mGain;
  }

  /**
   * @ignore
   * @readonly
   * @returns {!AudioNode}
   */
  get _outputNode() {
    return this.mGain;
  }
}

/**
 * The main class, which is responsible for audio support.
 * 
 * @cat audio
 * @extends {black-engine~System}
 */
class MasterAudio extends System {
  /**
   * Singleton
   */
  constructor() {
    super();

    Black.audio = this;

    /** 
     * @private 
     * @type {AudioContext|null} 
     */
    this.mContext = null;

    /** 
     * @private 
     * @type {black-engine~SoundListener|null} 
     */
    this.mCurrentListener = null;

    /** 
     * @private 
     * @type {Object<string, black-engine~SoundChannel>} 
     */
    this.mChannels = {};

    /** 
     * @private 
     * @type {black-engine~SoundChannel|null} 
     */
    this.mMasterChannel = null;

    /**
     * @private
     * @type {boolean}
     */
    this.mIsPendingResume = false;

    /**
     * @private
     * @type {number}
     */
    this.mPendingResume = 0;

    /**
     * @private
     * @type {number}
     */
    this.mResumeTimeout = 0.1;

    this.__initialize();
  }

  /**
   * @inheritDoc
   */
  onPause() {
    if (this.mContext === null)
      return;

    if (this.mContext.state === 'running')
      this.mContext.suspend();

    this.mIsPendingResume = false;
  }

  /**
   * @inheritDoc
   */
  onResume() {
    this.mPendingResume = this.mResumeTimeout;
    this.mIsPendingResume = true;
  }

  onUpdate() {
    if (this.mIsPendingResume)
      this.mPendingResume -= Black.time.delta;
    else
      return;

    if (this.mPendingResume <= 0) {
      if (this.mContext === null)
        return;

      if (this.mContext.state === 'suspended' || this.mContext.state === 'interrupted') {
        this.mContext.resume();
        this.mIsPendingResume = false;
      }
    }
  }

  /**
   * @ignore
   */
  __initialize() {
    try {
      this.mContext = new (window['AudioContext'] || window['webkitAudioContext'])();
    } catch (error) {
      if (this.mContext == null) {
        Debug.warn('no audio support');
        return;
      }
    }

    this.__unlock();

    this.mMasterChannel = new SoundChannel('master');

    this.mMasterChannel._outputNode.connect(this.mContext.destination);
    this.mChannels['master'] = this.mMasterChannel;
  }

  dispose() {
    super.dispose();

    if (this.mContext !== null) {
      this.stopAll();
      this.mContext.close();
    }

    this.mIsPendingResume = false;

    Black.audio = null;
  }

  /**
   * @ignore
   * @private
   * @return {void}
   */
  __unlock() {
    let f = () => {
      let buffer = this.mContext.createBuffer(1, 1, 22050);
      let unlockSource = this.mContext.createBufferSource();
      unlockSource.buffer = buffer;
      unlockSource.connect(this.mContext.destination);

      if (unlockSource.start === undefined)
        unlockSource.noteOn(0);
      else
        unlockSource.start(0);

      if (unlockSource.context.state === 'suspended')
        unlockSource.context.resume();

      document.removeEventListener('touchstart', f);
      document.removeEventListener('click', f);
    };

    document.addEventListener('touchstart', f);
    document.addEventListener('click', f);
  }

  /**
   * Creates or returns the channel with specific name.
   * 
   * @param {string} name The name of channel to create.
   * @returns {black-engine~SoundChannel}
   */
  createChannel(name) {
    if (this.mChannels[name] == null) {
      let ch = new SoundChannel(name);
      ch._outputNode.connect(this.mMasterChannel._inputNode);
      this.mChannels[name] = ch;
    }

    return this.mChannels[name];
  }

  /**
   * Gets the channel with specific name.
   * 
   * @param {string} name The name of channel to get.
   * @returns {black-engine~SoundChannel|null}
   */
  getChannel(name) {
    return this.mChannels[name];
  }

  /**
   * @ignore
   * @param {black-engine~SoundInstance} snd 
   * @returns {black-engine~SoundChannel}
   */
  _resolveChannel(snd) {
    for (let chName in this.mChannels)
      this.mChannels[chName].detachSound(snd);

    let chName = snd.channel == '' ? 'master' : snd.channel;
    let ch = this.mChannels[chName];
    ch.attachSound(snd);

    return ch;
  }

  /**
   * Plays sound on specific channel.
   * 
   * @public
   * @param {string|black-engine~SoundAtlasClip} nameOrSound The name of sound or the instance of SoundInstance.
   * @param {string=} [channel='master']       The name of channel to play on.
   * @param {number=} [volume=1]               Volume level.
   * @param {boolean=} [loop=false]            Defines if sound will loop.
   * @param {number=} [pan=0]                  The panning of the sound, ranging from -1 (left) to 1 (right).
   * @returns {SoundInstance}                  New sound instance to be played.
   */
  play(nameOrSound, channel = 'master', volume = 1, loop = false, pan = 0) {
    Debug.assert(nameOrSound != null, `Param 'nameOrSound' cannot be null.`);

    let sound = null;
    if (nameOrSound.constructor === String)
      sound = (Black.assets.getSound( /** @type {string} */(nameOrSound)));

    return sound.play(channel, volume, loop, pan);
  }

  /**
   * Stops all sound on specific channel.
   * 
   * @public
   * @param {string|null} channelName The name of channel to stop sounds on. If empty, stops sounds on all channels.
   * @returns {void} 
   */
  stopAll(channelName = null) {
    if (channelName === null)
      for (let chName in this.mChannels)
        this.mChannels[chName].stopAll();
    else
      this.getChannel(channelName).stopAll();
  }

  /**
   * Pauses all the sounds on specific channel.
   * 
   * @public
   * @param {string|null} channelName The name of channel to pause sounds on. If empty, pauses all the sounds on all channels.
   * @returns {void}
   */
  pauseAll(channelName = null) {
    if (channelName === null)
      for (let chName in this.mChannels)
        this.mChannels[chName].pauseAll();
    else
      this.getChannel(channelName).pauseAll();
  }

  /**
   * Resumes all the sounds on specific channel.
   * 
   * @public
   * @param {string|null} channelName The name of channel to resume sounds on. If empty, resumes all the sounds on all channels.
   * @returns {void}
   */
  resumeAll(channelName = null) {
    if (channelName === null)
      for (let chName in this.mChannels)
        this.mChannels[chName].resumeAll();
    else
      this.getChannel(channelName).resumeAll();
  }

  /**
   * @param {number} value
   * @returns {void}
   */
  set masterVolume(value) {
    this.mMasterChannel.volume = value;
  }

  /**
   * Gets/Sets volume on master channel.
   * 
   * @public
   * @returns {number}
   */
  get masterVolume() {
    return this.mMasterChannel.volume;
  }

  /**
   * Gets the only instance of native AudioContext.
   * 
   * @readonly
   * @returns {AudioContext}
   */
  get context() {
    return this.mContext;
  }

  /**
   * Gets the master channel.
   * 
   * @readonly
   * @returns {black-engine~SoundChannel}
   */
  get masterChannel() {
    return this.mMasterChannel;
  }

  /**
   * @param {black-engine~SoundListener} value
   * @returns {void}
   */
  set currentListener(value) {
    this.mCurrentListener = value;
  }

  /**
   * Gets/Sets current listener for spatial sound effects.
   * 
   * @public
   * @returns {black-engine~SoundListener}
   */
  get currentListener() {
    return this.mCurrentListener;
  }

  /**
   * Gets/Sets current timeout when resuming audio context from sleep.
   * Recommended value is 100ms for iOS devices running in Safari.
   * 
   * @public
   * @returns {number}
   */
  get resumeTimeout() {
    return this.mResumeTimeout;
  }

  /**
   * @param {number} value 
   * @returns {void}
   */
  set resumeTimeout(value) {
    this.mResumeTimeout = value;
  }

  /**
   * Resets current listener to default AudioContext listener.
   * 
   * @public
   * @returns {void}
   */
  looseListener() {
    this.mContext.listener.setPosition(0, 0, 1);
    this.mCurrentListener = null;
  }

  /**
   * @ignore
   * @returns {!GainNode}
   */
  _newGainNode() {
    if (this.mContext.createGain === undefined)
      return this.mContext.createGainNode();

    return this.mContext.createGain();
  }
}

/**
 * The class which stores audio buffer and its all sounds data.
 * 
 * @cat audio
 */
class SoundClip {
  /**
   * Creates new instance of SoundClip.
   * 
   * @param {AudioBuffer} nativeBuffer     Decoded audio buffer.
   * @param {number=} [offset=0]           Determines at which position of buffer the sound will be played.
   * @param {number=} [duration=undefined] If undefined, gets duration value from native audio buffer.
   * @param {boolean=} [isSubClip=false]   Specifies whether this sound clip is part of a sound atlas.
   */
  constructor(nativeBuffer, offset = 0, duration = NaN, isSubClip = false) {

    /** 
     * @private 
     * @type {AudioBuffer} 
     */
    this.mNativeBuffer = nativeBuffer;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStartOffset = offset;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDuration = duration || nativeBuffer.duration;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsSubClip = isSubClip;
  }

  /**
   * Creates sound instance and starts to play on specific channel
   * 
   * @public
   * @param {string=} [channel='master'] The name of channel.
   * @param {number=} [volume=1]         The volume level.
   * @param {boolean=} [loop=false]      Specifies if sound will repeat infinite times.
   * @param {number=} [pan=0]            The panning value.
   * @returns {SoundInstance}            New sound instance to be played.
   */
  play(channel = 'master', volume = 1, loop = false, pan = 0) {
    let instance = new SoundInstance(this);
    instance.channel = channel;
    instance.volume = volume;
    instance.loop = loop;
    instance.pan = pan;
    return instance._play();
  }

  /**
   * Creates an array of blocks filled with average amplitude gathered in certain interval
   * 
   * @public
   * @param {number} blockNum Number of blocks to divide data to
   * @returns {Float32Array}
   */
  collectWaveData(blockNum) {
    let channels = [];
    for (let i = 0; i < this.mNativeBuffer.numberOfChannels; i++)
      channels[i] = this.mNativeBuffer.getChannelData(i);

    const playPercent = this.mDuration / this.mNativeBuffer.duration;
    const startPercent = this.mStartOffset / this.mNativeBuffer.duration;
    const startPos = ~~(channels[0].length * startPercent);
    const endPos = startPos + ~~(channels[0].length * playPercent);
    const values = new Float32Array(blockNum);
    const blockWidth = ~~(channels[0].length * playPercent / blockNum);
    let dataBlock = [];

    for (let i = startPos, c = 0; i < endPos ; i++) {
      dataBlock.push(this.__averagePeak(channels, i));

      if (dataBlock.length >= blockWidth) {
        let max = Math.max(...dataBlock);
        let min = Math.min(...dataBlock);
        values[c++] = (max + min) / 2;
        dataBlock = [];
      }
    }

    return values;
  }

  /**
   * @ignore
   * @private
   * @param {Array<Float32Array>} channels 
   * @param {number} ix 
   */
  __averagePeak(channels, ix) {
    let sum = 0;
    channels.forEach(ch => sum += Math.abs(ch[ix]));
    return sum / channels.length;
  }

  /**
   * Gets the decoded audio buffer.
   * 
   * @public
   * @readonly
   * @returns {AudioBuffer}
   */
  get native() {
    return this.mNativeBuffer;
  }

  /**
   * Gets the position in seconds, where the sound should start to play.
   * 
   * @public
   * @readonly
   * @returns {number}
   */
  get offset() {
    return this.mStartOffset;
  }

  /**
   * Gets sound clip duration.
   * 
   * @public
   * @readonly
   * @returns {number}
   */
  get duration() {
    return this.mDuration;
  }

  /**
   * Represents whether this sound clip is a part of sound atlas clip.
   * 
   * @public
   * @readonly
   * @returns {boolean}
   */
  get isSubClip() {
    return this.mIsSubClip;
  }
}

/**
 * Sound file asset class responsible for loading audio files.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class SoundAsset extends Asset {
  /**
   * Creates SoundAsset instance.
   *
   * @param {string} name Sound name.
   * @param {string} url  URL to load audio from.
   */
  constructor(name, url) {
    super(AssetType.SOUND, name);

    if (Black.device.webAudioSupported === false)
      return;

    if (Black.engine.hasSystem(MasterAudio) === false) {
      Debug.warn('[SoundAsset] Loading sound files without MasterAudio system.');
      return;
    }

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mXHR = factory.get(LoaderType.XHR, this.mUrl);
    this.mXHR.responseType = 'arraybuffer';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    let undecodedAudio = /** @type {!ArrayBuffer} */ (this.mXHR.data);
    Black.audio.context.decodeAudioData(undecodedAudio, (buffer) => {
      super.ready(new SoundClip(buffer));
    });
  }
}

/**
 * The class which stores audio buffer of sound atlas and information about sub sound clips.
 * 
 * @cat audio
 * @extends black-engine~SoundClip
 */
class SoundAtlasClip extends SoundClip {

  /**
   * Creates instance of SoundAtlas.
   * 
   * @param {AudioBuffer} nativeBuffer Decoded audio buffer.
   * @param {Object} jsonObject        Data representing sub sounds name, duration and offset.
   */
  constructor(nativeBuffer, jsonObject) {
    super(nativeBuffer);

    /** 
     * @private 
     * @type {Object<string, black-engine~SoundClip>} 
     */
    this.mClips = {};
    
    if (jsonObject !== null)
      for (let key in jsonObject['sounds'])
        this.addSubSound(key, jsonObject['sounds'][key][0], jsonObject['sounds'][key][1]);
  }

  /**
   * Dynamically sets new sub sound info bypassing json.
   * 
   * @public
   * @param {string} name     The name of the sub sound.
   * @param {number} offset   The offset is seconds, where sub sound will be start playing from.
   * @param {number} duration The duration of sub sound.
   * @returns {black-engine~SoundClip}     New instance of SoundClip.
   */
  addSubSound(name, offset = 0, duration = NaN) {
    this.mClips[name] = new SoundClip(this.native, offset, duration, true);
    return this.mClips[name];
  }

  /**
   * Removes previously added sub sound info.
   * 
   * @public
   * @param {string} name The name of the sub sound.
   * @returns {void}
   */
  removeSubSound(name) {
    delete this.mClips[name];
  }

  /**
   * Directly plays sub sound by given name on specific channel.
   * 
   * @public
   * @param {string} name                The name of the sub sound.
   * @param {string=} [channel='master'] The name of channel.
   * @param {number=} [volume=1]         The volume level.
   * @param {boolean=} [loop=false]      Specifies if sound will repeat infinite times.
   * @param {number=} [pan=0]            The panning value.
   * @returns {black-engine~SoundInstance|null}       New sound instance to be played.
   */
  playSubSound(name, channel = 'master', volume = 1, loop = false, pan = 0) {
    let clip = this.mClips[name];
    if (clip == null)
      return null;
    
    let instance = new SoundInstance(clip);
    instance.channel = channel;
    instance.volume = volume;
    instance.loop = loop;
    instance.pan = pan;
    return instance._play();
  }

  /**
   * The dictionary of sub sounds.
   *
   * @public
   * @readonly
   * @returns {Object<string, black-engine~SoundClip>}
   */
  get subSounds() {
    return this.mClips;
  }
}

/**
 * Sound file asset class responsible for loading audio atlas files.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class SoundAtlasAsset extends Asset {
  /**
   * Creates new SoundAtlasAsset instance.
   *
   * @param {string} name Sound name.
   * @param {string} soundUrl  URL to load audio atlas from.
   * @param {string} dataUrl  URL to load atlas data from.
   */
  constructor(name, soundUrl, dataUrl) {
    super(AssetType.SOUND_ATLAS, name);

    /**
     * @private
     * @type {string}
     */
    this.mSoundUrl = soundUrl;

    /**
     * @private
     * @type {string}
     */
    this.mDataUrl = dataUrl;

    if (Black.device.webAudioSupported === false)
      return;

    if (Black.engine.hasSystem(MasterAudio) === false) {
      Debug.warn('[SoundAsset] Loading sound files without MasterAudio system.');
      return;
    }

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mAudioXHR = null;

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mDataXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mAudioXHR = factory.get(LoaderType.XHR, this.mSoundUrl);
    this.mAudioXHR.responseType = 'arraybuffer';
    this.addLoader(this.mAudioXHR);

    this.mDataXHR = factory.get(LoaderType.XHR, this.mDataUrl);
    this.mDataXHR.mimeType = 'application/json';
    this.mDataXHR.responseType = 'json';
    this.addLoader(this.mDataXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    let undecodedAudio = /** @type {!ArrayBuffer} */ (this.mAudioXHR.data);
    Black.audio.context.decodeAudioData(undecodedAudio, (buffer) => {
      super.ready(new SoundAtlasClip(buffer, this.mDataXHR.data));
    });
  }
}

/**
 * Command to use in graphics
 * @cat display
 * @static
 * @constant
 * @enum {string}
 */
const GraphicsCommandType = {
  LINE_STYLE        : 'lineStyle',
  FILL_STYLE        : 'fillStyle',

  ARC               : 'arc',
  RECT              : 'rect',
  ROUNDED_RECT      : 'roundedRect',
  BEZIER_CURVE_TO   : 'bezierCurveTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEGIN_PATH        : 'beginPath',
  CLOSE_PATH        : 'closePath',
  FILL              : 'fill',
  LINE_TO           : 'lineTo',
  MOVE_TO           : 'moveTo',
  STROKE            : 'stroke',
  BOUNDS            : 'bounds',

  SHADOW_COLOR      : 'shadowColor',
  SHADOW_BLUR       : 'shadowBlur',

  LINE_DASH   : 'setLineDash',
  FILL_GRD    : 'gradientFillStyle',
  FILL_PATTERN: 'patternFillStyle',
};

/**
 * A helper class for Graphics.
 *
 * @ignore
 * @cat display
 */
class GraphicsCommand {
  /**
   * Creates new instance of GraphicsCommand
   *
   * @param {black-engine~GraphicsCommandType} type
   * @param {Array<*>} data
   */
  constructor(type, data) {
    /** 
     * @public 
     * @type {GraphicsCommandType} 
     */
    this.type = type;

    /** 
     * @public 
     * @type {Array<*>} 
     */
    this.data = data;
  }

  /**
   * Returns value at given index as a number. Used for GCC only.
   * @param {number} ix
   * @returns {number}
   */
  getNumber(ix) {
    return /** @type {!number} */ (this.data[ix]);
  }

  /**
   * Returns value at given index as a string. Used for GCC only.
   * @param {number} ix
   * @returns {string}
   */
  getString(ix) {
    return /** @type {!string} */ (this.data[ix]);
  }

  /**
   * Returns value at given index as a string. Used for GCC only.
   * @param {number} ix
   * @returns {boolean}
   */
  getBoolean(ix) {
    return /** @type {!boolean} */ (this.data[ix]);
  }

  /**
   * Returns value at given index as an object. Used for GCC only.
   * @param {number} ix
   * @returns {Object}
   */
  getObject(ix) {
    return /** @type {!Object} */ (this.data[ix]);
  }
}

/**
 * Path state holder for graphics.
 *
 * @ignore
 * @cat display
 */
class GraphicsPath {
  /**
   * Creates new instance of GraphicsPath
   */
  constructor() {
    /** @type {Recblack-engine~tangle|null} */
    this.bounds = null;

    /** @type {Array<number>} */
    this.points = [];

    /** @type {number} */
    this.maxLineWidth = 0;

    /** @type {number} */
    this.lastLineWidth = 0;

    /** @type {number} */
    this.lineMul = 0.5;
  }
}

/**
 * Joint style to use in drawing lines.
 * @cat display
 * @static
 * @constant
 * @enum {string}
 */
const JointStyle = {
  BEVEL: 'bevel',
  MITER: 'miter',
  ROUND: 'round'
};

/**
 * A base abstract class for graphics gradient fill.
 *
 * @ignore
 * @cat display
 */
class GraphicsGradient {
  /**
   * Creates new instance of GraphicsGradient
   */
  constructor() {

    /** @type {Object} */
    this.stops = {};

    /** @type {CanvasGradient|null} */
    this.native = null;
  }

  /**
   * Adds a new stop, defined by an offset and a color, to the gradient
   *
   * @param {number} offset A number between 0 and 1
   * @param {string} color A CSS <color>.
   *
   * @return {void}
   */
  addColorStop(offset, color) {
    this.stops[offset] = color;
    this.native = null;
  }
}

/**
 * Linear gradient fill style for graphics.
 *
 * @ignore
 * @cat display
 */
class GraphicsLinearGradient extends GraphicsGradient {
  /**
   * Creates new instance of GraphicsLinearGradient
   *
   * @param {number} x0 The x axis of the coordinate of the start point.
   * @param {number} y0 The y axis of the coordinate of the start point.
   * @param {number} x1 The x axis of the coordinate of the end point.
   * @param {number} y1 The y axis of the coordinate of the end point.
   */
  constructor(x0, y0, x1, y1) {
    super();

    /** @type {number} */
    this.x0 = x0;

    /** @type {number} */
    this.y0 = y0;

    /** @type {number} */
    this.x1 = x1;

    /** @type {number} */
    this.y1 = y1;

    /** @type {boolean} */
    this.isAbsolute = false;
  }

  /**
   * @inheritDoc
   */
  addColorStop(percent, color) {
    this.stops[percent] = color;
    this.native = null;
  }

  /**
   * Creates copy of this
   *
   * @return {GraphicsLinearGradient} New instance
   */
  clone() {
    const g = new GraphicsLinearGradient(this.x0, this.y0, this.x1, this.y1);
    g.isAbsolute = this.isAbsolute;

    for (let key in this.stops) {
      g.stops[key] = this.stops[key];
    }

    return g;
  }
}

/**
 * Caps style to use in drawing lines.
 * @cat display
 * @static
 * @constant
 * @enum {string}
 */
const CapsStyle = {
  NONE: 'none',
  ROUND: 'round',
  SQUARE: 'square'
};

/**
 * Structure object for graphics. Stores parsed layered data, ready for render.
 * Normally you should not work with this object, and use Graphics instead.
 *
 * @cat display
 */
class GraphicsData {
  /**
   * Creates new instance of GraphicsData
   */
  constructor() {
    /** 
     * @private 
     * @type {Array<black-engine~GraphicsData>} 
     */
    this.mNodes = [];

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.mTransform = new Matrix();

    /** 
     * @private 
     * @type {Array<black-engine~GraphicsCommand>} 
     */
    this.mCommandQueue = [];

    /** 
     * @private 
     * @type {number} 
     */
    this.mPivotX = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mPivotY = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mPosX = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mPosY = 0;

    /** 
     * @private 
     * @type {string|null} 
     */
    this.mName = null;
  }

  /**
   * Calculates trimmed local bounds.
   *
   * @protected
   * @param {Object} graphics Object to store bounds by reference.
   * @param {black-engine~Matrix} transform Matrix to transform children nodes, for internal use.
   *
   * @return {black-engine~Rectangle} Calculated local bounds.
   */
  onGetLocalBounds(graphics, transform) {
    let path = new GraphicsPath();
    let len = this.mCommandQueue.length;

    transform = transform.clone().append(this.mTransform);
    const m = transform.data;
    const scaleX = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
    const scaleY = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

    for (let i = 0; i < len; i++) {
      let cmd = this.mCommandQueue[i];

      switch (cmd.type) {
        case GraphicsCommandType.BEGIN_PATH: {
          if (path.bounds) {
            transform.transformRect(path.bounds, path.bounds);
            graphics.mLocalBounds = graphics.mLocalBounds ? graphics.mLocalBounds.union(path.bounds) : path.bounds;
          }

          path = new GraphicsPath();
          break;
        }
        case GraphicsCommandType.BOUNDS: {
          for (let k = 0; k < cmd.data.length; k += 2) {
            path.points.push(cmd.getNumber(k), cmd.getNumber(k + 1));
          }

          break;
        }
        case GraphicsCommandType.LINE_STYLE: {
          path.lastLineWidth = cmd.getNumber(0);
          let joints = cmd.getString(4);

          if (joints === JointStyle.MITER)
            path.lineMul = 1;

          break;
        }
        case GraphicsCommandType.FILL: {
          if (path.points.length !== 0) {
            let tmpBounds = Rectangle.fromPointsXY(path.points);
            path.bounds = path.bounds ? path.bounds.union(tmpBounds) : tmpBounds;
          }

          break;
        }
        case GraphicsCommandType.STROKE: {
          if (path.lastLineWidth > path.maxLineWidth)
            path.maxLineWidth = path.lastLineWidth;

          if (path.maxLineWidth === 0)
            path.maxLineWidth = 1;

          path.maxLineWidth *= path.lineMul;

          if (path.points.length !== 0) {
            let tmpBounds = Rectangle.fromPointsXY(path.points);

            if (path.points.length > 1)
              tmpBounds.inflate(path.maxLineWidth * scaleX, path.maxLineWidth * scaleY);

            path.bounds = path.bounds ? path.bounds.union(tmpBounds) : tmpBounds;
          }

          break;
        }

        default:
          break;
      }
    }

    if (path.bounds) {
      transform.transformRect(path.bounds, path.bounds);
      graphics.mLocalBounds = graphics.mLocalBounds ? graphics.mLocalBounds.union(path.bounds) : path.bounds;
    }

    for (let i = 0, l = this.mNodes.length; i < l; i++) {
      this.mNodes[i].onGetLocalBounds(graphics, transform);
    }

    return graphics.mLocalBounds;
  }

  /**
   * Sets line style. Zero or less values of `lineWidth` are ignored.
   *
   * @public
   * @param {number} lineWidth Line width.
   * @param {number=} [color=0] Line color.
   * @param {number=} [alpha=1] Line alpha.
   * @param {black-engine~CapsStyle=} [caps=CapsStyle.NONE] Line caps style.
   * @param {black-engine~JointStyle=} [joints=JointStyle.MITER] Line joints style.
   * @param {number=} [miterLimit=3] Miter limit.
   * @returns {void}
   */
  lineStyle(lineWidth = 0, color = 0, alpha = 1, caps = CapsStyle.NONE, joints = JointStyle.MITER, miterLimit = 3) {
    Debug.isNumber(lineWidth, color, alpha, miterLimit);
    if (lineWidth <= 0)
      return;

    this.__pushCommand(GraphicsCommandType.LINE_STYLE, lineWidth, color, alpha, caps, joints, miterLimit);
  }

  /**
   * Sets shadow blur level.
   * 
   * @param {number} level 
   * @returns {void}
   */
  shadowBlur(level) {
    Debug.isNumber(level);

    this.__pushCommand(GraphicsCommandType.SHADOW_BLUR, level);
  }

  /**
   * Sets shadow color.
   * 
   * @param {number} color 
   * @param {number} alpha 
   * @returns {void}
   */
  shadowColor(color, alpha) {
    Debug.isNumber(color, alpha);

    this.__pushCommand(GraphicsCommandType.SHADOW_COLOR, color, alpha);
  }
  
  /**
   * Sets fill style
   *
   * @public
   * @param {number} [color=0] Fill color.
   * @param {number=} [alpha=1] Fill alpha.
   * @returns {void}
   */
  fillStyle(color = 0, alpha = 1) {
    Debug.isNumber(color, alpha);
    this.__pushCommand(GraphicsCommandType.FILL_STYLE, color, alpha);
  }

  /**
   * Sets fill style to gradient.
   *
   * @public
   * @param {black-engine~GraphicsGradient} gradient Fill gradient.
   *
   * @returns {void}
   */
  fillGradient(gradient) {
    if (gradient instanceof GraphicsLinearGradient) {
      this.__pushCommand(GraphicsCommandType.FILL_GRD, /** @type {GraphicsLinearGradient} */(gradient));
    } // radial todo
  }

  /**
   * Sets fill style to pattern.
   *
   * @public
   * @param {black-engine~GraphicsPattern} pattern Fill pattern.
   *
   * @returns {void}
   */
  fillPattern(pattern) {
    this.__pushCommand(GraphicsCommandType.FILL_PATTERN, pattern);
  }

  /**
   * Clears the graphics that were drawn and resets fill and line styles.
   *
   * @public
   * @returns {void}
   */
  clear() {
    this.mPosX = 0;
    this.mPosY = 0;

    this.mCommandQueue = [];
    this.mNodes = [];

    this.beginPath();
  }

  /**
   * Moves the starting point of a path to given x and y coordinates.
   *
   * @public
   * @param {number} x The x-axis of the point.
   * @param {number} y The y-axis of the point.
   * @returns {void}
   */
  moveTo(x, y) {
    this.mPosX = x;
    this.mPosY = y;
    this.__pushCommand(GraphicsCommandType.MOVE_TO, x, y);
  }

  /**
   * Draws a line between last point and given.
   *
   * @public
   * @param {number} x The x-axis of the point.
   * @param {number} y The y-axis of the point.
   * @returns {void}
   */
  lineTo(x, y) {
    this.mPosX = x;
    this.mPosY = y;

    this.__pushCommand(GraphicsCommandType.LINE_TO, x, y);
    this.__pushCommand(GraphicsCommandType.BOUNDS, this.mPosX, this.mPosY, x, y);
  }

  /**
   * Adds an arc to the current path.
   *
   * @public
   * @param {number} x             The x-axis of the arc's center.
   * @param {number} y             The y-axis of the arc's center.
   * @param {number} radius        The radius of the arc.
   * @param {number} startAngle    The starting angle in radians.
   * @param {number} endAngle      The ending angle in radians.
   * @param {boolean=} [anticlockwise=false] If true the arc will be drawn counter-clockwise.
   * @returns {void}
   */
  arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {
    let needsMoveTo = false;
    let moveToX = 0;
    let moveToY = 0;
    let points = [];
    let diff = Math.abs(startAngle - endAngle);

    if (startAngle === endAngle)
      return;

    if (diff >= MathEx.PI2) {
      points.push(x - radius, y - radius, x + radius, y + radius);

      let end = Circle.getCircumferencePoint(x, y, radius, endAngle + Math.PI * 0.5);

      needsMoveTo = true;
      endAngle = startAngle + MathEx.PI2;
      moveToX = end.x;
      moveToY = end.y;
    } else {
      let start = startAngle % MathEx.PI2 + (startAngle < 0 ? MathEx.PI2 : 0);
      let end = endAngle;

      if (anticlockwise) {
        end = start;
        start = endAngle;
      }

      while (end < start)
        end += MathEx.PI2;

      const right = start === 0 || end >= MathEx.PI2;
      const left = start <= Math.PI && end >= Math.PI || end >= Math.PI * 3;
      const bottom = start <= Math.PI * 0.5 && end >= Math.PI * 0.5 || end >= Math.PI * 2.5;
      const top = start <= Math.PI * 1.5 && end >= Math.PI * 1.5 || end >= Math.PI * 3.5;

      let startCos, endCos, startSin, endSin;

      if (!left || !right) {
        startCos = Math.cos(start) * radius;
        endCos = Math.cos(end) * radius;
      }

      if (!top || !bottom) {
        startSin = Math.sin(start) * radius;
        endSin = Math.sin(end) * radius;
      }

      const minX = left ? -radius : Math.min(startCos, endCos);
      const maxX = right ? radius : Math.max(startCos, endCos);
      const minY = top ? -radius : Math.min(startSin, endSin);
      const maxY = bottom ? radius : Math.max(startSin, endSin);

      points.push(minX + x, minY + y, maxX + x, maxY + y);
    }

    this.__pushCommand(GraphicsCommandType.ARC, x, y, radius, startAngle, endAngle, anticlockwise);
    this.__pushCommand(GraphicsCommandType.BOUNDS, ...points);

    if (needsMoveTo === true)
      this.__pushCommand(GraphicsCommandType.MOVE_TO, moveToX, moveToY);
  }

  /**
   * Adds circle to current path.
   *
   * @public
   * @param {number} x      The x-axis of the circle's center.
   * @param {number} y      The y-axis of the circle's center.
   * @param {number} radius The radius of the circle.
   * @returns {void}
   */
  circle(x, y, radius) {
    this.__pushCommand(GraphicsCommandType.ARC, x, y, radius, 0, MathEx.PI2);
    this.__pushCommand(GraphicsCommandType.BOUNDS, x - radius, y - radius, x + radius, y + radius);
  }

  /**
   * Creates closed rectangle like path.
   *
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   *
   * @returns {void}
   */
  rect(x, y, width, height) {
    Debug.isNumber(x, y, width, height);

    this.__pushCommand(GraphicsCommandType.RECT, x, y, width, height);
    this.__pushCommand(GraphicsCommandType.BOUNDS, x, y, x + width, y + height);
  }

  /**
   * Creates closed rounded rectangle.
   *
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} radius
   *
   * @returns {void}
   */
  roundedRect(x, y, width, height, radius) {
    Debug.isNumber(x, y, width, height, radius);

    this.__pushCommand(GraphicsCommandType.ROUNDED_RECT, x, y, width, height, radius);
    this.__pushCommand(GraphicsCommandType.BOUNDS, x, y, x + width, y + height);
  }

  /**
   * @public
   * @param {number} cp1x
   * @param {number} cp1y
   * @param {number} cp2x
   * @param {number} cp2y
   * @param {number} x
   * @param {number} y
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    const rangeX = this.__bezierRange(this.mPosX, cp1x, cp2x, x, Vector.pool.get());
    const rangeY = this.__bezierRange(this.mPosY, cp1y, cp2y, y, Vector.pool.get());

    this.mPosX = x;
    this.mPosY = y;

    this.__pushCommand(GraphicsCommandType.BEZIER_CURVE_TO, cp1x, cp1y, cp2x, cp2y, x, y);
    this.__pushCommand(GraphicsCommandType.BOUNDS, rangeX.x, rangeY.x, rangeX.y, rangeY.y);

    Vector.pool.release(rangeX);
    Vector.pool.release(rangeY);
  }

  /**
   * @public
   * @param {number} cpx
   * @param {number} cpy
   * @param {number} x
   * @param {number} y
   */
  quadraticCurveTo(cpx, cpy, x, y) {
    const rangeX = this.__quadraticRange(this.mPosX, cpx, x, Vector.pool.get());
    const rangeY = this.__quadraticRange(this.mPosY, cpy, y, Vector.pool.get());

    this.mPosX = x;
    this.mPosY = y;

    this.__pushCommand(GraphicsCommandType.QUADRATIC_CURVE_TO, cpx, cpy, x, y);
    this.__pushCommand(GraphicsCommandType.BOUNDS, rangeX.x, rangeY.x, rangeX.y, rangeY.y);

    Vector.pool.release(rangeX);
    Vector.pool.release(rangeY);
  }

  /**
   * @private
   * @param {number} p0
   * @param {number} p1
   * @param {number} p2
   * @param {number} p3
   * @param {black-engine~Vector=} out
   *
   * @return {black-engine~Vector} Out vector with set x, y as min and max bezier coordinate on passed axis
   */
  __bezierRange(p0, p1, p2, p3, out) {
    out = out || new Vector();

    const a = (p2 - 2 * p1 + p0) - (p3 - 2 * p2 + p1);
    const b = 2 * (p1 - p0) - 2 * (p2 - p1);
    const c = p0 - p1;
    const discriminant = b * b - 4 * a * c;

    let min = Math.min(p0, p3);
    let max = Math.max(p0, p3);

    if (discriminant >= 0) {
      const discRoot = Math.sqrt(discriminant);
      const inv2a = 1 / (a * 2);
      let x1 = (-b + discRoot) * inv2a;
      let x2 = (-b - discRoot) * inv2a;
      x1 = isFinite(x1) ? x1 : 0.5;
      x2 = isFinite(x2) ? x2 : 0.5;

      if (x1 > 0 && x1 < 1) {
        const dot = this.__bezierDot(p0, p1, p2, p3, x1);
        min = Math.min(dot, min);
        max = Math.max(dot, max);
      }

      if (x2 > 0 && x2 < 1) {
        const dot = this.__bezierDot(p0, p1, p2, p3, x2);
        min = Math.min(dot, min);
        max = Math.max(dot, max);
      }
    }

    out.x = min;
    out.y = max;

    return out;
  }

  /**
   * @private
   * @param {number} p0
   * @param {number} p1
   * @param {number} p2
   * @param {number} p3
   * @param {number} x
   *
   * @return {number}
   */
  __bezierDot(p0, p1, p2, p3, x) {
    const y = 1 - x;
    return p0 * y * y * y + 3 * p1 * x * y * y + 3 * p2 * x * x * y + p3 * x * x * x;
  }

  /**
   * @private
   * @param {number} p0
   * @param {number} p1
   * @param {number} p2
   * @param {black-engine~Vector=} out
   *
   * @return {black-engine~Vector} Out vector with set x, y as min and max bezier coordinate on passed axis
   */
  __quadraticRange(p0, p1, p2, out) {
    const a = p2 - p0;
    const b = p1 - p0;
    const c = b / a;
    const d = p0 + (c < 0 || c > 1 ? b * b / (2 * b - a) : 0);

    out.x = Math.min(p0, p2, d);
    out.y = Math.max(p0, p2, d);

    return out;
  }

  /**
   * Starts new path.
   *
   * @public
   * @returns {void}
   */
  beginPath() {
    this.__pushCommand(GraphicsCommandType.BEGIN_PATH);
  }

  /**
   * Closes current path.
   *
   * @public
   * @returns {void}
   */
  closePath() {
    this.__pushCommand(GraphicsCommandType.CLOSE_PATH);
  }

  /**
   * Sets the line dash pattern used when stroking lines,
   * using an array of values which specify alternating lengths of lines and gaps which describe the pattern.
   *
   * @public
   * @param {Array<number>} segments An Array of numbers which specify distances to alternately draw a line and a gap (in coordinate space units).
   *
   * @returns {void}
   */
  setLineDash(segments) {
    this.__pushCommand(GraphicsCommandType.LINE_DASH, segments);
  }

  /**
   * Strokes current path with the current line style..
   *
   * @public
   * @returns {void}
   */
  stroke() {
    this.__pushCommand(GraphicsCommandType.STROKE);
  }

  /**
   * Fills current path with the current fill style.
   *
   * @public
   * @param {boolean} isNonZero The algorithm by which to determine if a point is inside a path or outside a path, True is for "nonzero" and False is for "evenodd".
   *
   * @returns {void}
   */
  fill(isNonZero) {
    this.__pushCommand(GraphicsCommandType.FILL, isNonZero);
  }

  /**
   * @private
   * @ignore
   * @param {black-engine~GraphicsCommandType} type
   * @param {...*} data
   */
  __pushCommand(type, ...data) {
    let cmd = new GraphicsCommand(type, data);
    this.mCommandQueue.push(cmd);
  }

  searchNode(name, parent = this) {
    if (parent.name === name) {
      return parent;
    }

    for (let i = 0, l = parent.mNodes.length; i < l; i++) {
      const node = this.searchNode(name, parent.mNodes[i]);

      if (node) {
        return node;
      }
    }
  }

  /**
   * Gets/Sets the name of this GraphicsData instance. Used for searching elements.
   *
   * @return {string|null}
   */
  get name() {
    return this.mName;
  }

  /**
   * @param {string|null} value
   * @return {void}
   */
  set name(value) {
    this.mName = value;
  }
}

class ParserBase {
  constructor() {
    /** 
     * Input data to parse
     * @public 
     * @type {Object}
     */
    this.data = null;
  }

  /**
   * 
   * @param {Object} data
   *
   * @return {Object} Parsed data
   */
  parse(data) {
    this.data = data;

    return null;
  }
}

/**
 * A pattern fill style class for Graphics.
 *
 * @ignore
 * @cat display
 */
class GraphicsPattern {
  /**
   * Creates new instance of GraphicsPattern
   */
  constructor(image, repetition) {

    /** @type {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} */
    this.image = image;

    /** @type {string} */
    this.repetition = repetition;

    /** @type {CanvasPattern|null} */
    this.native = null;
  }

  /**
   * Creates copy of this
   *
   * @return {black-engine~GraphicsPattern} New instance
   */
  clone() {
    return new GraphicsPattern(this.image, this.repetition);
  }
}

/**
 * Fill Rule style to use on shapes fill.
 * @cat display
 * @static
 * @constant
 * @enum {string}
 */
const FillRule = {
  NONE_ZERO: 'nonzero',
  EVEN_ODD : 'evenodd',
};

/**
 * Black Vector Graphics style
 * Helper class for BVG style parse
 *
 * @cat parsers
 */
class BVGStyle {
  /**
   * Creates new instance of BVGStyle.
   */
  constructor() {

    /**
     * Stroke color
     *
     * @private 
     * @type {string} */
    this.L = '-';

    /**
     * Stroke alpha.
     *
     * @private 
     * @type {number} */
    this.l = 1;

    /**
     * Line width.
     *
     * @private 
     * @type {number} */
    this.w = 1;

    /**
     * Fill color.
     *
     * @private 
     * @type {string}*/
    this.F = '0';

    /**
     * Fill alpha.
     *
     * @private 
     * @type {number} */
    this.f = 1;

    /**
     * Fill rule.
     * {nonzero: 1, evenodd: 0}
     *
     * @private 
     * @type {number} */
    this.r = 1;

    /**
     * Line cap.
     * {butt: 'b', round: 'r', square: 's'}
     *
     * @private 
     * @type {string} */
    this.c = 'b';

    /**
     * Line join.
     * {miter: 'm', round: 'r', bevel: 'b'}
     *
     * @private 
     * @type {string} */
    this.j = 'm';

    /**
     * Miter limit.
     *
     * @private 
     * @type {number} */
    this.m = 4;

    /**
     * Global alpha.
     *
     * @private 
     * @type {number} */
    this.a = 1;

    /**
     * Line dash.
     *
     * @private 
     * @type {string} */
    this.d = '';

    /**
     * Fill necessity flag.
     *
     * @public 
     * @type {boolean} 
     */
    this.needsFill = true;

    /**
     * Stroke necessity flag.
     *
     * @public 
     * @type {boolean} 
     */
    this.needsStroke = false;

    /** 
     * @public 
     * @type {number} 
     */
    this.fillColor = 0;

    /** 
     * @public 
     * @type {number} 
     */
    this.fillAlpha = 1;

    /** 
     * @public 
     * @type {number} 
     */
    this.lineColor = 0;

    /** 
     * @public 
     * @type {number} 
     */
    this.lineAlpha = 1;

    /** 
     * @public 
     * @type {number} 
     */
    this.lineWidth = 1;

    /** 
     * @public 
     * @type {black-engine~CapsStyle} 
     */
    this.lineCap = CapsStyle.NONE;

    /** 
     * @public 
     * @type {black-engine~JointStyle} 
     */
    this.lineJoin = JointStyle.MITER;

    /** 
     * @public 
     * @type {number} 
     */
    this.miterLimit = this.m;

    /** 
     * @public 
     * @type {black-engine~FillRule} 
     */
    this.fillRule = FillRule.NONE_ZERO;

    /**
     * Line dash segments length, unit.
     *
     * @public 
     * @type {Array<number>} 
     */
    this.lineDash = [];
  }

  /**
   * Merge parent style to this.
   *
   * @public
   * @param {black-engine~BVGStyle} style Parent style
   *
   * @returns {void}
   */
  merge(style) {
    if (style.F)
      this.F = style.F;

    if (style.L)
      this.L = style.L;

    if (style.w)
      this.w = style.w;

    if (style.l)
      this.l *= style.l;

    if (style.f)
      this.f *= style.f;

    if (style.r)
      this.r = style.r;

    if (style.c)
      this.c = style.c;

    if (style.j)
      this.j = style.j;

    if (style.m)
      this.m = style.m;

    if (style.a)
      this.a = style.a;

    if (style.d)
      this.d = style.d;
  }

  /**
   * Update readable properties to use this style.
   *
   * @public
   *
   * @returns {void}
   */
  compute() {
    this.needsFill = this.F !== '-';

    if (this.needsFill)
      this.fillColor = parseInt(this.F, 16);

    this.lineWidth = +this.w;
    this.needsStroke = this.L !== '-' && this.lineWidth > 0;

    if (this.needsStroke)
      this.lineColor = parseInt(this.L, 16);

    const alpha = Number(this.a);
    this.lineAlpha = Number(this.l) * alpha;
    this.fillAlpha = Number(this.f) * alpha;

    this.lineCap = { b: CapsStyle.NONE, r: CapsStyle.ROUND, s: CapsStyle.SQUARE }[this.c];
    this.lineJoin = { m: JointStyle.MITER, r: JointStyle.ROUND, b: JointStyle.BEVEL }[this.j];
    this.miterLimit = Number(this.m);
    this.fillRule = { 1: FillRule.NONE_ZERO, 0: FillRule.EVEN_ODD }[this.r];
    this.lineDash = this.d.split(',').map(v => Number(v));
  }

  /**
   * Create copy of this style.
   *
   * @public
   *
   * @returns {black-engine~BVGStyle} Created style.
   */
  clone() {
    let s = new BVGStyle();
    s.L = this.L;
    s.l = this.l;
    s.w = this.w;
    s.F = this.F;
    s.f = this.f;
    s.r = this.r;
    s.c = this.c;
    s.j = this.j;
    s.m = this.m;
    s.a = this.a;

    return s;
  }
}

/**
 * A basic utility class for drawing shapes.
 *
 * @cat display
 * @extends black-engine~DisplayObject
 */
class Graphics extends DisplayObject {
  /**
   * Creates new Graphics instance.
   *
   * @param {black-engine~GraphicsData|string|null} graphicsData The id of BVG object.
   * @param {boolean} trim Flag to determine the passed graphicsData needs trim.
   */
  constructor(graphicsData = null, trim = false) {
    super();

    /** 
     * @private
     * @type {black-engine~Rectangle} 
     */
    this.mBounds = new Rectangle();

    /**
     * For internal usage
     *
     * 
     * @private
     * @type {black-engine~Rectangle|null} 
     */
    this.mLocalBounds = null;

    /** 
     * @private
     * @type {black-engine~GraphicsData|null} 
     */
    this.mGraphicsData = null;

    /** 
     * @private
     * @type {number} 
     */
    this.mDataOffsetX = 0;

    /** 
     * @private
     * @type {number} 
     */
    this.mDataOffsetY = 0;

    /** 
     * @private
     * @type {boolean} 
     */
    this.mTrim = trim;

    if (graphicsData === null) {
      this.mGraphicsData = new GraphicsData();
    } else if (typeof graphicsData === 'string') {
      this.mGraphicsData = Black.assets.getGraphicsData(graphicsData);
    } else {
      this.mGraphicsData = graphicsData;
    }

    if (trim) {
      this.mGraphicsData.onGetLocalBounds(this, new Matrix());

      if (this.mLocalBounds) {
        this.mDataOffsetX = this.mLocalBounds.x;
        this.mDataOffsetY = this.mLocalBounds.y;
        this.mLocalBounds = null;
      }
    }
  }

  /**
   * @inheritDoc
   */
  getRenderer() {
    return Black.driver.getRenderer('Graphics', this);
  }

  /**
   * @inheritDoc
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    if (this.mClipRect !== null) {
      this.mClipRect.copyTo(outRect);
      return outRect;
    }

    this.mGraphicsData.onGetLocalBounds(this, new Matrix());

    this.mLocalBounds && outRect.copyFrom(this.mLocalBounds);
    this.mLocalBounds = null;

    if (!this.mTrim) {
      outRect.width += Math.max(0, outRect.x);
      outRect.height += Math.max(0, outRect.y);
      outRect.x = Math.min(0, outRect.x);
      outRect.y = Math.min(0, outRect.y);
    }

    return outRect;
  }

  /**
   * Sets line style. Zero or less values of `lineWidth` are ignored.
   *
   * @public
   * @param {number} lineWidth Line width.
   * @param {number=} [color=0] Line color.
   * @param {number=} [alpha=1] Line alpha.
   * @param {black-engine~CapsStyle=} [caps=CapsStyle.NONE] Line caps style.
   * @param {black-engine~JointStyle=} [joints=JointStyle.MITER] Line joints style.
   * @param {number=} [miterLimit=3] Miter limit.
   * @returns {void}
   */
  lineStyle(lineWidth = 0, color = 0, alpha = 1, caps = CapsStyle.NONE, joints = JointStyle.MITER, miterLimit = 3) {
    this.mGraphicsData.lineStyle(lineWidth, color, alpha, caps, joints, miterLimit);
  }

  /**
   * Sets shadow blur level.
   * 
   * @param {number} level 
   * @returns {void}
   */
  shadowBlur(level) {
    this.mGraphicsData.shadowBlur(level);
  }

  /**
   * Sets shadow color.
   * 
   * @param {number} color 
   * @param {number} alpha 
   * @returns {void}
   */
  shadowColor(color, alpha = 1) {
    this.mGraphicsData.shadowColor(color, alpha);
  }

  /**
   * Sets fill style
   *
   * @public
   * @param {number} [color=0] Fill color.
   * @param {number=} [alpha=1] Fill alpha.
   * @returns {void}
   */
  fillStyle(color = 0, alpha = 1) {
    this.mGraphicsData.fillStyle(color, alpha);
  }

  /**
   * Sets fill style to gradient.
   *
   * @public
   * @param {black-engine~GraphicsGradient} gradient Fill gradient.
   *
   * @returns {void}
   */
  fillGradient(gradient) {
    this.mGraphicsData.fillGradient(gradient);
  }

  /**
   * Sets fill style to pattern.
   *
   * @public
   * @param {black-engine~GraphicsPattern} pattern Fill pattern.
   *
   * @returns {void}
   */
  fillPattern(pattern) {
    this.mGraphicsData.fillPattern(pattern);
  }

  /**
   * Clears the graphics that were drawn and resets fill and line styles.
   *
   * @public
   * @returns {void}
   */
  clear() {
    this.mBounds.zero();
    this.mGraphicsData.clear();
    this.setTransformDirty();
  }

  /**
   * Moves the starting point of a path to given x and y coordinates.
   *
   * @public
   * @param {number} x The x-axis of the point.
   * @param {number} y The y-axis of the point.
   * @returns {void}
   */
  moveTo(x, y) {
    this.mGraphicsData.moveTo(x, y);
  }

  /**
   * Draws a line between last point and given.
   *
   * @public
   * @param {number} x The x-axis of the point.
   * @param {number} y The y-axis of the point.
   * @returns {void}
   */
  lineTo(x, y) {
    this.mGraphicsData.lineTo(x, y);
  }

  /**
   * Adds an arc to the current path.
   *
   * @public
   * @param {number} x             The x-axis of the arc's center.
   * @param {number} y             The y-axis of the arc's center.
   * @param {number} radius        The radius of the arc.
   * @param {number} startAngle    The starting angle in radians.
   * @param {number} endAngle      The ending angle in radians.
   * @param {boolean=} [anticlockwise=false] If true the arc will be drawn counter-clockwise.
   * @returns {void}
   */
  arc(x, y, radius, startAngle, endAngle, anticlockwise = false) {
    this.mGraphicsData.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }

  /**
   * Adds circle to current path.
   *
   * @public
   * @param {number} x      The x-axis of the circle's center.
   * @param {number} y      The y-axis of the circle's center.
   * @param {number} radius The radius of the circle.
   * @returns {void}
   */
  circle(x, y, radius) {
    this.mGraphicsData.circle(x, y, radius);
  }

  /**
   * Creates closed rectangle like path.
   *
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   *
   * @returns {void}
   */
  rect(x, y, width, height) {
    this.mGraphicsData.rect(x, y, width, height);
  }

  /**
   * Creates closed rounded rectangle.
   *
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} radius
   *
   * @returns {void}
   */
  roundedRect(x, y, width, height, radius) {
    this.mGraphicsData.roundedRect(x, y, width, height, radius);
  }

  /**
   * @public
   * @param {number} cp1x
   * @param {number} cp1y
   * @param {number} cp2x
   * @param {number} cp2y
   * @param {number} x
   * @param {number} y
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.mGraphicsData.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }

  /**
   * @public
   * @param {number} cpx
   * @param {number} cpy
   * @param {number} x
   * @param {number} y
   */
  quadraticCurveTo(cpx, cpy, x, y) {
    this.mGraphicsData.quadraticCurveTo(cpx, cpy, x, y);
  }

  /**
   * Starts new path.
   *
   * @public
   * @returns {void}
   */
  beginPath() {
    this.mGraphicsData.beginPath();
  }

  /**
   * Closes current path.
   *
   * @public
   * @returns {void}
   */
  closePath() {
    this.mGraphicsData.closePath();
  }

  /**
   * Sets the line dash pattern used when stroking lines,
   * using an array of values which specify alternating lengths of lines and gaps which describe the pattern.
   *
   * @public
   * @param {Array<number>} An Array of numbers which specify distances to alternately draw a line and a gap (in coordinate space units).
   *
   * @returns {void}
   */
  setLineDash(segments) {
    this.mGraphicsData.setLineDash(segments);
  }

  /**
   * Strokes current path with the current line style..
   *
   * @public
   * @returns {void}
   */
  stroke() {
    this.mGraphicsData.stroke();
    this.setTransformDirty();
  }

  /**
   * Fills current path with the current fill style.
   *
   * @public
   * @param {boolean} isNonZero The algorithm by which to determine if a point is inside a path or outside a path, True is for "nonzero" and False is for "evenodd".
   *
   * @returns {void}
   */
  fill(isNonZero = true) {
    this.mGraphicsData.fill(isNonZero);
    this.setTransformDirty();
  }

  createLinearGradient(x, y, width, height) {
    return new GraphicsLinearGradient(x, y, width, height);
  }
}

const pathCmds = {
  MOVETO: 'M',
  MOVETO_REL: 'm',
  LINETO: 'L',
  LINETO_REL: 'l',
  VLINE: 'V',
  VLINE_REL: 'v',
  HLINE: 'H',
  HLINE_REL: 'h',
  CURVE: 'C',
  CURVE_REL: 'c',
  SCURVE: 'S',
  SCURVE_REL: 's',
  QCURVE: 'Q',
  QCURVE_REL: 'q',
  SQCURVE: 'T',
  SQCURVE_REL: 't',
  ARC: 'A',
  ARC_REL: 'a',
  CLOSE_PATH: 'Z',
};

const shapeCmds = {
  RECT: 'r',
  CIRCLE: 'c',
  ELLIPSE: 'e',
  LINE: 'l',
  POLYLINE: 's',
  PATH: 'p',
  POLYGON: 'g',
  CLIPPING: 'm',
};

/**
 * Black Vector Graphics parser.
 * Creates GraphicsData for Graphics from BVG format.
 *
 * @cat parsers
 * @extends black-engine~ParserBase
 */

class BVGParser extends ParserBase {
  /**
   * Creates new instance of BVGParser
   */
  constructor() {
    super();

    /** @type {Object} */
    this._defs = {};
  }

  /**
   * @inheritDoc
   *
   * @return {black-engine~GraphicsData} Data for Graphics renderer
   */
  parse(data) {
    super.parse(data);

    const styles = this.__parseStyles(data['styles']);

    this._defs = {};
    this.__parseDefs(data['defs'], this._defs);

    return this.__traverse(data, styles, new GraphicsData(), new BVGStyle());
  }

  /**
   * Recursively goes through children nodes and builds final GraphicsData.
   *
   * @private
   * @param {Object} node BVG node.
   * @param {Array<black-engine~BVGStyle>} styles Parsed BVG styles.
   * @param {black-engine~GraphicsData} parent Parent node.
   * @param {black-engine~BVGStyle} parentStyle Style for inheritance.
   *
   * @returns {black-engine~GraphicsData} Parsed data root.
   */
  __traverse(node, styles, parent, parentStyle) {
    const defs = this._defs;
    const graphicsData = new GraphicsData();
    let style = parentStyle.clone();
    parent.mNodes.push(graphicsData);

    if (node['id'])
      graphicsData.name = node['id'];

    let t = node['t'];
    if (t) {
      const x = t[0] || 0;
      const y = t[1] || 0;
      const sx = t[2] || 1;
      const sy = t[3] || 1;
      const px = t[5] || 0;
      const py = t[6] || 0;

      graphicsData.mTransform.rotate(t[4] || 0);
      graphicsData.mTransform.scale(sx, sy);
      graphicsData.mTransform.skew(t[7] || 0, t[8] || 0);

      graphicsData.mTransform.data[4] = x + px / sx;
      graphicsData.mTransform.data[5] = y + py / sy;

      graphicsData.mPivotX = px;
      graphicsData.mPivotY = py;
    }

    if (node['cmds']) {
      const cmds = node['cmds'].split('$').filter(v => v).reverse();
      const lastRect = new Rectangle();
      let prevName = '';

      while (cmds.length > 0) {
        const cmd = cmds.pop();
        const name = cmd[0];
        const args = cmd.slice(1).split(',').map(v => Number(v));

        graphicsData.beginPath();

        if (prevName !== 'S' && name !== 'S') {
          graphicsData.fillStyle(0x000000, 1);
          graphicsData.lineStyle(1, 0x000000, 1, CapsStyle.NONE, JointStyle.MITER, 4);
        }

        prevName = name;

        switch (name) {
          case 'S':
            const newStyle = styles[args[0]];
            style = parentStyle.clone();
            style.merge(newStyle);
            style.compute();

            break;
          case shapeCmds.PATH:
            this.__drawPath(cmd, graphicsData);
            break;
          case shapeCmds.RECT: {
            const x = args[0];
            const y = args[1];
            const width = args[2];
            const height = args[3];
            const rx = (args[4] === undefined ? args[5] : args[4]) || 0;
            const ry = (args[5] === undefined ? args[4] : args[5]) || 0;

            lastRect.set(x, y, width, height);

            if (rx !== 0 && ry !== 0) {
              graphicsData.moveTo(x, y + ry);
              graphicsData.quadraticCurveTo(x, y, x + rx, y);
              graphicsData.lineTo(x + width - rx, y);
              graphicsData.quadraticCurveTo(x + width, y, x + width, y + ry);
              graphicsData.lineTo(x + width, y + height - ry);
              graphicsData.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
              graphicsData.lineTo(x + rx, y + height);
              graphicsData.quadraticCurveTo(x, y + height, x, y + height - ry);
              graphicsData.closePath();
            } else {
              graphicsData.rect(args[0], args[1], args[2], args[3]);
            }

            break;
          }
          case shapeCmds.CIRCLE:
            const d = args[2] * 2;
            lastRect.set(0, 0, d, d);
            graphicsData.circle(args[0], args[1], args[2]);
            break;
          case shapeCmds.ELLIPSE:
            const x = args[0];
            const y = args[1];
            const rx = args[2];
            const ry = args[3];

            let a = /** @type {!Array<!Array<number>>} */ (this.__arcToBezier(x - rx, y, rx, ry, 0, 0, 0, x + rx, y));
            let b = /** @type {!Array<!Array<number>>} */ (this.__arcToBezier(x + rx, y, rx, ry, 0, 0, 0, x - rx, y));

            const curves = [...a, ...b];

            graphicsData.moveTo(x - rx, y);

            for (let i = 0, l = curves.length; i < l; i++) {
              const c = curves[i];
              graphicsData.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
            }

            // graphics.moveTo(x, y);
            break;
          case shapeCmds.LINE:
            const x1 = args[0];
            const y1 = args[1];
            const x2 = args[2];
            const y2 = args[3];

            graphicsData.moveTo(x1, y1);
            graphicsData.lineTo(x2, y2);
            break;
          case shapeCmds.POLYLINE:
          case shapeCmds.POLYGON:
            const points = cmd.slice(1).split(',').map(v => Number(v));
            graphicsData.moveTo(points[0], points[1]);

            for (let i = 2, l = points.length; i < l; i += 2) {
              graphicsData.lineTo(points[i], points[i + 1]);
            }

            name === shapeCmds.POLYGON && graphicsData.closePath();
            break;
          default:
            break;
        }
        
        if (style.needsFill && name !== 'S') {
          if (this.__isRef(style.F)) {
            const def = defs[style.F.slice(1)].clone();

            if (def instanceof GraphicsPattern) {
              graphicsData.fillPattern(def);
            } else if (def instanceof GraphicsLinearGradient) {
              if (def.isAbsolute) ; else {
                def.x0 *= lastRect.width; // todo other units (Now for percents only)
                def.x1 *= lastRect.width;
                def.y0 *= lastRect.height;
                def.y1 *= lastRect.height;
              }

              for (let key in def.stops) {
                def.stops[key] = ColorHelper.intToRGBA(parseInt(def.stops[key].slice(1), 16), style.fillAlpha);
              }

              graphicsData.fillGradient(def);
            }

          } else {
            graphicsData.fillStyle(style.fillColor, style.fillAlpha);
          }

          graphicsData.fill(style.fillRule === FillRule.NONE_ZERO);
        }

        if (style.needsStroke) {
          graphicsData.lineStyle(style.lineWidth, style.lineColor,
            style.lineAlpha, style.lineCap, style.lineJoin, style.miterLimit);

          graphicsData.setLineDash(style.lineDash);
          graphicsData.stroke();
        }
      }
    }

    if (node['nodes']) {
      node['nodes'].forEach(c => {
        this.__traverse(c, styles, graphicsData, style);
      });
    }

    return graphicsData;
  }

  /**
   * Determines whether color string is url to defs or simple color.
   *
   * @private
   * @param {string} value Color or url.
   *
   * @return {boolean}
   */
  __isRef(value) {
    return value.indexOf('$') === 0;
  }

  /**
   * Parses raw defs to this defs object.
   *
   * @private
   * @param {Object} defs Raw defs.
   * @param {Object} res  Reference to this defs.
   *
   * @returns {Object} res Parsed data.
   */
  __parseDefs(defs, res) {
    if (!defs) {
      return res;
    }

    for (let id in defs) {
      if (!defs.hasOwnProperty(id)) continue;

      const def = defs[id];

      if (typeof def === 'string') {
        const cmd = def.charAt(0);

        switch (cmd) {
          case 'R': // Linear Gradient
            const pairs = def.slice(1).split(' ');
            const v = pairs[0].split(',').map(v => parseFloat(v));
            const gradientInfo = new GraphicsLinearGradient(v[0], v[1], v[2], v[3]);
            gradientInfo.isAbsolute = v[4] === 0;
            res[id] = gradientInfo;

            for (let i = 1, l = pairs.length; i < l; i++) {
              const pair = pairs[i];
              const values = pair.split(',');
              const color = '#' + values[1];

              gradientInfo.addColorStop(parseFloat(values[0]), color);
            }
        }
      } else {

        // Pattern
        const styles = this.__parseStyles(def.s);
        const gData = this.__traverse(def, styles, new GraphicsData(), new BVGStyle());
        const graphics = new Graphics(gData);
        const renderTexture = new CanvasRenderTexture(graphics.width, graphics.height, Black.driver.renderScaleFactor);
        Black.driver.render(graphics, renderTexture, new Matrix());

        res[id] = new GraphicsPattern(renderTexture.native, def.r);
      }
    }

    return res;
  }

  /**
   * BVG styles parser.
   *
   * @private
   *
   * @returns {Array<black-engine~BVGStyle>} Parsed data styles.
   */
  __parseStyles(styles) {
    if (!styles)
      return [];

    return styles.map(s => {
      const style = {};
      const props = s.split(' ');

      props.forEach(p => {
        const cmd = p[0];
        style[cmd] = p.slice(1);
      });

      return style;
    });
  }

  /**
   * BVG path data parser.
   *
   * @private
   * @param {string} data Path data attribute value
   * @param {black-engine~GraphicsData} graphicsData Graphics data to store parsed values to.
   *
   * @return {void}
   */
  __drawPath(data, graphicsData) {
    const values = [];

    data
      .split(',')
      .map(item => {
        while (item.length !== 0) {
          const arg = parseFloat(item);

          if (isNaN(arg)) {
            values.push(item.charAt(0));
            item = item.slice(1);
          } else {
            values.push(arg);

            for (let i = 1; true; i++) {
              if (parseFloat(item.slice(0, i)) === arg) {
                item = item.slice(i);
                break;
              }
            }
          }
        }
      });

    values.reverse();

    // Context position
    let x = 0;
    let y = 0;

    // Path start position, to return on close path
    let mx = 0;
    let my = 0;

    // Bezier curve control point 1 position, to draw next smoothed bezier curve
    let bcx = 0;
    let bcy = 0;

    // Quadratic curve control point 1 position, to draw next smoothed quadratic curve
    let qcx = 0;
    let qcy = 0;

    // Store last command
    let prevValue = '';

    // 0 for absolute path and x, y for relative
    let relX = 0;
    let relY = 0;

    while (values.length !== 0) {
      const last = values[values.length - 1];
      const v = last === last.toString() ? values.pop() : prevValue;
      prevValue = v;
      relX = relY = 0;

      if (v === v.toLowerCase()) {
        relX = x;
        relY = y;
      }

      switch (v) {
        case pathCmds.MOVETO:
        case pathCmds.MOVETO_REL:
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.moveTo(x, y);
          mx = x;
          my = y;
          break;
        case pathCmds.LINETO:
        case pathCmds.LINETO_REL:
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.lineTo(x, y);
          break;
        case pathCmds.VLINE:
        case pathCmds.VLINE_REL:
          y = values.pop() + relY;
          graphicsData.lineTo(x, y);
          break;
        case pathCmds.HLINE:
        case pathCmds.HLINE_REL:
          x = values.pop() + relX;
          graphicsData.lineTo(x, y);
          break;
        case pathCmds.CURVE:
        case pathCmds.CURVE_REL: {
          const cp1x = values.pop() + relX;
          const cp1y = values.pop() + relY;
          const cp2x = values.pop() + relX;
          const cp2y = values.pop() + relY;
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
          bcx = x * 2 - cp2x;
          bcy = y * 2 - cp2y;
          break;
        }
        case pathCmds.SCURVE:
        case pathCmds.SCURVE_REL: {
          const cp2x = values.pop() + relX;
          const cp2y = values.pop() + relY;
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.bezierCurveTo(bcx, bcy, cp2x, cp2y, x, y);
          bcx = x * 2 - cp2x;
          bcy = y * 2 - cp2y;
          break;
        }
        case pathCmds.QCURVE:
        case pathCmds.QCURVE_REL: {
          const cpx = values.pop() + relX;
          const cpy = values.pop() + relY;
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.quadraticCurveTo(cpx, cpy, x, y);
          qcx = x * 2 - cpx;
          qcy = y * 2 - cpy;
          break;
        }
        case pathCmds.SQCURVE:
        case pathCmds.SQCURVE_REL: {
          x = values.pop() + relX;
          y = values.pop() + relY;
          graphicsData.quadraticCurveTo(qcx, qcy, x, y);
          qcx = x * 2 - qcx;
          qcy = y * 2 - qcy;
          break;
        }
        case pathCmds.ARC:
        case pathCmds.ARC_REL: {
          const px = x;
          const py = y;
          const rx = values.pop();
          const ry = values.pop();
          const xAxisRotation = values.pop();
          const largeArcFlag = values.pop();
          const sweepFlag = values.pop();
          x = values.pop() + relX;
          y = values.pop() + relY;

          const curves = this.__arcToBezier(px, py, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y);

          if (!curves) break;

          for (let i = 0, l = curves.length; i < l; i++) {
            const c = curves[i];
            graphicsData.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
          }

          break;
        }
        case pathCmds.CLOSE_PATH:
          graphicsData.closePath();
          x = mx;
          y = my;
          break;
      }

      if (v !== pathCmds.CURVE && v !== pathCmds.CURVE_REL && v !== pathCmds.SCURVE && v !== pathCmds.SCURVE_REL) {
        bcx = x;
        bcy = y;
      }

      if (v !== pathCmds.QCURVE && v !== pathCmds.QCURVE_REL && v !== pathCmds.SQCURVE && v !== pathCmds.SQCURVE_REL) {
        qcx = x;
        qcy = y;
      }
    }
  }

  // ARC TO BEZIER START
  /**
   * Approximate curve corner. Single bezier shouldn't be longer than 90 degrees.
   *
   * @private
   * @param {number} theta Start angle.
   * @param {number} deltaTheta Angle from start to end.
   *
   * @returns {Array<number>} Center.
   */
  __approxUnitArc(theta, deltaTheta) {
    const alpha = 4 / 3 * Math.tan(deltaTheta / 4);
    const x1 = Math.cos(theta);
    const y1 = Math.sin(theta);
    const x2 = Math.cos(theta + deltaTheta);
    const y2 = Math.sin(theta + deltaTheta);

    return [
      x1, y1,
      x1 - y1 * alpha, y1 + x1 * alpha,
      x2 + y2 * alpha, y2 - x2 * alpha,
      x2, y2,
    ];
  }

  __vectorAngle(ux, uy, vx, vy) {
    const sign = (ux * vy - uy * vx < 0) ? -1 : 1;
    const dot = MathEx.clamp(ux * vx + uy * vy, -1, 1);

    return sign * Math.acos(dot);
  }

  /**
   * Find arc center.
   *
   * @private
   * @param {number} x1 Context current position x.
   * @param {number} y1 Context current position y.
   * @param {number} x2 Context target (next) position x.
   * @param {number} y2 Context target (next) position y.
   * @param {number} fa Flag to determine which arc to draw.
   * @param {number} fs Another flag to determine which arc to draw.
   * @param {number} rx Arc radius x.
   * @param {number} ry Arc radius y.
   * @param {number} sinPhi Sin of x axis rotation.
   * @param {number} cosPhi Cos of x axis rotation.
   *
   * @returns {Array<number>} Center.
   */
  __getArcCenter(x1, y1, x2, y2, fa, fs, rx, ry, sinPhi, cosPhi) {
    const x1p = cosPhi * (x1 - x2) / 2 + sinPhi * (y1 - y2) / 2;
    const y1p = -sinPhi * (x1 - x2) / 2 + cosPhi * (y1 - y2) / 2;

    const rxSq = rx * rx;
    const rySq = ry * ry;
    const x1pSq = x1p * x1p;
    const y1pSq = y1p * y1p;

    let radical = Math.max(0, (rxSq * rySq) - (rxSq * y1pSq) - (rySq * x1pSq));
    radical /= (rxSq * y1pSq) + (rySq * x1pSq);
    radical = Math.sqrt(radical) * (fa === fs ? -1 : 1);

    const cxp = radical * rx / ry * y1p;
    const cyp = radical * -ry / rx * x1p;

    const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;
    const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;

    const v1x = (x1p - cxp) / rx;
    const v1y = (y1p - cyp) / ry;
    const v2x = (-x1p - cxp) / rx;
    const v2y = (-y1p - cyp) / ry;

    const theta = this.__vectorAngle(1, 0, v1x, v1y);
    let deltaTheta = this.__vectorAngle(v1x, v1y, v2x, v2y);

    if (fs === 0 && deltaTheta > 0) {
      deltaTheta -= Math.PI * 2;
    }

    if (fs === 1 && deltaTheta < 0) {
      deltaTheta += Math.PI * 2;
    }

    return [cx, cy, theta, deltaTheta];
  }

  /**
   * BVG path data parser.
   *
   * @private
   * @param {number} px Context current position x.
   * @param {number} py Context current position y.
   * @param {number} rx Arc radius x.
   * @param {number} ry Arc radius y.
   * @param {number} xAxisRotation Rotation in degrees.
   * @param {number} largeFlag Flag to determine which arc to draw.
   * @param {number} sweepFlag Another flag to determine which arc to draw.
   * @param {number} x Context target (next) position x.
   * @param {number} y Context target (next) position y.
   *
   * @returns {Array<Array<number>>|null} Array of bezier curves attributes.
   */
  __arcToBezier(px, py, rx, ry, xAxisRotation, largeFlag, sweepFlag, x, y) {
    const sinPhi = Math.sin(xAxisRotation * Math.PI / 180);
    const cosPhi = Math.cos(xAxisRotation * Math.PI / 180);

    const x1p = cosPhi * (px - x) / 2 + sinPhi * (py - y) / 2;
    const y1p = -sinPhi * (px - x) / 2 + cosPhi * (py - y) / 2;

    if (x1p === 0 && y1p === 0 || rx === 0 || ry === 0)
      return;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    const lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);

    if (lambda > 1) {
      const lambdaRt = Math.sqrt(lambda);
      rx *= lambdaRt;
      ry *= lambdaRt;
    }

    const center = this.__getArcCenter(px, py, x, y, largeFlag, sweepFlag, rx, ry, sinPhi, cosPhi);
    const curves = [];
    let theta = center[2];
    let deltaTheta = center[3];

    const segments = Math.max(Math.ceil(Math.abs(deltaTheta) / (Math.PI * 0.5)), 1);
    deltaTheta /= segments;

    for (let i = 0; i < segments; i++) {
      curves.push(this.__approxUnitArc(theta, deltaTheta));
      theta += deltaTheta;
    }

    return curves.map(function (curve) {
      for (let i = 0; i < curve.length; i += 2) {
        const x = curve[i] * rx;
        const y = curve[i + 1] * ry;
        const xp = cosPhi * x - sinPhi * y;
        const yp = sinPhi * x + cosPhi * y;

        curve[i] = xp + center[0];
        curve[i + 1] = yp + center[1];
      }

      return curve;
    });
  }
}

/**
 * Single JSON file asset class responsible for loading json file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */
class BVGAsset extends Asset {
  /**
   * Creates new JSONAsset instance.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   *
   * @returns {void}
   */
  constructor(name, url) {
    super(AssetType.VECTOR_GRAPHICS, name);

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** 
     * @private 
     * @type {black-engine~GraphicsData|null} 
     */
    this.mGraphicsData = null;

    /** 
     * @private 
     * @type {XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mXHR = factory.get(LoaderType.XHR, this.mUrl);
    this.mXHR.mimeType = 'application/json';
    this.mXHR.responseType = 'json';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    const data = /** @type {!Object}*/(this.mXHR.data);
    const parser = new BVGParser();

    this.mGraphicsData = parser.parse(data);
    this.mGraphicsData.name = this.name;

    super.ready(this.mGraphicsData);
  }
}

/**
 * Single JSON file asset class responsible for loading json file.
 *
 * @cat assets
 * @extends black-engine~Asset
 */

class VectorTextureAsset extends Asset {
  /**
   * Creates new JSONAsset instance.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   * @param {boolean} bakeSelf Flag to bake full BVG as texture. If false root will not be baked.
   * @param {boolean} bakeChildren Flag to bake each node with id to textures. If false none children nodes will be baked.
   * @param {Array<string>} namesToBake Concrete nodes ids to bake. Works only if bakeChildren is set to true.
   *
   * @returns {void}
   */
  constructor(name, url, bakeSelf, bakeChildren, namesToBake) {
    super(AssetType.VECTOR_TEXTURE, name);

    /**
     * @private
     * @type {string}
     */
    this.mUrl = url;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mBakeSelf = bakeSelf;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mBakeChildren = bakeChildren;

    /** 
     * @private 
     * @type {Array<string>} 
     */
    this.mNamesToBake = /** @type {Array<string>} */ (bakeChildren && namesToBake ? namesToBake : []);

    /** 
     * @private 
     * @type {black-engine~GraphicsData|null} 
     */
    this.mGraphicsData = null;

    /** 
     * @private 
     * @type {black-engine~XHRAssetLoader|null} 
     */
    this.mXHR = null;
  }

  /**
   * @inheritDoc
   */
  onLoaderRequested(factory) {
    this.mXHR = factory.get(LoaderType.XHR, this.mUrl);
    this.mXHR.mimeType = 'application/json';
    this.mXHR.responseType = 'json';
    this.addLoader(this.mXHR);
  }

  /**
   * @inheritDoc
   */
  onAllLoaded() {
    const data = /** @type {!Object}*/(this.mXHR.data);
    const parser = new BVGParser();

    this.mGraphicsData = parser.parse(data);
    this.mGraphicsData.name = this.name;

    const bakedTextures = this.bakeTextures();
    const ret = [];

    for (let name in bakedTextures) {
      if (!bakedTextures.hasOwnProperty(name))
        continue;

      ret.push({ name: name, data: bakedTextures[name] });
    }

    super.ready(ret);
  }

  /**
   * Creates baked textures from this graphics data.
   *
   * @return {Object.<string, black-engine~CanvasRenderTexture>}
   */
  bakeTextures() {
    const textures = {};
    const namesToBake = this.mNamesToBake;

    if (this.mBakeChildren && namesToBake.length === 0) {
      const traverse = nodes => {
        nodes = /** @type {Array<GraphicsData>} */(nodes);

        if (nodes.length === 0)
          return;

        for (let i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].name)
            namesToBake.push(/** @type {string} */(nodes[i].name));

          traverse(/** @type {Array<GraphicsData>} */(nodes[i].mNodes));
        }
      };

      traverse(this.mGraphicsData.mNodes);
    }

    if (this.mBakeSelf)
      namesToBake.unshift(this.mGraphicsData.name);

    for (let i = 0, l = namesToBake.length; i < l; i++) {
      const name = namesToBake[i];
      const node = this.mGraphicsData.searchNode(name);

      if (!node) {
        Debug.warn(`[BVGAsset] GraphicsData node with id '${name}' not found.`);
        continue;
      }

      const graphics = new Graphics(node, name !== this.mGraphicsData.name);
      const dpr = 1 / Black.driver.renderScaleFactor;
      const renderTexture = new CanvasRenderTexture(graphics.width, graphics.height, 1);

      Black.driver.render(graphics, renderTexture, new Matrix().scale(dpr, dpr));

      textures[name] = renderTexture;
    }

    return textures;
  }
}

/**
 * Represents current state of the AssetManager.
 * 
 * @cat assets
 * @static
 * @constant
 * @enum {string}
 */
const AssetManagerState = {
  NONE     : 'none',
  LOADING  : 'loading',
  FINISHED : 'finished'
};

/**
 * A factory object used to get or create a loader.
 * @cat assets
 */
class LoaderFactory {
  /**
   * 
   * @param {black-engine~AssetManager} assetManager 
   */
  constructor(assetManager) {
    this.mAssetManager = assetManager;
  }

  /**
   * Returns an existing instance of the loader if url is already in queue or creates new instance if not.
   * 
   * @param {string} type 
   * @param {string|black-engine~LoaderType} url 
   * @param {...any} args
   * 
   * @returns {black-engine~AssetLoader}
   */
  get(type, url, ...args) {
    let am = this.mAssetManager;
    // TODO: idea is to not create new loader each time it is requested.
    // But the problem that for example XHR can have different responseTypes.

    // let loader = am.mLoadersQueue[url];

    // if (loader != undefined)
    //   return loader;

    return new am.mLoaderTypeMap[type](url, ...args);
  }
}

/**
 * Responsible for loading assets and manages its in memory state.
 *
 * @fires AssetManager#progress
 * @fires AssetManager#complete
 * @fires AssetManager#error
 *
 * @cat assets
 * @extends black-engine~MessageDispatcher
 */
class AssetManager extends MessageDispatcher {
  /**
   * Creates new AssetManager instance. AssetManager exposes static property
   * called 'default' and many internal classes uses default instance.
   */
  constructor() {
    super();

    if (Black.assets === null)
      Black.assets = this;

    /** 
     * @private 
     * @type {string} 
     */
    this.mDefaultPath = '';

    /** 
     * @private 
     * @type {number} 
     */
    this.mTotalLoaded = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTotalPending = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTotalErrors = 0;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsAllLoaded = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mLoadingProgress = 0;

    /** 
     * @private 
     * @type {Array<black-engine~Asset>} 
     */
    this.mQueue = [];

    /** 
     * @private 
     * @type {Object.<string, black-engine~AssetLoader>} 
     */
    this.mLoadersQueue = {};

    /** 
     * @private 
     * @type {black-engine~AssetManagerState} 
     */
    this.mState = AssetManagerState.NONE;

    /**
     * @private
     * @type {black-engine~LoaderFactory}
     */
    this.mLoaderFactory = new LoaderFactory(this);

    this.mAssets = {};
    this.mAssetTypeMap = {};
    this.mLoaderTypeMap = {};

    this.registerDefaultTypes();
  }

  registerDefaultTypes() {
    // Textures
    this.mAssetTypeMap[AssetType.TEXTURE] = TextureAsset;
    this.mAssetTypeMap[AssetType.TEXTURE_ATLAS] = AtlasTextureAsset;

    // Vector
    this.mAssetTypeMap[AssetType.VECTOR_GRAPHICS] = BVGAsset;

    // Vector textures 
    this.mAssetTypeMap[AssetType.VECTOR_TEXTURE] = VectorTextureAsset;
    //this.mAssetTypeMap[AssetType.VECTOR_TEXTURE_ATLAS] = VectorTextureAsset;

    // Fonts
    this.mAssetTypeMap[AssetType.FONT] = FontAsset;
    this.mAssetTypeMap[AssetType.BITMAP_FONT] = BitmapFontAsset;

    // JSON & XML
    this.mAssetTypeMap[AssetType.XML] = XMLAsset;
    this.mAssetTypeMap[AssetType.JSON] = JSONAsset;

    // Sounds
    this.mAssetTypeMap[AssetType.SOUND] = SoundAsset;
    this.mAssetTypeMap[AssetType.SOUND_ATLAS] = SoundAtlasAsset;

    // Loaders
    this.mLoaderTypeMap[LoaderType.FONT_FACE] = FontFaceAssetLoader;
    this.mLoaderTypeMap[LoaderType.IMAGE] = ImageAssetLoader;
    this.mLoaderTypeMap[LoaderType.XHR] = XHRAssetLoader;
  }

  /**
   * Sets asset type. You can use this method to override Asset with your own.
   * 
   * @param {string} name 
   * @param {string} type 
   */
  setAssetType(name, type) {
    this.mAssetTypeMap[name] = type;
  }

  /**
   * Sets loader type. Use this method to override default loaders with custom ones.
   * 
   * @param {string} name 
   * @param {string} type 
   */
  setLoaderType(name, type) {
    this.mLoaderTypeMap[name] = type;
  }

  /**
   * Adds asset into the loading queue.
   * 
   * @param {string} name 
   * @param {black-engine~Asset} asset 
   * @returns {void}
   */
  enqueueAsset(name, asset) {
    this.__validateState();
    this.__validateName(asset.type, name);

    this.mQueue.push(asset);
  }

  /**
   * Returns new asset instance by given type.
   * 
   * @private
   * @param {string|black-engine~AssetType} type 
   * @param  {...any} args 
   */
  __getAsset(type, ...args) {
    return new this.mAssetTypeMap[type](...args);
  }

  /**
   * Adds or changes texture to the internal list for future reuse by given name.
   * @param {string} name
   * @param {black-engine~Texture} texture
   */
  addTexture(name, texture) {
    this.mTextures[name] = texture;
  }

  /**
   * Adds single image to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the image.
   * @returns {void}
   */
  enqueueImage(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.TEXTURE, name, this.mDefaultPath + url));
  }

  /**
   * Adds atlas to the loading queue.
   *
   * @param {string} name     Name of the asset.
   * @param {string} imageUrl Atlas URL.
   * @param {string} dataUrl  URL to the .json file which describes the atlas.
   * @returns {void}
   */
  enqueueAtlas(name, imageUrl, dataUrl) {
    this.enqueueAsset(name, this.__getAsset(AssetType.TEXTURE_ATLAS, name, this.mDefaultPath + imageUrl, this.mDefaultPath + dataUrl));
  }

  /**
   * Adds bitmap font to the loading queue.
   *
   * @param {string} name     Name of the font.
   * @param {string} imageUrl Image URL.
   * @param {string} xmlUrl   URL to the .xml file which describes the font.
   * @returns {void}
   */
  enqueueBitmapFont(name, imageUrl, xmlUrl) {
    this.enqueueAsset(name, this.__getAsset(AssetType.BITMAP_FONT, name, this.mDefaultPath + imageUrl, this.mDefaultPath + xmlUrl));
  }

  /**
   * Adds single xml file to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   * @returns {void}
   */
  enqueueXML(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.XML, name, this.mDefaultPath + url));
  }

  /**
   * Adds single json file to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   * @returns {void}
   */
  enqueueJSON(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.JSON, name, this.mDefaultPath + url));
  }

  /**
   * Adds single Black Vector Graphics file to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   *
   * @returns {void}
   */
  enqueueVector(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.VECTOR_GRAPHICS, name, this.mDefaultPath + url));
  }

  /**
   * Adds single Black Vector Graphics file to the loading queue and bakes it into the Texture.
   * 
   * If baked both graphics data and baked texture will be stored inside this AssetManager.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL of the json.
   * @param {boolean=} [bakeSelf=false] Flag to bake full BVG as texture. If false root will not be baked.
   * @param {boolean=} [bakeChildren=false] Flag to bake each node with id to textures. If false none children nodes will be baked.
   * @param {Array<string>=} [namesToBake=null] Concrete nodes ids to bake. Works only if bakeChildren is set to true.
   *
   * @returns {void}
   */
  enqueueVectorTexture(name, url, bakeSelf = false, bakeChildren = false, namesToBake = null) {
    if (bakeSelf === true || bakeChildren === true)
      this.enqueueAsset(name, this.__getAsset(AssetType.VECTOR_TEXTURE, name, this.mDefaultPath + url, bakeSelf, bakeChildren, namesToBake));
  }

  // /**
  //  * Adds single Black Vector Graphics file to the loading queue and bakes it into the AtlasTexture.
  //  * 
  //  * If baked both graphics data and baked texture will be stored inside this AssetManager.
  //  *
  //  * @param {string} name Name of the asset.
  //  * @param {string} url  The URL of the json.
  //  * @param {boolean=} [bakeSelf=false] Flag to bake full BVG as texture. If false root will not be baked.
  //  * @param {boolean=} [bakeChildren=false] Flag to bake each node with id to textures. If false none children nodes will be baked.
  //  * @param {Array<string>=} [namesToBake=null] Concrete nodes ids to bake. Works only if bakeChildren is set to true.
  //  *
  //  * @returns {void}
  //  */
  // enqueueVectorAtlas(name, url, bakeSelf = false, bakeChildren = false, namesToBake = null) {
  //   if (bakeSelf === true || bakeChildren === true)
  //     this.enqueueAsset(name, this.__getAsset(AssetType.VECTOR_TEXTURE_ATLAS, name, this.mDefaultPath + url, bakeSelf, bakeChildren, namesToBake));
  // }

  /**
   * Adds single sound to the loading queue.
   *
   * @param {string} name Name of the sound.
   * @param {string} url  The URL of the sound.
   * @returns {void}
   */
  enqueueSound(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.SOUND, name, this.mDefaultPath + url));
  }

  /**
   * Adds sound atlas to the loading queue.
   *
   * @param {string} name Name of the sound.
   * @param {string} soundUrl  The URL of the sound.
   * @param {string} dataUrl  The URL of the data JSON.
   * @returns {void}
   */
  enqueueSoundAtlas(name, soundUrl, dataUrl) {
    this.enqueueAsset(name, this.__getAsset(AssetType.SOUND_ATLAS, name, this.mDefaultPath + soundUrl, this.mDefaultPath + dataUrl));
  }

  /**
   * Adds local font to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @param {string} url  The URL to the font.
   * @returns {void}
   */
  enqueueFont(name, url) {
    this.enqueueAsset(name, this.__getAsset(AssetType.FONT, name, this.mDefaultPath + url, true));
  }

  /**
   * Adds Google Font to the loading queue.
   *
   * @param {string} name Name of the asset.
   * @returns {void}
   */
  enqueueGoogleFont(name) {
    this.enqueueAsset(name, this.__getAsset(AssetType.FONT, name, '', false));
  }

  /**
   * Starts loading all enqueued assets.
   *
   * @fires complete
   * @return {void}
   */
  loadQueue() {
    this.__validateState();

    if (this.mQueue.length === 0) {
      this.post(Message.COMPLETE);
      return;
    }

    this.mState = AssetManagerState.LOADING;

    for (let i = 0; i < this.mQueue.length; i++) {
      let item = this.mQueue[i];

      item.onLoaderRequested(this.mLoaderFactory);

      if (item.loaders.length > 0) {
        item.once(Message.COMPLETE, this.onAssetLoaded, this);
        item.once(Message.ERROR, this.onAssetError, this);

        this.mTotalPending++;

        item.loaders.forEach(x => {
          //this.mLoadersQueue[x.url] = x;
          x.load();
        });
      }
    }

    // Loader will notify Asset when its ready. Asset will notify AssetManager.
    // for (const key in this.mLoadersQueue) {
    //   if (this.mLoadersQueue.hasOwnProperty(key)) {
    //     const loader = this.mLoadersQueue[key];
    //     loader.load();
    //   }
    // }
  }

  /**
   * @protected
   * @ignore
   * @param {black-engine~Message} msg
   * @return {void}
   */
  onAssetLoaded(msg) {
    this.mTotalLoaded++;
    this.mLoadingProgress = this.mTotalLoaded / this.mTotalPending;

    let item = /** @type {Asset}*/ (msg.sender);
    item.off(Message.COMPLETE, Message.ERROR);

    if (this.mAssets[item.type] == null)
      this.mAssets[item.type] = {};

    if (Array.isArray(item.data)) {
      let objects = (item.data);

      objects.forEach(x => {
        this.__validateName(x.name);
        this.mAssets[item.type][x.name] = x.data;
      });
    }
    else
      this.mAssets[item.type][item.name] = item.data;

    /**
     * Posted when loading progress is changed.
     * @event AssetManager#progress
     */
    this.post(Message.PROGRESS, this.mLoadingProgress);

    if (this.mTotalLoaded === this.mTotalPending) {
      this.mQueue.splice(0, this.mQueue.length);
      this.mLoadersQueue = {};
      this.mState = AssetManagerState.FINISHED;
      this.mTotalLoaded = 0;
      this.mTotalErrors = 0;
      this.mTotalPending = 0;
      this.mIsAllLoaded = true;

      /**
       * Posted when all assets finished loading.
       * @event AssetManager#complete
       */
      this.post(Message.COMPLETE);
    }
  }

  onAssetError(msg) {
    this.mTotalErrors++;

    let total = this.mTotalLoaded + this.mTotalErrors;
    this.mLoadingProgress = this.mTotalLoaded / this.mTotalPending;

    let item = /** @type {Asset}*/ (msg.sender);

    item.off(Message.COMPLETE, Message.ERROR);
    Debug.warn(`[AssetManager] Error loading asset '${item.name}'.`);

    /**
     * Posted when error occurred while loading assets.
     * @event AssetManager#complete
     */
    this.post(Message.ERROR, item);

    if (total === this.mTotalPending) {
      this.mQueue.splice(0, this.mQueue.length);
      this.mLoadersQueue = {};
      this.mState = AssetManagerState.FINISHED;
      this.mTotalLoaded = 0;
      this.mTotalErrors = 0;
      this.mTotalPending = 0;
      this.mIsAllLoaded = true;
      this.post(Message.COMPLETE);
    }
  }

  /**
   * Returns BitmapFontData object by given name.
   *
   * @param {string} name The name of the Asset to search.
   * @return {black-engine~BitmapFontData|null} Returns a BitmapFontData if found or null.
   */
  getBitmapFont(name) {
    /** @type {black-engine~BitmapFontData} */
    let font = this.mAssets[AssetType.BITMAP_FONT][name];

    if (font != null)
      return font;

    Debug.warn(`[AssetManager] BitmapFontData '${name}' was not found.`);
    return null;
  }

  /**
   * Returns Texture object by given name.
   *
   * @param {string} name The name of the Asset.
   * @return {black-engine~Texture|null} Returns a Texture if found or null.
   */
  getTexture(name) {
    let textures = this.mAssets[AssetType.TEXTURE];
    if (textures != null) {
      /** @type {Texture} */
      let t = textures[name];

      if (t != null)
        return t;
    }

    let textureAtlases = this.mAssets[AssetType.TEXTURE_ATLAS];
    if (textureAtlases != null) {
      for (let key in textureAtlases) {
        let t = textureAtlases[key].subTextures[name];

        if (t != null)
          return t;
      }
    }

    let vectorTextures = this.mAssets[AssetType.VECTOR_TEXTURE];
    if (vectorTextures != null) {
      let t = vectorTextures[name];

      if (t != null)
        return t;
    }

    let vectorTextureAtlases = this.mAssets[AssetType.VECTOR_TEXTURE_ATLAS];
    if (vectorTextureAtlases != null) {
      for (let key in vectorTextureAtlases) {
        let t = vectorTextureAtlases[key].subTextures[name];

        if (t != null)
          return t;
      }
    }

    Debug.warn(`[AssetManager] Texture '${name}' was not found.`);
    return null;
  }

  /**
   * Returns Graphics data by given name.
   * @param {string} name 
   * @returns {black-engine~GraphicsData}
   */
  getGraphicsData(name) {
    let vectors = this.mAssets[AssetType.VECTOR_GRAPHICS];

    if (vectors == null)
      return null;

    /** @type {GraphicsData} */
    let data = vectors[name];

    if (data)
      return data;

    for (let key in vectors) {
      data = vectors[key].searchNode(name);

      if (data) {
        return data;
      }
    }

    Debug.warn(`[AssetManager] GraphicsData '${name}' was not found.`);
    return null;
  }

  /**
   * Returns array of Texture by given name mask.
   * Searches across all loaded images and atlases.
   *
   * @param {string} nameMask The name mask.
   * @returns {Array<black-engine~Texture>|null}
   */
  getTextures(nameMask) {
    let textures = this.mAssets[AssetType.TEXTURE];
    let textureAtlases = this.mAssets[AssetType.TEXTURE_ATLAS];
    let vectorTextures = this.mAssets[AssetType.VECTOR_TEXTURE];
    let vectorTextureAtlases = this.mAssets[AssetType.VECTOR_TEXTURE_ATLAS];

    let out = [];
    let names = [];

    let re = new RegExp('^' + nameMask.split('*').join('.*') + '$');

    // collect single textures
    if (textures != null) {
      for (let key in textures)
        if (re.test(key))
          names.push({ name: key, atlas: null, isBakedVector: false });
    }

    if (vectorTextures != null) {
      for (let key in vectorTextures)
        if (re.test(key))
          names.push({ name: key, atlas: null, isBakedVector: true });
    }

    // collect textures from all atlases
    if (textureAtlases != null) {
      for (let key in textureAtlases) {
        let atlas = textureAtlases[key];

        for (let key2 in atlas.subTextures)
          if (re.test(key2))
            names.push({ name: key2, atlas: atlas, isBakedVector: false });
      }
    }

    // collect texture from vector atlases
    if (vectorTextureAtlases != null) {
      for (let key in vectorTextureAtlases) {
        let atlas = vectorTextureAtlases[key];

        for (let key2 in atlas.subTextures)
          if (re.test(key2))
            names.push({ name: key2, atlas: atlas, isBakedVector: true });
      }
    }

    AtlasTexture.naturalSort(names, 'name');

    for (let i = 0; i < names.length; i++) {
      let ao = names[i];

      if (ao.atlas === null) {
        if (ao.isBakedVector === true)
          out.push(vectorTextures[ao.name]);
        else
          out.push(textures[ao.name]);
      }
      else
        out.push(ao.atlas.mSubTextures[ao.name]);
    }

    if (out.length > 0)
      return out;

    return null;
  }

  /**
   * Returns AtlasTexture by given name.
   *
   * @param {string} name The name of the Asset.
   * @return {black-engine~AtlasTexture|null} Returns atlas or null.
   */
  getAtlas(name) {
    let atlasses = this.mAssets[AssetType.TEXTURE_ATLAS];
    if (atlasses == null)
      return null;

    if (atlasses[name] != null)
      return atlasses[name];

    Debug.warn(`[AssetManager] Atlas '${name}' was not found.`);
    return null;
  }

  /**
   * Returns `SoundClip` by given name.
   *
   * @param {string} name The name of the sound.
   * @return {black-engine~SoundClip} Returns sound or null.
   */
  getSound(name) {
    let sounds = this.mAssets[AssetType.SOUND];
    let soundAtlases = this.mAssets[AssetType.SOUND_ATLAS];

    if (sounds != null) {
      /** @type {SoundClip} */
      let s = sounds[name];

      if (s != null)
        return s;
    }

    if (soundAtlases != null) {
      for (let key in soundAtlases) {
        let s = soundAtlases[key].subSounds[name];
        if (s != null)
          return s;
      }
    }

    Debug.warn(`[AssetManager] Sound '${name}' was not found.`);
    return null;
  }

  /**
   * Returns `SoundAtlasClip` by given name.
   *
   * @param {string} name The name of the sound.
   * @return {black-engine~SoundClip} Returns sound or null.
   */
  getSoundAtlas(name) {
    if (this.mAssets[AssetType.SOUND_ATLAS] == null)
      return null;

    return this.mAssets[AssetType.SOUND_ATLAS][name];
  }

  /**
   * Returns Object parsed from JSON by given name.
   *
   * @param {string} name The name of the JSON asset.
   * @return {Object} Returns object or null.
   */
  getJSON(name) {
    if (this.mAssets[AssetType.JSON] == null)
      return null;

    return this.mAssets[AssetType.JSON][name];
  }

  /**
   * Returns Object parsed from `CutsomAsset` by given name.
   *
   * @param {string} type The type of the asset.
   * @param {string} name The name of the asset.
   * @return {Object|null} Returns object or null.
   */
  getCustomAsset(type, name) {
    if (this.mAssets[type] == null)
      return null;

    return this.mAssets[type][name];
  }

  __validateState() {
    Debug.assert(this.mState === AssetManagerState.NONE || this.mState === AssetManagerState.FINISHED, 'Illegal state.');
  }

  __validateName(type, name) {
    if (this.mAssets[type] && this.mAssets[type][name])
      Debug.assert(this.mDictionary[name] == null, 'Asset with such name is already added.');
  }

  /**
   * Destroys all loaded resources.
   */
  dispose() {
    // todo: for each asset call abort
    this.mQueue.forEach(x => {
      x.abort();
    });
  }

  /**
   * Gets/Sets default path for loading. Useful when URLs getting too long.
   * The asset path will be concatenated with defaultPath.
   *
   * @return {string}
   */
  get defaultPath() {
    return this.mDefaultPath;
  }

  /**
   * @param {string} value
   * @return {void}
   */
  set defaultPath(value) {
    this.mDefaultPath = value;
  }

  /**
   * Returns True if all assets were loaded.
   *
   * @return {boolean}
   */
  get isAllLoaded() {
    return this.mIsAllLoaded;
  }

  /**
   * Returns number of errors occurred during loading.
   * @returns {number}
   */
  get numErrors() {
    return this.mTotalErrors;
  }

  /**
   * Returns current state.
   *
   * @returns {black-engine~AssetManagerState}
   */
  get state() {
    return this.mState;
  }

  /**
   * Always returns 'AssetManager', can be used to overhear AssetManager's messages.
   *
   * @override
   * @readonly
   * @return {string|null}
   */
  get path() {
    return 'AssetManager';
  }
}

/**
 * A RenderSession object holds state of current frame renderers.
 *
 * @cat drivers
 */
class RenderSession {
  /**
   * Creates new instance of RenderSession.
   */
  constructor() {
    /** @type {Array<Renderer>} */
    this.parentRenderers = [];

    /** @type {Array<black-engine~Renderer>} */
    this.endPassParentRenderers = [];

    /** @type {boolean} */
    this.isBackBufferActive = true;

    /** @type {Mblack-engine~atrix|null} */
    this.customTransform = null;
  }

  /**
   * Resets state for future reuse.
   */
  reset() {
    this.parentRenderers.splice(0, this.parentRenderers.length);
    this.endPassParentRenderers.splice(0, this.endPassParentRenderers.length);
    this.isBackBufferActive = true;
    this.customTransform = null;
  }
}

/**
 * Responsible for rendering `TextField` objects by different drivers.
 *
 * @extends black-engine~Renderer
 * @cat drivers
 */
class TextRenderer extends Renderer {
  /**
   * Creates new instance of TextRenderer.
   */
  constructor() {
    super();

    this.texture = null;

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     * @ignore 
     */
    this.mTransformCache = new Matrix();

    /** 
     * @private 
     * @type {black-engine~Matrix|null} 
     * @ignore 
     */
    this.mTransform = null;

    /** 
     * @private 
     * @type {boolean} 
     * @ignore 
     */
    this.mUseTransformCache = false;

    /** 
     * @private 
     * @type {HTMLCanvasElement} 
     */
    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));

    /** 
     * @private 
     * @type {CanvasRenderingContext2D} 
     */
    this.mContext = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext('2d'));

    /** 
     * @ignore
     */
    this.mContext.lineJoin = 'round';

    /** 
     * @ignore
     */
    this.mContext.miterLimit = 2;

    /** 
     * @private 
     * @type {black-engine~TextMetricsData|null} 
     */
    this.mMetrics = null;
  }

  /** @inheritDoc */
  preRender(driver, session) {
    this.endPassRequired = this.gameObject.mClipRect !== null && this.gameObject.mClipRect.isEmpty === false;

    this.skipChildren = !(this.gameObject.mAlpha > 0 && this.gameObject.mVisible === true);
    this.skipSelf = this.skipChildren === true;
  }

  /** @inheritDoc */
  upload(driver, session) {
    let gameObject = /** @type {TextField} */ (this.gameObject);

    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {
      gameObject.onGetLocalBounds();
      this.mMetrics = gameObject.mMetrics;
    }

    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE || gameObject.mDirty & DirtyFlag.RENDER)
      this.updateTransform();

    this.mTransform = this.mUseTransformCache === true ? this.mTransformCache : this.gameObject.worldTransformation;

    driver.setSnapToPixels(gameObject.snapToPixels);
    driver.setTransform(this.mTransform);
    driver.setGlobalAlpha(this.alpha);
    driver.setGlobalBlendMode(this.blendMode);

    if (this.endPassRequired === true) {
      driver.beginClip(gameObject.mClipRect, gameObject.mPivotX, gameObject.mPivotY);
    }
  }

  /**
   * @ignore
   * @private
   * @param {black-engine~TextMetricsData} metrics
   * @param {black-engine~TextSegmentMetricsData} segment
   * @param {CanvasRenderingContext2D} ctx
   * @param {black-engine~VideoNullDriver} driver
   * @param {black-engine~FontMetrics} fontMetrics
   * @param {boolean} isStroke
   */
  renderSegment(metrics, segment, ctx, driver, fontMetrics, isStroke) {
    let gameObject = /** @type {TextField} */ (this.gameObject);

    let baseline = fontMetrics.baselineNormalized * segment.style.size;

    if (isStroke === true) {
      ctx.lineWidth = segment.style.strokeThickness;
      ctx.strokeStyle = ColorHelper.intToRGBA(segment.style.strokeColor, segment.style.strokeAlpha);
    } else {
      ctx.fillStyle = ColorHelper.intToRGBA(segment.style.color, segment.style.alpha);
    }

    ctx.font = `${segment.style.weight} ${segment.style.style} ${segment.style.size}px ${segment.style.family}`;

    let lx = segment.bounds.x - Math.min(metrics.strokeBounds.x, metrics.shadowBounds.x);
    let ly = baseline + segment.bounds.y - Math.min(metrics.strokeBounds.y, metrics.shadowBounds.y);

    lx += gameObject.padding.x;
    ly += gameObject.padding.y;

    if (gameObject.align === 'center')
      lx += metrics.bounds.width * 0.5 - metrics.lineWidth[segment.lineIndex] * 0.5;
    else if (gameObject.align === 'right')
      lx += metrics.bounds.width - metrics.lineWidth[segment.lineIndex];

    if (isStroke === true)
      ctx.strokeText(segment.text, lx, ly);
    else
      ctx.fillText(segment.text, lx, ly);
  }

  /** @inheritDoc */
  render(driver, session) {
    let gameObject = /** @type {TextField} */ (this.gameObject);

    if (gameObject.mHighQuality === true && gameObject.mDirty & DirtyFlag.RENDER) {
      gameObject.mDirty ^= DirtyFlag.RENDER;
      gameObject.mDirty |= DirtyFlag.RENDER_CACHE;
    }

    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {
      gameObject.mDirty ^= DirtyFlag.RENDER_CACHE;

      const cvs = this.mCanvas;
      const ctx = this.mContext;
      let scale = 1;
      ctx.textBaseline = 'alphabetic';

      if (gameObject.mHighQuality === true) {
        let data = this.mTransform.data;
        let gameObjectScaleX = Math.sqrt((data[0] * data[0]) + (data[2] * data[2]));
        let gameObjectScaleY = Math.sqrt((data[1] * data[1]) + (data[3] * data[3]));
        scale = Math.max(gameObjectScaleX, gameObjectScaleY) * driver.renderScaleFactor;
      }

      let canvasBounds = this.mMetrics.strokeBounds.clone();
      canvasBounds.union(this.mMetrics.shadowBounds);
      canvasBounds.inflate(gameObject.padding.right, gameObject.padding.bottom);
      canvasBounds.scale(scale, scale);

      cvs.width = canvasBounds.width;
      cvs.height = canvasBounds.height;

      let fontMetrics = FontMetrics.get(gameObject.mDefaultStyle.family);
      let segments = this.mMetrics.segments;

      ctx.save();
      ctx.scale(scale, scale);

      for (let i = 0; i < segments.length; i++) {
        if (segments[i].style.dropShadow) {
          ctx.save();
          ctx.shadowColor = ColorHelper.intToRGBA(segments[i].style.shadowColor, segments[i].style.shadowAlpha);
          ctx.shadowBlur = segments[i].style.shadowBlur;
          ctx.shadowOffsetX = segments[i].style.shadowDistanceX * scale;
          ctx.shadowOffsetY = segments[i].style.shadowDistanceY * scale;
          this.renderSegment(this.mMetrics, segments[i], ctx, driver, fontMetrics, false);
          ctx.restore();
        }
      }

      for (let i = 0; i < segments.length; i++) {
        let segment = segments[i];
        if (segment.style.strokeThickness > 0) {
          ctx.lineJoin = 'round';
          ctx.miterLimit = 2;
          this.renderSegment(this.mMetrics, segment, ctx, driver, fontMetrics, true);
        }
      }

      for (let i = 0; i < segments.length; i++)
        this.renderSegment(this.mMetrics, segments[i], ctx, driver, fontMetrics, false);

      ctx.restore();

      // whats the max texture size?
      if (this.texture === null)
        this.texture = new Texture(cvs, null, null, 1 / scale);
      else
        this.texture.set(cvs, null, null, 1 / scale);
    }
  }

  /** @ignore */
  updateTransform() {
    let gameObject = /** @type {TextField} */ (this.gameObject);
    let transform = gameObject.worldTransformation;

    let fieldXOffset = 0;
    let fieldYOffset = 0;

    let filterOffsetX = Math.min(this.mMetrics.strokeBounds.x, this.mMetrics.shadowBounds.x);
    let filterOffsetY = Math.min(this.mMetrics.strokeBounds.y, this.mMetrics.shadowBounds.y);

    const hasFilter = filterOffsetX !== 0 || filterOffsetY !== 0;

    if (gameObject.mAutoSize === false) {
      if (gameObject.align === 'center')
        fieldXOffset = (gameObject.mFieldWidth - this.mMetrics.bounds.width) * 0.5;
      else if (gameObject.align === 'right')
        fieldXOffset = gameObject.mFieldWidth - this.mMetrics.bounds.width;

      if (gameObject.mVerticalAlign === 'middle')
        fieldYOffset = (gameObject.mFieldHeight - this.mMetrics.bounds.height) * 0.5;
      else if (gameObject.mVerticalAlign === 'bottom')
        fieldYOffset = gameObject.mFieldHeight - this.mMetrics.bounds.height;
    }

    if (hasFilter === true || gameObject.mAutoSize === false) {
      this.mUseTransformCache = true;
      transform.copyTo(this.mTransformCache);
      this.mTransformCache.translate((filterOffsetX + fieldXOffset) - gameObject.padding.x, (filterOffsetY + fieldYOffset) - gameObject.padding.y);
    } else if (gameObject.padding.isEmpty === false) {
      this.mUseTransformCache = true;
      transform.copyTo(this.mTransformCache);
      this.mTransformCache.translate(-gameObject.padding.x, -gameObject.padding.y);
    } else {
      this.mUseTransformCache = false;
    }
  }
}

/**
 * Responsible for rendering `BitmapTextField` objects by different drivers.
 *
 * @extends black-engine~Renderer
 * @cat drivers
 */
class BitmapTextRenderer extends Renderer {
  /**
   * Creates new instance of BitmapTextRenderer.
   */
  constructor() {
    super();

    /** 
     * @ignore 
     * @private 
     * @type {HTMLCanvasElement} 
     */
    this.mCanvas = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));

    /** 
     * @ignore 
     * @private 
     * @type {CanvasRenderingContext2D} 
     */
    this.mContext = /** @type {CanvasRenderingContext2D} */ (this.mCanvas.getContext('2d'));

    /** 
     * @ignore 
     * @type {black-engine~Texture|null} 
     */
    this.texture = null;
  }

  /**
   * @inheritDoc
   */
  render(driver, session) {
    let gameObject = /** @type {BitmapTextField} */ (this.gameObject);

    if (gameObject.mText === null)
      return;

    if (gameObject.mDirty & DirtyFlag.RENDER_CACHE) {
      const cvs = this.mCanvas;
      const ctx = this.mContext;

      let data = gameObject.mData;
      let text = gameObject.mText;
      let canvasBounds = gameObject.onGetLocalBounds();

      // remove dirty flag only after getting bounds
      gameObject.mDirty ^= DirtyFlag.RENDER_CACHE;

      let prevCharCode = -1;
      let cx = 0;
      let cy = 0;

      cvs.width = canvasBounds.width;
      cvs.height = canvasBounds.height;

      for (let i = 0; i < text.length; i++) {
        let charCode = text.charCodeAt(i);

        if (/(?:\r\n|\r|\n)/.test(text.charAt(i))) {
          cx = 0;
          cy += data.lineHeight * gameObject.mLineHeight;
          prevCharCode = -1;
          continue;
        }

        let charData = data.chars[charCode];

        if (charData == null)
          continue;

        let texture = charData.texture;

        if (prevCharCode >= 0 && charData.kerning[prevCharCode])
          cx += charData.kerning[prevCharCode];

        const w = texture.width;
        const h = texture.height;

        // skip empty char (space for example)
        if (w === 0 || h === 0)
          continue

        const ox = texture.untrimmedRegion.x + charData.xOffset + cx;
        const oy = texture.untrimmedRegion.y + charData.yOffset + cy;

        ctx.drawImage(texture.native, texture.region.x, texture.region.y, w, h, ~~ox, ~~oy, w, h);

        cx += charData.xAdvance;
        prevCharCode = charCode;
      }

      if (this.texture === null)
        this.texture = new Texture(cvs);
      else
        this.texture.set(cvs);
    }
  }
}

/**
 * Responsible for rendering `Graphics` objects by different drivers.
 *
 * @extends black-engine~Renderer
 * @cat drivers
 */
class GraphicsRenderer extends Renderer {
  constructor() {
    super();
  }
}

/**
 * Renders `DisplayObject` objects on canvas.
 *
 * @extends black-engine~Renderer
 * @cat drivers.canvas
 */
class DisplayObjectRendererCanvas extends Renderer {
  constructor() {
    super();

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mCacheAsBitmapDirty = true;

    /** 
     * @private 
     * @type {black-engine~Matrix|null} 
     */
    this.mCacheAsBitmapMatrixCache = null;

    /** 
     * @private 
     * @type {black-engine~CanvasRenderTexture|null} 
     */
    this.mCacheTexture = null;

    /** 
     * @private 
     * @type {black-engine~Rectangle|null} 
     */
    this.mCacheBounds = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsClipped = false;

    this.mIsCached = false;

    /** 
     * @private 
     * @type {black-engine~Matrix|null} 
     */
    this.mBakeInvertedMatrix = null;
  }

  /** @inheritDoc */
  preRender(driver, session) {
    let gameObject = /** @type {DisplayObject} */ (this.gameObject);

    this.mIsClipped = gameObject.mClipRect !== null;
    this.endPassRequired = this.mIsClipped;

    if (gameObject.mCacheAsBitmap === true) {
      if (gameObject.mCacheAsBitmapDynamic === false) {
        if (this.mIsCached === false) {
          this.mIsCached = true;
          gameObject.setTransformDirty();
          this.__refreshBitmapCache();
          this.mCacheAsBitmapDirty = false;
          this.endPassRequired = false;
        } else {
          gameObject.mDirty |= DirtyFlag.RENDER;
        }
      } else {
        let isStatic = gameObject.checkStatic(true);

        if (isStatic === true && this.mCacheAsBitmapDirty === true) {
          gameObject.setTransformDirty();
          this.__refreshBitmapCache();
          this.mCacheAsBitmapDirty = false;
          this.endPassRequired = false;
        } else if (isStatic === false) {
          this.mCacheAsBitmapDirty = true;
          gameObject.mDirty |= DirtyFlag.RENDER;
        }
      }
    }

    this.skipChildren = gameObject.mCacheAsBitmap === true && this.mCacheAsBitmapDirty === false || this.mIsClipped && gameObject.mClipRect.isEmpty;
    this.skipSelf = false;

    if (this.skipChildren === true) {
      this.endPassRequired = false;
      this.skipSelf = true;
    }
  }

  /** @inheritDoc */
  begin(driver, session) {
    let gameObject = /** @type {DisplayObject} */ (this.gameObject);
    if (this.skipChildren === true && session.isBackBufferActive === true) {
      this.alpha = 1;
      this.blendMode = BlendMode.NORMAL;
      this.color = null;
      this.skipSelf = gameObject.mAlpha <= 0 || gameObject.mVisible === false || this.mIsClipped && gameObject.mClipRect.isEmpty;
    }
    else {
      this.alpha = gameObject.mAlpha * this.parent.alpha;
      this.color = gameObject.mColor === null ? this.parent.color : gameObject.mColor;
      this.blendMode = gameObject.mBlendMode === BlendMode.AUTO ? this.parent.blendMode : gameObject.mBlendMode;

      this.skipChildren = gameObject.mAlpha <= 0 || gameObject.mVisible === false;
      this.skipSelf = this.skipChildren === true || this.mIsClipped === false || this.mIsClipped && gameObject.mClipRect.isEmpty;
    }
  }

  /** @inheritDoc */
  upload(driver, session) {
    let gameObject = /** @type {DisplayObject} */ (this.gameObject);
    let transform = gameObject.worldTransformation;

    if (this.skipChildren === true && this.mCacheAsBitmapMatrixCache) {
      transform = this.mCacheAsBitmapMatrixCache;

      if (gameObject.mCacheAsBitmapDynamic === false) {
        transform = new Matrix()
          .append(this.gameObject.worldTransformation)
          .append(this.mBakeInvertedMatrix)
          .append(this.mCacheAsBitmapMatrixCache);
      }
    }

    if (this.skipChildren === true || this.endPassRequired === true) {
      driver.setSnapToPixels(gameObject.snapToPixels);
      driver.setTransform(transform);
      driver.setGlobalAlpha(this.alpha);
      driver.setGlobalBlendMode(this.blendMode);
    }

    if (this.endPassRequired === true)
      driver.beginClip(gameObject.mClipRect, gameObject.mPivotX, gameObject.mPivotY);
  }

  /** @inheritDoc */
  render(driver, session) {
    if (this.skipChildren === true && session.isBackBufferActive === true)
      driver.drawTexture(this.mCacheTexture);
  }

  __refreshBitmapCache() {
    const bounds = this.gameObject.getBounds(Black.stage, true);
    const sf = Black.stage.scaleFactor;
    const fs = Black.driver.renderScaleFactor * sf;

    /** @type {Matrix} */
    let m = Matrix.pool.get();
    m.set(1, 0, 0, 1, ~~(-bounds.x * sf - Black.stage.mX), ~~(-bounds.y * sf - Black.stage.mY));

    if (this.mIsClipped === true && this.skipChildren === true) {
      m.data[4] += this.gameObject.mPivotX * sf;
      m.data[5] += this.gameObject.mPivotY * sf;
    }

    if (this.mCacheBounds === null)
      this.mCacheBounds = new Rectangle();

    bounds.copyTo(this.mCacheBounds);
    bounds.width *= fs;
    bounds.height *= fs;

    if (this.mCacheTexture === null)
      this.mCacheTexture = new CanvasRenderTexture(bounds.width, bounds.height, 1);
    else
      this.mCacheTexture.resize(bounds.width, bounds.height, 1);

    Black.driver.render(this.gameObject, this.mCacheTexture, m);
    Matrix.pool.release(m);

    if (this.mCacheAsBitmapMatrixCache === null)
      this.mCacheAsBitmapMatrixCache = new Matrix();

    this.mCacheAsBitmapMatrixCache.copyFrom(m);
    this.mCacheAsBitmapMatrixCache.scale(1 / Black.driver.renderScaleFactor, 1 / Black.driver.renderScaleFactor);
    this.mCacheAsBitmapMatrixCache.data[4] = -this.mCacheAsBitmapMatrixCache.data[4];
    this.mCacheAsBitmapMatrixCache.data[5] = -this.mCacheAsBitmapMatrixCache.data[5];

    this.mBakeInvertedMatrix = this.gameObject.worldTransformationInverted.clone();
    //this.mCacheTexture.__dumpToDocument();
  }
}

/**
 * Renders `TextField` objects on canvas.
 *
 * @extends black-engine~TextRenderer
 * @cat drivers.canvas
 */
class TextRendererCanvas extends TextRenderer {
  /** @inheritDoc */
  render(driver, session) {
    super.render(driver, session);

    driver.drawTexture(Renderer.getColoredTexture(this.texture, this.gameObject.mColor));
  }
}

/**
 * Renders `BitmapTextField` objects on canvas.
 *
 * @extends black-engine~BitmapTextRenderer
 * @cat drivers.canvas
 */
class BitmapTextRendererCanvas extends BitmapTextRenderer {
  /** @inheritDoc */
  render(driver, session) {
    super.render(driver, session);

    driver.drawTexture(Renderer.getColoredTexture(this.texture, this.gameObject.mColor));
  }
}

/**
 * Base class for distribution objects.
 *
 * @cat scatters
 */
class Scatter {
  /**
   * Creates new Scatter instance.
   */
  constructor() {}

  /**
   * Returns random value.
   *
   * @return {*} Any object.
   */
  getValue() {}

  /**
   * Returns value at given position.
   *
   * @param {number} t Position to get value at.
   * @return {*} Any object.
   */
  getValueAt(t) {}
}

/**
 * A base class for number scatters.
 *
 * @cat scatters
 * @extends black-engine~Scatter
 */
class FloatScatterBase extends Scatter {
  /**
   * Creates new FloatScatter instance.
   */
  constructor() {
    super();

    /**
     * Cached last value of `getValueAt` result.
     * 
     * @readonly
     * @type {number}
     */
    this.value = 0;
  }
  
  /**
   * Returns random value.
   *
   * @return {number}
   */
  getValue() {
    return this.getValueAt(Math.random());
  }
}

/**
 * A number scatter for defining a range in 1D space.
 *
 * @cat scatters
 * @extends black-engine~FloatScatterBase
 */
class FloatScatter extends FloatScatterBase {
  /**
   * Creates new FloatScatter instance.
   *
   * @param {number}                   [min=0]  The min value along x-axis.
   * @param {number}                   [max=null]  The max value along x-axis.
   * @param {?function(number):number} [ease=null] Easing function. If null linear function is used as default.
   */
  constructor(min = 0, max = null, ease = null) {
    super();

    /**
     * A min value.
     * 
     * @type {number}
     */
    this.min = min;

    /**
     * A max value.
     * 
     * @type {number}
     */
    this.max = max === null ? min : max;

    /**
     * Optional easing function.
     * 
     * @type {?function(number):number}
     */
    this.ease = ease;
  }

  /**
   * Returns value at given position within defined range.
   *
   * @override
   * @param {number} t The position.
   * @return {number} Number at given position.
   */
  getValueAt(t) {
    if (this.ease !== null)
      t = this.ease(t);

    this.value = this.min + t * (this.max - this.min);

    return this.value;
  }

  /**
   * Creates new FloatScatterBase from a set of numbers.
   *
   * @param {...number|black-engine~FloatScatterBase} values Set of values.
   * @returns {black-engine~FloatScatterBase}
   */
  static fromObject(...values) {
    if (values[0] instanceof FloatScatterBase)
      return /** @type {FloatScatterBase} */ (values[0]);

    return new FloatScatter(...values);
  }
}

/**
 * Represents current state of the emitter.
 * @cat particles
 * @static
 * @constant
 * @enum {number}
 */
const EmitterState = {
  PENDING: 0,
  EMITTING: 1,
  PAUSED: 2,
  FINISHED: 3,
};

/**
 * Indicates the order in which particles will be rendered.
 * @cat particles
 * @enum {string}
 */
const EmitterSortOrder = {
  FRONT_TO_BACK: 'frontToBack',
  BACK_TO_FRONT: 'backToFront'
};

/**
 * A base utility class used by particle systems. Must be extended.
 *
 * @cat particles
 */
class Modifier {
  /**
   * Creates new instance.
   *
   * @param {boolean} isInitializer Indicates whenever this modifier will be applied to particle during initialization stage or particle lifetime.
   */
  constructor(isInitializer = true) {
    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsInitializer = isInitializer;

    /** 
     * Modifier's object to get values from. 
     * @type {Scatter}
     */
    this.scatter = null;

    /**
     * Indicates whenever this modifier is active or not.
     * @type {boolean}
     */
    this.isActive = true;
  }

  /**
   * Called on each Emitter's update before `Modifier.update`
   *
   * @protected
   * @param {number} dt Time since last update.
   * @return {void}
   */
  preUpdate(dt) { }

  /**
   * Called on each Emitter's update for each particle.
   *
   * @protected
   * @param {Emitter} emitter Emitter this modifier attached to.
   * @param {Particle} particle Instance of `Particle`.
   * @param {number} dt Time since last update.
   * @return {void}
   */
  update(emitter, particle, dt) { }

  /**
   * Called on each Emitter's update after `Modifier.update`
   *
   * @protected
   * @param {number} dt Time since last update.
   * @return {void}
   */
  postUpdate(dt) { }

  /**
   * Specifies if the modifier is initializer or action.
   *
   * @readonly
   * @returns {boolean}
   */
  get isInitializer() {
    return this.mIsInitializer;
  }
}

/**
 * The particle!
 *
 * @cat particles
 */
class Particle {
  constructor() {

    /** @type {number} The index of a texture. */
    this.textureIndex = 0;

    /** @type {number} The x scale of this particle. */
    this.scaleX = 1;

    /** @type {number} The x scale of this particle. */
    this.scaleY = 1;

    /** @type {number} An alpha value. */
    this.alpha = 1;

    /** @type {number} The life of this particle. */
    this.life = 1;

    /** @type {number} The age of this particle. */
    this.age = 0;

    /** @type {number} Relation of life to age. */
    this.energy = this.age / this.life;

    /** @type {number} The mass. */
    this.mass = 0;

    /** @type {number} X-component. */
    this.x = 0;

    /** @type {number} Y-component. */
    this.y = 0;

    /** @type {number} Rotation of this particle. */
    this.r = 0;

    /** @type {number} Velocity by x. */
    this.vx = 0;

    /** @type {number} Velocity by y. */
    this.vy = 0;

    /** @type {number} Particle x-acceleration. */
    this.ax = 0;

    /** @type {number} Particle y-acceleration. */
    this.ay = 0;

    /** @type {number|null} Particle tinting color. */
    this.color = null;

    /** @type {number} Particle origin point along x-axis. */
    this.anchorX = 0.5;

    /** @type {number} Particle origin point along y-axis. */
    this.anchorY = 0.5;
  }

  /**
   * Resets particle to default state.
   *
   * @returns {void}
   */
  reset() {
    this.scaleX = this.scaleY = this.alpha = this.life = 1;
    this.textureIndex = this.age = this.energy = this.mass = this.x = this.y = this.r = this.vx = this.vy = this.ax = this.ay = 0;
    this.anchorX = this.anchorY = 0.5;
  }

  /**
   * Internal update method.
   *
   * @param {number} dt Time since last update.
   * @return {void}
   */
  update(dt) {
    if (this.life <= 0) {
      this.life = 0;
      return;
    }

    this.x += this.vx * dt;
    this.y += this.vy * dt;

    if (this.mass > 0) {
      this.ax *= 1 / this.mass;
      this.ay *= 1 / this.mass;
    }

    this.vx += this.ax * dt;
    this.vy += this.ay * dt;

    this.ax = 0;
    this.ay = 0;

    this.life -= dt;
    this.age += dt;

    this.energy = this.age / (this.age + this.life);
  }
}

// TODO: pretty much the emitter is always dirty and caching should not be applied onto it.
// TODO: q/a every property

/**
 * Particle emitter.
 *
 * @cat particles
 * @extends black-engine~DisplayObject
 */
class Emitter extends DisplayObject {
  /**
   * Creates new Emitter instance.
   */
  constructor() {
    super();

    /** 
     * @private 
     * @type {Array<black-engine~Texture>} 
     */
    this.mTextures = [];

    /** 
     * @private 
     * @type {Array<black-engine~Particle>} 
     */
    this.mParticles = [];

    /** 
     * @private 
     * @type {Array<black-engine~Particle>} 
     */
    this.mRecycled = [];

    /** 
     * @private 
     * @type {Array<black-engine~Modifier>} 
     */
    this.mInitializers = [];

    /** 
     * @private 
     * @type {Array<black-engine~Modifier>} 
     */
    this.mActions = [];

    /** 
     * @private 
     * @type {black-engine~GameObject} 
     */
    this.mSpace = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsLocal = true;

    /** 
     * @private 
     * @type {number} 
     */
    this.mMaxParticles = 10000;

    /** 
     * @private 
     * @type {black-engine~FloatScatter} 
     */
    this.mEmitCount = new FloatScatter(10);

    /** 
     * @private 
     * @type {black-engine~FloatScatter} 
     */
    this.mEmitNumRepeats = new FloatScatter(0, Number.MAX_SAFE_INTEGER);

    /** 
     * @private 
     * @type {number} 
     */
    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();

    /** 
     * @private 
     * @type {black-engine~FloatScatter} 
     */
    this.mEmitDuration = new FloatScatter(1 / 60);

    /** 
     * @private 
     * @type {number} 
     */
    this.mEmitDurationLeft = this.mEmitDuration.getValue();

    /** 
     * @private 
     * @type {black-engine~FloatScatter} 
     */
    this.mEmitInterval = new FloatScatter(1 / 60);

    /** 
     * @private 
     * @type {number} 
     */
    this.mEmitIntervalLeft = this.mEmitInterval.getValue();

    /** 
     * @private 
     * @type {black-engine~FloatScatter} 
     */
    this.mEmitDelay = new FloatScatter(1);

    /** 
     * @private 
     * @type {number} 
     */
    this.mEmitDelayLeft = this.mEmitDelay.getValue();

    /** 
     * @private 
     * @type {number} 
     */
    this.mNextUpdateAt = 0;

    /** 
     * @private 
     * @type {black-engine~EmitterState} 
     */
    this.mState = EmitterState.PENDING;

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.__tmpLocal = new Matrix();

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.__tmpWorld = new Matrix();

    /** 
     * @private 
     * @type {black-engine~EmitterSortOrder} 
     */
    this.mSortOrder = EmitterSortOrder.FRONT_TO_BACK;

    /**
     * @private
     * @type {Array<string>|null}
     */
    this.mTextureNames = null;

    /**
     * @private
     * @type {number}
     */
    this.mPresimulateSeconds = 0;

    /**
     * @private
     * @type {number}
     */
    this.mCurrentPresimulationTime = 0;
  }

  /**
   * Starts emitting particles. By default emitter will start emitting automatically.
   */
  play() {
    if (this.mState === EmitterState.EMITTING)
      return;

    // resume or restart
    if (this.mState !== EmitterState.PAUSED) {
      this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();
      this.mEmitDurationLeft = this.mEmitDuration.getValue();
      this.mEmitIntervalLeft = this.mEmitInterval.getValue();
      this.mEmitDelayLeft = this.mEmitDelay.getValue();

      this.mState = EmitterState.PENDING;
    }
  }

  /**
   * Pauses the emitting process.
   */
  pause() {
    this.mState = EmitterState.PAUSED;
  }

  /** 
   * Stops emitting process and destroys all particles.
   */
  stop() {
    this.mParticles = [];
    this.mRecycled = [];

    this.mState = EmitterState.FINISHED;
  }

  /**
   * Simulates current emmitter for a given amount of time (seconds).
   * 
   * @param {number} time Time in secounds
   * @returns {void}
   */
  simulate(time) {
    Debug.isNumber(time);
    Debug.assert(time > 0);

    this.mCurrentPresimulationTime = 0;
    this.mPresimulateSeconds = time;

    while (this.mCurrentPresimulationTime <= this.mPresimulateSeconds) {
      this.onUpdate();
      this.mCurrentPresimulationTime += Black.time.delta;
    }

    this.mPresimulateSeconds = 0;
    this.mCurrentPresimulationTime = 0;
  }

  /**
   * @inheritDoc
   */
  getRenderer() {
    return Black.driver.getRenderer('Emitter', this);
  }

  /**
   * A helper method for quick adding modifiers.
   *
   * @param {...(black-engine~GameObject|black-engine~Component|black-engine~Modifier)} modifiers The list of modifiers.
   * @returns {Emitter}
   */
  add(...modifiers) {
    for (let i = 0; i < modifiers.length; i++) {
      let ai = modifiers[i];

      if (ai instanceof Modifier)
        this.addModifier(ai);
      else
        super.add(ai);
    }
    return this;
  }

  /**
   * Adds modifier to the end of the list.
   *
   * @param {black-engine~Modifier} modifier Modifier to add.
   * @return {black-engine~Modifier}
   */
  addModifier(modifier) {
    if (modifier.isInitializer)
      this.mInitializers.push(modifier);
    else
      this.mActions.push(modifier);

    return modifier;
  }

  /**
   * Removes given modifier.
   *
   * @param {black-engine~Modifier} modifier Modifier to remove.
   * @return {boolean} True if modifier was removed.
   */
  removeModifier(modifier) {
    let array = this.mActions;

    if (modifier.isInitializer)
      array = this.mInitializers;

    let ix = array.indexOf(modifier);
    if (ix >= 0) {
      array.splice(ix, 1);
      return true;
    }

    return false;
  }

  /**
   * Hacky method which returns time now or presimulation time depending on a case.
   */
  __getTime() {
    return Black.time.now;
  }

  /**
   * Updates delay, duration, interval. Use this function each time you change one of those values.
   *
   * @private
   * @param {number} [dt=0]
   * @return {void}
   */
  updateNextTick(dt = 0) {
    let t = Black.time.now;
    let firstEmit = false;

    if (this.mState === EmitterState.PENDING) {
      this.mNextUpdateAt = t + this.mEmitDelayLeft;
      this.mEmitDelayLeft -= dt;

      if (this.mEmitDelayLeft <= 0) {
        this.mEmitDelayLeft = this.mEmitDelay.getValue();
        this.mState = EmitterState.EMITTING;
        firstEmit = true;
      }
    }

    if (this.mState === EmitterState.EMITTING) {
      if (this.mEmitDurationLeft <= 0) {
        this.mEmitDurationLeft = this.mEmitDuration.getValue();

        this.mEmitNumRepeatsLeft--;

        if (this.mEmitNumRepeatsLeft <= 0) {
          this.mState = EmitterState.FINISHED;

          this.post(Message.COMPLETE);
          return;
        } else {
          this.mState = EmitterState.PENDING;
          return;
        }
      } else {
        // we are getting value here each update to make sure we are up to date!
        if (firstEmit) {
          // for a first emit we do not want to add an extra delay. emit now!
          this.mNextUpdateAt = t;
          this.mEmitIntervalLeft = this.mEmitInterval.getValue();
        }
        else {
          this.mEmitIntervalLeft -= dt;
          this.mNextUpdateAt = t + this.mEmitIntervalLeft;

          // reset interval
          if (this.mEmitIntervalLeft <= 0)
            this.mEmitIntervalLeft = this.mEmitInterval.getValue();
        }
      }

      this.mEmitDurationLeft -= dt;
    }
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    if (this.mState === EmitterState.PAUSED)
      return;

    let dt = Black.time.delta;

    // rate logic
    this.updateNextTick(dt);

    if (Black.time.now >= this.mNextUpdateAt && this.mState === EmitterState.EMITTING) {
      this.__create(this.mEmitCount.getValue());
    }

    // main update login
    const alength = this.mActions.length;
    const plength = this.mParticles.length;

    for (let k = 0; k < alength; k++)
      if (this.mActions[k].isActive === true)
        this.mActions[k].preUpdate(dt);

    let particle;

    let i = plength;
    while (i--) {
      particle = this.mParticles[i];

      for (let k = 0; k < alength; k++)
        if (this.mActions[k].isActive === true)
          this.mActions[k].update(this, particle, dt);

      particle.update(dt);

      if (particle.life === 0) {
        this.mRecycled.push(particle);
        this.mParticles.splice(i, 1);
      }
    }

    for (let k = 0; k < alength; k++)
      if (this.mActions[k].isActive === true)
        this.mActions[k].postUpdate(dt);

    // set dummy dirty flag so unchanged frames can be detected
    if (this.mVisible === true && this.mAlpha > 0)
      this.setDirty(DirtyFlag.LOCAL, false);
  }

  /**
   * @ignore
   * @private
   */
  __create(amount) {
    let matrix = this.worldTransformation.clone();
    let minv = null;

    if (this.mIsLocal === false) {
      minv = this.mSpace.worldTransformationInverted.clone();
      matrix.prepend(minv);
    }

    for (let i = 0; i < amount; i++) {
      let p = null;

      if (this.mRecycled.length > 0) {
        p = this.mRecycled.pop();
      } else {
        if (this.mParticles.length >= this.mMaxParticles)
          return;

        p = new Particle();
      }

      p.reset();

      for (let k = 0; k < this.mInitializers.length; k++)
        if (this.mInitializers[k].isActive === true)
          this.mInitializers[k].update(this, p, 0);

      if (this.mIsLocal === false) {
        matrix.transformXY(p.x, p.y, Vector.__cache);
        p.x = Vector.__cache.x;
        p.y = Vector.__cache.y;
      }

      this.mParticles.push(p);
    }
  }

  /**
   * Gets current emitter state.
   *
   * @return {black-engine~EmitterState}
   */
  get state() {
    return this.mState;
  }

  /**
   * Gets/Sets The maximum number of particles can be created.
   *
   * @return {number}
   */
  get maxParticles() {
    return this.mMaxParticles;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set maxParticles(value) {
    if (value < 0)
      throw new Error('Bad argument error.');

    this.mMaxParticles = value;
  }

  /**
   * Gets/Sets the number of particles to be emitted per {@link Emitter#emitInterval}
   *
   * @return {black-engine~FloatScatter}
   */
  get emitCount() {
    return this.mEmitCount;
  }

  /**
   * @param {black-engine~FloatScatter} value
   * @return {void}
   */
  set emitCount(value) {
    this.mEmitCount = value;
  }

  /**
   * Gets/Sets the number of "durations" to to repeat.
   *
   * @return {black-engine~FloatScatter}
   */
  get emitNumRepeats() {
    return this.mEmitNumRepeats;
  }

  /**
   * @param {black-engine~FloatScatter} value
   * @return {void}
   */
  set emitNumRepeats(value) {
    this.mEmitNumRepeats = value;
    this.mEmitNumRepeatsLeft = this.mEmitNumRepeats.getValue();
  }

  /**
   * Gets/Sets
   *
   * @return {black-engine~FloatScatter}
   */
  get emitDuration() {
    return this.mEmitDuration;
  }

  /**
   * @param {black-engine~FloatScatter} value
   * @return {void}
   */
  set emitDuration(value) {
    this.mEmitDuration = value;
    this.mEmitDurationLeft = this.mEmitDuration.getValue();
  }


  /**
   * Gets/Sets
   *
   * @return {black-engine~FloatScatter}
   */
  get emitInterval() {
    return this.mEmitInterval;
  }

  /**
   * @param {black-engine~FloatScatter} value
   * @return {void}
   */
  set emitInterval(value) {
    this.mEmitInterval = value;
    this.mEmitIntervalLeft = this.mEmitInterval.getValue();
  }


  /**
   * Gets/Sets
   *
   * @return {black-engine~FloatScatter}
   */
  get emitDelay() {
    return this.mEmitDelay;
  }

  /**
   * @param {black-engine~FloatScatter} value
   * @return {void}
   */
  set emitDelay(value) {
    this.mEmitDelay = value;
    this.mEmitDelayLeft = this.mEmitDelay.getValue();
  }


  /**
   * Gets/Sets the space where emitting simulation will happen, ignoring space transformation, so all forces are relative to global.
   *
   * @return {black-engine~GameObject}
   */
  get space() {
    return this.mSpace;
  }

  /**
   * @param {black-engine~GameObject} gameObject
   * @return {void}
   */
  set space(gameObject) {
    this.mSpace = gameObject;
    this.mIsLocal = this.mSpace === null || this.mSpace === this;
    this.setRenderDirty();
  }

  /**
   * Gets/Sets a list of textures to use.
   *
   * @return {Array<black-engine~Texture>}
   */
  get textures() {
    return this.mTextures;
  }

  /**
   * @param {Array<black-engine~Texture>} value
   * @return {void}
   */
  set textures(value) {
    this.mTextures = value;

    Debug.assert(!(this.mTextures === null || this.mTextures.length === 0), 'At least one texture must be provided.');

    this.setRenderDirty();
  }

  /**
   * Returns list of textures used by this emitter.
   * @returns {Array<string>}
   */
  get textureNames() {
    return this.mTextureNames;
  }

  /**
    * Sets the list of textures with given string. It uses AssetManager to find textures.
    * 
    * @param {Array<string>} value
    * @return {void}
    */
  set textureNames(value) {
    this.mTextureNames = value;

    this.textures = value.map(x => Black.assets.getTexture(x));
  }

  /**
   * Gets/Sets the order in which particles will be sorted when rendering.
   *
   * @return {black-engine~EmitterSortOrder}
   */
  get sortOrder() {
    return this.mSortOrder;
  }

  /**
   * @param {black-engine~EmitterSortOrder} value
   * @return {void}
   */
  set sortOrder(value) {
    this.mSortOrder = value;
    this.setRenderDirty();
  }
}

/**
 * Renders `Particle` objects on canvas.
 *
 * @extends black-engine~Renderer
 * @cat drivers.canvas
 */
class EmitterRendererCanvas extends Renderer {
  /**
   * Creates new instance of EmitterRendererCanvas.
   */
  constructor() {
    super();

    /**
     * @ignore
     * @type {boolean}
     */
    this.isLocal = false;

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.__tmpLocal = new Matrix();

    /** 
     * @private 
     * @type {black-engine~Matrix} 
     */
    this.__tmpWorld = new Matrix();
  }

  /** @inheritDoc */
  preRender(driver, session) {
    let gameObject = /** @type {Emitter} */ (this.gameObject);

    this.endPassRequired = this.gameObject.mClipRect !== null && this.gameObject.mClipRect.isEmpty === false;
    this.skipChildren = !(gameObject.mAlpha > 0 && gameObject.mTextures.length > 0 && gameObject.mVisible === true);
    this.skipSelf = !(gameObject.mTextures.length > 0 && gameObject.mParticles.length > 0);
  }

  /** @inheritDoc */
  render(driver, session) {
    let gameObject = /** @type {Emitter} */ (this.gameObject);

    driver.setSnapToPixels(gameObject.snapToPixels);

    let plength = gameObject.mParticles.length;
    let localTransform = this.__tmpLocal;
    let worldTransform = this.__tmpWorld;
    localTransform.identity();

    if (gameObject.sortOrder === EmitterSortOrder.FRONT_TO_BACK) {
      for (let i = 0; i < plength; i++)
        this.__renderParticle(gameObject.mParticles[i], localTransform, worldTransform, driver);
    } else {
      for (let i = plength - 1; i > 0; i--)
        this.__renderParticle(gameObject.mParticles[i], localTransform, worldTransform, driver);
    }
  }

  /**
   * @ignore
   * @private
   * @param {black-engine~Particle} particle
   * @param {black-engine~Matrix} localTransform
   * @param {black-engine~Matrix} worldTransform
   * @param {black-engine~VideoNullDriver} driver
   */
  __renderParticle(particle, localTransform, worldTransform, driver) {
    let gameObject = /** @type {Emitter} */ (this.gameObject);

    let texture = gameObject.textures[particle.textureIndex];
    let tw = texture.displayWidth * particle.anchorX;
    let th = texture.displayHeight * particle.anchorY;

    if (particle.r === 0) {
      let tx = particle.x - tw * particle.scaleX;
      let ty = particle.y - th * particle.scaleY;
      localTransform.set(particle.scaleX, 0, 0, particle.scaleY, tx, ty);
    } else {
      let cos = Math.cos(particle.r);
      let sin = Math.sin(particle.r);
      let a = particle.scaleX * cos;
      let b = particle.scaleX * sin;
      let c = particle.scaleY * -sin;
      let d = particle.scaleY * cos;

      let tx = particle.x - tw * a - th * c;
      let ty = particle.y - tw * b - th * d;
      localTransform.set(a, b, c, d, tx, ty);
    }

    if (gameObject.mIsLocal === true) {
      worldTransform.identity();
      worldTransform.copyFrom(localTransform);
      worldTransform.prepend(gameObject.worldTransformation);
    } else {
      worldTransform.copyFrom(gameObject.mSpace.worldTransformation);
      worldTransform.append(localTransform);
    }

    driver.setGlobalAlpha(gameObject.mAlpha * particle.alpha);
    driver.setTransform(worldTransform);
    driver.drawTexture(Renderer.getColoredTexture(texture, particle.color === null ? gameObject.mColor : particle.color));
  }
}

/**
 * Renders `Sprite` objects on canvas.
 *
 * @extends black-engine~Renderer
 * @cat drivers.canvas
 */

class SpriteRendererCanvas extends Renderer{
  constructor() {
    super();

    /** @type {CanvasPattern|null} */
    this.pattern = null;

    /** @type {black-engine~Texture|null} */
    this.patternTexture = null;

    /** @type {black-engine~CanvasRenderTexture|null} */
    this.sliceTextureCache = null;

    /** @type {number|null} */
    this.sizeWidthCache = null;

    /** @type {number|null} */
    this.sizeHeightCache = null;

    /** @type {black-engine~Texture} */
    this.textureCache = null;
  }

  /** @inheritDoc */
  preRender(driver, session) {
    let gameObject = /** @type {Sprite} */ (this.gameObject);

    const skip = gameObject.mClipRect !== null && gameObject.mClipRect.isEmpty;

    this.endPassRequired = gameObject.mClipRect !== null && !gameObject.mClipRect.isEmpty;
    this.skipChildren = skip || gameObject.mAlpha <= 0 || gameObject.mVisible === false;
    this.skipSelf = skip || gameObject.mTexture === null || gameObject.mAlpha <= 0 || gameObject.mVisible === false;
  }

  renderSlice9Grid(driver, texture, grid) {
    const dpr = driver.mDevicePixelRatio;
    let desiredWidth = texture.width * this.gameObject.mScaleX;
    let desiredHeight = texture.height * this.gameObject.mScaleY;

    if (this.textureCache === texture && this.sizeWidthCache === desiredWidth && this.sizeHeightCache === desiredHeight)
      return this.sliceTextureCache;

    this.textureCache = texture;
    this.sizeWidthCache = desiredWidth;
    this.sizeHeightCache = desiredHeight;

    const sourceX = texture.region.x;
    const sourceY = texture.region.y;
    const sourceWidth = texture.region.width;
    const sourceHeight = texture.region.height;

    const destX = texture.untrimmedRegion.x * dpr;
    const destY = texture.untrimmedRegion.y * dpr;

    if (this.sliceTextureCache === null)
      this.sliceTextureCache = new CanvasRenderTexture(desiredWidth, desiredHeight, 1 / texture.scale);
    else
      this.sliceTextureCache.resize(desiredWidth, desiredHeight, 1 / texture.scale);

    const ctx = this.sliceTextureCache.renderTarget.context;
    const scale = Math.min(this.gameObject.scaleX, this.gameObject.scaleY);

    if (scale <= 1) {
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      desiredWidth /= scale;
      desiredHeight /= scale;
    }

    const gridLeft = grid.x / texture.scale;
    const gridTop = grid.y / texture.scale;
    const gridRight = sourceWidth - grid.right / texture.scale;
    const gridBottom = sourceHeight - grid.bottom / texture.scale;

    // non-scalable
    const srcOffsetX = sourceX + sourceWidth - gridRight;
    const dstOffsetX = destX + desiredWidth / texture.scale - gridRight;

    const srcOffsetY = sourceY + sourceHeight - gridBottom;
    const dstOffsetY = destY + desiredHeight / texture.scale - gridBottom;

    // top left
    ctx.drawImage(texture.native, sourceX, sourceY, gridLeft, gridTop, destX, destY, gridLeft, gridTop);

    // top right
    ctx.drawImage(texture.native, srcOffsetX, sourceY, gridRight, gridTop, dstOffsetX, destY, gridRight, gridTop);

    // bottom right
    ctx.drawImage(texture.native, srcOffsetX, srcOffsetY, gridRight, gridBottom, dstOffsetX, dstOffsetY, gridRight, gridBottom);

    // bottom left
    ctx.drawImage(texture.native, sourceX, srcOffsetY, gridLeft, gridBottom, destX, dstOffsetY, gridLeft, gridBottom);

    // scalable
    const srcLeftOffset = sourceX + gridLeft;
    const dstLeftOffset = destX + gridLeft;

    const srcTopOffset = sourceY + gridTop;
    const dstTopOffset = destY + gridTop;

    const srcRightOffset = sourceX + sourceWidth - gridRight;
    const dstRightOffset = destX + desiredWidth / texture.scale - gridRight;

    const srcBottomOffset = sourceY + sourceHeight - gridBottom;
    const dstBottomOffset = destY + desiredHeight / texture.scale - gridBottom;

    const srcCenterWidth = sourceWidth - gridLeft - gridRight;
    const dstCenterWidth = desiredWidth / texture.scale - gridLeft - gridRight;

    const srcCenterHeight = sourceHeight - gridTop - gridBottom;
    const dstCenterHeight = desiredHeight / texture.scale - gridTop - gridBottom;

    // top
    ctx.drawImage(texture.native, srcLeftOffset, sourceY, srcCenterWidth, gridTop, dstLeftOffset, destY, dstCenterWidth, gridTop);

    // right
    ctx.drawImage(texture.native, srcRightOffset, srcTopOffset, gridRight, srcCenterHeight, dstRightOffset, dstTopOffset, gridRight, dstCenterHeight);

    // bottom
    ctx.drawImage(texture.native, srcLeftOffset, srcBottomOffset, srcCenterWidth, gridBottom, dstLeftOffset, dstBottomOffset, dstCenterWidth, gridBottom);

    // left
    ctx.drawImage(texture.native, sourceX, srcTopOffset, gridLeft, srcCenterHeight, destX, dstTopOffset, gridLeft, dstCenterHeight);

    //center
    ctx.drawImage(texture.native, srcLeftOffset, srcTopOffset, srcCenterWidth, srcCenterHeight, dstLeftOffset, dstTopOffset, dstCenterWidth, dstCenterHeight);

    return this.sliceTextureCache;
  }

  /** @inheritDoc */
  render(driver, session) {
    let ctx = /** @type {CanvasDriver}*/ (driver).mCtx;
    let gameObject = /** @type {Sprite} */ (this.gameObject);

    let texture = Renderer.getColoredTexture(gameObject.mTexture, this.color);

    if (gameObject.mSlice9grid !== null) {
      const data = this.gameObject.worldTransformation.data;
      const m = Matrix.pool.get().set(data[0] / this.gameObject.scaleX, data[1] / this.gameObject.scaleX, data[2] / this.gameObject.scaleY, data[3] / this.gameObject.scaleY, data[4], data[5]);
      driver.setTransform(m);
      Matrix.pool.release(m);

      texture = this.renderSlice9Grid(driver, texture, gameObject.mSlice9grid);
    }

    if (gameObject.mTiling === null) {
      driver.drawTexture(texture);
    } else {
      // we got some tiling
      if (this.pattern === null || this.patternTexture !== texture) {
        const renderCanvas = new RenderTargetCanvas(texture.width, texture.height);
        const r = texture.region;
        const u = texture.untrimmedRegion;
        renderCanvas.context.drawImage(texture.native, r.x, r.y, r.width, r.height, u.x, u.y, r.width, r.height);

        this.pattern = ctx.createPattern(renderCanvas.native, 'repeat');
        this.patternTexture = texture;
      }

      ctx.fillStyle = /** @type {CanvasPattern} */(this.pattern);

      let dpr = driver.renderScaleFactor;

      let m = gameObject.worldTransformation.clone();
      m.scale(gameObject.tiling.scaleX * dpr, gameObject.tiling.scaleY * dpr);
      m.translate(gameObject.tiling.wrapX / dpr, gameObject.tiling.wrapY / dpr);

      driver.setTransform(m);

      // draw pattern
      ctx.fillRect(-gameObject.tiling.wrapX, -gameObject.tiling.wrapY, gameObject.tiling.width / gameObject.tiling.scaleX, gameObject.tiling.height / gameObject.tiling.scaleY);
      ctx.fillStyle = 'black';
    }
  }
}

/**
 * Renders `Graphics` objects on canvas.
 *
 * @extends black-engine~GraphicsRenderer
 * @cat drivers.canvas
 */

class GraphicsRendererCanvas extends GraphicsRenderer {
  /**
   * Creates new instance of GraphicsRendererCanvas.
   */
  constructor() {
    super();
  }

  /** @inheritDoc */
  render(driver, session) {
    let gameObject = /** @type {Graphics} */ (this.gameObject);
    this.__drawCommandBuffer(driver);

    if (gameObject.mColor !== null && gameObject.mColor !== 0xFFFFFF) {
      driver.context.globalCompositeOperation = 'multiply';
      this.__drawCommandBuffer(driver, gameObject.mColor);
    }
  }

  /**
   * Prepare context to draw.
   *
   * @private
   * @param {black-engine~VideoNullDriver} driver Driver to draw.
   * @param {number|null=} [color=null] Tint.
   *
   * @return {void}
   */
  __drawCommandBuffer(driver, color = null) {
    const gameObject = /** @type {Graphics} */ (this.gameObject);
    const ctx = driver.context;

    ctx.save();
    ctx.beginPath();

    const transform = Matrix.pool.get().copyFrom(gameObject.worldTransformation);
    transform.translate(-gameObject.mDataOffsetX, -gameObject.mDataOffsetY);

    this.__renderNode(driver, color, gameObject.mGraphicsData, transform);

    Matrix.pool.release(transform);
    ctx.restore();
  }

  /**
   * Recursively draws each node of GraphicsData.
   *
   * @private
   * @param {black-engine~VideoNullDriver} driver Driver to draw.
   * @param {number|null} color Tint.
   * @param {black-engine~GraphicsData} node Commands provider.
   * @param {black-engine~Matrix} transform Graphics Data global transformation.
   *
   * @return {void}
   */
  __renderNode(driver, color, node, transform) {
    const commands = node.mCommandQueue;
    const ctx = driver.context;
    const len = commands.length;
    const r = driver.renderScaleFactor;
    const px = node.mPivotX;
    const py = node.mPivotY;

    transform = transform.clone().append(node.mTransform);
    driver.setTransform(transform);

    for (let i = 0; i < len; i++) {
      const cmd = commands[i];

      switch (cmd.type) {
        case GraphicsCommandType.LINE_STYLE: {
          ctx.lineWidth = cmd.getNumber(0) * r;
          ctx.strokeStyle = ColorHelper.intToRGBA(color === null ? cmd.getNumber(1) : /** @type {number} */(color), cmd.getNumber(2));
          ctx.lineCap = cmd.getString(3);
          ctx.lineJoin = cmd.getString(4);
          ctx.miterLimit = cmd.getNumber(5);
          break;
        }

        case GraphicsCommandType.FILL_STYLE: {
          ctx.fillStyle = ColorHelper.intToRGBA(color === null ? cmd.getNumber(0) : /** @type {number} */(color), cmd.getNumber(1));
          break;
        }

        case GraphicsCommandType.FILL_GRD: {
          const gradientInfo = /** @type {GraphicsLinearGradient} */(cmd.getObject(0));
          let grd = gradientInfo.native;

          if (!grd) {
            const dpr = Black.driver.renderScaleFactor;
            const entries = [];

            grd = gradientInfo.native = ctx.createLinearGradient(gradientInfo.x0 * dpr, gradientInfo.y0 * dpr,
              gradientInfo.x1 * dpr, gradientInfo.y1 * dpr);

            for (let key in gradientInfo.stops) {
              entries.push({ percent: parseFloat(key), color: gradientInfo.stops[key] });
            }

            entries.sort((a, b) => a.percent - b.percent);

            for (let i = 0, l = entries.length; i < l; i++) {
              const entry = entries[i];
              grd.addColorStop(entry.percent, entry.color);
            }
          }

          ctx.fillStyle = /** @type {CanvasGradient} */(grd);

          break;
        }

        case GraphicsCommandType.FILL_PATTERN: {
          const patternInfo = /** @type {GraphicsPattern} */(cmd.getObject(0));
          let pattern = patternInfo.native;

          if (!pattern) {
            pattern = patternInfo.native = ctx.createPattern(patternInfo.image, patternInfo.repetition);
          }

          ctx.fillStyle = /** @type {CanvasPattern} */(pattern);

          break;
        }

        case GraphicsCommandType.ARC: {
          ctx.arc(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py, cmd.getNumber(2) * r, cmd.getNumber(3), cmd.getNumber(4), cmd.getBoolean(5));
          break;
        }

        case GraphicsCommandType.RECT: {
          ctx.rect(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py, cmd.getNumber(2) * r, cmd.getNumber(3) * r);
          break;
        }

        case GraphicsCommandType.ROUNDED_RECT: {
          const x = cmd.getNumber(0);
          const y = cmd.getNumber(1);
          const width = cmd.getNumber(2);
          const height = cmd.getNumber(3);
          const radius = cmd.getNumber(4);

          ctx.moveTo(x * r - px, (y + radius) * r - py);
          ctx.quadraticCurveTo(x * r - px, y * r - py, (x + radius) * r - px, y * r - py);
          ctx.lineTo((x + width - radius) * r - px, y * r - py);
          ctx.quadraticCurveTo((x + width) * r - px, y * r - py, (x + width) * r - px, (y + radius) * r - py);
          ctx.lineTo((x + width) * r - px, (y + height - radius) * r - py);
          ctx.quadraticCurveTo((x + width) * r - px, (y + height) * r - py, (x + width - radius) * r - px, (y + height) * r - py);
          ctx.lineTo((x + radius) * r - px, (y + height) * r - py);
          ctx.quadraticCurveTo(x * r - px, (y + height) * r - py, x * r - px, (y + height - radius) * r - py);
          ctx.closePath();
          break;
        }

        case GraphicsCommandType.BEZIER_CURVE_TO: {
          ctx.bezierCurveTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py, cmd.getNumber(2) * r - px, cmd.getNumber(3) * r - py, cmd.getNumber(4) * r - px, cmd.getNumber(5) * r - py);
          break;
        }
        case GraphicsCommandType.QUADRATIC_CURVE_TO: {
          ctx.quadraticCurveTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py, cmd.getNumber(2) * r - px, cmd.getNumber(3) * r - py);
          break;
        }
        case GraphicsCommandType.BEGIN_PATH: {
          ctx.beginPath();
          break;
        }
        case GraphicsCommandType.CLOSE_PATH: {
          ctx.closePath();
          break;
        }
        case GraphicsCommandType.FILL: {
          ctx.fill(cmd.getBoolean(0) === true ? 'nonzero' : 'evenodd');
          break;
        }

        case GraphicsCommandType.LINE_TO: {
          ctx.lineTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py);
          break;
        }

        case GraphicsCommandType.MOVE_TO: {
          ctx.moveTo(cmd.getNumber(0) * r - px, cmd.getNumber(1) * r - py);
          break;
        }

        case GraphicsCommandType.LINE_DASH: {
          ctx.setLineDash(cmd.getNumber(0));
          break;
        }

        case GraphicsCommandType.STROKE: {
          ctx.stroke();
          break;
        }

        case GraphicsCommandType.SHADOW_BLUR: {
          ctx.shadowBlur = cmd.getNumber(0) * r;
          break;
        }

        case GraphicsCommandType.SHADOW_COLOR: {
          let stringColor = ColorHelper.intToRGBA(color === null ? cmd.getNumber(0) : /** @type {number} */(color), cmd.getNumber(1));
          ctx.shadowColor = stringColor;
          break;
        }

        case GraphicsCommandType.BOUNDS: {
          break;
        }

        default:
          Debug.error(`Unsupported canvas command '${cmd.type}'.`);
          break;
      }
    }

    for (let i = 0, l = node.mNodes.length; i < l; i++)
      this.__renderNode(driver, color, node.mNodes[i], transform);
  }
}

/**
 * Base class for custom video drivers. VideoDriver is used to render things onto the screen.
 *
 * @cat drivers
 */
class VideoNullDriver {
  /**
   * Creates new instance of VideoNullDriver.
   *
   * @param  {HTMLElement} containerElement The HTML element container for rendering.
   * @param  {number} width                 The width of the viewport.
   * @param  {number} height                The height of the viewport.
   */
  constructor(containerElement, width, height) {

    /** 
     * @protected 
     * @type {HTMLElement} 
     */
    this.mContainerElement = containerElement;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mClientWidth = width;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mClientHeight = height;

    /** 
     * @protected 
     * @type {black-engine~Matrix} Actual object - do not change 
     */
    this.mTransform = new Matrix();

    /** 
     * @protected 
     * @type {black-engine~Matrix} 
     */
    this.mIdentityMatrix = new Matrix();

    /** 
     * @protected 
     * @type {black-engine~RenderSession} 
     */
    this.mActiveSession = new RenderSession();

    /** 
     * @protected 
     * @type {Array<black-engine~RenderSession>} 
     */
    this.mSessions = [];

    /** 
     * @protected 
     * @type {*} 
     */
    this.mLastRenderTexture = null;

    /** 
     * @protected 
     * @type {boolean} 
     */
    this.mSnapToPixels = false;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mDevicePixelRatio = Black.engine.useHiDPR === true ? Black.device.getDevicePixelRatio() : 1;

    /** 
     * @protected 
     * @type {black-engine~BlendMode|null} 
     */
    this.mGlobalBlendMode = BlendMode.AUTO;

    /** 
     * @protected 
     * @type {number} 
     */
    this.mGlobalAlpha = 1;

    /** 
     * @protected 
     * @type {black-engine~Renderer} 
     */
    this.mStageRenderer = new Renderer();

    /** 
     * @protected 
     * @type {Object.<string, function(new: black-engine~Renderer)>} 
     */
    this.mRendererMap = {};

    Black.engine.viewport.on('resize', this.__onResize, this);
  }

  /**
   * A main render function.
   *
   * @public
   * @param {black-engine~GameObject} gameObject                    A GameObject instance to render onto RenderTarget.
   * @param {black-engine~CanvasRenderTexture} [renderTexture=null] Destination surface to render game object on. Will be rendered
   *                                                   onto backbuffer if null.
   * @param {black-engine~Matrix} [customTransform=null]            An optional extra offset.
   */
  render(gameObject, renderTexture = null, customTransform = null) {
  }

  /**
   * A factory method which returns new Renderer instance based on internal GameObject to Renderer map.
   *
   * @param {string} type      The type of the GameObject to find renderer for.
   * @param {black-engine~GameObject} owner The owner of this renderer.
   * @returns {black-engine~Renderer} New renderer instance.
   */
  getRenderer(type, owner) {
    return null;
  }

  /**
   * @ignore
   * @private
   * @returns {black-engine~RenderSession}
   */
  __saveSession() {
    let session = VideoNullDriver.sessionPool.get();
    session.reset();

    this.mSessions.push(session);

    this.mActiveSession = session;
    return session;
  }

  /**
   * @ignore
   * @private
   */
  __restoreSession() {
    this.mSessions.pop();
    this.mActiveSession = this.mSessions[this.mSessions.length - 1] || null;
  }

  /**
   * @ignore
   * @protected
   * @param {black-engine~RenderSession} session
   * @param {black-engine~GameObject} gameObject
   * @param {black-engine~Renderer} parentRenderer
   * @returns {void}
   */
  __collectParentRenderables(session, gameObject, parentRenderer) {
    let current = gameObject;
    if (current === null)
      return;

    let parents = [];
    for (current = current.parent; current !== null; current = current.parent)
      parents.splice(0, 0, current);

    for (let i = 0; i < parents.length; i++) {
      current = parents[i];

      let renderer = current.mRenderer;

      if (renderer == null)
        continue;

      session.parentRenderers.push(renderer);
      renderer.parent = parentRenderer;
      parentRenderer = renderer;

      renderer.preRender(this, session);

      if (renderer.endPassRequired === true)
        session.endPassParentRenderers.push(renderer);
    }
  }

  /**
   * Notifies renderer about new clipping.
   *
   * @protected
   * @param {black-engine~Rectangle} clipRect The region to clip.
   * @param {number} px Pivot-x.
   * @param {number} py Pivot-y.
   */
  beginClip(clipRect, px, py) {
  }

  /**
   * Notifies renderer to stop last clipping.
   * @protected
   */
  endClip() {
  }

  /**
   * @protected
   * @ignore
   * @param {black-engine~Message} msg
   * @param {black-engine~Rectangle} rect
   * @returns {void}
   */
  __onResize(msg, rect) {
    Renderer.__dirty = true;

    let w = this.mContainerElement.clientWidth;
    let h = this.mContainerElement.clientHeight;

    this.mClientWidth = w;
    this.mClientHeight = h;
  }

  /**
   * Initialization function.
   *
   * @protected
   * @return {void}
   */
  start() {
  }

  /**
   * Called before rendering anything. Usually used to clear back-buffer.
   *
   * @protected
   * @returns {void}
   */
  beginFrame() {
    this.clear();
  }

  /**
   * Called after rendering is finished.
   *
   * @protected
   * @returns {void}
   */
  endFrame() {
  }

  /**
   * @param {HTMLCanvasElement} canvas
   * @return {?black-engine~Texture}
   */
  getTextureFromCanvas(canvas) {
    return null;
  }

  /**
   * Sets world transformation for future use.
   *
   * @public
   * @param {black-engine~Matrix} m An transformation matrix to store.
   * @returns {void}
   */
  setTransform(m) {
    this.mTransform = m;
  }

  /**
   * Indicates if transform should be snapped to pixels.
   * @param {boolean} value 
   * @returns {void}
   */
  setSnapToPixels(value) {
    this.mSnapToPixels = value;
  }

  /**
   * Gets/Sets the global alpha. Used to calculate alpha relative to parent object.
   *
   * @protected
   * @return {number}
   */
  getGlobalAlpha() {
    return this.mGlobalAlpha;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  setGlobalAlpha(value) {
    this.mGlobalAlpha = value;
  }

  /**
   * Gets/Sets global blending mode. Used to calculate blend mode relative to parent object.
   *
   * @return {?black-engine~BlendMode}
   */
  getGlobalBlendMode() {
    return this.mGlobalBlendMode;
  }

  /**
   * @param {?black-engine~BlendMode} value
   * @return {void}
   */
  setGlobalBlendMode(value) {
    this.mGlobalBlendMode = value;
  }

  /**
   * Draws texture onto back-buffer. alpha, blend mode and transformation matrix must be set prior to calling this
   * method.
   *
   * @public
   * @param {black-engine~Texture} texture Instance of the Texture to draw.
   * 
   */
  drawTexture(texture) {
  }

  /**
   * Draws texture onto back-buffer with given offset. alpha, blend mode and transformation matrix must be set prior to calling this
   * method.
   *
   * @param {black-engine~Texture} texture Instance of the Texture to draw.
   * @param {number} ox Offset along x-axis
   * @param {number} oy Offset along y-axis
   */
  drawTextureWithOffset(texture, ox, oy) {
  }

  /**
   * Clears back-buffer.
   *
   * @protected
   * @returns {void}
   */
  clear() {
  }

  /**
   * Disposes all allocated resources.
   */
  dispose() {
    VideoNullDriver.sessionPool.releaseAll();
  }

  /** 
   * Returns current rendering context or null.
   * @returns {*}
   */
  get context() {
    return null;
  }

  /**
   * Returns device pixel ratio or 1 in case high DPR support is disabled.
   * 
   * @returns {number}
   */
  get renderScaleFactor() {
    return this.mDevicePixelRatio;
  }
}

/**
 * Recyclable session pool. Do not recycle manually.
 *
 * @type {black-engine~ObjectPool}
 * @nocollapse
 */
VideoNullDriver.sessionPool = new ObjectPool(RenderSession);

/**
 * Video driver responsible for rendering game objects onto HTML canvas element.
 *
 * @extends black-engine~VideoNullDriver
 * @cat drivers.canvas
 */
class CanvasDriver extends VideoNullDriver {
  /**
   * Creates new instance of CanvasDriver
   *
   * @param {HTMLElement} containerElement The DOM element to draw into.
   * @param {number} width                 The width of the viewport.
   * @param {number} height                The height of the viewport.
   */
  constructor(containerElement, width, height) {
    super(containerElement, width, height);

    /** 
     * @private 
     * @type {CanvasRenderingContext2D|null} 
     */
    this.mCtx = null;

    this.__createCanvas();

    /**
     * @private 
     * @inheritDoc 
     */
    this.mRendererMap = {
      'DisplayObject': DisplayObjectRendererCanvas,
      'Sprite': SpriteRendererCanvas,
      'Emitter': EmitterRendererCanvas,
      'Text': TextRendererCanvas,
      'BitmapText': BitmapTextRendererCanvas,
      'Graphics': GraphicsRendererCanvas
    };
  }

  getRenderer(type, owner) {
    let renderer = new this.mRendererMap[type]();
    renderer.gameObject = /** @type {DisplayObject} */ (owner);
    return renderer;
  }

  /**
   * @inheritDoc
   */
  render(gameObject, renderTexture = null, customTransform = null) {
    let isBackBufferActive = renderTexture === null;

    if (Renderer.skipUnchangedFrames === true && isBackBufferActive === true && Renderer.__dirty === false)
      return;

    let session = this.__saveSession();
    session.isBackBufferActive = isBackBufferActive;
    session.customTransform = customTransform;

    let parentRenderer = this.mStageRenderer;

    // RenderTexture related
    if (renderTexture !== null) {
      // Swap context
      this.mLastRenderTexture = this.mCtx;
      this.mCtx = renderTexture.renderTarget.context;

      // clear context cache
      this.mGlobalAlpha = -1;
      this.mGlobalBlendMode = null;

      parentRenderer.alpha = 1;
      parentRenderer.blendMode = BlendMode.NORMAL;
      parentRenderer.color = null;

      // collect parents of given GameObject
      this.__collectParentRenderables(session, gameObject, this.mStageRenderer);

      for (let i = 0, len = session.parentRenderers.length; i !== len; i++) {
        let renderer = session.parentRenderers[i];
        renderer.begin(this, session);

        if (renderer.skipSelf === false)
          renderer.upload(this, session);
      }

      if (session.parentRenderers.length > 0)
        parentRenderer = session.parentRenderers[session.parentRenderers.length - 1];
    }

    this.renderObject(gameObject, session, parentRenderer);

    if (renderTexture !== null) {
      while (session.endPassParentRenderers.length > 0)
        session.endPassParentRenderers.pop().end(this, session);

      this.mCtx = this.mLastRenderTexture;

      this.mGlobalAlpha = -1;
      this.mGlobalBlendMode = null;
    }

    this.__restoreSession();
  }

  /**
   * @ignore
   * @param {black-engine~GameObject} child 
   * @param {black-engine~RenderSession} session 
   * @param {black-engine~Renderer} parentRenderer
   */
  renderObject(child, session, parentRenderer) {
    let skipChildren = false;
    let renderer = /** @type {DisplayObject} */ (child).mRenderer;

    if (renderer != null) {
      renderer.parent = parentRenderer;
      renderer.preRender(this, session);

      for (let i = 0; i < child.mComponents.length; i++) {
        const comp = child.mComponents[i];
        comp.onRender();
      }
      /** @type {DisplayObject} */ (child).onRender();

      renderer.begin(this, session);

      if (renderer.skipSelf === false) {
        renderer.upload(this, session);
        renderer.render(this, session);
      }

      skipChildren = renderer.skipChildren;
    }

    if (skipChildren === false) {
      for (let i = 0; i < child.mChildren.length; i++)
        this.renderObject(child.mChildren[i], session, renderer || parentRenderer);
    }

    if (renderer != null && renderer.endPassRequired === true)
      renderer.end(this, session);
  }

  /**
   * @ignore
   * @private
   * @return {void}
   */
  __createCanvas() {
    let dpr = this.mDevicePixelRatio;

    let cvs = /** @type {HTMLCanvasElement} */ (document.createElement('canvas'));
    cvs.style.position = 'absolute';
    cvs.id = 'canvas';

    cvs.width = this.mClientWidth * dpr;
    cvs.height = this.mClientHeight * dpr;
    cvs.style.width = this.mClientWidth + 'px';
    cvs.style.height = this.mClientHeight + 'px';

    this.mContainerElement.appendChild(cvs);

    this.mCtx = /** @type {CanvasRenderingContext2D} */ (cvs.getContext('2d'));
  }

  /**
   * @ignore
   * @protected
   * @param {black-engine~Message} msg
   * @param {black-engine~Rectangle} rect
   * @returns {void}
   */
  __onResize(msg, rect) {
    super.__onResize(msg, rect);

    // canvas will reset state after changing size
    this.mGlobalBlendMode = null;
    this.mGlobalAlpha = -1;

    let dpr = this.mDevicePixelRatio;
    this.mCtx.canvas.width = this.mClientWidth * dpr;
    this.mCtx.canvas.height = this.mClientHeight * dpr;
    this.mCtx.canvas.style.width = this.mClientWidth + 'px';
    this.mCtx.canvas.style.height = this.mClientHeight + 'px';
  }

  /**
   * @inheritDoc
   */
  drawTexture(texture) {
    if (texture.isValid === false)
      return;

    let dpr = this.mDevicePixelRatio;

    let sourceX = texture.region.x;
    let sourceY = texture.region.y;
    let sourceWidth = texture.region.width;
    let sourceHeight = texture.region.height;

    let destX = texture.untrimmedRegion.x * dpr;
    let destY = texture.untrimmedRegion.y * dpr;
    let destWidth = texture.renderWidth * dpr;
    let destHeight = texture.renderHeight * dpr;

    this.mCtx.drawImage(texture.native, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
  }

  /**
   * @inheritDoc
   */
  drawTextureWithOffset(texture, ox, oy) {
    if (texture.isValid === false)
      return;

    let dpr = this.mDevicePixelRatio;

    let sourceX = texture.region.x;
    let sourceY = texture.region.y;
    let sourceWidth = texture.region.width;
    let sourceHeight = texture.region.height;

    let destX = (ox + texture.untrimmedRegion.x) * dpr;
    let destY = (oy + texture.untrimmedRegion.y) * dpr;
    let destWidth = texture.renderWidth * dpr;
    let destHeight = texture.renderHeight * dpr;

    this.mCtx.drawImage(texture.native, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
  }

  /**
   * @inheritDoc
   */
  beginClip(clipRect, px, py) {
    let dpr = this.mDevicePixelRatio;

    this.mCtx.save();
    this.mCtx.beginPath();
    this.mCtx.rect((clipRect.x + px) * dpr, (clipRect.y + py) * dpr, clipRect.width * dpr, clipRect.height * dpr);

    this.mCtx.clip();
  }

  /**
   * @inheritDoc
   */
  endClip() {
    this.mCtx.restore();

    this.mGlobalAlpha = -1;
    this.mGlobalBlendMode = null;
  }

  /**
   * @inheritDoc
   */
  setTransform(transform) {
    let dpr = this.mDevicePixelRatio;
    let session = this.mActiveSession;

    if (session.isBackBufferActive === false) {
      if (session.customTransform === null) {
        transform = transform.clone(); // TODO: too much allocations
        transform.data[4] -= Black.stage.mX;
        transform.data[5] -= Black.stage.mY;
      } else {
        transform = transform.clone(); // TODO: too much allocations
        transform.prepend(session.customTransform);
      }
    }

    if (Black.camera !== null) {
      transform = transform.clone();
      transform.prepend(Black.camera.worldTransformationInverted);
    }

    this.mTransform = transform;

    let mv = transform.value;
    Debug.isNumber(mv[0], mv[1], mv[2], mv[3], mv[4], mv[5]);

    if (this.mSnapToPixels === true)
      this.mCtx.setTransform(mv[0], mv[1], mv[2], mv[3], (mv[4] * dpr) | 0, (mv[5] * dpr) | 0);
    else
      this.mCtx.setTransform(mv[0], mv[1], mv[2], mv[3], mv[4] * dpr, mv[5] * dpr);
  }

  /**
   * @inheritDoc
   */
  setGlobalAlpha(value) {
    Debug.isNumber(value);

    if (value == this.mGlobalAlpha)
      return;

    this.mGlobalAlpha = value;
    this.mCtx.globalAlpha = value;
  }

  /**
   * @inheritDoc
   */
  setGlobalBlendMode(blendMode) {
    if (blendMode === BlendMode.AUTO)
      return;

    blendMode = CanvasBlendMode[blendMode];

    if (this.mGlobalBlendMode === blendMode)
      return;

    this.mGlobalBlendMode = blendMode;
    this.mCtx.globalCompositeOperation = blendMode;
  }

  /**
   * @inheritDoc
   */
  clear() {
    if (Renderer.skipUnchangedFrames === true && Renderer.__dirty === false)
      return;

    // TODO: clear only changed region
    this.mCtx.setTransform(1, 0, 0, 1, 0, 0);

    let viewport = Black.engine.viewport;
    if (viewport.isTransparent === false) {
      this.mCtx.fillStyle = ColorHelper.hexColorToString(viewport.backgroundColor);
      this.mCtx.fillRect(0, 0, viewport.size.width * this.mDevicePixelRatio, viewport.size.height * this.mDevicePixelRatio);
    } else {
      this.mCtx.clearRect(0, 0, viewport.size.width * this.mDevicePixelRatio, viewport.size.height * this.mDevicePixelRatio);
    }
  }

  /**
   * @inheritDoc
   */
  getTextureFromCanvas(canvas) {
    return new Texture(canvas);
  }

  /**
   * @override
   */
  dispose() {
    super.dispose();

    if (this.mCtx !== null)
      this.mCtx.canvas.remove();
  }

  /** 
   * Returns current rendering context or null.
   * @returns {CanvasRenderingContext2D}
   */
  get context() {
    return this.mCtx;
  }
}

/**
 * Class that holds information about tiling,
 * @cat display
 */
class TilingInfo {
  /**
   * Creates new TilingInfo instance.
   * 
   * @param {number} width  The width of destination texture.
   * @param {number} height The height of destination texture.
   * @param {number} scaleX Indicates how much source texture should be scaled along x-axis.
   * @param {number} scaleY Indicates how much source texture should be scaled along y-axis.
   * @param {number} wrapX  Indicates how many pixels needs to be wrapped around along x-axis.
   * @param {number} wrapY  Indicates how many pixels needs to be wrapped around along y-axis.
   */
  constructor(width = 0, height = 0, scaleX = 1, scaleY = 1, wrapX = 0, wrapY = 0) {
    /**
     * The width of destination texture.
     * @type {number}
     */
    this.width = width;

    /**
     * The height of destination texture.
     * @type {number}
     */
    this.height = height;

    /**
     * Indicates how much source texture should be scaled along x-axis.
     * @type {number}
     */
    this.scaleX = scaleX;

    /**
     * Indicates how much source texture should be scaled along y-axis.
     * @type {number}
     */
    this.scaleY = scaleY;

    /**
     * Indicates how many pixels needs to be wrapped around along x-axis.
     * @type {number}
     */
    this.wrapX = wrapX;

    /**
     * Indicates how many pixels needs to be wrapped around along y-axis.
     * @type {number}
     */
    this.wrapY = wrapY;
  }
}

/**
 * Sprite is used to render Texture onto screen.
 *
 * @cat display
 * @extends black-engine~DisplayObject
 */
class Sprite extends DisplayObject {
  /**
   * Creates a new Sprite instance.
   *
   * @param {black-engine~Texture|string|null} texture The Texture instance or null.
   */
  constructor(texture = null, useTextureProps = true) {
    super();

    /** 
     * @private 
     * @type {black-engine~Texture|null} 
     */
    this.mTexture = null;

    /** 
     * @private 
     * @type {string|null} 
     */
    this.mTextureName = null;

    /** 
     * @private 
     * @type {black-engine~TilingInfo|null} 
     */
    this.mTiling = null;

    /** 
     * @private 
     * @type {black-engine~Rectangle|null} 
     */
    this.mSlice9grid = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mUseTextureProps = useTextureProps;

    if (texture !== null && texture.constructor === String) {
      this.mTextureName = /** @type {string} */ (texture);
      this.texture = Black.assets.getTexture(/** @type {string} */(texture));
    } else {
      this.texture = /** @type {Texture} */ (texture);
    }
  }

  /**
   * @inheritDoc
   */
  getRenderer() {
    return Black.driver.getRenderer('Sprite', this);
  }

  /**
   * Returns a rectangle that completely encloses the object in local coordinate system.
   *
   * @protected
   * @param {black-engine~Rectangle=} outRect Rectangle to be returned.
   * @return {black-engine~Rectangle} The new Rectangle or outRect if it was passed as a param.
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    if (!this.mTexture)
      return outRect;

    if (this.mClipRect !== null)
      this.mClipRect.copyTo(outRect);
    else if (this.tiling !== null)
      outRect.set(0, 0, this.tiling.width, this.tiling.height);
    else
      outRect.set(0, 0, this.mTexture.displayWidth, this.mTexture.displayHeight);

    return outRect;
  }

  /**
   * Returns the current Texture on this sprite.
   *
   * @return {black-engine~Texture|null} The current texture set on this Sprite or null.
   */
  get texture() {
    return this.mTexture;
  }

  /**
   * Sets the Texture on this sprite by name.
   * Only Black.assets is used.
   *
   * @param {black-engine~Texture|null} texture Texture to apply on.
   * @return {void}
   */
  set texture(texture) {
    if (this.mTexture === texture)
      return;

    if (texture === null) {
      this.mTexture = null;
      this.mTextureName = null;

      this.setDirty(DirtyFlag.RENDER_CACHE, false);
      this.setRenderDirty();
      return;
    }

    this.mTexture = texture;

    if (this.mUseTextureProps === true) {
      if (texture.slice9borders)
        this.slice9grid = texture.slice9borders.clone();

      if (texture.registrationPoint !== null)
        this.alignPivotOffset(texture.registrationPoint.x, texture.registrationPoint.y);
    }

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setRenderDirty();
  }

  /**
   * Returns the current texture name.
   *
   * @return {?string}
   */
  get textureName() {
    return this.mTextureName;
  }

  /**
   * Sets the current texture by its name
   *
   * @param {?string} value
   */
  set textureName(value) {
    if (this.mTextureName === value)
      return;

    if (value === null) {
      this.texture = null;
      return;
    }

    this.mTextureName = value;
    this.texture = Black.assets.getTexture(/** @type {string} */(value));
  }

  /**
   * Gets sets tiling information.
   *
   * NOTE: after changing one of TilingInfo properties make sure to call `setDirty(DirtyFlag.RENDER_CACHE)`.
   *
   * @returns {black-engine~TilingInfo|null}
   */
  get tiling() {
    return this.mTiling;
  }

  /**
   * @param {black-engine~TilingInfo|null} value
   */
  set tiling(value) {
    this.mTiling = value;

    this.setRenderDirty();
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /**
   * Gets/sets nine slice grid rectangle.
   *
   * NOTE: after changing x, y, width or height of nine slice grid attributes make sure to call `setDirty(DirtyFlag.RENDER_CACHE)` to refresh renderer.
   *
   * @returns {black-engine~Rectangle|null}
   */
  get slice9grid() {
    return this.mSlice9grid;
  }

  /**
   * @param {black-engine~Rectangle|null} value
   */
  set slice9grid(value) {
    this.mSlice9grid = value;

    this.setRenderDirty();
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }
}

/**
 * @cat display.text
 * @static
 * @constant
 * @enum {string}
 */
const FontAlign = {
  NONE: 'none',
  LEFT: 'left',
  RIGHT: 'right',
  CENTER: 'center'
};

/**
 * @cat display.text
 * @static
 * @constant
 * @enum {string}
 */
const FontVerticalAlign = {
  TOP: 'top',
  MIDDLE: 'middle',
  BOTTOM: 'bottom'
};

/**
 * This class is used to create display text.
 *
 * @cat display.text
 * @fires TextField#change
 * @extends black-engine~DisplayObject
 */
class TextField extends DisplayObject {
  /**
   * Creates new instance of TextField
   * 
   * @param {string=} [text=''] Text to be displayed inside this text field
   * @param  {string=} family                                             Font name
   * @param  {number=} [color=0x0]                                        Text color as hexadecimal number eg 0xff0000 (total red)
   * @param  {number=} [size=14]                                          Text size
   * @param  {black-engine~FontStyle=} [style=black-engine~FontStyle.NORMAL]    Text style eg italic
   * @param  {black-engine~FontWeight=} [weight=black-engine~FontWeight.NORMAL] Font thickness. The value is set from 100 to 900 in increments of 100.
   * @param  {number=} [strokeThickness=0]                                Thickness of the stroke. 0 means that no stroke
   * @param  {number=} [strokeColor=0xffffff]                             Stroke color as hexadecimal number eg 0x00ff00 (total green)
   */
  constructor(text = '', family = 'sans-serif', color = 0x000000, size = 14, style = FontStyle.NORMAL, weight = FontWeight.NORMAL, strokeThickness = 0, strokeColor = 0xffffff) {
    super();

    /** 
     * @private 
     * @type {string} 
     */
    this.mText = text;

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mCacheBounds = new Rectangle();

    /** 
     * @private 
     * @type {number} 
     */
    this.mTextWidth = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTextHeight = 0;

    /** 
     * @private 
     * @type {black-engine~TextStyle} 
     */
    this.mDefaultStyle = new TextStyle(family, color, size, style, weight, strokeThickness, strokeColor);

    /** 
     * @private 
     * @type {Object.<string,black-engine~TextStyle>} 
     */
    this.mStyles = {};

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mAutoSize = true;

    /** 
     * @private 
     * @type {black-engine~FontAlign} 
     */
    this.mAlign = FontAlign.LEFT;

    /** 
     * @private 
     * @type {black-engine~FontVerticalAlign} 
     */
    this.mVerticalAlign = FontVerticalAlign.MIDDLE;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mMultiline = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mLineHeight = 1.2;

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mTextBounds = new Rectangle();

    /** 
     * @private 
     * @type {number} 
     */
    this.mFieldWidth = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mFieldHeight = 0;

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mPadding = new Rectangle(0, 0, 0, 0);

    /** 
     * @private 
     * @type {black-engine~TextMetricsData|null} 
     */
    this.mMetrics = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mHighQuality = false;
  }

  /**
   * @inheritDoc
   */
  getRenderer() {
    return Black.driver.getRenderer('Text', this);
  }

  /**
   * @inheritDoc
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    if (this.mDirty & DirtyFlag.RENDER_CACHE) {
      let text = this.text;
      if (this.mMultiline === false)
        text = text.replace(/\n/g, '');

      let styles = [this.mDefaultStyle];

      for (let key in /** @type {!Object} */(this.mStyles)) {
        styles.push(this.mStyles[key]);
      }

      this.mMetrics = TextMetricsEx.measure(text, this.mLineHeight, ...styles);
      this.mTextBounds.copyFrom(this.mMetrics.bounds);
    }

    if (this.mClipRect !== null) {
      this.mClipRect.copyTo(outRect);
      return outRect;
    }

    if (this.mAutoSize === false) {
      outRect.width = this.mFieldWidth;
      outRect.height = this.mFieldHeight;
    } else {
      outRect.width = this.mTextBounds.width;
      outRect.height = this.mTextBounds.height;
    }

    outRect.width += this.mPadding.right;
    outRect.height += this.mPadding.bottom;

    return outRect;
  }

  /**
   * Adds or updates given text style by given tag name.
   * 
   * @param {string} name 
   * @param {black-engine~TextStyle} style 
   */
  setStyle(name, style) {
    Debug.assert(name !== 'def', `Please use 'setDefaultStyle' instead.`);
    style.name = name;

    this.mStyles[name] = style;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Updates default text style with a given one.
   * 
   * @param {black-engine~TextStyle} style 
   */
  setDefaultStyle(style) {
    this.mDefaultStyle = style;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Removes style by given name.
   * 
   * @param {string} name 
   */
  removeStyle(name) {
    delete this.mStyles[name];

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Returns text style by given name or null if not found.
   * 
   * @param {string} name 
   * @return {black-engine~TextStyle} 
   */
  getStyle(name) {
    return this.mStyles.hasOwnProperty(name) ? this.mStyles[name] : null;
  }

  /**
   * Returns an array of all not default styles.
   * 
   * @return {Array<black-engine~TextStyle>} 
   */
  getAllStyles() {
    let styles = [];
    for (let s in this.mStyles)
      styles.push(this.mStyles[s]);
    return styles;
  }

  /**
   * Returns default text style.
   */
  getDefaultStyle(name) {
    return this.mDefaultStyle;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set multiline(value) {
    this.mMultiline = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Get/Set multiLine value switcher.
   *
   * @return {boolean}
   */
  get multiline() {
    return this.mMultiline;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set lineHeight(value) {
    this.mLineHeight = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Get/Set lines vertical offset. From top previous to top next line.
   *
   * @return {number}
   */
  get lineHeight() {
    return this.mLineHeight;
  }

  /**
   * Get/Set text size.
   *
   * @return {number}
   */
  get size() {
    return this.mDefaultStyle.size;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set size(value) {
    if (this.mDefaultStyle.size === value)
      return;

    this.mDefaultStyle.size = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Get/Set text font.
   *
   * @return {string}
   */
  get font() {
    return this.mDefaultStyle.family;
  }

  /**
   * @param {string} value
   * @return {void}
   */
  set font(value) {
    if (this.mDefaultStyle.family === value)
      return;

    this.mDefaultStyle.family = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Specifies text color as hexadecimal number eg 0xff0000 (total red).
   *
   * @return {number}
   */
  get textColor() {
    return this.mDefaultStyle.color;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set textColor(value) {
    if (this.mDefaultStyle.color === value)
      return;

    this.mDefaultStyle.color = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Gets/sets text alpha in range [0..1].
   * NOTE: This property will affect shadow alpha.
   *
   * @return {number}
   */
  get textAlpha() {
    return this.mDefaultStyle.alpha;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set textAlpha(value) {
    if (this.mDefaultStyle.alpha === value)
      return;

    this.mDefaultStyle.alpha = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Get/Set text style.
   *
   * @return {black-engine~FontStyle}
   */
  get fontStyle() {
    return this.mDefaultStyle.style;
  }

  /**
   * @param {black-engine~FontStyle} value
   * @return {void}
   */
  set fontStyle(value) {
    if (this.mDefaultStyle.style === value)
      return;

    this.mDefaultStyle.style = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Specifies the font thick. The value is set from 100 to 900 in increments of 100.
   *
   * @return {black-engine~FontWeight}
   */
  get weight() {
    return this.mDefaultStyle.weight;
  }

  /**
   * @param {black-engine~FontWeight} value
   * @return {void}
   */
  set weight(value) {
    if (this.mDefaultStyle.weight === value)
      return;

    this.mDefaultStyle.weight = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Specifies the horizontal alignment of the text (left | center | right).
   *
   * @return {black-engine~FontAlign}
   */
  get align() {
    return this.mAlign;
  }

  /**
   * @param {black-engine~FontAlign} value
   * @return {void}
   */
  set align(value) {
    if (this.mAlign === value)
      return;

    this.mAlign = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Specifies the vertical alignment of the text (top | middle | bottom).
   *
   * @return {black-engine~FontVerticalAlign}
   */
  get vAlign() {
    return this.mVerticalAlign;
  }

  /**
   * @param {black-engine~FontVerticalAlign} value
   * @return {void}
   */
  set vAlign(value) {
    if (this.mVerticalAlign === value)
      return;

    this.mVerticalAlign = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Specifies stroke color as hexadecimal number eg 0xff0000 (total red)
   * @return {number}
   */
  get strokeColor() {
    return this.mDefaultStyle.strokeColor;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set strokeColor(value) {
    if (this.mDefaultStyle.strokeColor === value)
      return;

    this.mDefaultStyle.strokeColor = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets  stroke alpha in range [0..1].
   * @return {number}
   */
  get strokeAlpha() {
    return this.mDefaultStyle.strokeAlpha;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set strokeAlpha(value) {
    if (this.mDefaultStyle.strokeAlpha === value)
      return;

    this.mDefaultStyle.strokeAlpha = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Specifies the thickness of the stroke. 0 means that no stroke.
   * Note: if autoSize is true stroke works like filter meaning that position of the text will not be adjusted and bounds will be the same.
   * 
   * @return {number} 
   */
  get strokeThickness() {
    return this.mDefaultStyle.strokeThickness;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set strokeThickness(value) {
    if (value === this.mDefaultStyle.strokeThickness)
      return;

    this.mDefaultStyle.strokeThickness = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Specifies the width of the text field. If autoSize set as false
   *
   * @return {number}
   */
  get fieldWidth() {
    return this.mFieldWidth;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set fieldWidth(value) {
    if (value === this.mFieldWidth)
      return;

    this.mFieldWidth = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /** Specifies the height of the text field, if autoSize set as false
   *
   * @return {number}
   */
  get fieldHeight() {
    return this.mFieldHeight;
  }


  /**
   * @param {number} value
   * @return {void}
   */
  set fieldHeight(value) {
    if (value === this.mFieldHeight)
      return;

    this.mFieldHeight = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Text to be displayed inside this text field.
   * @return {string}
   */
  get text() {
    return this.mText;
  }

  /**
   * @param {string} value
   * @return {void}
   */
  set text(value) {
    if (this.mText === value)
      return;

    this.mText = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();

    /**
     * Posts every time text has been changed.
     * @event TextField#change
     */
    this.post(Message.CHANGE);
  }

  /**
   * Determines whether the size of the field will adjust to the size of the text. Note: if this set as true, you need to specify fieldHeight and fieldWidth manually
   *
   * @return {boolean}
   */
  get autoSize() {
    return this.mAutoSize;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set autoSize(value) {
    if (this.mAutoSize === value)
      return;

    this.mAutoSize = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * An extra padding. Also useful for bad prepared fonts.
   *
   * @return {black-engine~Rectangle}
   */
  get padding() {
    return this.mPadding;
  }

  /**
   * @param {black-engine~Rectangle} value
   * @return {void}
   */
  set padding(value) {
    this.mPadding = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Gets sets whenever to drop shadow or not.
   * 
   * @return {boolean} 
   */
  get dropShadow() {
    return this.mDefaultStyle.dropShadow;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set dropShadow(value) {
    if (value === this.mDefaultStyle.dropShadow)
      return;

    this.mDefaultStyle.dropShadow = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }

  /**
   * Gets/sets the color of the shadow.
   * 
   * @return {number} 
   */
  get shadowColor() {
    return this.mDefaultStyle.shadowColor;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set shadowColor(value) {
    if (value === this.mDefaultStyle.shadowColor)
      return;

    this.mDefaultStyle.shadowColor = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets alpha component of the shadows.
   * 
   * @return {number} 
   */
  get shadowAlpha() {
    return this.mDefaultStyle.shadowAlpha;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set shadowAlpha(value) {
    if (value === this.mDefaultStyle.shadowAlpha)
      return;

    this.mDefaultStyle.shadowAlpha = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets the shadow blur radius.
   * 
   * @return {number} 
   */
  get shadowBlur() {
    return this.mDefaultStyle.shadowBlur;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set shadowBlur(value) {
    if (value === this.mDefaultStyle.shadowBlur)
      return;

    this.mDefaultStyle.shadowBlur = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets shadow distance on x axis.
   * 
   * @return {number} 
   */
  get shadowDistanceX() {
    return this.mDefaultStyle.shadowDistanceX;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set shadowDistanceX(value) {
    if (value === this.mDefaultStyle.shadowDistanceX)
      return;

    this.mDefaultStyle.shadowDistanceX = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets shadow distance on y axis.
   * 
   * @return {number} 
   */
  get shadowDistanceY() {
    return this.mDefaultStyle.shadowDistanceY;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set shadowDistanceY(value) {
    if (value === this.mDefaultStyle.shadowDistanceY)
      return;

    this.mDefaultStyle.shadowDistanceY = value;
    this.setDirty(/** @type {DirtyFlag} */(DirtyFlag.RENDER_CACHE | DirtyFlag.RENDER), false);
  }

  /**
   * Gets/sets render quality of this text field. False by default.
   * When true font will respect object's scale and device pixel ratio. The downside is it may cause font shaking when animating.
   * 
   * @returns {boolean}
   */
  get highQuality() {
    return this.mHighQuality;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set highQuality(value) {
    this.mHighQuality = value;

    this.setDirty(DirtyFlag.RENDER_CACHE, false);
    this.setTransformDirty();
  }
}

/**
 * This class is used to create display text.
 *
 * @cat display.text
 * @extends black-engine~DisplayObject
 */
class BitmapTextField extends DisplayObject {
  /**
   * Create new instance of BitmapTextField.
   *
   * @param {string|black-engine~BitmapFontData} font     The name of the bitmap font
   * @param {string=} text                   Text to be displayed inside this text field
   */
  constructor(font, text = '') {
    super();

    if (font !== null && font.constructor === String)
      this.mData = Black.assets.getBitmapFont(/** @type {string} */(font));
    else
      this.mData = /** @type {BitmapFontData} */ (font);

    /** 
     * @private 
     * @type {string} 
     */
    this.mText = text;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mAutoSize = true;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mMultiline = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mLineHeight = 1.2;

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mBounds = new Rectangle();

    /** 
     * @private 
     * @type {black-engine~Rectangle} 
     */
    this.mTextBounds = new Rectangle();

    /** 
     * @private 
     * @type {number} 
     */
    this.mFieldWidth = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mFieldHeight = 0;
  }

  /**
   * @inheritDoc
   */
  getRenderer() {
    return Black.driver.getRenderer('BitmapText', this);
  }

  /**
   * @inheritDoc
   */
  onGetLocalBounds(outRect = undefined) {
    outRect = outRect || new Rectangle();

    if (this.mClipRect !== null) {
      this.mClipRect.copyTo(outRect);
      return outRect;
    }

    if (this.mDirty & DirtyFlag.RENDER_CACHE) {
      let text = this.text;
      if (this.mMultiline === false)
        text = text.replace(/\n/g, '');

      TextMetricsEx.measureBitmap(text, this.mData, this.mLineHeight, this.mTextBounds);
    }

    if (this.mAutoSize === false) {
      outRect.width = this.mFieldWidth;
      outRect.height = this.mFieldHeight;
    } else {
      outRect.width = this.mTextBounds.width;
      outRect.height = this.mTextBounds.height;
    }

    return outRect;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set multiline(value) {
    this.mMultiline = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /**
   * Get/Set multiLine value switcher.
   *
   * @return {boolean}
   */
  get multiline() {
    return this.mMultiline;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set lineHeight(value) {
    this.mLineHeight = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /**
   * Get/Set lines vertical offset. From top previous to top next line.
   *
   * @return {number}
   */
  get lineHeight() {
    return this.mLineHeight;
  }

  /**
   * Specifies the width of the text field. If autoSize set as false
   *
   * @return {number}
   */
  get fieldWidth() {
    return this.mFieldWidth;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set fieldWidth(value) {
    if (value === this.mFieldWidth)
      return;

    this.mFieldWidth = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /** Specifies the height of the text field, if autoSize set as false
   *
   * @return {number}
   */
  get fieldHeight() {
    return this.mFieldHeight;
  }


  /**
   * @param {number} value
   * @return {void}
   */
  set fieldHeight(value) {
    if (value === this.mFieldHeight)
      return;

    this.mFieldHeight = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /**Text to be displayed inside this text field.

   * @return {string}
   */
  get text() {
    return this.mText;
  }

  /**
   * @param {string} value
   * @return {void}
   */
  set text(value) {
    if (this.mText === value)
      return;

    this.mText = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }

  /**
   * Determines whether the size of the field will adjust to the size of the text. Note: if this set as true, you need to specify fieldHeight and fieldWidth manually
   *
   * @return {boolean}
   */
  get autoSize() {
    return this.mAutoSize;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set autoSize(value) {
    if (this.mAutoSize === value)
      return;

    this.mAutoSize = value;
    this.setDirty(DirtyFlag.RENDER_CACHE, false);
  }
}

/**
 * A base class for Vector scatters.
 *
 * @cat scatters
 * @extends black-engine~Scatter
 */
class VectorScatterBase extends Scatter {
  /**
   * Creates new VectorScatter instance.
   */
  constructor() {
    super();

    /**
     * Cached last value of `getValueAt` result.
     * 
     * @public
     * @readonly
     * @type {black-engine~Vector}
     */
    this.value = new Vector();
  }

  /**
   * Returns random value.
   *
   * @return {black-engine~Vector}.
   */
  getValue() {
    return this.getValueAt(Math.random());
  }
}

/**
 * A base class for color scatters.
 *
 * @cat scatters
 * @extends Scatter
 */
class ColorScatterBase extends Scatter {  
  constructor() {
    super();

    /**
     * Cached last value of `getValueAt` result.
     * 
     * @readonly
     * @type {number}
     */
    this.value = 0;
  }
    
  /**
   * Returns random value.
   *
   * @return {number}
   */
  getValue() {
    return this.getValueAt(Math.random());
  }
}

/**
 * A color scatter.
 *
 * @cat scatters
 * @extends black-engine~FloatScatterBase
 */
class ColorScatter extends ColorScatterBase {
  /**
   * Creates new ColorScatter instance.
   * 
   * @param {number} [startColor=0]
   * @param {number} [endColor=null]
   * @param {?function(number):number} [ease=null] Easing function. If null linear function is used as default.
   */
  constructor(startColor, endColor = null, ease = null) {
    super();

    /**
     * Defines starting color
     * 
     * @type {number}
     */
    this.startColor = startColor;

    /**
     * Defines ending color
     * 
     * @type {number}
     */
    this.endColor = endColor === null ? startColor : endColor;

    /**
     * Optional easing function.
     * 
     * @type {number}
     */
    this.ease = ease;
  }

  getValueAt(t) {
    if (this.ease !== null)
      t = this.ease(t);

    this.value = this.startColor === this.endColor ? this.startColor : ColorHelper.lerpHSV(this.startColor, this.endColor, t);

    return this.value;
  }

  /**
   * Creates new ColorScatterBase from a set of numbers.
   *
   * @param {...number|black-engine~ColorScatterBase} values Set of values.
   * @returns {black-engine~ColorScatterBase}
   */
  static fromObject(...values) {
    if (values[0] instanceof ColorScatterBase)
      return /** @type {ColorScatterBase} */ (values[0]);

    return new ColorScatter(...values);
  }
}

/**
 * A vector scatter for defining a range in 2D space.
 *
 * @cat scatters
 * @extends black-engine~VectorScatterBase
 */
class VectorScatter extends VectorScatterBase {
  /**
   * Creates new VectorScatter instance.
   *
   * @param {number}  [minX=0]                     The min value along x-axis.
   * @param {number}  [minY=0]                     The min value along y-axis.
   * @param {number=} [maxX=null]                  The max value along x-axis.
   * @param {number=} [maxY=null]                  The max value along y-axis.
   * @param {?function(number):number} [ease=null] Easing function. If null linear function is used as default.
   */
  constructor(minX = 0, minY = 0, maxX = null, maxY = null, ease = null) {
    super();

    /**
     * A min value along x-axis.
     * 
     * @type {number}
     */
    this.minX = minX;

    /**
     * A min value along y-axis.
     * 
     * @type {number}
     */
    this.minY = minY;

    /**
     * A max value along x-axis.
     * 
     * @type {number}
     */
    this.maxX = maxX === null ? minX : maxX;

    /**
     * A max value along y-axis.
     * 
     * @type {number}
     */
    this.maxY = maxY === null ? minY : maxY;

    /**
     * Optional easing function.
     * 
     * @type {?function(Vector):Vector}
     */
    this.ease = ease;
  }

  /**
   * Returns a random Vector object at given position within a specified range.
   *
   * @override
   * @return {black-engine~Vector} Vector object with random values withing defined range.
   */
  getValue() {
    this.value.x = Math.random() * (this.maxX - this.minX) + this.minX;
    this.value.y = Math.random() * (this.maxY - this.minY) + this.minY;

    return this.value;
  }

  /**
   * Returns a Vector object at given position.
   *
   * @override
   * @param {number} t The position.
   * @return {black-engine~Vector} Vector object representing values in a range at given position.
   */
  getValueAt(t) {
    if (this.ease !== null)
      t = this.ease(t);

    this.value.x = this.minX + t * (this.maxX - this.minX);
    this.value.y = this.minY + t * (this.maxY - this.minY);

    return this.value;
  }

  /**
   * Creates new VectorScatter from a set of numbers.
   *
   * @param {...number|black-engine~VectorScatterBase} values Set of values.
   * @returns {black-engine~VectorScatterBase}
   */
  static fromObject(...values) {
    if (values[0] instanceof VectorScatterBase)
      return /** @type {VectorScatterBase} */ (values[0]);

    return new VectorScatter(...values);
  }
}

/**
 * Sets particle's starting velocity.
 *
 * @cat scatters
 * @extends black-engine~VectorScatterBase
 */
class VectorCurveScatter extends VectorScatterBase {
  /**
   * Creates new VectorCurveScatter instance.
   *
   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...
   */
  constructor(...points) {
    super();

    /** 
     * @private 
     * @type {black-engine~Curve} 
     */
    this.mCurve = new Curve();
    this.mCurve.baked = true;
    this.mCurve.set(...points);

    /**
     * @private
     * @type {Array<number>}
     */
    this.mPointsCache = points;

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mCache = new Vector();
  }

  /**
   * Updates curve with new array of points.
   * 
   * @param {Array<number>} value
   */
  set points(value) {
    this.mPointsCache = value;
    this.mCurve.set(...value);
  }

  /**
   * Returns list of points.
   * @returns {Array<number>}
   */
  get points() {
    return this.mPointsCache;
  }

  /**
   * Returns a Vector at given position on a curve.
   *
   * @override
   * @param {number} t The position.
   * @return {black-engine~Vector} Vector object representing a value on a curve at given position.
   */
  getValueAt(t) {
    this.mCurve.interpolate(t, this.mCache);

    return this.mCache;
  }
}

/**
 * A number scatter for defining a range in a circular shape.
 *
 * @cat scatters
 * @extends black-engine~VectorScatterBase
 */
class RadialScatter extends VectorScatterBase {
  /**
   * Creates new VectorScatter instance.
   *
   * @param {number} x The center of a circle along x-axis.
   * @param {number} y The center of a circle along y-axis.
   * @param {number} minRadius The min radius value.
   * @param {number} [maxRadius=null] The max radius value.
   */
  constructor(x = 0, y = 0, minRadius = 0, maxRadius = null) {
    super();

    /**
     * A min value along x-axis.
     * 
     * @type {number}
     */
    this.x = x;

    /**
     * A min value along y-axis.
     * 
     * @type {number}
     */
    this.y = y;

    /**
     * A max value along x-axis.
     * 
     * @type {number}
     */
    this.minRadius = minRadius;

    /**
     * A max value along y-axis.
     * 
     * @type {number}
     */
    this.maxRadius = maxRadius === null ? minRadius : maxRadius;
  }

  /**
   * Returns a random Vector object at given position within a range specified in the constructor.
   *
   * @override
   * @return {black-engine~Vector} Vector object with random values withing defined range.
   */
  getValue() {
    return this.getValueAt(Math.random());
  }

  /**
   * Returns a Vector object at given position.
   *
   * @override
   * @param {number} t The position.
   * @return {black-engine~Vector} Vector object representing values in a range at given position.
   */
  getValueAt(t) {
    const r = this.minRadius + t * (this.maxRadius - this.minRadius);

    const angle = Math.random() * 2 * Math.PI; // MathEx.PI2?
    const rSq = r * r;
    const rx = this.x + (Math.sqrt(rSq) * Math.cos(angle));
    const ry = this.y + (Math.sqrt(rSq) * Math.sin(angle));

    this.value.x = rx;
    this.value.y = ry;

    return this.value;
  }
}

/**
 * A number scatter for defining a range in 2D space on a curve.
 *
 * @cat scatters
 * @extends black-engine~FloatScatterBase
 */
class FloatCurveScatter extends FloatScatterBase {
  /**
   * Creates new FloatCurveScatter instance.
   *
   * @param {...number} points Coordinates: startX, startY, cpStartX, cpStartY, cpEndX, cpEndY, endX/start2X, endY/start2Y, cp2StartX, cp2StartX... 8 or 14 or 20...
   */
  constructor(...points) {
    super();

    /** 
     * @private 
     * @type {black-engine~Curve} 
     */
    this.mCurve = new Curve();
    this.mCurve.baked = true;
    this.mCurve.set(...points);

    /**
     * @private
     * @type {Array<number>}
     */
    this.mPointsCache = points;

    /** 
     * @private 
     * @type {black-engine~Vector} 
     */
    this.mCache = new Vector();
  }

  /**
   * Updates curve with new array of points.
   * 
   * @param {Array<number>} value
   */
  set points(value) {
    this.mPointsCache = value;
    this.mCurve.set(...value);
  }

  /**
   * Returns list of points.
   * @returns {Array<number>}
   */
  get points() {
    return this.mPointsCache;
  }

  /**
   * Returns a number at given position on a curve.
   *
   * @override
   * @param {number} t The position.
   * @return {number} A value on a curve at given position.
   */
  getValueAt(t) {
    this.mCurve.interpolate(t, this.mCache);

    this.value = this.mCache.y;
    return this.value;
  }
}

/**
 * Adds acceleration to particles along given direction.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class Acceleration extends Modifier {
  /**
   * Creates new Acceleration instance.
   *
   * @param {...(number|black-engine~VectorScatterBase)} values An VectorScatterBase which defines acceleration direction.
   */
  constructor(...values) {
    super(false);

    /** 
     * @type {black-engine~VectorScatterBase} Modifier's object to get values from.
     */
    this.scatter = VectorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    this.scatter.getValue();
    
    particle.ax += this.scatter.value.x;
    particle.ay += this.scatter.value.y;
  }
}

/**
 * Sets particle's alpha value according to its energy value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class AlphaOverLife extends Modifier {
  /**
   * Creates new AlphaOverLife instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values A starting and ending values of alpha property.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.alpha = this.scatter.getValueAt(particle.energy);
  }
}

/**
 * Sets particle's color value according to its energy value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class ColorOverLife extends Modifier {
  /**
   * Creates new ColorOverLife instance.
   *
   * @param {...(number|black-engine~ColorScatterBase)} values A starting and ending values of color property.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~ColorScatterBase} Modifier's object to get values from.  */
    this.scatter = ColorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.color = this.scatter.getValueAt(particle.energy);
  }
}

/**
 * Sets particle's scale value according to its energy value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class ScaleOverLife extends Modifier {
  /**
   * Creates new ScaleOverTime instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values A starting and ending values of scale property.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.scaleX = particle.scaleY = this.scatter.getValueAt(particle.energy);
  }
}

/**
 * Sets particle's rotation value according to its energy value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class RotationOverLife extends Modifier {
  /**
   * Creates new RotationOverLife instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values A starting and ending values of alpha property.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.r = this.scatter.getValueAt(particle.energy);
  }
}

/**
 * Sets particle's texture according to its energy value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class TextureOverLife extends Modifier {
  /**
   * Creates new TextureOverLife instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values A starting and ending values of textureIndex property.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.textureIndex = Math.round(this.scatter.getValueAt(particle.energy));
  }
}

/**
 * Changes particle alpha according to its life.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class AnchorOverLife extends Modifier {
  /**
   * Creates new Acceleration instance.
   *
   * @param {...(number|black-engine~VectorScatterBase)} values An VectorScatterBase which defines acceleration direction.
   */
  constructor(...values) {
    super(false);

    /** @type {black-engine~VectorScatterBase} Modifier's object to get values from.  */
    this.scatter = VectorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    this.scatter.getValueAt(particle.energy);

    particle.anchorX = this.scatter.value.x;
    particle.anchorY = this.scatter.value.y;
  }
}

/**
 * Rotates particle along velocity vector.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class Oriented extends Modifier {
  /**
   * Creates new instance of oriented modifier.
   */
  constructor(angleShift = 0) {
    super(false);

    /**
     * @type {number}
     */
    this.angleShift = angleShift;
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.r = (Math.atan2(particle.vy, particle.vx) * MathEx.RAD2DEG - (90 + this.angleShift)) * dt;
  }
}

/**
 * @ignore
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class VectorField extends Modifier {
  /**
   * Creates new instance of VectorField.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number=} [resolution=0.1]
   */
  constructor(x, y, width, height, resolution = 0.1) {
    super(false);

    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.resolution = resolution;
    this.field = [];

    this.widthScaled = Math.floor(this.width * this.resolution);
    this.heightScaled = Math.floor(this.height * this.resolution);

    this.reset();
  }

  /**
   * Resets this vector field data.
   *
   * @returns {void}
   */
  reset() {    
    this.field.splice(0, this.field.length); // why?

    for (let y = 0; y < this.heightScaled; y++)
      for (let x = 0; x < this.widthScaled; x++)
        this.field.push(new Vector(0, 0));
  }

  /**
   * Updates field data with a given callback function.
   *
   * @param {Function} fn
   * @returns {void}
   */
  setData(fn) {
    for (let y = 0; y < this.heightScaled; y++) {
      for (let x = 0; x < this.widthScaled; x++) {
        const index = x + y * this.widthScaled;
        fn(x, y, this.field[index]);
      }
    }
  }

  /**
   * Returns value at given position.
   * 
   * @param {number} x
   * @param {number} y
   * @returns {black-engine~Vector|null}
   */
  getVectorAt(x, y) {
    x = Math.floor(x * this.resolution);
    y = Math.floor(y * this.resolution);
    let ix = ~~(x + y * this.widthScaled);

    if (ix < 0 || ix >= this.field.length)
      return null;

    return this.field[ix];
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    let v = this.getVectorAt(particle.x, particle.y);

    if (v === null)
      return;

    particle.ax = v.x;
    particle.ay = v.y;
  }
}

/**
 * Sets initial particle life value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialLife extends Modifier {
  /**
   * Creates new InitialLife instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values Min and max values in seconds.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.life = this.scatter.getValue();
  }
}

/**
 * Sets initial particle mass value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialMass extends Modifier {
  /**
   * Creates new InitialMass instance.
   *
   * @param {...(number|Fblack-engine~loatScatterBase)} values Min and max values.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.mass = this.scatter.getValue();
  }
}

/**
 * Sets initial particle scale value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialScale extends Modifier {
  /**
   * Creates new InitialScale instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values Min and max values.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.scaleX = particle.scaleY = this.scatter.getValue();
  }
}

/**
 * Sets initial particle velocity vector.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialVelocity extends Modifier {
  /**
   * Creates new InitialVelocity instance.
   *
   * @param {...(number|black-engine~VectorScatterBase)} values Min and max vectors.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~VectorScatterBase} Modifier's object to get values from.  */
    this.scatter = VectorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    this.scatter.getValue();

    particle.vx = this.scatter.value.x;
    particle.vy = this.scatter.value.y;
  }
}

/**
 * Sets initial particle position.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialPosition extends Modifier {
  /**
   * Creates new InitialPosition instance.
   *
   * @param {...(number|black-engine~VectorScatterBase)} values Rectangle coordinates, its width and height.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~VectorScatterBase} Modifier's object to get values from.  */
    this.scatter = VectorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    let v = this.scatter.getValue();
    particle.x = v.x;
    particle.y = v.y;
  }
}

/**
 * Sets initial particle rotation value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialRotation extends Modifier {
  /**
   * Creates new InitialRotation instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values Min and max values in radians.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.r = this.scatter.getValue();
  }
}

/**
 * Sets initial particle texture.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialTexture extends Modifier {
  /**
   * Creates new InitialTexture instance.
   *
   * @param {...(number|black-engine~FloatScatterBase)} values Min and max indexes from texture list.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~FloatScatterBase} Modifier's object to get values from.  */
    this.scatter = FloatScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.textureIndex = Math.round(this.scatter.getValue());
  }
}

/**
 * Sets initial particle color value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialColor extends Modifier {
  /**
   * Creates new InitialLife instance.
   *
   * @param {...(number|black-engine~ColorScatterBase)} values Two color values.
   */
  constructor(...values) {
    super();

    /** @type {black-engine~ColorScatterBase} Modifier's object to get values from.  */
    this.scatter = ColorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    particle.color = this.scatter.getValue();
  }
}

/**
 * Sets initial particle scale value.
 *
 * @cat particles.modifiers
 * @extends black-engine~Modifier
 */
class InitialAnchor extends Modifier {
  /**
   * Creates new InitialScale instance.
   *
   * @param {...(number|black-engine~VectorScatterBase)} values
   */
  constructor(...values) {
    super();

    /** @type {black-engine~VectorScatterBase} Modifier's object to get values from.  */
    this.scatter = VectorScatter.fromObject(...values);
  }

  /**
   * @inheritDoc
   */
  update(emitter, particle, dt) {
    let v = this.scatter.getValue();
    particle.anchorX = v.x;
    particle.anchorY = v.y;
  }
}

/**
 * @readonly
 * @enum {number}
 * @cat input
 */
const Key = {
  /**
   * @type {number}
   */
  A: 65,
  /**
   * @type {number}
   */
  B: 66,
  /**
   * @type {number}
   */
  C: 67,
  /**
   * @type {number}
   */
  D: 68,
  /**
   * @type {number}
   */
  E: 69,
  /**
   * @type {number}
   */
  F: 70,
  /**
   * @type {number}
   */
  G: 71,
  /**
   * @type {number}
   */
  H: 72,
  /**
   * @type {number}
   */
  I: 73,
  /**
   * @type {number}
   */
  J: 74,
  /**
   * @type {number}
   */
  K: 75,
  /**
   * @type {number}
   */
  L: 76,
  /**
   * @type {number}
   */
  M: 77,
  /**
   * @type {number}
   */
  N: 78,
  /**
   * @type {number}
   */
  O: 79,
  /**
   * @type {number}
   */
  P: 80,
  /**
   * @type {number}
   */
  Q: 81,
  /**
   * @type {number}
   */
  R: 82,
  /**
   * @type {number}
   */
  S: 83,
  /**
   * @type {number}
   */
  T: 84,
  /**
   * @type {number}
   */
  U: 85,
  /**
   * @type {number}
   */
  V: 86,
  /**
   * @type {number}
   */
  W: 87,
  /**
   * @type {number}
   */
  X: 88,
  /**
   * @type {number}
   */
  Y: 89,
  /**
   * @type {number}
   */
  Z: 90,
  /**
   * @type {number}
   */
  DIGIT_0: 48,
  /**
   * @type {number}
   */
  DIGIT_1: 49,
  /**
   * @type {number}
   */
  DIGIT_2: 50,
  /**
   * @type {number}
   */
  DIGIT_3: 51,
  /**
   * @type {number}
   */
  DIGIT_4: 52,
  /**
   * @type {number}
   */
  DIGIT_5: 53,
  /**
   * @type {number}
   */
  DIGIT_6: 54,
  /**
   * @type {number}
   */
  DIGIT_7: 55,
  /**
   * @type {number}
   */
  DIGIT_8: 56,
  /**
   * @type {number}
   */
  DIGIT_9: 57,
  /**
   * @type {number}
   */
  NUMPAD_0: 96,
  /**
   * @type {number}
   */
  NUMPAD_1: 97,
  /**
   * @type {number}
   */
  NUMPAD_2: 98,
  /**
   * @type {number}
   */
  NUMPAD_3: 99,
  /**
   * @type {number}
   */
  NUMPAD_4: 100,
  /**
   * @type {number}
   */
  NUMPAD_5: 101,
  /**
   * @type {number}
   */
  NUMPAD_6: 102,
  /**
   * @type {number}
   */
  NUMPAD_7: 103,
  /**
   * @type {number}
   */
  NUMPAD_8: 104,
  /**
   * @type {number}
   */
  NUMPAD_9: 105,
  /**
   * @type {number}
   */
  NUMPAD_MULTIPLY: 106,
  /**
   * @type {number}
   */
  NUMPAD_ADD: 107,
  /**
   * @type {number}
   */
  NUMPAD_SUBTRACT: 109,
  /**
   * @type {number}
   */
  NUMPAD_DECIMAL: 110,
  /**
   * @type {number}
   */
  NUMPAD_DIVIDE: 111,
  /**
   * @type {number}
   */
  LEFT_ARROW: 37,
  /**
   * @type {number}
   */
  UP_ARROW: 38,
  /**
   * @type {number}
   */
  RIGHT_ARROW: 39,
  /**
   * @type {number}
   */
  DOWN_ARROW: 40,
  /**
   * @type {number}
   */
  BACKSPACE: 8,
  /**
   * @type {number}
   */
  TAB: 9,
  /**
   * @type {number}
   */
  ENTER: 13,
  /**
   * @type {number}
   */
  SHIFT: 16,
  /**
   * @type {number}
   */
  CTRL: 17,
  /**
   * @type {number}
   */
  ALT: 18,
  /**
   * @type {number}
   */
  F1: 112,
  /**
   * @type {number}
   */
  F2: 113,
  /**
   * @type {number}
   */
  F3: 114,
  /**
   * @type {number}
   */
  F4: 115,
  /**
   * @type {number}
   */
  F5: 116,
  /**
   * @type {number}
   */
  F6: 117,
  /**
   * @type {number}
   */
  F7: 118,
  /**
   * @type {number}
   */
  F8: 119,
  /**
   * @type {number}
   */
  F9: 120,
  /**
   * @type {number}
   */
  F10: 121,
  /**
   * @type {number}
   */
  F11: 122,
  /**
   * @type {number}
   */
  F12: 123,
  /**
   * @type {number}
   */
  PAUSE_BREAK: 19,
  /**
   * @type {number}
   */
  CAPS_LOCK: 20,
  /**
   * @type {number}
   */
  ESCAPE: 27,
  /**
   * @type {number}
   */
  PAGE_UP: 33,
  /**
   * @type {number}
   */
  PAGE_DOWN: 34,
  /**
   * @type {number}
   */
  END: 35,
  /**
   * @type {number}
   */
  HOME: 36,
  /**
   * @type {number}
   */
  INSERT: 45,
  /**
   * @type {number}
   */
  DELETE: 46,
  /**
   * @type {number}
   */
  LEFT_WINDOW: 91,
  /**
   * @type {number}
   */
  RIGHT_WINDOW: 92,
  /**
   * @type {number}
   */
  CONTEXT_MENU: 93,
  /**
   * @type {number}
   */
  NUM_LOCK: 144,
  /**
   * @type {number}
   */
  SCROLL_LOCK: 145,
  /**
   * @type {number}
   */
  SEMI_COLON: 186,
  /**
   * @type {number}
   */
  EQUAL_SIGN: 187,
  /**
   * @type {number}
   */
  COMMA: 188,
  /**
   * @type {number}
   */
  DASH: 189,
  /**
   * @type {number}
   */
  PERIOD: 190,
  /**
   * @type {number}
   */
  FORWARD_SLASH: 191,
  /**
   * @type {number}
   */
  BACKQUOTE: 192,
  /**
   * @type {number}
   */
  BRAKET_LEFT: 219,
  /**
   * @type {number}
   */
  BACK_SLASH: 220,
  /**
   * @type {number}
   */
  BRAKET_RIGHT: 221,
  /**
   * @type {number}
   */
  SINGLE_QUOTE: 222,
  /**
   * @type {number}
   */
  SPACE: 32
};

/**
 * A static class with many static easing functions.
 *
 * @cat animation
 * 
 * @static
 * @staticClass
 */
class Ease {
  /**
   * linear
   * 
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static linear(k) {
    return k;
  }

  /**
   * quadraticIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quadraticIn(k) {
    return k * k;
  }

  /**
   * quadraticOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quadraticOut(k) {
    return k * (2 - k);
  }

  /**
   * quadraticInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quadraticInOut(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;

    return -0.5 * (--k * (k - 2) - 1);
  }

  /**
   * cubicIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static cubicIn(k) {
    return k * k * k;
  }

  /**
   * cubicOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static cubicOut(k) {
    return --k * k * k + 1;
  }

  /**
   * cubicInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static cubicInOut(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;

    return 0.5 * ((k -= 2) * k * k + 2);
  }

  /**
   * quarticIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quarticIn(k) {
    return k * k * k * k;
  }

  /**
   * quarticOut
   * 
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quarticOut(k) {
    return 1 - (--k * k * k * k);
  }

  /**
   * quarticInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quarticInOut(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k * k;

    return -0.5 * ((k -= 2) * k * k * k - 2);
  }

  /**
   * quinticIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quinticIn(k) {
    return k * k * k * k * k;
  }

  /**
   * quinticOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quinticOut(k) {
    return --k * k * k * k * k + 1;
  }

  /**
   * quinticInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static quinticInOut(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k * k * k;

    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  }

  /**
   * sinusoidalIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static sinusoidalIn(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  }

  /**
   * sinusoidalOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static sinusoidalOut(k) {
    return Math.sin(k * Math.PI / 2);
  }

  /**
   * sinusoidalInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static sinusoidalInOut(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  }

  /**
   * exponentialIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static exponentialIn(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  }

  /**
   * exponentialOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static exponentialOut(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  }

  /**
   * exponentialInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static exponentialInOut(k) {
    if (k === 0)
      return 0;

    if (k === 1)
      return 1;

    if ((k *= 2) < 1)
      return 0.5 * Math.pow(1024, k - 1);

    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  }

  /**
   * circularIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static circularIn(k) {
    return 1 - Math.sqrt(1 - k * k);
  }

  /**
   * circularOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static circularOut(k) {
    return Math.sqrt(1 - (--k * k));
  }

  /**
   * circularInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static circularInOut(k) {
    if ((k *= 2) < 1)
      return -0.5 * (Math.sqrt(1 - k * k) - 1);

    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  }

  /**
   * elasticIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static elasticIn(k) {
    if (k === 0)
      return 0;

    if (k === 1)
      return 1;

    return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
  }

  /**
   * elasticOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static elasticOut(k) {
    if (k === 0)
      return 0;

    if (k === 1)
      return 1;

    return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
  }

  /**
   * elasticInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static elasticInOut(k) {
    if (k === 0)
      return 0;

    if (k === 1)
      return 1;

    k *= 2;

    if (k < 1)
      return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

    return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

  }

  /**
   * backIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static backIn(k) {
    const s = 1.70158;
    return k * k * ((s + 1) * k - s);
  }

  /**
   * backOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static backOut(k) {
    const s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  }

  /**
   * backInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static backInOut(k) {
    const s = 1.70158 * 1.525;

    if ((k *= 2) < 1)
      return 0.5 * (k * k * ((s + 1) * k - s));

    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  }

  /**
   * bounceIn
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static bounceIn(k) {
    return 1 - Ease.bounceOut(1 - k);
  }

  /**
   * bounceOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static bounceOut(k) {
    if (k < (1 / 2.75))
      return 7.5625 * k * k;
    else if (k < (2 / 2.75))
      return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
    else if (k < (2.5 / 2.75))
      return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;

    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
  }

  /**
   * bounceInOut
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static bounceInOut(k) {
    if (k < 0.5)
      return Ease.bounceIn(k * 2) * 0.5;

    return Ease.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }

  /**
   * smoothstep
   *
   * @param {number} k Value between 0 and 1
   * @return {number}
   */
  static smootherStep(k) {
    return k * k * k * (k * (6.0 * k - 15.0) + 10.0);
  }
}

/**
 * Interpolation functions.
 *
 * @cat animation
 * @static
 */
class Interpolation {
  /**
   * Linear interpolation.
   *
   * @param {Array}  v The input array of values to interpolate between.
   * @param {number} k The percentage of interpolation, between 0 and 1.
   * @param {function(number, number, number):number=} lerpFunction Interpolation function.
   * @return {number}  The interpolated value
   */
  static linear(v, k, lerpFunction) {
    let m = v.length - 1;
    let f = m * k;
    let i = Math.floor(f);

    lerpFunction = lerpFunction || MathEx.lerp;

    if (k < 0)
      return lerpFunction(v[0], v[1], f);

    if (k > 1)
      return lerpFunction(v[m], v[m - 1], m - f);

    return lerpFunction(v[i], v[i + 1 > m ? m : i + 1], f - i);
  }

  /**
   * Cubic bezier interpolation.
   *
   * @param {Array}  v The input array of values to interpolate between.
   * @param {number} k The percentage of interpolation, between 0 and 1.
   * @return {number}  The interpolated value
   */
  static bezier(v, k) {
    let b = 0;
    let n = v.length;
    let pow = Math.pow;
    // Bernstein basis polynomials
    let bn = (n, i) => {
      let fc = Interpolation.__factorial;
      return fc(n) / fc(i) / fc(n - i);
    };

    for (let i = 0; i < n; i++)
      b += pow(1 - k, n - i) * pow(k, i) * v[i] * bn(n, i);

    return b;
  }

  /**
   * Catmull Rom interpolation.
   *
   * @param {Array}  v The input array of values to interpolate between.
   * @param {number} k The percentage of interpolation, between 0 and 1.
   * @return {number}  The interpolated value
   */
  static catmullRom(v, k) {
    let m = v.length - 1;
    let f = m * k;
    let i = Math.floor(f);

    let fn = (p0, p1, p2, p3, t) => {
      let v0 = (p2 - p0) * 0.5;
      let v1 = (p3 - p1) * 0.5;
      let t2 = t * t;
      let t3 = t * t2;

      return ((p1 - p2) * 2 + v0 + v1) * t3 + ((p2 - p1) * 3 - 2 * v0 - v1) * t2 + v0 * t + p1;
    };

    if (v[0] === v[m]) {
      if (k < 0)
        i = Math.floor(f = m * (1 + k));

      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    } else {
      if (k < 0)
        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
      else if (k > 1)
        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);

      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
  }
}

/**
 * @private
 * @param {number} n
 * @return {number}
 */
Interpolation.__factorial = (function() {
  let a = [1];

  return function(n) {
    if (a[n])
      return a[n];

    let s = n;

    while (--n)
      s *= n;

    a[n] = s;
    return s;
  };
})();

var defaultEase = Ease.smootherStep;

/**
 * A tweening component.
 *
 * @fires Tween#start
 * @fires Tween#update
 * @fires Tween#loop
 * @fires Tween#complete 
 * 
 * @cat animation
 * @unrestricted
 * @extends black-engine~Component
 */
class Tween extends Component {
  /**
   * Creates new instance of Tween Component.
   * 
   * @param {Object}        values            The values to tween.
   * @param {number}        [duration=0.25]   Duraction in seconds.
   * @param {Object|null}   [properties=null] Tween properties Object.
   * @param {Object|null}   [plugins=null]    Interpolation plugins object
   */
  constructor(values, duration = 0.250, properties = null, plugins = null) {
    super();

    /** 
     * @private 
     * @dict 
     */
    this.mValues = values;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDuration = duration;

    /** 
     * @private 
     * @dict 
     */
    this.mProperties = properties;

    /** 
     * @private 
     * @dict 
     */
    this.mPlugins = plugins;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsPlaying = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsPaused = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStartTime = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mPausedTime = 0;

    /** 
     * @private 
     * @dict 
     */
    this.mValuesStart = {};

    /** 
     * @private 
     * @type {number} 
     */
    this.mElapsed = 0;

    /** 
     * @private 
     * @type {function (Array, number):number} 
     */
    this.mInterpolation = Interpolation.linear;

    /** 
     * @private 
     * @type {number} 
     */
    this.mDelay = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mRepeatDelay = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mRepeats = 0;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mInitiated = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mStarted = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mReversed = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mYoyo = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsYoyoBack = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mReverseOnInit = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mRemoveOnComplete = true;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPlayOnAdded = true;

    /** 
     * @private 
     * @type {function(number):number} 
     */
    this.mEase = defaultEase;

    if (this.mProperties !== null) {
      for (let f in this.mProperties) {
        this[f] = /** @dict */ (this.mProperties[f]);
      }
    }
  }

  /**
   * Sets/Gets active ease function.
   *
   * @return {function(number):number}
   */
  get ease() {
    return this.mEase;
  }

  /**
   * @param {function(number):number} value The easing function.
   * @return {void}
   */
  set ease(value) {
    this.mEase = value;
  }

  /**
   * Sets/Gets the interpolation algorithm. Possible values Interpolation.linear, Interpolation.bezier, Interpolation.catmullRom or your custom function.
   *
   * @return {function(Array, number):number}
   */
  get interpolation() {
    return this.mInterpolation;
  }

  /**
   * @param {function(Array, number):number} value The interpolation function.
   * @return {void}
   */
  set interpolation(value) {
    this.mInterpolation = value;
  }

  /**
   * Time elapsed since tween start in seconds.
   *
   * @readonly
   * @return {number}
   */
  get elapsed() {
    return this.mElapsed;
  }

  /**
   * Sets/Gets amount of seconds to wait before tweening.
   *
   * @return {number}
   */
  get delay() {
    return this.mDelay;
  }

  /**
   * @param {number} value Seconds to wait.
   * @return {void}
   */
  set delay(value) {
    this.mDelay = value;
  }

  /**
   * Gets/Sets the number of times the tween will be repeated after first execution.
   *
   * @return {number}
   */
  get repeats() {
    return this.mRepeats;
  }

  /**
   * @param {number} value Number of times.
   * @return {void}
   */
  set repeats(value) {
    this.mRepeats = value;
  }

  /**
   * Sets/Gets amount of seconds to wait between repeats.
   *
   * @return {number}
   */
  get repeatDelay() {
    return this.mRepeatDelay;
  }

  /**
   * @param {number} value Seconds to wait.
   * @return {void}
   */
  set repeatDelay(value) {
    this.mRepeatDelay = value;
  }

  /**
   * Gets/Sets if tween should be looped over.
   *
   * @return {boolean}
   */
  get loop() {
    return this.mRepeats === Infinity;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set loop(value) {
    this.mRepeats = value ? Infinity : 0;
  }

  /**
   * Enables/disables reversing between repeats.
   *
   * @return {boolean}
   */
  get yoyo() {
    return this.mYoyo;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set yoyo(value) {
    this.mYoyo = value;
  }

  /**
   * Enables/disables reversed playback on start.
   *
   * @return {boolean}
   */
  get reversed() {
    return this.mReversed;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set reversed(value) {
    this.mReversed = value;
  }

  /**
   * Sets/Gets whether the Tween Component should be automatically detached from owner GameObject after completion.
   *
   * @return {boolean}
   */
  get removeOnComplete() {
    return this.mRemoveOnComplete;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set removeOnComplete(value) {
    this.mRemoveOnComplete = value;
  }

  /**
   * Sets/Gets whether the tween should start playing automatically when added to the root.
   * 
   * @return {boolean}
   */
  get playOnAdded() {
    return this.mPlayOnAdded;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set playOnAdded(value) {
    this.mPlayOnAdded = value;
  }

  /**
   * Sets/Gets optional object with custom interpolation handler function for specific target properties.
   * 
   * @return {Object}
   */
  get plugins() {
    return this.mPlugins;
  }

  /**
   * @param {Object} value
   * @return {void}
   */
  set plugins(value) {
    this.mPlugins = value;
  }

  /**
   * Gets this tween duration.
   * 
   * @return {number}
   */
  get duration() {
    return this.mDuration;
  }

  /**
   * Indicated whether the tween is playing and not paused.
   * 
   * @return {boolean}
   */
  get isPlaying() {
    return this.mIsPlaying === true && this.mIsPaused === false;
  }

  /**
   * @private
   * @param {number} t
   * @return {void}
   */
  __start(t) {
    this.mIsPlaying = true;
    this.mStartTime = t + this.mDelay;
  }

  /**
   * Starts tweening.
   *
   * @return {black-engine~Tween} Returns this.
   */
  play() {
    if (!this.mIsPaused) {
      this.__start(Black.time.now);
    } else {
      this.__resume();
    }

    return this;
  }

  /**
   * Stops current tween.
   *
   * @return {black-engine~Tween} Returns this.
   */
  stop() {
    if (!this.mIsPlaying)
      return this;

    this.mIsPlaying = false;

    return this;
  }

  /**
   * Resets current tween.
   *
   * @return {black-engine~Tween} Returns this.
   */
  reset() {
    this.mElapsed = 0;
    if (this.mIsPlaying)
      this.play();

    return this;
  }

  /**
   * Sets the values for tweening.
   *
   * @param {Object} values Values to tween.
   * @param {number} [duration=0.25] Duration in seconds.
   * @return {black-engine~Tween} Returns this.
   */
  to(values = {}, duration = 0.250) {
    this.mValues = values;
    this.mDuration = duration;
    this.mInitiated = false;
    return this;
  }

  /**
   * Pauses current tween.
   *
   * @return {black-engine~Tween} Returns this.
   */
  pause() {
    if (!this.mIsPlaying)
      return this;

    this.mIsPaused = true;
    this.mPausedTime = Black.time.now;

    return this;
  }

  /**
   * @private
   * @return {void}
   */
  __resume() {
    if (!this.mIsPaused)
      return;

    this.mIsPaused = false;
    this.mStartTime += Black.time.now - this.mPausedTime;
  }

  /**
   * @inheritDoc
   */
  removeFromParent() {
    if (this.mIsPlaying)
      this.stop();

    super.removeFromParent();
  }

  /**
   * Add specified tween object into the queue. The specified tween will be executed after completion of this tween,
   *
   * @return {black-engine~Tween} Returns tween to chain.
   */
  chain(tween) {
    if (!tween) {
      return this;
    }

    this.mRemoveOnComplete = false;
    tween.playOnAdded = false;

    this.on(Message.COMPLETE, () => {
      tween.play();
    });

    return tween;
  }

  /**
   * @inheritDoc
   */
  onAdded(gameObject) {
    if (this.mPlayOnAdded) {
      this.__start(Black.time.now);
    }
  }

  /**
   * @private
   * @param {number} t
   * @return {void}
   */
  __update(t) {

  }

  /**
   * Updates tween values.
   *
   * @param {Object} values The Object to get values from.
   * @return {void}
   */
  set(values) {
    this.mValues = values;

    for (let f in this.mValues)
      this.mValuesStart[f] = parseFloat(this.gameObject[f]);
  }

  /**
   * Switches end values with start values.
   *
   * @param {boolean} asYoyo Indicates wether easing function should be also reversed.
   * @return {black-engine~Tween} Returns this.
   */
  reverse(asYoyo = false) {
    if (this.mInitiated) {
      this.__reverse();
    } else {
      this.mReverseOnInit = true;
    }

    if (asYoyo)
      this.mIsYoyoBack = !this.mIsYoyoBack;

    return this;
  }

  /**
   * @private
   * @return {void}
   */
  __reverse() {
    for (let f in this.mValues) {
      [this.mValues[f], this.mValuesStart[f]] = [this.mValuesStart[f], this.mValues[f]];
    }
  }

  onRender() {
    if (Black.engine.numUpdates !== 0)
      return;

    let time = Black.time.now;

    if (time < this.mStartTime || this.mIsPlaying === false || this.mIsPaused === true)
      return;

    if (this.mStarted === false || this.mInitiated === false)
      return;

    this.mElapsed = (time - this.mStartTime) / this.mDuration;

    if (this.mElapsed > 1)
      this.mElapsed = 1;

    let t = this.mEase(this.mIsYoyoBack ? 1 - this.mElapsed : this.mElapsed);

    for (let f in this.mValues) {
      let start = /** @type {number} */ (this.mValuesStart[f]);
      let end = /** @type {number|Array} */ (this.mValues[f]);

      if (this.mPlugins !== null && this.mPlugins.hasOwnProperty(f)) {
        let toLerp = Array.isArray(end) ? end : [start, end];
        this.gameObject[f] = Interpolation.linear(toLerp, t, this.mPlugins[f]);
      } else if (Array.isArray(end)) {
        this.gameObject[f] = this.mInterpolation(end, t);
      } else {
        this.gameObject[f] = /** @type {number} */ (start + (/** @type {number} */(end) - start) * (this.mIsYoyoBack ? 1 - t : t));
      }
    }
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    let t = Black.time.now;

    if (t < this.mStartTime || this.mIsPlaying === false || this.mIsPaused === true)
      return;

    this.__collectStartingValues();

    this.mElapsed = (t - this.mStartTime) / this.mDuration;

    if (this.mElapsed > 1)
      this.mElapsed = 1;

    let tt = this.mEase(this.mIsYoyoBack ? 1 - this.mElapsed : this.mElapsed);

    for (let f in this.mValues) {
      let start = /** @type {number} */ (this.mValuesStart[f]);
      let end = /** @type {number|Array} */ (this.mValues[f]);

      if (this.mPlugins !== null && this.mPlugins.hasOwnProperty(f)) {
        let toLerp = Array.isArray(end) ? end : [start, end];
        this.gameObject[f] = Interpolation.linear(toLerp, tt, this.mPlugins[f]);
      } else if (Array.isArray(end)) {
        this.gameObject[f] = this.mInterpolation(end, tt);
      } else {
        this.gameObject[f] = /** @type {number} */ (start + (/** @type {number} */(end) - start) * (this.mIsYoyoBack ? 1 - tt : tt));
      }
    }

    /**
     * Posted on every tween update. 
     * Note: tween can update object values inside `onRender` method without posting `black-engine~Tween#update` message.
     * @event Tween#update
     */
    this.post(Message.UPDATE, this.gameObject);

    if (this.mElapsed === 1) {
      if (this.mRepeats-- > 0) {
        if (this.mYoyo === true) {
          this.reverse(true);
        }

        this.mStartTime = t + this.mRepeatDelay;

        /**
         * Posted everytime tween is repeating.
         * @event Tween#loop
         */
        this.post('loop', this.gameObject);
      } else {
        this.mIsPlaying = false;

        /**
         * Posten when tween is finished.
         * @event Tween#complete
         */
        this.post(Message.COMPLETE, this.gameObject);

        if (this.mRemoveOnComplete) {
          this.removeFromParent();
        } else {
          for (let f in this.mValues) {
            this.mValuesStart[f] = this.mValues[f];
          }

          this.mStarted = false;
        }
      }
    }
  }

  __collectStartingValues() {
    if (this.mStarted === false) {
      this.mStarted = true;

      /**
       * Posted when tween started.
       * @event Tween#start
       */
      this.post('start', this.gameObject);

      for (let f in this.mValues) {
        if (!this.mInitiated && Array.isArray(this.mValues[f])) {
          this.mValues[f] = [this.gameObject[f]].concat(this.mValues[f]);
        }
        this.mValuesStart[f] = parseFloat(this.gameObject[f]);
      }

      if (this.mReversed === true || this.mReverseOnInit === true)
        this.__reverse();

      this.mInitiated = true;
    }
  }

  /**
   * Ease to be used in all tweens, if another ease is not specified. `Ease.smootherStep` is used.
   *
   * @returns {function(number):number}
   */
  static get defaultEase() {
    return defaultEase;
  }

  /**
   * @param {function(number):number} value The defaykt easing function.
   * @returns {void}
   */
  static set defaultEase(value) {
    defaultEase = value;
  }
}

/**
 * Holds details about sprite animation.
 *
 * @fires AnimationInfo#complete
 * @cat animation
 */
class AnimationInfo {
  /**
   * Creates an instance of Animation class
   *
   * @param {black-engine~AnimationController}    controller  Animation controller
   * @param {string}                 name        The name of animation
   * @param {Array<black-engine~Texture>}         frames      Array of Textures for this animation
   * @param {number}                 [fps=14]    Frame rate
   * @param {boolean}                [loop=true] Is animations should be looped
   */
  constructor(controller, name, frames, fps = 14, loop = true) {
    Debug.assert(fps > 0, 'FPS must be greater than 0.');

    /**
     * @private
     * @type {black-engine~AnimationController}
     */
    this.mController = controller;

    /**
     * @private
     * @type {string}
     */
    this.mName = name;

    /**
     * @private
     * @type {Array<black-engine~Texture>}
     */
    this.mFrames = frames;

    /**
     * @private
     * @type {number}
     */
    this.mCurrentFrame = 0;

    /**
     * @private
     * @type {number}
     */
    this.mNextFrameAt = 0;

    /**
     * @private
     * @type {number}
     */
    this.mFPS = fps;

    /**
     * @private
     * @type {number}
     */
    this.mFrameDuration = 1 / this.mFPS;

    /**
     * @private
     * @type {boolean}
     */
    this.mLoop = loop;

    /**
     * @private
     * @type {boolean}
     */
    this.mPaused = false;

    /**
     * @private
     * @type {number}
     */
    this.mElapsed = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.mStopped = false;

    /**
     * @private
     * @type {boolean}
     */
    this.mCompleted = false;
  }

  /**
   * Plays animation. If Animation is completed, current frame is reset to 0.
   * 
   * @ignore
   * @return {black-engine~Texture} Returns the current frame Texture.
   */
  __play() {
    if (this.mCompleted === true) {
      this.mCurrentFrame = 0;
      this.mElapsed = 0;
    }

    this.mPaused = false;
    this.mStopped = false;
    this.mCompleted = false;

    this.mNextFrameAt = Black.time.now + this.mFrameDuration - this.mElapsed;
    this.mElapsed = 0;

    return this.mFrames[this.mCurrentFrame];
  }

  /**
   * Stops animation and resets the value of current frame.
   *
   * @ignore
   * @return {void}
   */
  __stop() {
    this.mStopped = true;
    this.mCurrentFrame = 0;
  }

  /**
   * Pauses animation.
   *
   * @ignore
   * @return {void}
   */
  __pause() {
    this.mPaused = true;
    this.mElapsed = this.mNextFrameAt - Black.time.now;
  }

  /**
   * @ignore
   * @return {black-engine~Texture|null}
   */
  __update() {
    let t = Black.time.now;
    let dt = Black.time.dt;
    
    if (t < this.mNextFrameAt || this.mPaused === true || this.mStopped === true || this.mCompleted === true)
      return null;

    this.mCurrentFrame++;

    if (this.mCurrentFrame >= this.mFrames.length) {
      if (this.mLoop === true) {
        this.mCurrentFrame = 0;
      } else {
        this.mCurrentFrame = this.mFrames.length - 1;

        /**
         * Post messages when animation reach its end.
         *
         * @event AnimationInfo#complete
         */
        this.mController.post(Message.COMPLETE, this);
        this.mCompleted = true;
        return null;
      }
    }

    this.mNextFrameAt = Black.time.now + this.mFrameDuration;
    return this.mFrames[this.mCurrentFrame];
  }

  /**
   * Get/Set animation speed in frames per second.
   *
   * @return {number}
   */
  get fps() {
    return this.mFPS;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set fps(value) {
    Debug.assert(value > 0, 'FPS must be greater than 0.');

    this.mFPS = value;
    this.mFrameDuration = 1 / this.mFPS;

    // update next frame start time
    this.mNextFrameAt += this.mNextFrameAt - Black.time.now;
  }

  /**
   * Get/Set if animation should be looped.
   * @return {boolean}
   */
  get loop() {
    return this.mLoop;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set loop(value) {
    this.mLoop = value;
  }

  /**
   * Gets array of Texture.
   *
   * @return {Array<black-engine~Texture>}
   */
  get frames() {
    return this.mFrames;
  }

  /**
   * Returns true if Animation is playing (neither stopped nor paused).
   *
   * @return {boolean}
   */
  get isPlaying() {
    return this.mPaused === false && this.mStopped === false;
  }

  /**
   * Returns true if animation is completed.
   *
   * @return {boolean}
   */
  get isComplete() {
    return this.mCompleted;
  }

  /**
   * Returns name of this animation.
   *
   * @return {string}
   */
  get name() {
    return this.mName;
  }
}

/**
 * A Component which allows to play sprite animations.
 *
 * @cat animation
 * @extends black-engine~Component
 */
class AnimationController extends Component {
  /**
   * Creates an instance of AnimationController
   */
  constructor() {
    super();

    /**
     * @private
     * @type {Object<string, black-engine~AnimationInfo>}
     */
    this.mAnimations = {};

    /**
     * @private
     * @type {black-engine~AnimationInfo|null}
     */
    this.mCurrentAnim = null;
  }

  /**
   * Returns the AnimationInfo object that exists with the specified name.
   *
   * @param {string} name     The name of the child to return.
   * @returns {black-engine~AnimationInfo} Animation object that exists with the specified name.
   */
  getByName(name) {
    Debug.assert(name !== null, 'Animation must be set first.');
    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');

    return this.mAnimations[name];
  }

  /**
   * Removes Animation object that exists with the specified name. If animation is playing right now it will be stopped.
   *
   * @param {string} name The name of the animation to remove.
   * @returns {void}
   */
  remove(name) {
    Debug.assert(name !== null, 'Animation name shall not be null.');
    Debug.assert(this.mAnimations.hasOwnProperty(name) === true, 'Unable to find animation.');

    let anim = this.mAnimations[name];

    if (this.mCurrentAnim !== null && this.mCurrentAnim === anim) {
      this.stop();
      delete this.mAnimations[name];
    }

    this.mCurrentAnim = null;
  }

  /**
   * Add the Animation object into the list of animations. If animation with given name already exists exception will be thrown.
   *
   * @param {string}          name        The name of animation to update
   * @param {Array<black-engine~Texture>}  textures    Array of Textures
   * @param {number}          [fps=14]    Frames Per Second
   * @param {boolean}         [loop=true] Indicated if animation should be started over at the end.
   * @return {black-engine~AnimationInfo} The newly created Animation Object.
   */
  add(name, textures, fps = 14, loop = true) {
    Debug.assert(textures.length > 0, 'Animation cannot be empty.');
    Debug.assert(fps > 0, 'FPS must be greater than 0.');
    Debug.assert(this.mAnimations.hasOwnProperty(name) == false, 'Animation with same name already exists');

    let anim = new AnimationInfo(this, name, textures, fps, loop);
    this.mAnimations[name] = anim;

    return anim;
  }

  /**
   * Plays animation that exists with the specified name.
   *
   * @param {string} name The name of animation to play.
   * @return {void}
   */
  play(name) {
    Debug.assert(this.mAnimations.hasOwnProperty(name), 'Animation must be set first.');

    this.mCurrentAnim = this.mAnimations[name];

    let texture = this.mCurrentAnim.__play();

    let sprite = /** @type {Sprite} */ (this.gameObject);
    if (sprite === null)
      return;

    if (texture !== null)
      sprite.texture = texture;
  }

  /**
   * Stops active animation. If no animations are playing at the moment nothing will happen.
   *
   * @return {void}
   */
  stop() {
    if (this.mCurrentAnim === null)
      return;

    this.mCurrentAnim.__stop();
  }

  /**
   * Pauses active animation.
   * 
   * @return {void}
   */
  pause() {
    if (this.mCurrentAnim === null)
      return;

    this.mCurrentAnim.__pause();
  }

  /**
   * @inheritDoc
   */
  onRender() {
    if (this.mCurrentAnim === null)
      return;

    let newTexture = this.mCurrentAnim.__update();
    if (newTexture === null)
      return;

    let sprite = /** @type {black-engine~Sprite} */ (this.gameObject);
    sprite.texture = newTexture;
  }

  /**
   * Returns current active animation.
   *
   * @returns {black-engine~AnimationInfo|null}
   */
  get currentAnimation() {
    return this.mCurrentAnim;
  }
}

function addTexture(name, texture) {
  if (!texture)
    return null;

  let pages = this.pages;

  let page = null;
  for (let i = 0; i < pages.length; i++) {
    if (pages[i].baseTexture === texture.baseTexture) {
      page = pages[i];
      break;
    }
  }

  if (page === null) {
    page = new spine.TextureAtlasPage();
    page.name = 'texturePage';
    page.baseTexture = texture.native;
    pages.push(page);
  }

  let region = new spine.TextureAtlasRegion();
  region.name = name;
  region.page = page;
  region.texture = texture;
  region.index = -1;
  region.width = texture.width;
  region.height = texture.height;
  this.regions.push(region);
  return region;
}

/**
 * Esoteric Software SPINE wrapper for Black Engine
 *
 * @cat animation
 * @unrestricted
 * @nocompile
 * @extends DisplayObject
 */
class Spine extends DisplayObject {
  /**
   * Creates new instance of Spine.
   */
  constructor(name, texturesPath = '') {
    super();

    let json = Black.assets.getJSON(name);

    let fakeLoader = function (path, loaderFunction, callback) {
      console.log('FAKE LOADER', path);
    };

    let spineAtlas = new spine.TextureAtlas('', fakeLoader);
    spineAtlas.addTexture = addTexture;

    let regions = {};

    for (let skinName in json.skins) {
      let skin = json.skins[skinName];

      for (let slotName in skin) {
        let slot = skin[slotName];

        for (let entryName in slot) {
          let attachment = slot[entryName];

          if (attachment.type === 'point')
            continue;

          if (attachment.type === 'path')
            continue;
          
          if (attachment.type === 'clipping')
            continue;

          let textureName = attachment.path || entryName;

          if (attachment.name)
            textureName = attachment.name;

          if (regions[textureName])
            continue;

          regions[textureName] = spineAtlas.addTexture(textureName, Black.assets.getTexture(texturesPath + textureName));
        }
      }
    }

    let attachmentParser = new spine.AtlasAttachmentLoader(spineAtlas);
    let spineJsonParser = new spine.SkeletonJson(attachmentParser);
    let skeletonData = spineJsonParser.readSkeletonData(json);

    this.mSkeleton = new spine.Skeleton(skeletonData);
    this.mSkeleton.updateWorldTransform();

    this.mStateData = new spine.AnimationStateData(skeletonData);

    this.mState = new spine.AnimationState(this.mStateData);

    this.mTempClipContainers = [];
    this.mTexturesPath = texturesPath;

    for (let i = 0, len = this.mSkeleton.slots.length; i < len; i++) {
      let slot = this.mSkeleton.slots[i];
      let attachment = slot.attachment;

      let slotContainer = new DisplayObject();
      slot.container = slotContainer;

      this.addChild(slotContainer);
      this.mTempClipContainers.push(null);

      if (attachment instanceof spine.RegionAttachment) {
        let spriteName = attachment.region.name;

        let sprite = this._createSprite(slot, attachment, spriteName);
        slot.currentSprite = sprite;
        slot.currentSpriteName = spriteName;
        slotContainer.addChild(sprite);
      }
    }

    this.mState.addListener({ complete: x => this.post('animationComplete', x.animation.name) });
  }

  get skeleton() {
    return this.mSkeleton;
  }

  play(name, loop = false) {
    this.mState.setAnimation(0, name, loop);
  }

  setMixing(from, to, dur) {
    this.mStateData.setMix(from, to, dur);
  }

  setTransition(from, to, loop, dur = 0, viseversaDur = 0) {
    let h = (t) => {
      if (t.animation.name === from)
        this.play(to, loop);
    };

    this.mState.addListener({ complete: h });

    if (dur > 0)
      this.mStateData.setMix(from, to, dur);
    if (viseversaDur > 0)
      this.mStateData.setMix(to, from, viseversaDur);
  }

  changeSlotAttachment(slotName, attachmentName) {
    this.mSkeleton.setAttachment(slotName, attachmentName);
  }

  onUpdate() {
    let dt = Black.time.delta;
    this.mState.update(dt);
    this.mState.apply(this.mSkeleton);
    this.mSkeleton.updateWorldTransform();
    let slots = this.mSkeleton.slots;

    for (let i = 0, n = slots.length; i < n; i++) {
      let slot = slots[i];
      let attachment = slot.attachment;

      let sprite = slot.currentSprite;
      let wrapper = slot.container;

      if (!attachment) {
        wrapper.visible = false;
        continue;
      }

      wrapper.visible = true;

      if (attachment instanceof spine.RegionAttachment) {
        let region = attachment.region;

        if (region) {

          if (!slot.currentSpriteName || slot.currentSpriteName !== region.name) {
            let spriteName = region.name;
            if (slot.currentSprite) {
              slot.currentSprite.visible = false;
            }
            slot.sprites = slot.sprites || {};
            if (slot.sprites[spriteName] !== undefined) {
              slot.sprites[spriteName].visible = true;
            }
            else {
              let sprite = this._createSprite(slot, attachment, spriteName);
              wrapper.addChild(sprite);
            }
            slot.currentSprite = slot.sprites[spriteName];
            slot.currentSpriteName = spriteName;
            sprite = slot.currentSprite;
          }
        }

        let bone = slot.bone;
        let w = region.width;
        let h = region.height;

        let regionHeight = region.rotate ? region.width : region.height;

        sprite.scaleX = attachment.scaleX * (attachment.width / region.width);
        sprite.scaleY = attachment.scaleY * (attachment.height / region.height);

        let radians = -attachment.rotation * Math.PI / 180;
        sprite.rotation = radians;

        let cos = Math.cos(radians);
        let sin = Math.sin(radians);
        let shiftX = -attachment.width / 2 * attachment.scaleX;
        let shiftY = -attachment.height / 2 * attachment.scaleY;
        sprite.x = attachment.x + shiftX * cos - shiftY * sin;
        sprite.y = -attachment.y + shiftX * sin + shiftY * cos;

        wrapper.x = bone.worldX;
        wrapper.y = -bone.worldY;

        wrapper.rotation = Math.atan2(-bone.c, bone.a);

        let flipX = 1;
        let flipY = 1;

        let wsx = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
        let wsy = Math.sqrt(bone.b * bone.b + bone.d * bone.d);

        wrapper.scaleX = wsx * flipX;
        wrapper.scaleY = wsy * flipY;

        wrapper.alpha = this.mSkeleton.color.a * slot.color.a * attachment.color.a;

      } else if (attachment instanceof spine.PointAttachment) {
        wrapper.x = slot.bone.worldX + attachment.x;
        wrapper.y = -slot.bone.worldY - attachment.y;
      }
    }
  }

  _createSprite(slot, attachment, name) {
    let region = attachment.region;
    
    if (slot.tempAttachment === attachment) {
      region = slot.tempRegion;
      slot.tempAttachment = null;
      slot.tempRegion = null;
    }

    let sprite = new Sprite(this.mTexturesPath + name);
    sprite.alpha = attachment.color.a;
    sprite.region = attachment.region;
    this._setSpriteRegion(attachment, sprite, attachment.region);

    slot.sprites = slot.sprites || {};
    slot.sprites[name] = sprite;
    return sprite;
  }

  _setSpriteRegion(attachment, sprite, region) {
    sprite.region = region;
    if (!region.size) {
      sprite.scaleX = attachment.scaleX * attachment.width / region.width;
      sprite.scaleY = -attachment.scaleY * attachment.height / region.height;
    } else {
      //hacked!
      sprite.scaleX = region.size.width / region.width;
      sprite.scaleY = -region.size.height / region.height;
    }
  }
}

/**
 * Distortion sound effect.
 * 
 * @cat audio.effects
 * @extends {black-engine~SoundEffect}
 */
class DistortionEffect extends SoundEffect {

  /**
   * Creates new instance of DistortionEffect
   * 
   * @param {number} value Level of distortion.
   */
  constructor(value = 0.5) {
    super();

    /** 
     * @private 
     * @type {WaveShaperNode} 
     */
    this.mWaveShaperNode = Black.audio.context.createWaveShaper();

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mInputNode = this.mWaveShaperNode;

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mOutputNode = this.mWaveShaperNode;

    /** 
     * @private 
     * @type {number} 
     */
    this.mSamples = 44100;

    /** 
     * @private 
     * @type {Float32Array} 
     */
    this.mCurve = new Float32Array(this.mSamples);

    /** 
     * @private 
     * @type {number}
     */
    this.mValue = value;

    this.distortion = value;
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set distortion(value) {
    this.mValue = MathEx.clamp(value, 0, 1);
    this.__makeDistortionCurve(this.mValue, this.mSamples, this.mCurve);
    this.mWaveShaperNode.curve = this.mCurve;
  }

  /**
   * Gets/Sets level of distortion
   * 
   * @public
   * @returns {number}
   */
  get distortion() {
    return this.mValue;
  }

  // https://stackoverflow.com/a/22313408
  /**
   * @ignore
   * @private
   * @param {number} amount 
   * @param {number} n_samples 
   * @param {Float32Array} curve 
   * @returns {Float32Array}
   */
  __makeDistortionCurve(amount, n_samples, curve) {
    let k = ~~(amount * 100);
    let deg = Math.PI / 180;
    let x = 0;
    for (let i = 0; i < n_samples; ++i) {
      x = i * 2 / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  };

  // tuna.js

//   makeDistortionCurve2(amount, n_samples, curve) {
//     amount = Math.min(amount, 0.9999);
//     let k = 2 * amount / (1 - amount),
//         i, x;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
//     }
//   }

//   makeDistortionCurve3(amount, n_samples, curve) {
//     let i, x, y;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         y = ((0.5 * Math.pow((x + 1.4), 2)) - 1) * y >= 0 ? 5.8 : 1.2;
//         curve[i] = tanh(y);
//     }
//   }

//   makeDistortionCurve4(amount, n_samples, curve) {
//     let i, x, y, a = 1 - amount;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         y = x < 0 ? -Math.pow(Math.abs(x), a + 0.04) : Math.pow(x, a);
//         curve[i] = tanh(y * 2);
//     }
//   }

//   // is it working?
//   makeDistortionCurve5(amount, n_samples, curve) {
//     let i, x, y, abx, a = 1 - amount > 0.99 ? 0.99 : 1 - amount;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         abx = Math.abs(x);
//         if (abx < a) y = abx;
//         else if (abx > a) y = a + (abx - a) / (1 + Math.pow((abx - a) / (1 - a), 2));
//         else if (abx > 1) y = abx;
//         curve[i] = sign(x) * y * (1 / ((a + 1) / 2));
//     }
//   }

//   makeDistortionCurve6(amount, n_samples, curve) {
//     let i, x;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         if (x < -0.08905) {
//             curve[i] = (-3 / 4) * (1 - (Math.pow((1 - (Math.abs(x) - 0.032857)), 12)) + (1 / 3) * (Math.abs(x) - 0.032847)) + 0.01;
//         } else if (x >= -0.08905 && x < 0.320018) {
//             curve[i] = (-6.153 * (x * x)) + 3.9375 * x;
//         } else {
//             curve[i] = 0.630035;
//         }
//     }
//   }

//   // is it working?
//   makeDistortionCurve7(amount, n_samples, curve) {
//     let a = 2 + Math.round(amount * 14),
//     bits = Math.round(Math.pow(2, a - 1)),
//     i, x;
//     for (i = 0; i < n_samples; i++) {
//         x = i * 2 / n_samples - 1;
//         curve[i] = Math.round(x * bits) / bits;
//     }
//   }
}

// function sign(x) {
//   if (x === 0) {
//       return 1;
//   } else {
//       return Math.abs(x) / x;
//   }
// }

// function tanh(n) {
//   return (Math.exp(n) - Math.exp(-n)) / (Math.exp(n) + Math.exp(-n));
// }

/**
 * Equalizer.
 * 
 * @cat audio.effects
 * @extends {black-engine~SoundEffect}
 */
class SimpleEQ extends SoundEffect {
  /**
   * Creates new instance of equalizer.
   * 
   * @param {...number} frequencies List of frequencies to control sound with.
   */
  constructor(...frequencies) {
    super();

    // default values from winamp
    frequencies = frequencies || [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000];

    /** 
     * @private 
     * @type {Array<BiquadFilterNode>} 
     */
    this.mFilters = [];

    for (let i = 0; i < frequencies.length; i++) {
      this.mFilters.push(this.__createFilter(frequencies[i]));
      if (i > 0)
        this.mFilters[i - 1].connect(/** @type {!AudioNode} */ (this.mFilters[i]));
    }

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mInputNode = this.mFilters[0];

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mOutputNode = this.mFilters[this.mFilters.length - 1];

    // todo: determine correct max value
    /** 
     * @private 
     * @type {number} 
     */
    this.mMaxGainLevel = 16; // 18

    /** 
     * @private 
     * @type {Object.<string, Array<number>>} 
     */
    this.mPresets = {};
  }

  /**
   * @ignore
   * @private
   * @param {number} freq 
   * @returns {BiquadFilterNode}
   */
  __createFilter(freq) {
    let f = Black.audio.context.createBiquadFilter();
    f.type = 'peaking';
    f.frequency.setValueAtTime(freq, 0);
    f.Q.setValueAtTime(1, 0);
    f.gain.setValueAtTime(0, 0);
    return f;
  }

  /**
   * Sets level by index.
   * 
   * @public
   * @param {number} freqIndex Index of frequency from the list.
   * @param {number} value     Ranging from -1 to 1.
   * @returns {void}
   */
  setLevelByIndex(freqIndex, value) {
    Debug.assert(freqIndex >= 0 && freqIndex < this.mFilters.length, 'Frequency index is out of range');
    if (freqIndex < 0 || freqIndex >= this.mFilters.length)
      return;
    value = MathEx.clamp(value, -1, 1);
    value *= this.mMaxGainLevel;
    this.mFilters[freqIndex].gain.setValueAtTime(value, 0);
  }

  /**
   * Sets level by frequency if there is one in the list.
   * 
   * @public
   * @param {number} freq  Concrete frequency value.
   * @param {number} value Ranging from -1 to 1.
   * @returns {void}
   */
  setLevelByFrequency(freq, value) {
    for (let i = 0; i < this.mFilters.length; i++) {
      if (this.mFilters[i].frequency.value === freq) {
        this.setLevelByIndex(i, value);
      }
    }
  }

  /**
   * Adds new preset of levels.
   * 
   * @public
   * @param {string} name      The name of a preset.
   * @param {...number} values Frequency levels. Their number must be equal to frequencies number.
   * @returns {void}
   */
  addPreset(name, ...values) {
    Debug.assert(values.length != this.mFilters.length, 'Number of preset values must be equal to frequencies number');
    this.mPresets[name] = values;
  }

  /**
   * Saves current levels as new preset with given name.
   * 
   * @public
   * @param {string} name The name of a preset.
   * @returns {void}
   */
  savePreset(name) {
    this.mPresets[name] = [];
    this.mFilters.forEach(x => this.mPresets[name].push(x.frequency.value / this.mMaxGainLevel));
  }

  /**
   * Applies previously added or saved preset.
   * 
   * @public
   * @param {string} name The name of a preset.
   * @returns {void}
   */
  applyPreset(name) {
    if (this.mPresets[name] !== null) {
      for (let i = 0; i < this.mPresets[name].length; i++) {
        this.setLevelByIndex(i, this.mPresets[name][i]);
      }
    }
  }
}

/**
 * Reverberation sound effect.
 * 
 * @cat audio.effects
 * @extends {black-engine~SoundEffect}
 */
class ReverbEffect extends SoundEffect {
  /**
   * Creates instance of ReverbEffect.
   * 
   * @param {AudioBuffer} IRBuffer Impulse Response audio buffer.
   */
  constructor(IRBuffer) {
    super();

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mInputNode = Black.audio._newGainNode();

    /** 
     * @protected 
     * @type {AudioNode} 
     */
    this.mOutputNode = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {ConvolverNode} 
     */
    this.mConvolver = Black.audio.context.createConvolver();

    /** 
     * @private 
     * @type {GainNode} 
     */
    this.mDry = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {GainNode} 
     */
    this.mWet = Black.audio._newGainNode();

    /** 
     * @private 
     * @type {BiquadFilterNode} 
     */
    this.mTone = Black.audio.context.createBiquadFilter();

    this.mConvolver.buffer = IRBuffer;

    this.mInputNode.connect(this.mDry);
    this.mDry.connect(this.mOutputNode);

    this.mInputNode.connect(this.mTone);
    this.mTone.connect(this.mConvolver);
    this.mConvolver.connect(this.mWet);
    this.mWet.connect(this.mOutputNode);

    this.mDry.gain.setValueAtTime(1, 0);
    this.mWet.gain.setValueAtTime(0, 0);
    this.mTone.type = 'lowpass';
    this.mTone.frequency.setValueAtTime(350, 0);
    this.mTone.Q.setValueAtTime(Math.SQRT1_2, 0);
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set wet(value) {
    value = MathEx.clamp(value, 0, 1);
    this.mWet.gain.setValueAtTime(value, 0);
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set dry(value) {
    value = MathEx.clamp(value, 0, 1);
    this.mDry.gain.setValueAtTime(value, 0);
  }

  /**
   * @public
   * @param {number} value
   * @returns {void}
   */
  set tone(value) {
    value = MathEx.clamp(value, 10, Black.audio.context.sampleRate / 2);
    this.mTone.frequency.setValueAtTime(value, 0);
  }

  /**
   * Gets/Sets level of convolved sound.
   * 
   * @public
   * @returns {number}
   */
  get wet() {
    return this.mWet.gain.value;
  }

  /**
   * Gets/Sets level of original sound with no effect.
   * 
   * @public
   * @returns {number}
   */
  get dry() {
    return this.mDry.gain.value;
  }

  /**
   * Gets/Sets frequency effect is applied on.
   * 
   * @public
   * @returns {number}
   */
  get tone() {
    return this.mTone.frequency.value;
  }
}

/**
 * The sound component.
 * 
 * @cat audio
 * @extends {black-engine~Component}
 */
class Sound extends Component {
  /**
   * Creates new instance of SoundComponent.
   * 
   * @param {string} name                    The name of sound. Uses Black.assets only.
   * @param {string=} [channel='master']     The name of channel, to play sound on.
   * @param {boolean=} [spatialEffect=false] Specifies if spatial effect is enabled.
   * @param {number=} [rolloff=100]          Determines how far from the listener the volume reduces.
   */
  constructor(name, channel = 'master', spatialEffect = false, rolloff = 100) {
    super();

    /** 
     * @private 
     * @type {black-engine~SoundClip} 
     */
    this.mSoundClip = Black.assets.getSound(name);

    /** 
     * @private 
     * @type {number} 
     */
    this.mRolloff = rolloff;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPlayOnAdded = true;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mStopOnRemove = true;

    /** 
     * @private 
     * @type {black-engine~SoundInstance} 
     */
    this.mSoundInstance = null;

    /** 
     * @private 
     * @type {black-engine~MessageBinding|null}  
     */
    this.mCompleteBinding = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mSpatialEffect = spatialEffect;

    /** 
     * @private 
     * @type {string} 
     */
    this.mChannelName = channel;
  }

  /**
   * Starts playing sound.
   * 
   * @public
   * @param {number=} [volume=1]         The volume level.
   * @param {boolean=} [loop=false]      Specifies if sound repeats infinite times.
   * @param {boolean=} [overwrite=false] If true, stops previously started sound, if there is one.
   * @returns {black-engine~SoundInstance}            Newly created sound instance or already playing sound.
   */
  play(volume = 1, loop = false, overwrite = false) {
    overwrite && this.mSoundInstance && this.stop();
    if (!this.mSoundInstance || overwrite) {
      this.mSoundInstance = this.mSoundClip.play(this.mChannelName, volume, loop);
      this.mCompleteBinding = this.mSoundInstance.on(Message.COMPLETE, this.__onSoundComplete, this);
      this.spatialEffect = this.mSpatialEffect;
    }
    return this.mSoundInstance;
  }

  /**
   * Stops current sound instance if there is playing one.
   * 
   * @public
   * @returns {void}
   */
  stop() {
    if (this.mSoundInstance) {
      this.mCompleteBinding.off();
      this.mSoundInstance.stop();
      this.mSoundInstance = null;
    }
  }

  /**
   * @ignore
   * @private
   * @returns {void}
   */
  __onSoundComplete() {
    this.mSoundInstance = null;
  }

  /**
   * @inheritDoc
   */
  onAdded(gameObject) {
    if (this.mPlayOnAdded) {
      this.play();
    }
  }

  /**
   * @inheritDoc
   */
  onRemoved(gameObject) {
    if (this.mStopOnRemove && this.mSoundInstance) {
      this.mSoundInstance.stop();
    }
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    if (this.mSpatialEffect && this.mSoundInstance != null && this.mSoundInstance.isPlaying === true) {
      const stage = Black.stage;
      const pos = this.gameObject.localToGlobal(stage.globalToLocal(new Vector(this.gameObject.pivotX, this.gameObject.pivotY)));
      const px = (pos.x - stage.centerX) / stage.width * 2;
      const py = (pos.y - stage.centerY) / stage.height * 2;

      this.mSoundInstance.mSpatialPanner.setPosition(px, py, 0);
    }
  }

  /**

   * @param {boolean} value
   * @return {void}
   */
  set playOnAdded(value) {
    this.mPlayOnAdded = value;
  }

  /**
   * Gets/Sets whether the sound should start playing when added to stage. Default value is true.
   * 
   * @return {boolean}
   */
  get playOnAdded() {
    return this.mPlayOnAdded;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set stopOnRemove(value) {
    this.mStopOnRemove = value;
  }

  /**
   * Sets/Gets whether the sound should be stopped if the owner GameObject is being removed form the stage. Default value is true.
   *
   * @return {boolean}
   */
  get stopOnRemove() {
    return this.mStopOnRemove;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set spatialEffect(value) {
    this.mSpatialEffect = value;

    if (value && this.mSoundInstance != null && this.mSoundInstance.isPlaying === true) {
      let p = this.mSoundInstance.enableSpacePan();
      p.rolloffFactor = this.mRolloff;
      p.refDistance = 1;
      p.distanceModel = 'inverse';
    }
  }

  /**
   * Sets/Gets whether the sound should have spatial effect. Default value is false.
   *
   * @return {boolean}
   */
  get spatialEffect() {
    return this.mSpatialEffect;
  }
}

/**
 * The sound listener component, which controls one and only instance of AudioContext.listener.
 * 
 * @cat audio
 * @extends {black-engine~Component}
 */
class SoundListener extends Component {
  /**
   * Creates new instance of SoundListener.
   */
  constructor() {
    super();
  }

  /**
   * @inheritDoc
   */
  onRemoved(gameObject) {
    this.loose();
  }

  /**
   * Starts controlling only instance of AudioContext.listener.
   */
  listen() {
    Black.audio.currentListener = this;
  }

  /**
   * Stops controlling AudioContext.listener.
   */
  loose() {
    Black.audio.looseListener();
  }

  /**
   * @inheritDoc
   */
  onRender() {
    if (Black.audio.currentListener === this) {
      let listener = Black.audio.context.listener;
      
      let stage = Black.stage;
      let pos = this.gameObject.localToGlobal(stage.globalToLocal(new Vector(this.gameObject.pivotX, this.gameObject.pivotY)));
      let px = (pos.x - stage.centerX) / stage.width * 2;
      let py = (pos.y - stage.centerY) / stage.height * 2;
      if (listener.positionX != null) {
        listener.positionX.setValueAtTime(px, 0);
        listener.positionY.setValueAtTime(py, 0);
        listener.positionZ.setValueAtTime(1, 0);
      } else {
        listener.setPosition(px ,py, 1);
      }
    }
  }
}

/**
 * RigidBody is used to describe physics properties of game object colliders
 *
 * @cat physics
 * @extends black-engine~Component
 */
class RigidBody extends Component {
  /**
   * Creates new instance of RigidBody.
   */
  constructor() {
    super();

    /** 
     * Default collider. Used in case no any custom colliders provided by user.
     * @private 
     * @type {black-engine~BoxCollider}
     */
    this.mCollider = new BoxCollider(0, 0, 0, 0);

    /** 
     * For internal usage. To mark this body is in island.
     * @private 
     * @type {boolean}
     */
    this.mInGroup = false;

    /**
     * Flag to mark this body is in rest.
     * @private 
     * @type {boolean}
     */
    this.mIsSleeping = false;

    /** 
     * Internal counter. How many times (updates) this body has velocity lower than `Pair.sleepThreshold`.
     * @private 
     * @type {number}
     */
    this.mSleepTime = 0;

    /** 
     * All colliding pairs this body participates in.
     * @private 
     * @type {Array<black-engine~Pair>} 
     */
    this.mContacts = [];

    /**
     * Game object pivot. To track changes and update default collider if needed.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mPivot = new Vector(Number.MAX_VALUE);

    /**  
     * Game bounds position. To track changes and update this position, if object was moved without physics.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mCachedPosition = new Vector();

    /** 
     * All pairs this body participates in.
     * @public 
     * @type {Array<black-engine~Pair>}
     */
    this.mPairs = [];

    /** 
     * Flag to indicate immovable body.
     * @private 
     * @type {boolean}
     */
    this.mIsStatic = false;

    /** 
     * This position in stage coordinates.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mPosition = new Vector();

    /** 
     * This velocity to integrate.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mVelocity = new Vector();

    /** 
     * Force accumulator.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mForce = new Vector();

    /** 
     * Game object transform. To track changes and update this colliders.
     * @private 
     * @type {black-engine~Matrix}
     */
    this.mTransform = new Matrix(Number.MAX_VALUE);

    /**
     * Cached mass
     * @private 
     * @type {number}
     */
    this.mMass = 1;

    /**
     * Inverted mass or zero if body is static. 
     * 
     * @private
     * @ignore 
     * @type {number} 
     */
    this.mInvMass = 1;

    /** 
     * Velocity damper.
     * @public 
     * @type {number}
     */
    this.frictionAir = 0.01;

    /**
     * Friction for collision solving.
     * @public 
     * @type {number}
     */
    this.friction = 0.1;

    /**
     * Bounce for collision solving. 
     * @public 
     * @type {number}
     */
    this.bounce = 0.1;
  }

  /**
   * Returns this cached mass.
   *
   * @return {number}
   */
  get mass() {
    return this.mMass;
  }

  /**
   * Sets the mass of this body.
   *
   * @param {number} v Mass to set.
   * @return {void}
   */
  set mass(v) {
    this.mMass = v;

    if (v === 0 || this.mIsStatic) {
      this.mInvMass = 0;
    } else {
      this.mInvMass = 1 / v;
    }
  }

  /**
   * Returns this static indicator.
   *
   * @return {boolean}
   */
  get isStatic() {
    return this.mIsStatic;
  }

  /**
   * Sets this body movable state. Refresh inverted mass
   *
   * @param {boolean} v Value to set.
   *
   * @return {void}
   */
  set isStatic(v) {
    this.mIsStatic = v;
    this.mass = this.mMass;
  }

  /**
   * Sets the global position x of this body.
   *
   * @param {number} v Position to set.
   * @return {void}
   */
  set x(v) {
    this.mPosition.x = v;
  }

  /**
   * Returns this position x.
   *
   * @return {number}
   */
  get x() {
    return this.mPosition.x;
  }

  /**
   * Sets the global position y of this body.
   *
   * @param {number} v Position to set.
   * @return {void}
   */
  set y(v) {
    this.mPosition.y = v;
  }

  /**
   * Returns this position y.
   *
   * @return {number}
   */
  get y() {
    return this.mPosition.y;
  }

  /**
   * Sets the force x of this body.
   *
   * @param {number} v Force to set.
   * @return {void}
   */
  set forceX(v) {
    this.mIsSleeping = false;
    this.mForce.x = v;
  }

  /**
   * Returns this force x.
   *
   * @return {number}
   */
  get forceX() {
    return this.mForce.x;
  }

  /**
   * Sets the force y of this body.
   *
   * @param {number} v Force to set.
   * @return {void}
   */
  set forceY(v) {
    this.mIsSleeping = false;
    this.mForce.y = v;
  }

  /**
   * Returns this force y.
   *
   * @return {number}
   */
  get forceY() {
    return this.mForce.y;
  }

  /**
   * Sets the velocity x of this body.
   *
   * @param {number} v Velocity to set.
   * @return {void}
   */
  set velocityX(v) {
    this.mVelocity.x = v;
  }

  /**
   * Returns this velocity x.
   *
   * @return {number}
   */
  get velocityX() {
    return this.mVelocity.x;
  }

  /**
   * Sets the velocity y of this body.
   *
   * @param {number} v Velocity to set.
   * @return {void}
   */
  set velocityY(v) {
    this.mVelocity.y = v;
  }

  /**
   * Returns this velocity y.
   *
   * @return {number}
   */
  get velocityY() {
    return this.mVelocity.y;
  }

  /**
   * Updates game object position, colliders
   *
   * @public
   * @return {void}
   */
  update() {
    const gameObject = this.gameObject;
    const colliders = gameObject.mCollidersCache;
    const collider = this.mCollider;
    const position = this.mPosition;
    const wt = gameObject.worldTransformation;
    const wtData = wt.data;
    const transform = this.mTransform;

    // Check scale x, y and rotation (skew is forbidden for arcade physics)
    // Also for circle world scale x and y should be the same
    if (transform.data[0] !== wtData[0] || transform.data[2] !== wtData[2]) {
      transform.set(wtData[0], wtData[1], wtData[2], wtData[3], 0, 0);
      collider.mChanged = true;

      for (let i = 0, l = colliders.length; i < l; i++) {
        colliders[i].mChanged = true;
      }
    }

    if (gameObject !== Black.stage) {
      const cachedPosition = this.mCachedPosition;
      const prevX = cachedPosition.x;
      const prevY = cachedPosition.y;

      wt.transformXY(gameObject.pivotX, gameObject.pivotY, cachedPosition);

      // Update this position if game object position was changed during frame
      position.x += cachedPosition.x - prevX;
      position.y += cachedPosition.y - prevY;

      gameObject.parent.globalToLocal(position, cachedPosition);
      gameObject.x = cachedPosition.x;
      gameObject.y = cachedPosition.y;
      gameObject.worldTransformation.transformXY(gameObject.pivotX, gameObject.pivotY, cachedPosition);
    }

    // Refresh colliders
    if (colliders.length === 0) {
      // TODO; do we need a boundsChanged callback?
      let bounds = gameObject.localBounds;

      if (gameObject instanceof DisplayObject) {
        let disp = /** @type {DisplayObject} */(gameObject);
        if (disp.mClipRect !== null)
          collider.set(0, 0, bounds.width, bounds.height);
        else
          collider.set(-gameObject.pivotX, -gameObject.pivotY, bounds.width, bounds.height);
      } else {
        collider.set(-gameObject.pivotX, -gameObject.pivotY, bounds.width, bounds.height);
      }

      collider.refresh(transform, position);
    } else {
      for (let i = 0, l = colliders.length; i < l; i++) {
        colliders[i].refresh(transform, position);
      }
    }
  }

  /**
   * Resets colliders dirty state after collision test. Sync with update
   *
   * @public
   * @return {void}
   */
  clearFlags() {
    const colliders = this.gameObject.mCollidersCache;
    this.mCollider.mChanged = false;

    for (let i = 0, l = colliders.length; i < l; i++) {
      colliders[i].mChanged = false;
    }
  }

  // /**
  //  * Draws all the colliders
  //  *
  //  * @public
  //  * @return {void}
  //  */
  // debug() {
  //   if (!this.gameObject) return;
  //
  //   if (RigidBody.mDebug.graphics === null) {
  //     RigidBody.mDebug.graphics = new Graphics();
  //   }
  //
  //   const debug = RigidBody.mDebug;
  //   const graphics = debug.graphics;
  //   const colliders = this.gameObject.mCollidersCache;
  //
  //   if (debug.time !== Black.instance.mLastFrameTimeMs) {
  //     debug.time = Black.instance.mLastFrameTimeMs;
  //     Black.stage.add(debug.graphics);
  //
  //     debug.graphics.clear();
  //   }
  //
  //   debug.graphics.lineStyle(2, this.mIsSleeping ? 0x00ff00 : 0xff0000);
  //
  //   if (colliders.length === 0) {
  //     this.mCollider.debug(graphics, this.mCachedPosition);
  //   } else {
  //     for (let i = 0, l = colliders.length; i < l; i++) {
  //       colliders[i].debug(graphics, this.mCachedPosition);
  //     }
  //   }
  // }
}

// /** @private @type {Object} Debug options */
// RigidBody.mDebug = {
//   graphics: null,
//   time    : 0,
// };

/**
 * Projection is used to calculate ranges for collision test with Separate Axis Theorem.
 *
 * @cat physics.arcade.helpers
 */
class Projection {
  /**
   * Creates new instance of Projection.
   */
  constructor() {

    /** 
     * @private 
     * @type {black-engine~Vector|null} Box normal 
     */
    this.axis = null;

    /** 
     * @private 
     * @type {Array<black-engine~Vector>|null} Box a vertices 
     */
    this.verticesA = null;

    /** 
     * @private 
     * @type {Array<black-engine~Vector>|null} Box b vertices 
     */
    this.verticesB = null;

    /** 
     * @private 
     * @type {black-engine~Range} Range from project box a vertices to axis 
     */
    this.rangeA = new Range();

    /** 
     * @private 
     * @type {black-engine~Range} Range from project box b vertices to axis 
     */
    this.rangeB = new Range();

    /** 
     * @private 
     * @type {number} body a to body b offset projected on the axis 
     */
    this.offset = 0;
  }

  /**
   * Setter
   *
   * @public
   *
   * @param {Array<black-engine~Vector>} verticesA box a points
   * @param {Array<black-engine~Vector>} verticesB box b points
   * @param {black-engine~Vector}        axis One from box normals
   *
   * return {void}
   */
  set(verticesA, verticesB, axis) {
    this.verticesA = verticesA;
    this.verticesB = verticesB;
    this.axis = axis;
    this.refresh();
  }

  /**
   * Recalculates the ranges.
   *
   * @public
   *
   * return {void}
   */
  refresh() {
    Projection.__project(this.verticesA, this.axis, this.rangeA);
    Projection.__project(this.verticesB, this.axis, this.rangeB);
  }

  /**
   * Recalculates range.
   *
   * @private
   *
   * return {void}
   */
  static __project(points, axis, range) {
    let min = Number.MAX_VALUE;
    let max = -Number.MAX_VALUE;

    for (let i = 0, l = points.length; i < l; i++) {
      const dot = points[i].dot(axis);
      min = dot < min ? dot : min;
      max = dot > max ? dot : max;
    }

    range.min = min;
    range.max = max;
  }
}

/**
 * Simple range helper class.
 *
 * @cat physics.arcade.helpers
 */
class Range {
  /**
   * Creates new instance of Range.
   */
  constructor() {

    /** 
     * Min value.
     * @public 
     * @type {number} 
     */
    this.min = 0;

    /** 
     * Max value.
     * @public 
     * @type {number} 
     */
    this.max = 0;
  }
}

/**
 * Updates to start sleep if velocities is lower, than sleep threshold.
 *
 * @ignore 
 * @type {number} 
 */
let timeToSleep = 5; //

/**
 * How many pixels colliders can overlap each other without resolve.
 *
 * @ignore 
 * @type {number} 
 */
let slop = 1;

/**
 * Position correction koefficient. Lower is softer and with less twitches.
 *
 * @ignore 
 * @type {number} 
 */
let baumgarte = 0.2;

/**
 * Scale koefficient to normalize physics in some local coordinates or different resolutions.
 *
 * @ignore 
 * @type {number} 
 */
let unitsPerMeter = 1;

/**
 * Maximum body speed to begin sleep process, if sleeping is enabled.
 *
 * @ignore 
 * @type {number} 
 */
let sleepThreshold = 0.1;

/**
 * Minimal relative velocity within two bodies, required for bounce effect.
 *
 * @ignore 
 * @type {number} 
 */
let bounceTreshhold = 1;

/**
 * Pair is used for narrow test, and resolve collision within two colliders.
 *
 * @cat physics.arcade.pairs
 */

class Pair {
  /**
   * Creates new instance of Pair.
   */
  constructor() {
    /**
     * Collider from body a.
     * @public 
     * @type {Collider|null}
     */
    this.a = null;

    /**
     * Collider from body b.
     * @public 
     * @type {black-engine~Collider|null}
     */
    this.b = null;

    /**
     * Parent of collider a.
     * @public 
     * @type {black-engine~RigidBody|null}
     */
    this.bodyA = null;

    /**
     * Parent of collider b.
     * @public 
     * @type {black-engine~RigidBody|null}
     */
    this.bodyB = null;

    /**
     * Flag to indicate collision state.
     * @private 
     * @type {boolean}
     */
    this.mInCollision = false;

    /**
     * Flag to determine one from two bodies can move. invMass !== 0 and isSleeping === false.
     * @private 
     * @type {boolean}
     */
    this.mIsStatic = false;

    /**
     * Cached normal impulse to apply in next iteration or frame if collision still exist.
     * @private 
     * @type {number}
     */
    this.mNormalImpulse = 0;

    /**
     * Cached tangent impulse to apply in next iteration or frame if collision still exist.
     * @private 
     * @type {number}
     */
    this.mTangentImpulse = 0;

    /**
     * Position impulse cache to use within iterations.
     * @private 
     * @type {number}
     */
    this.mPositionImpulse = 0;

    /**
     * This colliders cached friction.
     * @private 
     * @type {number}
     */
    this.mFriction = 0;

    /**
     * This colliders cached bounce factor.
     * @private 
     * @type {number}
     */
    this.mBias = 0;

    /**
     * This colliders cached inverse mass sum.
     * @private 
     * @type {number}
     */
    this.mMass = 0;

    /**
     * Offset within the colliders on preSolve to correct overlap on each iteration.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mOffset = new Vector();

    /**
     * Normal collision direction from a to b.
     * @private 
     * @type {black-engine~Vector}
     */
    this.mNormal = new Vector();

    /**
     * Positive number. Penetration within colliders.
     * @private 
     * @type {number}
     */
    this.mOverlap = 0;

    /**
     * Flag to indicate this pair needs refresh.
     * @private 
     * @type {boolean}
     */
    this.mChanged = false;
  }

  /**
   * Tests the collision state. Updates normal and overlap for solve.
   *
   * @public
   *
   * @return {boolean} This pair in collision flag
   */
  test() {
    return this.mInCollision;
  }

  /**
   * Prepares the solve properties depends on bodies physics characteristics and test result.
   *
   * @public
   *
   * @return {void}
   */
  preSolve() {
    const normalX = this.mNormal.x;
    const normalY = this.mNormal.y;
    const tangentX = -normalY;
    const tangentY = +normalX;
    const positionA = this.bodyA.mPosition;
    const positionB = this.bodyB.mPosition;
    const velocityA = this.bodyA.mVelocity;
    const velocityB = this.bodyB.mVelocity;
    const invMassA = this.bodyA.mInvMass;
    const invMassB = this.bodyB.mInvMass;
    const offset = this.mOffset;

    const impulseX = this.mNormalImpulse * normalX + this.mTangentImpulse * tangentX;
    const impulseY = this.mNormalImpulse * normalY + this.mTangentImpulse * tangentY;

    offset.x = positionB.x - positionA.x;
    offset.y = positionB.y - positionA.y;

    velocityA.x -= impulseX * invMassA;
    velocityA.y -= impulseY * invMassA;

    velocityB.x += impulseX * invMassB;
    velocityB.y += impulseY * invMassB;

    const relVelX = velocityB.x - velocityA.x;
    const relVelY = velocityB.y - velocityA.y;
    const relVel = relVelX * normalX + relVelY * normalY;

    const bounceThreshold = Pair.bounceTreshhold * Pair.unitsPerMeter * Black.stage.mScaleX;
    this.mBias = relVel < -bounceThreshold ? -Math.max(this.bodyA.bounce, this.bodyB.bounce) * relVel : 0;
    this.mMass = 1 / (invMassA + invMassB);
    this.mFriction = Math.min(this.bodyA.friction, this.bodyB.friction);
    this.mPositionImpulse = 0;
  }

  /**
   * Updates the bodies velocities to solve collision.
   *
   * @public
   *
   * @return {void}
   */
  solveVelocity() {
    const normalX = this.mNormal.x;
    const normalY = this.mNormal.y;
    const tangentX = -normalY;
    const tangentY = +normalX;
    const velocityA = this.bodyA.mVelocity;
    const velocityB = this.bodyB.mVelocity;
    const invMassA = this.bodyA.mInvMass;
    const invMassB = this.bodyB.mInvMass;

    {
      const relVelX = velocityB.x - velocityA.x;
      const relVelY = velocityB.y - velocityA.y;
      const relVel = relVelX * normalX + relVelY * normalY;
      let impulse = -(relVel - this.mBias) * this.mMass;
      const newImpulse = Math.max(this.mNormalImpulse + impulse, 0);
      impulse = newImpulse - this.mNormalImpulse;
      this.mNormalImpulse = newImpulse;

      const impulseX = impulse * normalX;
      const impulseY = impulse * normalY;

      velocityA.x -= impulseX * invMassA;
      velocityA.y -= impulseY * invMassA;

      velocityB.x += impulseX * invMassB;
      velocityB.y += impulseY * invMassB;
    }

    {
      const relVelX = velocityB.x - velocityA.x;
      const relVelY = velocityB.y - velocityA.y;
      const relVel = relVelX * tangentX + relVelY * tangentY;
      let impulse = -relVel * this.mMass;
      const maxFriction = this.mFriction * this.mNormalImpulse;
      const newImpulse = MathEx.clamp(this.mTangentImpulse + impulse, -maxFriction, maxFriction);
      impulse = newImpulse - this.mTangentImpulse;
      this.mTangentImpulse = newImpulse;

      const impulseX = impulse * tangentX;
      const impulseY = impulse * tangentY;

      velocityA.x -= impulseX * invMassA;
      velocityA.y -= impulseY * invMassA;

      velocityB.x += impulseX * invMassB;
      velocityB.y += impulseY * invMassB;
    }
  }

  /**
   * Updates the bodies positions to solve collision.
   *
   * @public
   *
   * @return {void}
   */
  solvePosition() {
    const normalX = this.mNormal.x;
    const normalY = this.mNormal.y;
    const invMassA = this.bodyA.mInvMass;
    const invMassB = this.bodyB.mInvMass;
    const positionA = this.bodyA.mPosition;
    const positionB = this.bodyB.mPosition;
    const offset = this.mOffset;

    const dx = offset.x - positionB.x + positionA.x;
    const dy = offset.y - positionB.y + positionA.y;

    const overlap = this.mOverlap + (dx * normalX + dy * normalY);
    const correction = (overlap - Pair.slop) * Pair.baumgarte;

    if (correction <= 0)
      return;

    let normalImpulse = correction * this.mMass;
    const impulsePrev = this.mPositionImpulse;
    this.mPositionImpulse = Math.max(impulsePrev + normalImpulse, 0);
    normalImpulse = this.mPositionImpulse - impulsePrev;

    const impulseX = normalImpulse * normalX;
    const impulseY = normalImpulse * normalY;

    positionA.x -= impulseX * invMassA;
    positionA.y -= impulseY * invMassA;

    positionB.x += impulseX * invMassB;
    positionB.y += impulseY * invMassB;
  }

  /**
   * Generates pair id.
   *
   * @public
   * @param {black-engine~Collider} a Pair collider
   * @param {black-engine~Collider} b Pair collider
   *
   * @return {string} Pair unique id
   */
  static __id(a, b) {
    return a.mId > b.mId ? `${a.mId}&${b.mId}` : `${b.mId}&${a.mId}`;
  }

  /**
   * Updates to start sleep if velocities is lower, than sleep threshold.
   *
   * @type {number} 
   */
  static get timeToSleep() { return timeToSleep; }
  static set timeToSleep(value) { timeToSleep = value; }

  /**
   * How many pixels colliders can overlap each other without resolve.
   *  
   * @type {number} 
   */
  static get slop() { return slop; }
  static set slop(value) { slop = value; }

  /**
   * Position correction koefficient. Lower is softer and with less twitches.
   *  
   * @type {number} 
   */
  static get baumgarte() { return baumgarte; };
  static set baumgarte(value) { baumgarte = value; };

  /**
   * Scale koefficient to normalize physics in some local coordinates or different resolutions.
   *  
   * @type {number} 
   */
  static get unitsPerMeter() { return unitsPerMeter; }
  static set unitsPerMeter(value) { unitsPerMeter = value; }

  /**
   * Maximum body speed to begin sleep process, if sleeping is enabled.
   *  
   * @type {number} 
   */
  static get sleepThreshold() { return sleepThreshold; };
  static set sleepThreshold(value) { sleepThreshold = value; };

  /**
   * Minimal relative velocity within two bodies, required for bounce effect.
   *  
   * @type {number} 
   */
  static get bounceTreshhold() { return bounceTreshhold; }
  static set bounceTreshhold(value) { bounceTreshhold = value; }
}

var pool$1 = null;

/**
 * BoxToBoxPair is used to test collision within boxes
 *
 * @cat physics.arcade.pairs
 * @extends black-engine~Pair
 */
class BoxToBoxPair extends Pair {
  /**
   * Creates new instance of BoxToBoxPair.
   */
  constructor() {
    super();

    /**
     * Collider from body a.
     * 
     * @public 
     * @type {black-engine~BoxCollider|null}
     */
    this.a = null;

    /**
     * Collider from body b. 
     * 
     * @public 
     * @type {black-engine~BoxCollider|null}
     */
    this.b = null;

    const projections = [];

    for (let i = 0; i < 4; i++) {
      projections.push(new Projection());
    }

    /**
     * Projection keeps range of projected vertices. For each normal from both the colliders.
     * @private 
     * @type {Array<black-engine~Projection>}
     */
    this.mProjections = projections;
  }

  /**
   * Updates this pair with a new given colliders and bodies.
   *
   * @public
   *
   * @param {black-engine~BoxCollider} a   Pair collider
   * @param {black-engine~BoxCollider} b   Pair collider
   * @param {black-engine~RigidBody} bodyA Pair body
   * @param {black-engine~RigidBody} bodyB Pair body
   *
   * @return {Pair} This
   */
  set(a, b, bodyA, bodyB) {
    this.a = a;
    this.b = b;
    this.bodyA = bodyA;
    this.bodyB = bodyB;

    const projections = this.mProjections;

    for (let i = 0, j = 0; i < 4; i += 2, j += 1) {
      projections[i].set(a.mVertices, b.mVertices, a.mNormals[j]);
      projections[i + 1].set(a.mVertices, b.mVertices, b.mNormals[j]);
    }

    return this;
  }

  /**
   * Refreshes projections.
   *
   * @private
   *
   * @return {void}
   */
  __refreshProjectionsRanges() {
    const projections = this.mProjections;

    for (let i = 0; i < 4; i++) {
      projections[i].refresh();
    }
  }

  /**
   * @inheritDoc
   */
  test() {
    const a = this.a;
    const b = this.b;

    if (a.mChanged || b.mChanged) {
      this.mChanged = true;
    }

    if (a.mMax.x < b.mMin.x || a.mMin.x > b.mMax.x || a.mMax.y < b.mMin.y || a.mMin.y > b.mMax.y) {
      return this.mInCollision = false;
    }

    const projections = this.mProjections;
    const normal = this.mNormal;
    const offsetX = this.bodyB.mPosition.x - this.bodyA.mPosition.x;
    const offsetY = this.bodyB.mPosition.y - this.bodyA.mPosition.y;

    if (this.mChanged) {
      this.mChanged = false;
      this.__refreshProjectionsRanges();
    }

    this.mOverlap = Number.MAX_VALUE;

    for (let i = 0; i < 4; i++) {
      const projection = projections[i];
      projection.offset = projection.axis.x * offsetX + projection.axis.y * offsetY;
      const minA = projection.rangeA.min;
      const maxA = projection.rangeA.max;
      const minB = projection.rangeB.min + projection.offset;
      const maxB = projection.rangeB.max + projection.offset;

      if (minA > maxB || minB > maxA) {
        return this.mInCollision = false;
      }
    }

    for (let i = 0; i < 4; i++) {
      const projection = projections[i];
      const minA = projection.rangeA.min;
      const maxA = projection.rangeA.max;
      const minB = projection.rangeB.min + projection.offset;
      const maxB = projection.rangeB.max + projection.offset;

      const optionA = maxA - minB;
      const optionB = maxB - minA;
      let overlap = optionA < optionB ? optionA : -optionB;

      if (minA < minB && maxA < maxB) {
        overlap = maxA - minB;
      } else if (maxA > maxB) {
        overlap = minA - maxB;
      }

      const absOverlap = Math.abs(overlap);

      if (absOverlap < this.mOverlap) {
        this.mOverlap = absOverlap;
        normal.copyFrom(projection.axis);
        overlap < 0 && normal.multiplyScalar(-1);
      }
    }

    return this.mInCollision = true;
  }

  static get pool() {
    if (pool$1 === null)
      pool$1 = new ObjectPool(BoxToBoxPair, 100);

    return pool$1;
  }
}

var pool$2 = null;

/**
 * BoxToCirclePair is used to test collision within box - circle colliders.
 *
 * @cat physics.arcade.pairs
 * @extends black-engine~Pair
 */

class BoxToCirclePair extends Pair {

  /**
   * Creates new instance of BoxToBoxPair.
   */
  constructor() {
    super();

    /**
     * Collider from body a. 
     * @public 
     * @type {BoxCollider|null}
     */
    this.a = null;

    /**
     * Collider from body a. 
     * @public 
     * @type {CircleCollider|null}
     */
    this.b = null;

    /** 
     * Cached half width of box in stage coordinates.
     * @private 
     * @type {number}
     */
    this.mBoxHalfWidth = 0;

    /** 
     * Cached half height of box in stage coordinates,
     * @private 
     * @type {number}
     */
    this.mBoxHalfHeight = 0;

    /**
     * Cached cos and sin from box game object world transformation without scale, to rotate.
     * @private 
     * @type {Vector}
     */
    this.mBoxRotate = new Vector();

    /**
     * Tmp point to rotate. 
     * @private 
     * @type {Vector}
     */
    this.mCircleCenter = new Vector();
  }

  /**
   * Assigns colliders and bodies to this pair.
   *
   * @public
   *
   * @param {BoxCollider} a     Pair box collider
   * @param {CircleCollider} b  Pair circle collider
   * @param {RigidBody} bodyA   Pair body
   * @param {RigidBody} bodyB   Pair body
   *
   * @return {Pair} This
   */
  set(a, b, bodyA, bodyB) {
    this.a = a;
    this.b = b;
    this.bodyA = bodyA;
    this.bodyB = bodyB;

    return this;
  }

  /**
   * Rotates point around anchor
   *
   * @private
   *
   * @return {void}
   */
  __rotate(point, anchorX, anchorY, cos, sin) {
    const x = point.x - anchorX;
    const y = point.y - anchorY;
    const tx = cos * x - sin * y;
    const ty = sin * x + cos * y;

    point.x = tx + anchorX;
    point.y = ty + anchorY;
  }

  /**
   * @inheritDoc
   */
  test() {
    const box = this.a;
    const circle = this.b;

    if (box.mChanged) {
      this.mChanged = true;
    }

    if (box.mMax.x < circle.mMin.x || box.mMin.x > circle.mMax.x ||
      box.mMax.y < circle.mMin.y || box.mMin.y > circle.mMax.y) {
      return this.mInCollision = false;
    }

    if (this.mChanged) {
      this.mChanged = false;
      const transformData = this.bodyA.mTransform.data;
      const scaleX = Math.sqrt(transformData[0] * transformData[0] + transformData[1] * transformData[1]);
      const scaleY = Math.sqrt(transformData[2] * transformData[2] + transformData[3] * transformData[3]);

      this.mBoxRotate.set(transformData[0] / scaleX, transformData[1] / scaleX);
      this.mBoxHalfWidth = box.mRect.width / 2 * scaleX;
      this.mBoxHalfHeight = box.mRect.height / 2 * scaleY;
    }

    const boxRotate = this.mBoxRotate;
    const normal = this.mNormal;
    const circleCenter = this.mCircleCenter.copyFrom(circle.mCenter);
    let hw = this.mBoxHalfWidth;
    let hh = this.mBoxHalfHeight;

    const rotated = boxRotate.y !== 0;

    if (rotated) {
      this.__rotate(circleCenter, box.mCenter.x, box.mCenter.y, boxRotate.x, -boxRotate.y);
    }

    const dx = circleCenter.x - box.mCenter.x;
    const dy = circleCenter.y - box.mCenter.y;

    if (dx === 0 && dy === 0) {
      this.mOverlap = circle.mRadius + hw;
      normal.set(-1, 0);

      return this.mInCollision = true;
    }

    let closestX = MathEx.clamp(dx, -hw, hw);
    let closestY = MathEx.clamp(dy, -hh, hh);
    const inside = dx === closestX && dy === closestY;

    if (inside) {
      if (Math.abs(dx) > Math.abs(dy)) {
        closestX = closestX > 0 ? hw : -hw;
      } else {
        closestY = closestY > 0 ? hh : -hh;
      }
    }

    const normalX = dx - closestX;
    const normalY = dy - closestY;
    const sqLength = normalX * normalX + normalY * normalY;
    const r = circle.mRadius;

    if (sqLength > r * r && !inside) {
      return this.mInCollision = false;
    }

    if (sqLength === 0) {
      this.mOverlap = r;
      normal.set(0, 1);
    } else {
      const d = Math.sqrt(sqLength);
      this.mOverlap = r - d;
      inside ? normal.set(-normalX / d, -normalY / d) : normal.set(normalX / d, normalY / d);
    }

    if (rotated) {
      this.__rotate(normal, 0, 0, boxRotate.x, boxRotate.y);
    }

    return this.mInCollision = true;
  }

  static get pool() {
    if (pool$2 === null)
      pool$2 = new ObjectPool(BoxToCirclePair, 100);

    return pool$2;
  }
}

var pool$3 = null;

/**
 * CircleToCirclePair is used to test collision within circles colliders.
 *
 * @cat physics.arcade.pairs
 * @extends black-engine~Pair
 */
class CircleToCirclePair extends Pair {
  /**
   * Creates new instance of CircleToCirclePair.
   */
  constructor() {
    super();

    /**
     * Collider from body a. 
     * @public 
     * @type {black-engine~CircleCollider|null}
     */
    this.a = null;

    /**
     * Collider from body b. 
     * @public 
     * @type {black-engine~CircleCollider|null}
     */
    this.b = null;
  }

  /**
   * Setter
   *
   * @public
   *
   * @param {black-engine~CircleCollider} a  Pair circle collider
   * @param {black-engine~CircleCollider} b  Pair circle collider
   * @param {black-engine~RigidBody} bodyA   Pair body
   * @param {black-engine~RigidBody} bodyB   Pair body
   *
   * @return {Pair} This
   */
  set(a, b, bodyA, bodyB) {
    this.a = a;
    this.b = b;
    this.bodyA = bodyA;
    this.bodyB = bodyB;

    return this;
  }

  /**
   * @inheritDoc
   */
  test() {
    const a = this.a;
    const b = this.b;
    const offsetX = b.mCenter.x - a.mCenter.x;
    const offsetY = b.mCenter.y - a.mCenter.y;
    const totalRadius = a.mRadius + b.mRadius;

    if (offsetX === 0 && offsetY === 0) {
      this.mOverlap = totalRadius;
      this.mNormal.set(1, 0);

      return this.mInCollision = true;
    }

    const totalRadiusSq = totalRadius * totalRadius;
    const distanceSq = offsetX * offsetX + offsetY * offsetY;

    if (distanceSq > totalRadiusSq) {
      return this.mInCollision = false;
    }

    const dist = Math.sqrt(distanceSq);
    this.mOverlap = totalRadius - dist;
    this.mNormal.set(offsetX / dist, offsetY / dist);

    return this.mInCollision = true;
  }

  static get pool() {
    if (pool$3 === null)
      pool$3 = new ObjectPool(CircleToCirclePair, 100);

    return pool$3;
  }
}

/**
 * Broad collision checker using hash algorithm.
 *
 * @cat physics.arcade.phases
 */
class BroadPhase {
  /**
   * Creates new instance of BroadPhase.
   */
  constructor() { }

  /**
   * Test collision in each pair. Sets inCollision flag to false if there is no collision in pair.
   *
   * @param {Array<black-engine~Pair>} pairs All the arcade world colliders pairs.
   * @return {void}
   */
  test(pairs) { }
}

/**
 * Simple AABB physics engine (beta).
 *
 * @cat physics.arcade
 * @extends black-engine~System
 */
class Arcade extends System {
  /**
   * Creates new Arcade instance.
   */
  constructor() {
    super();

    /**
     * Bodies that are on stage.
     * @private 
     * @type {Array<black-engine~RigidBody>}
     */
    this.mBodies = [];

    /**
     * Pairs to check collisions within. With colliders which bodies are on stage.
     * @private 
     * @type {Array<black-engine~Pair>}
     */
    this.mPairs = [];

    /**
     * Pairs which are in collision per frame.
     * @private 
     * @type {Array<black-engine~Pair>}
     */
    this.mContacts = [];

    /**
     * Broad collision test instance.
     * @private 
     * @type {black-engine~BroadPhase}
     */
    this.mBroadPhase = new BroadPhase();

    /**
     * Object to store pairs by their id. For quick search in collision callbacks.
     * @private 
     * @type {Object}
     */
    this.mPairsHash = Object.create(null);

    /**
     * Reference to world bounds body.
     * @private 
     * @type {black-engine~RigidBody|null}
     */
    this.mBoundsBody = null;

    /** @private 
     * @type {black-engine~BoxCollider} */
    this.mBoundsLeft = new BoxCollider(0, 0, 0, 0);

    /** @private 
     * @type {black-engine~BoxCollider} */
    this.mBoundsRight = new BoxCollider(0, 0, 0, 0);

    /** @private 
     * @type {black-engine~BoxCollider} */
    this.mBoundsTop = new BoxCollider(0, 0, 0, 0);

    /** @private 
     * @type {black-engine~BoxCollider} */
    this.mBoundsBottom = new BoxCollider(0, 0, 0, 0);

    /** @private 
     * @type {black-engine~Vector} */
    this.mGravity = new Vector(0, 1000);

    /**
     * Bigger value gives better resolver result, but require more calculations.
     * @private 
     * @type {number}
     */
    this.mIterations = 5;

    /**
     * Switch for sleep calculations.
     * @private 
     * @type {boolean}
     */
    this.mSleepEnabled = true;

    /**
     * Update delta time, secs.
     * @public
     * @type {number}
     */
    this.delta = 1 / 60;
  }

  /**
   * Invokes passed callback if given colliders are in collision.
   *
   * Callback params:
   * normalX - collision normal projected on x axis. In direction from colliderA to colliderB.
   * normalY - collision normal projected on y axis. In direction from colliderA to colliderB.
   * overlap - positive number.
   * [args] - rest arguments.
   *
   * @public
   *
   * @param {black-engine~Collider} colliderA Collider to check
   * @param {black-engine~Collider} colliderB Collider to check
   * @param {Function} cb        Callback
   * @param {Object} ctx         Callback context
   * @param {...*} [args]        Rest arguments
   *
   * @return {void}
   */
  collisionInfo(colliderA, colliderB, cb, ctx, ...args) {
    const pair = this.mPairsHash[Pair.__id(colliderA, colliderB)];

    if (pair && pair.mInCollision) {
      const sign = pair.a === colliderA ? 1 : -1;
      cb.call(ctx, pair.mNormal.x * sign, pair.mNormal.y * sign, pair.mOverlap, ...args);
    }
  }

  /**
   * If callback passed and given bodies are in collision invokes callback.
   * If no bodyB provided result will show that bodyA is in collision with any other body if so.
   *
   * Note: if more than one collision occurred within bodies, callback will be invoked only with a first found.
   *
   * Callback params:
   * normalX - collision normal projected on x axis. In direction from bodyA collider to bodyB collider.
   * normalY - collision normal projected on y axis. In direction from bodyA collider to bodyB collider.
   * overlap - positive number.
   * [args] - rest arguments.
   *
   * @public
   *
   * @param {black-engine~RigidBody} bodyA         Body to check
   * @param {black-engine~RigidBody=} [bodyB=null] Body to check
   * @param {Function=} [cb=null]     Callback
   * @param {Object=} [ctx=null]      Callback context
   * @param {...*} [args]             Rest arguments
   *
   * @return {boolean} Indicator of bodies collision.
   */
  isColliding(bodyA, bodyB = null, cb = null, ctx = null, ...args) {
    const pairs = bodyA.mPairs;

    if (bodyB === null) {
      for (let i = 0, l = pairs.length; i < l; i++) {
        if (pairs[i].mInCollision) {
          return true;
        }
      }

      return false;
    }

    for (let i = 0, l = pairs.length; i < l; i++) {
      const pair = pairs[i];

      if (pair.mInCollision === false)
        continue;

      const sign = pair.bodyA === bodyA && pair.bodyB === bodyB ? 1 :
        pair.bodyA === bodyB && pair.bodyB === bodyA ? -1 : 0;

      if (sign === 0)
        continue;

      if (cb)
        cb.call(ctx, pair.mNormal.x * sign, pair.mNormal.y * sign, pair.mOverlap, ...args);

      return true;
    }

    return false;
  }

  /**
   * @inheritDoc
   */
  onChildrenAdded(gameObject) {
    GameObject.forEach(gameObject, object => {
      const body = object.getComponent(RigidBody);

      if (body) {
        this.__addBody(/** @type {RigidBody} */(body));
      }
    });
  }

  /**
   * @inheritDoc
   */
  onChildrenRemoved(gameObject) {
    GameObject.forEach(gameObject, object => {
      const body = /** @type {!RigidBody} */ (object.getComponent(RigidBody));

      if (body) {
        this.__removeBody(body, gameObject);
      }
    });
  }

  /**
   * @inheritDoc
   */
  onComponentAdded(child, component) {
    if (component instanceof RigidBody) {
      this.__addBody(/** @type {RigidBody} */(component));
    } else if (component instanceof Collider) {
      this.__addCollider(child, /** @type {Collider} */(component));
    }
  }

  /**
   * @inheritDoc
   */
  onComponentRemoved(child, component) {
    if (component instanceof RigidBody) {
      this.__removeBody(/** @type {RigidBody} */(component), child);
    } else if (component instanceof Collider) {
      this.__removeCollider(child, /** @type {Collider} */(component));
    }
  }

  /**
   * Adds body to arcade world. Start tracking its gameObject colliders.
   *
   * @private
   * @param {black-engine~RigidBody} body Body to add
   *
   * @return {void}
   */
  __addBody(body) {
    const bodies = this.mBodies;
    const colliders = body.gameObject.mCollidersCache;
    body.mPairs.length = 0;

    if (colliders.length === 0) {
      this.__addPairs(body.mCollider, body);
    } else {
      for (let i = 0, l = colliders.length; i < l; i++) {
        this.__addPairs(colliders[i], body);
      }
    }

    bodies.push(body);
  }

  /**
   * Removes body from arcade world.
   *
   * @private
   * @param {black-engine~RigidBody} body        Body to remove
   * @param {black-engine~GameObject} gameObject Body's game object
   *
   * @return {void}
   */
  __removeBody(body, gameObject) {
    const bodies = this.mBodies;
    const colliders = gameObject.mCollidersCache;

    if (colliders.length === 0) {
      this.__removePairs(body.mCollider);
    } else {
      for (let i = 0, l = colliders.length; i < l; i++) {
        this.__removePairs(colliders[i]);
      }
    }

    body.mPairs.length = 0;
    bodies.splice(bodies.indexOf(body), 1);
  }

  /**
   * Adds collider to arcade world.
   *
   * @private
   * @param {black-engine~GameObject} child  Parent of the collider
   * @param {black-engine~Collider} collider Collider to add
   *
   * @return {void}
   */
  __addCollider(child, collider) {
    const body = /** @type {RigidBody} */ (child.getComponent(RigidBody));

    if (body && this.mBodies.indexOf(body) !== -1) {
      this.__addPairs(collider, body);

      if (child.mCollidersCache.length === 1) {
        this.__removePairs(body.mCollider);
      }
    }
  }

  /**
   * Removes collider from arcade world.
   *
   * @private
   * @param {black-engine~GameObject} child  Parent of the collider
   * @param {black-engine~Collider} collider Collider to remove
   *
   * @return {void}
   */
  __removeCollider(child, collider) {
    const body = /** @type {RigidBody} */ (child.getComponent(RigidBody));

    if (body && this.mBodies.indexOf(body) !== -1) {
      this.__removePairs(collider);

      const pairs = body.mPairs;

      for (let i = pairs.length - 1; i >= 0; i--) {
        const pair = pairs[i];

        if (pair.a === collider || pair.b === collider) {
          pairs.splice(i, 1);
        }
      }

      if (child.mCollidersCache.length === 0) {
        this.__addCollider(child, body.mCollider);
      }
    }
  }

  /**
   * Generate pairs, passed collider with all present colliders.
   *
   * @private
   * @param {black-engine~Collider} collider   Collider to generate with
   * @param {black-engine~RigidBody} fromBody  The collider body
   *
   * @return {void}
   */
  __addPairs(collider, fromBody) {
    const bodies = this.mBodies;
    collider.mChanged = true;

    for (let i = 0, iLen = bodies.length; i < iLen; i++) {
      const body = bodies[i];
      const colliders = body.gameObject.mCollidersCache;

      if (body === fromBody)
        continue;

      if (colliders.length === 0) {
        this.__addPair(collider, body.mCollider, fromBody, body);
      } else {
        for (let j = 0, jLen = colliders.length; j < jLen; j++) {
          this.__addPair(collider, colliders[j], fromBody, body);
        }
      }
    }
  }

  /**
   * Creates pair and adds it to world.
   *
   * @private
   * @param {black-engine~Collider} a      Pair collider
   * @param {black-engine~Collider} b      Pair collider
   * @param {black-engine~RigidBody} bodyA Pair body
   * @param {black-engine~RigidBody} bodyB Pair body
   *
   * @return {void}
   */
  __addPair(a, b, bodyA, bodyB) {
    const isBoxA = a.constructor === BoxCollider;
    const isBoxB = b.constructor === BoxCollider;
    let pair;

    if (isBoxA && isBoxB) {
      pair = BoxToBoxPair.pool.get();
    } else if (!isBoxA && !isBoxB) {
      pair = CircleToCirclePair.pool.get();
    } else {
      pair = BoxToCirclePair.pool.get();

      if (isBoxB) {
        const body = bodyA;
        const collider = a;
        a = b;
        bodyA = bodyB;
        b = collider;
        bodyB = body;
      }
    }

    pair.mChanged = true;
    pair.set(a, b, bodyA, bodyB);
    pair.mInCollision = false;
    this.mPairs.push(pair);

    this.mPairsHash[Pair.__id(a, b)] = pair;
    bodyA.mPairs.push(pair);
    bodyB.mPairs.push(pair);
  }

  /**
   * Removes all pairs with given collider.
   *
   * @private
   * @param {black-engine~Collider} collider Pairs collider
   *
   * @return {void}
   */
  __removePairs(collider) {
    const pairs = this.mPairs;
    const pairsHash = this.mPairsHash;

    for (let i = pairs.length - 1; i >= 0; i--) {
      const pair = pairs[i];

      if (pair.a === collider || pair.b === collider) {
        pairs.splice(i, 1);

        if (pair instanceof BoxToBoxPair)
          BoxToBoxPair.pool.release(pair);
        else if (pair instanceof BoxToCirclePair)
          BoxToCirclePair.pool.release(pair);
        else if (pair instanceof CircleToCirclePair)
          CircleToCirclePair.pool.release(pair);

        //pair.constructor.pool.release(pair);

        delete pairsHash[Pair.__id(pair.a, pair.b)];

        pair.bodyA.mPairs.splice(pair.bodyA.mPairs.indexOf(pair), 1);
        pair.bodyB.mPairs.splice(pair.bodyB.mPairs.indexOf(pair), 1);
      }
    }
  }

  /**
   * @inheritDoc
   */
  onPostUpdate() {
    const dt = this.delta;
    const contacts = this.mContacts;
    const bodies = this.mBodies;
    const pairs = this.mPairs;
    contacts.length = 0;

    // refresh body colliders if scale, rotation changed
    for (let i = 0, l = bodies.length; i < l; i++) {
      const body = bodies[i];
      body.update();
      body.mContacts.length = 0;
      body.mInGroup = false;
    }

    // reset each pair to defaults
    // so phases will know, if pair in collision is true, then it needs more precise check
    for (let i = 0, l = pairs.length; i < l; i++) {
      const pair = pairs[i];

      pair.mIsStatic = (pair.bodyA.mIsSleeping || pair.bodyA.mInvMass === 0) &&
        (pair.bodyB.mIsSleeping || pair.bodyB.mInvMass === 0);

      if (pair.mIsStatic === false) {
        pair.mInCollision = true;
      }
    }

    // update pairs in collision flag todo
    // this.mBroadPhase.test(pairs);

    // narrow collision test
    for (let i = 0, l = pairs.length; i < l; i++) {
      const pair = pairs[i];

      if (pair.mInCollision && pair.mIsStatic === false) {
        pair.test();
      }
    }

    for (let i = 0, l = pairs.length; i < l; i++) {
      const pair = pairs[i];

      if (pair.mInCollision) {
        pair.mIsStatic === false && contacts.push(pair);
        pair.bodyA.mContacts.push(pair);
        pair.bodyB.mContacts.push(pair);
      } else {
        pair.mNormalImpulse = 0;
        pair.mTangentImpulse = 0;
      }
    }

    this.__solve(dt);

    if (!this.mSleepEnabled)
      return;

    const group = [];
    const stack = [];

    for (let i = 0, l = bodies.length; i < l; i++) {
      const body = bodies[i];
      body.clearFlags(); // clear colliders dirty flags

      if (body.mInGroup || body.mIsSleeping || body.mInvMass === 0)
        continue;

      group.length = 0;
      stack.length = 0;

      stack.push(body);

      while (stack.length !== 0) {
        const body = stack.pop();
        const contacts = body.mContacts;

        group.push(body);
        body.mInGroup = true;

        for (let i = 0, l = contacts.length; i < l; i++) {
          const contact = contacts[i];
          const other = contact.bodyA === body ? contact.bodyB : contact.bodyA;

          if (other.mInGroup || other.mInvMass === 0)
            continue;

          stack.push(other);
        }
      }

      let isSleeping = true;
      const sleepThreshold = Pair.sleepThreshold * Pair.unitsPerMeter * Black.stage.mScaleX;

      for (let i = 0, l = group.length; i < l; i++) {
        const body = group[i];
        const velocity = body.mVelocity;
        body.mSleepTime = velocity.x * velocity.x + velocity.y * velocity.y < sleepThreshold ? body.mSleepTime + 1 : 0;
        isSleeping = isSleeping && body.mSleepTime > Pair.timeToSleep;
      }

      for (let i = 0, l = group.length; i < l; i++) {
        group[i].mIsSleeping = isSleeping;
      }
    }
  }

  /**
   * Solve contacts.
   *
   * @private
   * @param {number} dt Time from last update, ms.
   *
   * @return {void}
   */
  __solve(dt) {
    const iterations = this.mIterations;
    const contacts = this.mContacts;
    const bodies = this.mBodies;
    const gravity = this.mGravity;

    for (let i = 0, l = bodies.length; i < l; i++) {
      const body = bodies[i];

      if (body.mInvMass === 0 || body.mIsSleeping)
        continue;

      const force = body.mForce;
      const velocity = body.mVelocity;
      const invMass = body.mInvMass;
      const damping = 1 - body.frictionAir;

      velocity.x = (velocity.x + (force.x * invMass + gravity.x) * dt) * damping;
      velocity.y = (velocity.y + (force.y * invMass + gravity.y) * dt) * damping;
    }

    for (let i = 0, l = contacts.length; i < l; i++) {
      contacts[i].preSolve();
    }

    for (let i = 0; i < iterations; i++) {
      for (let j = 0, l = contacts.length; j < l; j++) {
        contacts[j].solveVelocity();
      }
    }

    const unitsPerMeterDt = Black.stage.mScaleX * Pair.unitsPerMeter * dt;

    for (let i = 0, l = bodies.length; i < l; i++) {
      const body = bodies[i];
      body.mForce.set(0, 0);

      if (body.mInvMass === 0 || body.mIsSleeping)
        continue;

      const position = body.mPosition;
      const velocity = body.mVelocity;

      position.x += velocity.x * unitsPerMeterDt;
      position.y += velocity.y * unitsPerMeterDt;
    }

    for (let i = 0; i < iterations; i++) {
      for (let j = 0, l = contacts.length; j < l; j++) {
        contacts[j].solvePosition();
      }
    }
  }

  /**
   * Sets bounds to default values.
   * Should be called on start and on resize.
   *
   * @private
   * @return {void}
   */
  __setBounds() {
    const bounds = Black.stage.bounds;
    const thickness = Number.MAX_SAFE_INTEGER;

    this.mBoundsLeft.set(-thickness, 0, thickness, bounds.height);
    this.mBoundsRight.set(bounds.width, 0, thickness, bounds.height);
    this.mBoundsTop.set(-thickness, -thickness, bounds.width + thickness * 2, thickness);
    this.mBoundsBottom.set(-thickness, bounds.height, bounds.width + thickness * 2, thickness);
  }

  /**
   * Enabled or disables world colliding bounds.
   *
   * @public
   * @param {boolean} v Value to set
   *
   * @return {void}
   */
  set boundsEnabled(v) {
    if (v) {
      if (!this.mBoundsBody) {
        this.mBoundsBody = new RigidBody();
        this.mBoundsBody.isStatic = true;

        Black.stage.addComponent(this.mBoundsLeft);
        Black.stage.addComponent(this.mBoundsRight);
        Black.stage.addComponent(this.mBoundsTop);
        Black.stage.addComponent(this.mBoundsBottom);

        this.__setBounds();
      }

      Black.stage.addComponent(this.mBoundsBody);
    } else {
      Black.stage.removeComponent(this.mBoundsBody);
    }
  }

  /**
   * Sets the gravity x.
   *
   * @param {number} v Value to set.
   * @return {void}
   */
  set gravityX(v) {
    this.mGravity.x = v;
  }

  /**
   * Returns this gravity x.
   *
   * @return {number}
   */
  get gravityX() {
    return this.mGravity.x;
  }

  /**
   * Sets the gravity y.
   *
   * @param {number} v Value to set.
   * @return {void}
   */
  set gravityY(v) {
    this.mGravity.y = v;
  }

  /**
   * Returns this gravity y.
   *
   * @return {number}
   */
  get gravityY() {
    return this.mGravity.y;
  }

  /**
   * Sets the count of solving iterations.
   *
   * @param {number} v Value to set.
   * @return {void}
   */
  set iterations(v) {
    this.mIterations = v;
  }

  /**
   * Returns this count of solving iterations.
   *
   * @return {number}
   */
  get iterations() {
    return this.mIterations;
  }

  /**
   * Sets the sleep allowed flag.
   *
   * @param {boolean} v Value to set.
   * @return {void}
   */
  set sleepEnabled(v) {
    this.mSleepEnabled = v;
  }

  /**
   * Returns this sleepAllowed flag.
   *
   * @return {boolean}
   */
  get sleepEnabled() {
    return this.mSleepEnabled;
  }
}

/**
 * @extends black-engine~MessageDispatcher
 * @cat core
 */
class SplashScreen extends MessageDispatcher {
  constructor(duration = 4200) {
    super(false);

    /** 
     * @private
     * @type {number}
     */
    this.mDuration = duration;

    /** 
     * @private
     * @type {string}
     */
    this.mSvgLogo = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 241.8 220.2"><defs><style>.b{fill:#f5f5f5}.c{fill:url(#a)}</style><pattern id="a" width="17.6" height="14.87" patternUnits="userSpaceOnUse" viewBox="0 0 17.6 14.9"><path fill="none" d="M0 0h17.6v14.87H0z"/><path class="b" d="M0 13.4v1.5h1.5A1.5 1.5 0 0 1 0 13.4z"/><path class="b" d="M8.8 0a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 1 1-3 0A1.5 1.5 0 0 1 8.8 0H0v13.4a1.5 1.5 0 0 1 1.5-1.5A1.5 1.5 0 0 1 3 13.4a1.5 1.5 0 0 1-1.5 1.5h4.3a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.4 1.4 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5h6a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 3 0 1.5 1.5 0 0 1-1.5 1.5h5.8V0zm6.6.7a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5 1.4 1.4 0 0 1-1.5-1.5A1.5 1.5 0 0 1 15.4.7zM.4 2.2A1.5 1.5 0 0 1 1.9.7a1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5A1.5 1.5 0 0 1 .4 2.2zm1.7 5.7A1.5 1.5 0 0 1 .6 6.4a1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 0 3zm2 3.8a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5zm.2-8a1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5 1.5 1.5 0 0 1-1.5-1.5zm2.2 3.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0zm2.2 5.3a1.5 1.5 0 1 1 1.5-1.5 1.5 1.5 0 0 1-1.5 1.5zm1.4-8a1.5 1.5 0 0 1 3 0 1.5 1.5 0 1 1-3 0zm2.5 5.7a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.4 1.4 0 0 1 1.5 1.5 1.5 1.5 0 0 1-1.5 1.5zm3 3.5a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5zm0-5.5a1.5 1.5 0 0 1-1.5-1.5 1.5 1.5 0 0 1 1.5-1.5 1.5 1.5 0 0 1 1.5 1.5 1.4 1.4 0 0 1-1.5 1.5z"/></pattern></defs><path class="c" d="M25.8 105.2c12.1 8.8 29.7 6.7 59.8 6.8-7.9-7.3-9.1-18.7-7.1-27.3-6.6 7.3-5.1 19.3-12.8 19.4-3.4.1-6.9-4.7-8.3-10.8-5.3 9.4-12 10.7-14.7-4.5-2.3 2-3.9 8.2-9.5 6.2S26.8 81.8 30 71.3A28.3 28.3 0 0 1 14.6 61c-1.4 20.8.5 36.4 11.2 44.2zM51.9 39.9c29.7-3.6 54-22.8 69.5-26.3-.1 0-40.7-.3-72.3 1.9 6.2 3.5 10.5 16.3 2.8 24.4zM170.4 34.2c5.6-2 32.1-9.5 54.4-2.7-3-13.7-22.9-17-71.8-17.8a32.2 32.2 0 0 1 17.4 20.5zM211.3 109.3c-12.2 2.1-12.8-8.8-32.9-8.9-15.5 0-35.2 13.2-36.1 13.7h49.3c19.1 0 32.5-.6 35.5-7.3s-2.7-12.3-10.7-15.6c5.3 5.6 4.1 16.5-5.1 18.1zM66 189.2c-5.9 5-26 17.8-43.6 6.3 3.6 8.4 13.6 12.7 45.1 12-1.6-2.4-5.3-10.4-1.5-18.3zM32 161.5c7.3 7.8 18.1 2.6 33.7-6.2 10.5-6 27.5-9.9 40.6-1.1 3.7-8.7 5.4-10.9 6.7-10.6s.7 2.7 5.6 7c.4-1 3.8-7.9 3.8-12l-59.9-.8c-1.5 6.6-9.9 19-23.9 17.4-2.4-.3-2.5-11.6 2.4-16.9a36.7 36.7 0 0 0-7.4.9c-4.4 5.1-7 16.4-1.6 22.3zM150.9 148.1c23.6-.5 26 19.9 41.1 21 10.9.9 13.6-16.8 35.7-11.8-1.3-11.1-7.7-16.2-22.2-17.4 3 10.3-6.6 28.5-19.3 21.5a1.5 1.5 0 0 1-.8-1.1c-.9-11 2.8-15.8 7.5-20.7l-55.7-.7a18.5 18.5 0 0 1 3.7 12.4 20.7 20.7 0 0 1 10-3.2zM162 195.9c-3.9 3.6-3.8 9.5-2.5 12.5h4.1c0-14.8 17-12.8 21.2-.8 22.7-1.5 30.9-3.2 36-8.7s6.4-15.3 6.8-27.1c-2.6 3-9.8 14.7-10.9 16.4-17.8 26.3-39.9-5.9-54.7 7.7z"/><path class="b" d="M150 42.6c-.2 10.4-9.8 13.6-9.4-.7-16.2 1.9-14.5 8.5-13.7 9.5 4.4 5.6 29 4.5 27.3-4.3a5.7 5.7 0 0 0-4.2-4.5z"/><path class="b" d="M162.2 46.4c-1.7-15.7-17.2-18.2-28.4-15.6s-22.3 12.7-15.6 25.4 46.2 10.3 44-9.8zm-37.8 6.7c-5.4-9.7 10.6-13.4 13.2-13.8 7.5-1.3 18.2-1.2 19.6 7.6 2 13.2-28.8 13.3-32.8 6.2zM184.7 68.8c-1.1 0-1.1 3.3-5.4 12.5.3 0 5.8 0 8.6.2-.7-9.1-2.1-12.7-3.2-12.7zM162.5 82.9l7-1.1c-2.5-4.6-5.8-8.6-7 1.1zM153.1 74.5a55.8 55.8 0 0 0-7.8 2c6.4 9.4 7.4 2.2 7.8-2zM134.8 94.6c.4-.2 4.9-3.1 6.9-4.1-1.9-2-8.1-9.9-6.9 4.1zM190.9 81.8a58.3 58.3 0 0 1 9 1.5 77.7 77.7 0 0 0 .4-8.8c-1.7-.3-7.2-1.2-10.3-1.5a52 52 0 0 1 .9 8.8z"/><path class="b" d="M216.5 76.2a39.1 39.1 0 0 1-5.6 10.4c13 3 25.3 10.8 18.1 23.1-3.8 6.6-16.4 7.5-37.4 7.5l-55.4-.2a32.3 32.3 0 0 1-18.8 1.1c-6.8 1.5-18.2 3.7-28.2-3.1-30.8-.4-49.7 3.2-64.9-7.1C6.4 95.7 11.6 60.3 12 56.8c-6.4-12.5-.8-29.4 2.3-34.1S29.4 7.5 44.4 13c.2-.1 27.5-2.4 76-2.4 74.4 0 105.2.8 107.6 22.3 6 2.4 13.2 13 6.2 21 4.8 9.4.1 19.1-9.7 21.5a37.4 37.4 0 0 1 10.7 5.7c1.4-2.5 8.5-19.8 4.8-41.9-4.5-27.1-17.9-33.2-35.4-34.9C157.9 0 88.5.2 81.7.1 38.1-.3 18.2-.5 8.1 22.2-3.1 47.6-2.6 91.7 9.1 108c7.7 10.7 19.1 15.3 37.9 15.3 34.5 0 141.3 1.4 165.3 1.8 11-.3 27.9-3.4 29.3-19.7s-6.8-25.2-25.1-29.2z"/><path class="b" d="M202.7 88.6c1.3-.2 6.5-2 10.7-12.6-3-.2-6.3-.5-10.1-1.1.8 11.4-3 14-.6 13.7z"/><path class="b" d="M231.9 56c-7.6 5.5-18.2 1.8-19.8-3.4-2.6-8.6 4.4-10.9 6.7-10.6 7.7.8 7 6.1 4 8.1a1.5 1.5 0 0 1-1.9-2.4c1.8-1.3 0-2.8-2.1-2.7s-5.4 1-3.8 6.7 17.1 7.3 18.9-4.4c1-6.8-5.8-16.4-32.5-15.4a108.5 108.5 0 0 0-30.4 5.2c1.2 8.3-1.9 15.7-8.5 20.1-5.3 11.2-41.6 17.9-48.4-2.7-7.5.8-13.1 10-13.9 14.9a1.4 1.4 0 0 1-1.6 1.2c-6.5-.7-16.7 3.6-17.9 20-1.3 18.3 14.9 29.2 31.7 25.4a21.7 21.7 0 0 1-5-3.5c-5.7-.2-13.7-1.1-17.4-12.1-.6-1.7 2.1-3.2 2.9-.9 2.5 7.8 8.3 9.6 11.8 10a23.3 23.3 0 0 1-4.4-13.3c-.1-2.5 3-2 3-.2-.1 12.3 14.5 29.4 42 13 33.9-20.2 50.8-8.1 55.8-5 1.4.9 9.2 5.2 13.7.1 1.8-2 4.1-10.3-6.4-14.9-4.2 3.7-11.5 3.3-8.9-3-32.1-5.7-50.2 2.7-61.8 10.2s-16.4.3-17-2.5c-1.8-8.4 16.6-26.2 60.2-24.6 1.3-3.9 5.3-5.7 8.1.6 7.4.6 18 3.2 28.9 3.2s18.2-5.3 14-17.1z"/><path class="b" d="M176 81.3l3.8-9.1a107.7 107.7 0 0 0-23.6 1.6c-1.1 15.7-9.6 10.9-13.8 3.6-27.3 10.6-19.1 22.7-10.5 18.6-1.6-15.7 6-15 12.5-7a77.4 77.4 0 0 1 15.1-5.4c1.4-15.6 10-9.6 13.3-2.1zM65.8 101.1c5.2-.4 1.4-10.4 17-26.2 13.1-13.2-7.9-26.6-17.9-13s-4.4 39.6.9 39.2z"/><path class="b" d="M49.8 63.9c-4.7 6.2-6.6 20.2-2.4 30.6 2.9 7 6.9-1.5 9.3-5.4-1.2-8.8 0-20.5 5.2-28.1-5.6-3.5-10.1.3-12.1 2.9zM32.3 74.3c-2.4 10.4-.6 17.3 2.6 18.1s4.7-5.4 7.3-7.6c-.6-7.7.9-15.8 4.2-21.2-8.7-3.1-12.8 5.3-14.1 10.7z"/><path class="b" d="M12.2 39.9c-1.8 22.1 15.2 28 18.9 28.5 1.7-3.6 6.8-11.4 17.2-7.3 5.5-6.4 12-4.8 15.5-2.5C73.9 48.2 92 53.8 89.6 69.3a16.6 16.6 0 0 1 7.9-1.7c1.7-5.9 7.7-14.9 15.9-16.1a18.6 18.6 0 0 1 5.1-15.2c-4 1.6-20.6 10.6-28.1 12.3-1.4.3-2.4-2.4-.3-3 9.3-2.5 26.9-13.5 42.8-17.6 19.5-5.2 34.5 6.7 32.1 22.8 10.1-14.5-5.4-34.6-20.7-36.4-33.4-4.1-53.3 26.5-98.8 28.9-7 .4-11.9-2-13.7-6s-.9-9 3.7-10.6c2.1-.7 3.5 2.3 1.1 2.8s-4.9 9.2 4.8 10.7c12.7 2 14.5-14.3 7.3-21.2s-34-9.4-36.5 20.9zM108.8 156a30.1 30.1 0 0 1 6.8 8.2 45.5 45.5 0 0 1 2-10.6 17.4 17.4 0 0 1-5-5.7 47.5 47.5 0 0 0-3.8 8.1zM40.3 152.4c7.2.6 18.4-6.1 19.7-17.7-20.3-.3-20.5 13-19.7 17.7zM105.5 182.8c-9.5-20.1-30.2-13.6-46.7-2.2-14.8 10.3-29.4 7.7-35.8.1a31.5 31.5 0 0 1-4.6-32.4C5 168 14.6 187.8 24.8 193.5c18.7 10.5 37.8-5 41.6-8.5 12.4-11.2 28.8-11.8 33.4 2.2 4 12.2-7.6 21.6-15.9 18.1-10.7-4.4-6.4-13.5-3.1-15.1a7.4 7.4 0 0 1 8.7 1.9c1.2 1.3-.5 3.6-2.1 2.1s-3.5-2.1-5.1-1.3-4.3 7.6 2.6 9.6c8.9 2.6 14.7-7.1 12-14.4-3.9-10.7-15.2-8.9-19.9-6.6-14.5 7.2-12.8 30 6 30.7 23.2.9 27-19.8 22.5-29.4zM188.4 159.2c11.6 4.5 18.7-15.8 11.7-23.9-4.2 7.6-13.1 10.2-11.7 23.9z"/><path class="b" d="M191.9 172.1c-15.6-.4-20.8-23.1-41.9-20.9-24 2.5-24.8 45.6-13.1 57.6h3.1c-4.1-9.4-6.7-28.1 7.8-38.2 1.7-1.1 3.6 1.3 1.7 2.5-13.6 9.4-10.2 27.6-6.2 35.7h3.5c-4.2-8.4-3.6-21.3 2.4-27.3 18.5-18.3 44.9 16.4 57.1-.5 8-11.1 12.7-17.8 26.8-16.9a13.3 13.3 0 0 0-7-4c-19.7-4.1-20.7 12.4-34.2 12z"/><path class="b" d="M208.6 182.8c-13.7 18.8-40.7-15.8-57.2.7-5.4 5.4-5.6 18-1.2 25.1h6.1c-2-5.6.6-12.1 3.8-14.9 17.6-15 37.6 17.6 54.2-7.3 1-1.5 8.3-14.5 13.9-19.3-10.5.6-14.4 8.6-19.6 15.7z"/><path class="b" d="M238.8 151.3c-4-14.1-13.7-23-25.3-23.2-.3 0-120-1.8-163.5-1.8-40.8 0-44.9 21.4-47.3 34.2-3.8 20.4 3.9 40.1 8.9 46.1 9.4 11.4 25.3 13.6 48 13.6l128.4-.3c35.9 0 44.8-12.6 48.4-23.6 4.7-14 5.7-33.3 2.4-45zm-1.3 15.2c-1.5 1.5-3.3-.7-6.8 2.3.1 26.5-6.3 35.4-19 38.4-16.1 3.8-43.4 4.7-112.7 4.4-5.8 3.8-19.8 6.6-29-1.2-23.1.7-48.8.4-51.7-18.1-4.9-4.8-12.3-15.9-8.2-33.2 5.2-21.3 22.1-24.3 34.6-23.9 4.2-2.6 10-3.9 17-3.4 2 .2 1.4 2.5 1.3 3l59.3.8c.1-2-.9-2.5.1-3.9s8.9 1.7 11.8 4.1l61.1 1c4.2-4.3 3.6-10 9.2 0 12.4.9 25 4.3 26.3 21.8 3.7 1.8 8.1 6.4 6.7 7.9z"/><path class="b" d="M166.6 208.3l15.1-.6c-3.8-8.4-15.4-10.2-15.1.6zM113.3 166.2c-11.1-19.9-33.8-15.2-46.1-8.3-16.4 9.1-28.6 15.1-37.4 5.6-5.7-6.1-4.3-16.7-.5-23.4-12.8 6.6-13.3 28.1-4 38.6 5.7 6.5 18.5 8.7 31.8-.5 16.2-11.4 36.6-18.1 48.8-1.1 5.5 7.7 6.4 22.9-3 31.6h7.1c8-7 11.2-28.4 3.3-42.5z"/><path class="b" d="M137.7 153.6c1.7-13.2-7.4-17.4-12.4-18.8 1.6 11.6-8 17-6.8 36 4.6 13.7 2 29.9-4.4 38h19c-8.6-12.6-10-41.8 4.6-55.2z"/></svg>`;

    /** 
     * @private
     * @type {string}
     */
    this.mSvgText = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 228.9 29"><defs><style>.a{fill:#f5f5f5}</style></defs><path class="a" d="M9.7 19a3.7 3.7 0 0 1 2.9 1.4 6 6 0 0 1 .9 3.6 4.6 4.6 0 0 1-1.4 3.8c-.9.7-2.5 1-4.7 1L0 28.7V10.1l6.6-.2a9.4 9.4 0 0 1 4.9 1c.9.7 1.4 2 1.4 3.9a5.1 5.1 0 0 1-.7 3A3.3 3.3 0 0 1 9.7 19zm-6.4-1.1h3.4a3.3 3.3 0 0 0 2.3-.6 2.5 2.5 0 0 0 .7-2.1 2.9 2.9 0 0 0-.7-2.1 5.1 5.1 0 0 0-2.6-.5H3.3zm0 8.3h3.5a3.9 3.9 0 0 0 2.6-.6c.5-.3.7-1.1.7-2.2a3 3 0 0 0-.7-2.4 3.8 3.8 0 0 0-2.7-.7H3.3zM22.9 10.1v14.3a2.1 2.1 0 0 0 .3 1.2 2.3 2.3 0 0 0 1.3.3h6.4l.2 2.6c-1.8.2-4.3.2-7.4.2s-4.2-1.2-4.2-3.8V10.1zM46.2 23.4h-6.9l-1.5 5.3h-3.5L39.9 11a1.2 1.2 0 0 1 1.2-.9h3.3a1.2 1.2 0 0 1 1.2.9l5.6 17.7h-3.5zm-.8-2.7l-1.9-6.4c-.2-1-.4-1.5-.4-1.6h-.7l-.4 1.6-1.9 6.4zM68.2 25.8l.3 2.5a18.5 18.5 0 0 1-5.7.7c-2.8 0-4.7-.7-5.8-2.1s-1.7-4-1.7-7.5.5-6 1.7-7.4 3-2.2 5.8-2.2a19.8 19.8 0 0 1 5.3.6l-.3 2.6a39.4 39.4 0 0 0-5-.2c-1.5 0-2.6.4-3.1 1.4s-.9 2.7-.9 5.2.3 4.3.9 5.2a3.2 3.2 0 0 0 3.1 1.5 37.5 37.5 0 0 0 5.4-.3zM79.1 20.3h-1.8a11.1 11.1 0 0 1 .2 1.9v6.5h-3.4V10.1h3.4v5.5a12.5 12.5 0 0 1-.2 2.1h1.8l5.1-7.6h3.7l-5 7.5a4.3 4.3 0 0 1-1.3 1.4 4.5 4.5 0 0 1 1.5 1.6l5.1 8h-3.7zM100 21.4l-3.8-1.2a5.1 5.1 0 0 1-2.8-2 5.9 5.9 0 0 1-.9-3.4c0-2 .5-3.4 1.4-4s2.6-1 5-1a24 24 0 0 1 5.8.6l-.2 2.4H99a4.7 4.7 0 0 0-2.5.4c-.4.2-.6.8-.6 1.7a2.5 2.5 0 0 0 .4 1.7 3.8 3.8 0 0 0 1.7.8l3.5 1.1a5.3 5.3 0 0 1 3 2 5.9 5.9 0 0 1 .9 3.4c0 2.1-.5 3.4-1.5 4.2s-2.7 1-5.1 1a30.8 30.8 0 0 1-6.1-.6L93 26l5.8.2a4.4 4.4 0 0 0 2.5-.5 2.2 2.2 0 0 0 .6-1.8 2.2 2.2 0 0 0-.4-1.6 3.5 3.5 0 0 0-1.5-.9zM126 10.1h3.5a1.2 1.2 0 0 1 1.3 1.4l.8 17.2h-3.3l-.7-15.8h-.5l-3.2 12.3a1.3 1.3 0 0 1-1.4 1.1H120a1.4 1.4 0 0 1-1.5-1.1l-3.2-12.3h-.5l-.6 15.8h-3.3l.7-17.2c.1-.9.5-1.4 1.4-1.4h3.5a1.2 1.2 0 0 1 1.3 1.2l2.7 10 .5 2.6h.4a26.1 26.1 0 0 1 .6-2.6l2.6-10a1.4 1.4 0 0 1 1.4-1.2zM141.4 28.7H138V10.1h3.4zM161.5 13h-5.7v15.7h-3.4V13h-5.7v-2.9h14.8zM180.9 10.1v18.6h-3.4v-8.5h-7.3v8.5h-3.4V10.1h3.4v7.3h7.3v-7.3zM196 13.1l-.2-2.6a24.4 24.4 0 0 1 5.9-.7 8.9 8.9 0 0 1 4.5.9 3.5 3.5 0 0 1 1.5 3.3 6.4 6.4 0 0 1-.7 3.1 13.3 13.3 0 0 1-2.4 3.3l-4.9 5.3 2.8-.2h5.8v3.2h-12.7v-2a2 2 0 0 1 .5-1.4l4.9-5.4c2.2-2.4 3.3-4.2 3.3-5.6a1.3 1.3 0 0 0-.7-1.3 5.7 5.7 0 0 0-2.2-.3 52.9 52.9 0 0 0-5.4.4zM214.3 28.7V10.1l7-.2c2.8 0 4.8.7 5.9 2.1s1.7 3.8 1.7 7.4-.6 6.1-1.7 7.5-3.1 2-5.9 2-4.5 0-7-.2zm3.4-16v13.4h3.6a3.6 3.6 0 0 0 3.2-1.4 12.6 12.6 0 0 0 .8-5.3c0-2.5-.3-4.3-.9-5.3a3.3 3.3 0 0 0-3.1-1.4h-3.6zM.1 8.1v-8h2.7a2.9 2.9 0 0 1 2.1.5 3 3 0 0 1 .5 2 2.9 2.9 0 0 1-.5 1.9 2.5 2.5 0 0 1-1.9.6H1.2v3zm1.1-4h1.6a1.6 1.6 0 0 0 1.1-.3 2.1 2.1 0 0 0 .3-1.2 2.3 2.3 0 0 0-.3-1.3A1.6 1.6 0 0 0 2.8 1H1.2zM9.7 0a3 3 0 0 1 2.5.9 5.2 5.2 0 0 1 .7 3.2 5 5 0 0 1-.7 3.2 3 3 0 0 1-2.5.9 2.8 2.8 0 0 1-2.4-.9 5 5 0 0 1-.7-3.2A5.2 5.2 0 0 1 7.3.9 2.8 2.8 0 0 1 9.7 0zm1.6 1.7A1.7 1.7 0 0 0 9.7 1a1.6 1.6 0 0 0-1.5.7 4.5 4.5 0 0 0-.4 2.4 4.5 4.5 0 0 0 .4 2.4 1.6 1.6 0 0 0 1.5.7 1.7 1.7 0 0 0 1.6-.7 4.5 4.5 0 0 0 .4-2.4 4.5 4.5 0 0 0-.4-2.4zM24.2.1l-1.6 7.6a.4.4 0 0 1-.4.4h-1.3a.4.4 0 0 1-.4-.4l-1.2-5.8a3.4 3.4 0 0 1-.1-.9h-.3l-.2.9-1.1 5.8V8h-1.7c-.3 0-.4-.1-.5-.4L13.9.1h1.2l1.2 6.1a5.1 5.1 0 0 0 .1 1h.3c0-.3.1-.7.1-1L18 .5a.4.4 0 0 1 .4-.4h1.3a.2.2 0 0 1 .2.2.2.2 0 0 1 .2.2l1.1 5.7c.1.3.1.6.2 1h.3v-.5a1.1 1.1 0 0 0 .1-.5L22.9.1zM30.3 7.1V8H27a1.6 1.6 0 0 1-1.2-.4 1.2 1.2 0 0 1-.4-1v-5a1.4 1.4 0 0 1 .4-1.1A2.1 2.1 0 0 1 27 .1h3.4V1h-3.2l-.5.2a.7.7 0 0 0-.1.5v1.7h3.3v1h-3.3v2a1.1 1.1 0 0 0 .1.6h3.6zM37.6 8.1h-1.2l-.7-2.5a1.1 1.1 0 0 0-1-.8h-1.6v3.3h-1.2v-8h2.8a3.4 3.4 0 0 1 2 .5 2.4 2.4 0 0 1 .6 1.8 2.8 2.8 0 0 1-.3 1.4 2 2 0 0 1-1.2.6 1.4 1.4 0 0 1 1 1.2zm-4.5-4.3h1.6a1.6 1.6 0 0 0 1.1-.3 1.4 1.4 0 0 0 .3-1.1 1.6 1.6 0 0 0-.3-1.1 1.6 1.6 0 0 0-1.1-.3h-1.6zM43.9 7.1V8h-3.3a1.6 1.6 0 0 1-1.2-.4 1.2 1.2 0 0 1-.4-1v-5a1.4 1.4 0 0 1 .4-1.1 2.1 2.1 0 0 1 1.2-.4H44V1h-3.2a.6.6 0 0 0-.5.2.8.8 0 0 0-.2.5v1.7h3.4v1h-3.4v2a1.1 1.1 0 0 0 .2.6h3.6zM45.5 8.1v-8h2.9a3 3 0 0 1 2.4.9 5.2 5.2 0 0 1 .7 3.2 5.2 5.2 0 0 1-.7 3.2 3 3 0 0 1-2.4.9zm1.1-7v6h1.8a1.6 1.6 0 0 0 1.5-.7 5.7 5.7 0 0 0 .4-2.4 6.5 6.5 0 0 0-.4-2.4 1.8 1.8 0 0 0-1.5-.6h-1.8zM59.6 3.9a1.5 1.5 0 0 1 1.3.6 2.8 2.8 0 0 1 .3 1.5 2.2 2.2 0 0 1-.5 1.6 3.4 3.4 0 0 1-2 .5h-3v-8h2.6a3.7 3.7 0 0 1 2.1.4 1.8 1.8 0 0 1 .6 1.6 2.3 2.3 0 0 1-.3 1.3 1.4 1.4 0 0 1-1.1.5zm-2.8-.4h1.6a2.9 2.9 0 0 0 1.2-.2 1.3 1.3 0 0 0 .3-1c0-.5-.1-.9-.4-1a1.7 1.7 0 0 0-1.2-.3h-1.5zm0 3.7h1.7a1.7 1.7 0 0 0 1.2-.3c.3-.1.4-.5.4-1a1.7 1.7 0 0 0-.4-1.2 1.9 1.9 0 0 0-1.3-.3h-1.6zM65.6 5.3v2.8h-1.1V5.3L61.8.1h1.3l1.6 3.3a4.2 4.2 0 0 0 .3.9h.1a8.5 8.5 0 0 1 .3-.9L67 .1h1.2z"/></svg>`;
  }

  show() {
    let duration = this.mDuration * 0.001;
    let css = `#logo,#splash-screen{position:relative;box-sizing:border-box}#logo-inner,#logo-name{margin-left:auto;margin-right:auto}#splash-screen{z-index:999;top:0;left:0;width:100%;height:100%;display:block;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQYV2OUkpL6/+zZMwYpKSkGEM3IwMDwnwEJMBJUAQCLUhABUGRZzwAAAABJRU5ErkJggg==);opacity:1;animation:hide 0s ease-in ${duration}s forwards}@keyframes hide{to{opacity:0}}#logo{top:20%;left:50%;animation:fadein ${duration}s linear forwards}@keyframes fadein{0%{opacity:0}100%,40%{opacity:1}}#logo-name{width:100%;margin-top:108px}`;

    let style = document.createElement('style');
    style.type = 'text/css';
    style.innerHTML = css;
    document.getElementsByTagName('head')[0].appendChild(style);

    let container = /** @type {HTMLElement} */ (document.getElementById(Black.engine.containerElementId));
    let oldOverflow = container.style.overflow;
    container.style.overflow = 'hidden';

    let splash = document.createElement('div');
    splash.id = 'splash-screen';
    container.appendChild(splash);

    let logo = document.createElement('div');
    logo.id = 'logo';
    splash.appendChild(logo);

    let logoInner = document.createElement('div');
    logoInner.id = 'logo-inner';
    logoInner.innerHTML = this.mSvgLogo;
    logo.appendChild(logoInner);

    let logoName = document.createElement('div');
    logoName.id = 'logo-name';
    logoName.innerHTML = this.mSvgText;
    logo.appendChild(logoName);

    let refresh = () => {
      let mw = splash.offsetWidth;
      let mh = splash.offsetHeight;

      let size = this.calculateAspectRatioFit(mw, mh, mw * 0.5, mh * 0.5);

      logo.style.width = `${size.width}px`;
      logo.style.height = `${size.height}px`;
      logo.style.marginLeft = `${-size.width * 0.5}px`;

      logoInner.style.width = `${Math.min(size.width, size.height)}px`;
      logoInner.style.height = `${Math.min(size.width, size.height)}px`;

      logoName.style.width = `${Math.min(size.width, size.height) * 0.9}px`;
      logoName.style.height = `${Math.min(size.width, size.height)}px`;
      logoName.style.marginTop = `${12}px`;
    };

    refresh();

    let cw = container.offsetWidth;
    let ch = container.offsetHeight;

    let handle = setInterval(x => {
      if (cw !== container.offsetWidth || ch !== container.offsetHeight) {
        cw = container.offsetWidth;
        ch = container.offsetHeight;
        refresh();
      }
    }, 1000 / 60);

    setTimeout(() => {
      clearTimeout(handle);

      style.parentNode.removeChild(style);
      splash.parentNode.removeChild(splash);

      container.style.overflow = oldOverflow;

      /**
       * Posts when splash screen is hidden.
       * @event SplashScreen#complete
       */
      this.post(Message.COMPLETE);
    }, this.mDuration);

    this.post(Message.COMPLETE);
  }

  calculateAspectRatioFit(srcWidth, srcHeight, maxWidth, maxHeight) {
    let ratio = Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
    return { width: srcWidth * ratio, height: srcHeight * ratio };
  }
}

/**
 * Timer component.
 *
 * @cat timers
 * 
 * @fires Timer#complete
 * @fires Timer#tick
 * 
 * @extends black-engine~Component
 */
class Timer extends Component {
  constructor(interval = 1, ticksCount = 1, startOnAdded = true) {
    super();
    
    Debug.assert(interval > 0, 'the interval value must be greater than 0');
    Debug.assert(ticksCount > 0, 'the ticksCount value must be greater than 0');
    
    /** 
     * @private 
     * @type {boolean} 
     */
    this.mStartOnAdded = startOnAdded;

    /** 
     * @private 
     * @type {number} 
     */
    this.mInterval = interval;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTicksCount = ticksCount;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsRunning = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTick = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mElapsedSeconds = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mTotalElapsedSeconds = 0;
  }

  /**
   * @inheritDoc
   */
  onAdded() {
    if (this.mStartOnAdded)
      this.start();
  }

  /**
   * @inheritDoc
   */
  onUpdate() {
    if (this.mIsRunning === false)
      return;

    this.mElapsedSeconds += Black.time.delta;
    this.mTotalElapsedSeconds += Black.time.delta;

    if (this.mElapsedSeconds >= this.mInterval) {
      this.mElapsedSeconds = 0;

      const ticksPerUpdate = Math.max(1, ~~(Black.time.delta / this.mInterval));
      for (let i = 0; i < ticksPerUpdate; i++) {
        this.mTick++;

        /**
        * Posted on every timer tick.
        * @event Timer#tick
        */
        this.post('tick', this.mTick);

        if (this.mTick >= this.mTicksCount) {
          this.mIsRunning = false;

          /**
           * Posted on timer complete.
           * @event Timer#complete
           */
          this.post('complete');
          return;
        }
      }
    }
  }

  /**
   * Start timer.
   *
   * @return {black-engine~Timer} Returns this.
   */
  start() {
    this.mIsRunning = true;
    return this;
  }

  /**
   * Stop and reset timer.
   *
   * @return {black-engine~Timer} Returns this.
   */
  stop() {
    this.mIsRunning = false;
    this.reset();
    return this;
  }

  /**
   * Pauses the timer.
   *
   * @return {black-engine~Timer} Returns this.
   */
  pause() {
    this.mIsRunning = false;
    return this;
  }

  /**
   * Reset timer.
   *
   * sets ticks elapsedSeconds and totalElapsedSeconds to 0
   * @return {black-engine~Timer} Returns this.
   */
  reset() {
    this.mTick = 0;
    this.mElapsedSeconds = 0;
    this.mTotalElapsedSeconds = 0;
    return this;
  }

  /** How many ticks left.
   *
   * @return {number} Returns this.
   */
  get ticksLeft() {
    return this.mTicksCount - this.mTick;
  }

  /** current tick index.
   *
   * @return {number} Returns this.
   */
  get currentTick() {
    return this.mTick;
  }

  /**
   * elapsed seconds from previous tick.
   *
   * @return {number}
   */
  get elapsedSeconds() {
    return this.mElapsedSeconds;
  }

  /** how many seconds left to the next tick.
   *
   * @return {number} Returns this.
   */
  get secondsToNextTick() {
    return this.mInterval - this.mElapsedSeconds;
  }

  /** If the timer is running, returns true, otherwise false.
   *
   * @return {boolean} Returns this.
   */
  get isRunning() {
    return this.mIsRunning === true;
  }

  /** If the number of ticks is less than the specified number, returns false, otherwise true.
   *
   * @return {boolean} Returns this.
   */
  get isComplete() {
    return this.mTick >= this.mTicksCount;
  }

  /**
   * Sets/Get the number of timer ticks.
   *
   * @return {number}
   */
  get ticksCount() {
    return this.mTicksCount;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set ticksCount(value) {
    Debug.assert(value > 0, 'the ticksCount value must be greater than 0');
    this.mTicksCount = value;
  }

  /**
   * Sets/Get the timer interval in seconds.
   *
   * @return {number}
   */
  get interval() {
    return this.mInterval;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set interval(value) {
    Debug.assert(value > 0, 'the interval value must be greater than 0');
    this.mInterval = value;
  }

  /**
   * total elapsed seconds.
   *
   * @return {number}
   */
  get totalElapsedSeconds() {
    return this.mTotalElapsedSeconds;
  }

  /**
   * Sets/Gets whether the timer should start automatically when added to the root.
   * 
   * @return {boolean}
   */
  get startOnAdded() {
    return this.mStartOnAdded;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set startOnAdded(value) {
    this.mStartOnAdded = value;
  }
}

let ID$3 = 0;
/**
 * The Black class represents the core of the Black Engine.
 *
 * @fires Engine#paused
 * @fires Engine#unpaused
 * @fires Engine#ready
 * @fires Engine#looped
 *
 * @extends black-engine~MessageDispatcher
 */
class Engine extends MessageDispatcher {
  /**
   * Creates a new Black instance.
   * 
   * First parameter has to be a id of the HTML div element the game will be rendered to.
   * Second parameter has to be `GameObject` class which will be the root object of your application.
   * Third parameter has to be a class name of `VideoNullDriver` subclass eg `CanvasDriver`.
   * Fourth parameter is optional array of System to use,
   * 
   * @example
   * // Creates new Black instance with MyGame as a root class, CanvasDriver as renderer and Arcade physics as a system.
   * new Black('game-container', MyGame, CanvasDriver, [Arcade]);
   * 
   * @param {string}                                                       containerElementId The id of an DOM element.
   * @param {function(new: black-engine~GameObject)}                                    gameClass          Type name of an GameObject to start execution from.
   * @param {function(new: black-engine~VideoNullDriver, HTMLElement, number, number)}  videoDriverClass   Type name of an VideoDriver (VideoNullDriver, DOMDriver or CanvasDriver)
   * @param {Array<function(new: black-engine~System)>  }                               systemClasses      The list of systems to be initialized with Black engine.
   */
  constructor(containerElementId, gameClass, videoDriverClass, systemClasses = null) {
    super();

    this.id = ++ID$3;

    Black.engine = this;

    /** 
     * @private 
     * @type {string} 
     */
    this.mContainerElementId = containerElementId;

    /** 
     * @private 
     * @type {HTMLElement|null} 
     */
    this.mContainerElement = null;

    /** 
     * @private 
     * @type {function(new: black-engine~VideoNullDriver, HTMLElement, number, number)} 
     */
    this.mVideoDriverClass = videoDriverClass;

    /** 
     * @private 
     * @type {Array<function(new: black-engine~System)>} 
     */
    this.mSystemClasses = systemClasses;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStageWidth = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mStageHeight = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mLastUpdateTime = 0;

    /** 
     * @private 
     * @type {number} 
     */
    this.mFrameNum = 0;

    /** 
     * @private
     * @type {number}
     */
    this.mNumUpdates = 0;

    /** 
     * @private
     * @type {number}
     */
    this.mMaxUpdatesPerFrame = 60;

    /** 
     * @private 
     * @type {number} 
     */
    this.mLastRenderTime = 0;

    /** 
     * @private 
     * @type {Array<black-engine~System>} 
     */
    this.mSystems = [];

    /** 
     * @private 
     * @type {black-engine~GameObject|null} 
     */
    this.mGameObject = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsRunning = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsStarted = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mIsPanic = false;

    /** 
     * @private 
     * @type {number} 
     */
    this.mRAFHandle = -1; // not sure

    /** 
     * @private 
     * @type {black-engine~Viewport} 
     */
    this.mViewport = null;

    /** 
     * @private 
     * @type {black-engine~VideoNullDriver} 
     */
    this.mVideo = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPaused = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mUnpausing = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPauseOnHide = true;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPauseOnBlur = true;

    /** 
     * @private 
     * @type {Object<string, Array>} 
     */
    this.mTagCache = {};

    /** 
     * @private 
     * @type {function(new: black-engine~GameObject)} 
     */
    this.mGameClass = gameClass;

    /** 
     * @private 
     * @type {black-engine~Stage} 
     */
    this.mStage = null;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mWasStopped = false;

    /** 
     * @private 
     * @type {Array<number>} 
     */
    this.mFrameTimes = [];

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mUseHiDPR = false;

    /** 
     * @private 
     * @type {boolean} 
     */
    this.mPendingDispose = false;

    this.__initialize();
  }

  /**
   * @ignore
   */
  __initialize() {
    console.log('%c                         >>> BLACK <<<                         ', 'background: #000; color: #fff;');

    this.mContainerElement = /** @type {!HTMLElement} */ (document.getElementById(this.mContainerElementId));

    if (!this.mContainerElement)
      throw new Error('Container element was not found');

    Black.device = new Device();

    this.mStageWidth = this.mContainerElement.clientWidth;
    this.mStageHeight = this.mContainerElement.clientHeight;
    this.mUseHiDPR = Black.device.isMobile;

    this.__bootViewport();
    this.__update = this.__update.bind(this);
  }

  /**
   * Pauses all engine update logic. Note: RAF is not going to be paused and will work in background.
   *
   * @return {void}
   */
  pause() {
    this.mPaused = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onPause();

    /**
     * Posted after engine entered paused state.
     *
     * @event Engine#paused
     */
    this.post('paused');
  }

  /**
   * Resumes update execution.
   *
   * @return {void}
   */
  resume() {
    if (this.mPaused === true)
      this.mUnpausing = true;
  }

  __setUnpaused() {
    this.mPaused = false;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onResume();

    /**
     * Posted after engine is unpaused.
     *
     * @event Engine#unpaused
     */
    this.post('unpaused');
  }

  /**
   * @private
   * @returns {void}
   */
  __bootViewport() {
    this.mViewport = new Viewport(this.mContainerElement);
  }

  /**
   * @private
   * @returns {void}
   */
  __bootSystems() {
    if (this.mSystemClasses === null)
      return;

    for (let i = 0; i < this.mSystemClasses.length; i++)
      this.__addSystem(new this.mSystemClasses[i]());
  }

  __checkVisibility() {
    if (typeof document.hidden === 'undefined') {
      // lets fake hidden if there is no support for Page Visibility API
      document.hidden = false;
      document.visibilityState = 'visible';

      window.onpagehide = event => this.__onVisibilityChangeFallback(event);
      window.onpageshow = event => this.__onVisibilityChangeFallback(event);
    } else {
      document.addEventListener('visibilitychange', event => this.__onVisibilityChange(event), false);
    }

    window.onblur = event => this.__onVisibilityChangeFallback(event);
    window.onfocus = event => this.__onVisibilityChangeFallback(event);
  }

  /**
   * @private
   * @returns {void}
   */
  __bootStage() {
    this.mStage = new Stage();

    this.__checkVisibility();

    if (document.hidden && this.mPauseOnHide === true)
      this.pause();
  }

  /**
   * @private
   * @returns {void}
   */
  __onVisibilityChangeFallback(event) {
    let type = event.type;

    if (type === 'blur' && this.mPauseOnBlur === true)
      this.pause();
    else if (type === 'pagehide' && this.mPauseOnHide === true)
      this.pause();
    else if (type === 'focus' || type === 'pageshow') {
      if (document.hidden === false)
        this.resume();
    }
  }

  __onVisibilityChange() {
    if (this.mPauseOnHide === true && document.visibilityState === 'hidden')
      this.pause();
    else if (document.visibilityState === 'visible')
      this.resume();
  }

  /**
   * Returns true if system exists.
   *
   * @param {Function} systemTypeName
   */
  hasSystem(systemTypeName) {
    for (let i = 0; i < this.mSystems.length; i++) {
      let c = this.mSystems[i];
      if (c instanceof systemTypeName)
        return true;
    }

    return false;
  }

  /**
   * @private
   * @param  {black-engine~System} system The System object you want to add.
   * @return {black-engine~System}
   */
  __addSystem(system) {
    this.mSystems.push(system);
    return system;
  }

  /**
   * Gets system by type.
   *
   * @param {Function} typeName The system type.
   * @return {black-engine~System|null} The `System` instance or null if not found.
   */
  getSystem(typeName) {
    for (let i = 0; i < this.mSystems.length; i++) {
      let s = this.mSystems[i];
      if (s instanceof typeName)
        return s;
    }

    return null;
  }

  /**
   * @private
   * @returns {void}
   */
  __bootVideo() {
    this.mVideo = new this.mVideoDriverClass(this.mViewport.mViewportElement, this.mStageWidth, this.mStageHeight);
  }

  /**
   * Boots up the engine!
   *
   * @return {void}
   */
  start() {
    if (this.mWasStopped === true) {
      Debug.error('Black engine cannot be re-started.');
      return;
    }

    Black.engine = this;

    if (this.mIsStarted === true)
      return;

    Black.time = new Time();

    this.__bootSystems();
    this.__bootStage();
    this.__bootVideo();

    this.mStage.__refresh();

    /**
     * Posted when all systems, stage and driver ready to be used. 
     *
     * @event Engine#ready
     */
    this.post(Message.READY);

    this.mGameObject = new this.mGameClass();
    this.mStage.addChild(this.mGameObject);

    const self = this;

    this.mIsStarted = true;
    this.mVideo.start();

    // TODO: is there a way to cancel first raf? no! eg pause will not work
    this.mRAFHandle = window.requestAnimationFrame(function (timestamp) {
      // TODO: do first update here
      self.mIsRunning = true;

      self.mLastUpdateTime = timestamp;
      self.mLastRenderTime = self.mLastUpdateTime;

      // Start the main loop.
      self.__update(timestamp, true);
    });
  }

  /**
   * Stops any executions, destroys resources and scene.
   *
   * @return {void}
   */
  stop() {
    this.mIsStarted = false;
    this.mIsRunning = false;
    window.cancelAnimationFrame(this.mRAFHandle);

    console.log('%c                        <<< BYE BYE >>>                        ', 'background: #000; color: #fff;');
  }

  /**
   * Destroys the whole thing!
   */
  destroy() {
    this.mPendingDispose = true;
  }

  __dispose() {
    this.stop();

    this.mVideo.dispose();
    this.mViewport.dispose();

    Black.assets.dispose();
    Black.assets = null;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].dispose();

    MessageDispatcher.dispose();

    this.mNumUpdates = 0;
    this.mFrameNum = 0;
    Black.engine = null;
  }

  /**
   * @private
   * @param {number} timestamp
   * @param {boolean} forceUpdate
   * @return {void}
   */
  __update(timestamp, forceUpdate) {
    let time = Black.time;

    // Calculate FPS
    if (this.mPaused === true && this.mUnpausing === true) {
      this.mUnpausing = false;

      this.mLastUpdateTime = timestamp;
      this.mLastRenderTime = this.mLastUpdateTime;

      this.__setUnpaused();
    }

    this.mRAFHandle = window.requestAnimationFrame(/** @type {function(number)} */(this.__update));

    if (this.mPaused === true)
      return;

    let numTicks = Math.floor((timestamp - this.mLastUpdateTime) / time.mDeltaTimeMs);

    if (forceUpdate === true)
      numTicks = 1;

    if (numTicks > this.mMaxUpdatesPerFrame) {
      /**
       * Posted when engine is not able to achieve desired amount of updates per second. 
       * 
       * Usually happens when user switches to another tab in browser or update logic is too heavy to be executed 
       * withing one update loop. Lowering `Black.ups` value can help if update is heavy. 
       * Increasing `Black.maxUpdatesPerFrame` can lead to dead lock.
       *
       * @event Engine#looped
       */
      this.post('looped', numTicks);
      Debug.warn(`Unable to catch up ${numTicks} update(s).`);

      numTicks = this.mMaxUpdatesPerFrame;
    }

    this.mNumUpdates = numTicks;
    for (let i = 0; i < numTicks; i++) {
      time.mActualTime += time.delta;
      time.mTime = time.mActualTime;

      this.__internalUpdate();
      this.__internalSystemPostUpdate();
    }

    for (let l = timestamp - time.mDeltaTimeMs; this.mLastUpdateTime < l;)
      this.mLastUpdateTime += time.mDeltaTimeMs;

    if (numTicks === 0)
      time.mAlphaTime = (timestamp - this.mLastUpdateTime) / time.mDeltaTimeMs;
    else
      time.mAlphaTime = 0;

    time.mTime = time.mActualTime + ((timestamp - this.mLastUpdateTime) * 0.001) * time.mScale;

    this.__internalSystemRender();
    this.mVideo.beginFrame();
    this.mVideo.render(this.mStage);
    this.mVideo.endFrame();

    this.mFrameNum++;

    this.mIsPanic = false;
    Renderer.__dirty = false;

    this.mLastRenderTime = timestamp;

    if (this.mPendingDispose === true)
      this.__dispose();
  }

  /**
   * @private
   * @return {void}
   */
  __internalUpdate() {
    this.mViewport.__update();

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onUpdate();

    this.mStage.__update();
  }

  /**
   * @private
   * @return {void}
   */
  __internalSystemPostUpdate() {
    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onPostUpdate();
  }

  /**
   * @private
   * @return {void}
   */
  __internalSystemRender() {
    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onRender();
  }

  /**
   * Called when tag changed for specific `GameObject`.
   *
   * @protected
   * @param {black-engine~GameObject} child   A game object fired the event.
   * @param {string|null} oldTag Old tag.
   * @param {string|null} newTag New tag.
   * @return {void}
   */
  onTagUpdated(child, oldTag, newTag) {
    if (oldTag !== null) {
      let arr = this.mTagCache[oldTag];
      arr.splice(arr.indexOf(child), 1);

      if (arr.length === 0)
        delete this.mTagCache[oldTag];
    }

    if (newTag !== null) {
      if (this.mTagCache.hasOwnProperty(newTag) === false)
        this.mTagCache[newTag] = [];

      this.mTagCache[newTag].push(child);
    }
  }

  /**
   * Called when specific game object is added to display list.
   *
   * @protected
   * @param  {black-engine~GameObject} child Instance of GameObject.
   * @return {void}
   */
  onChildrenAdded(child, parent) {
    if (!(parent.root instanceof Stage))
      return;

    Renderer.__dirty = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onChildrenAdded(child);

    GameObject.forEach(child, (x) => {
      if (x.mAdded === true)
        return;

      this.onTagUpdated(x, null, x.mTag);

      x.mAdded = true;
      x.onAdded();

      for (let i = 0; i < x.mComponents.length; i++) {
        let c = x.mComponents[i];

        if (c.mAdded === true)
          continue;

        c.mAdded = true;
        c.onAdded(x);
      }
    });
  }

  /**
   * Called when specific game object is changed its index in display list.
   *
   * @protected
   * @param {black-engine~GameObject} child Instance of GameObject.
   * @return {void}
   */
  onChildrenChanged(child) {
    Renderer.__dirty = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onChildrenChanged(child);
  }

  /**
   * Called when specific game object is added to display list.
   *
   * @protected
   * @param  {black-engine~GameObject} child Instance of GameObject.
   * @return {void}
   */
  onChildrenRemoved(child) {
    Renderer.__dirty = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onChildrenRemoved(child);

    GameObject.forEach(child, (x) => {
      if (x.mAdded === true) {
        this.onTagUpdated(x, null, x.mTag);

        x.mAdded = false;
        x.onRemoved();

        for (let i = 0; i < x.mComponents.length; i++) {
          let c = x.mComponents[i];

          if (c.mAdded === false)
            continue;

          c.mAdded = false;
          c.onRemoved(x);
        }
      }
    });
  }

  /**
   * Called when specific component is added to GameObject instance.
   *
   * @protected
   * @param  {black-engine~GameObject} child Instance of GameObject.
   * @param  {black-engine~Component} component Instance of Component added to game object.
   * @return {void}
   */
  onComponentAdded(child, component) {
    Renderer.__dirty = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onComponentAdded(child, component);

    if (component.mAdded === true)
      return;

    component.mAdded = true;
    component.onAdded(child);
  }

  /**
   * Called when specific component is removed from its owner.
   *
   * @protected
   * @param  {black-engine~GameObject} child Instance of GameObject.
   * @param  {black-engine~Component} component Instance of Component removed from game object.
   * @return {void}
   */
  onComponentRemoved(child, component) {
    Renderer.__dirty = true;

    for (let i = 0; i < this.mSystems.length; i++)
      this.mSystems[i].onComponentRemoved(child, component);

    if (component.mAdded === false)
      return;

    component.mAdded = false;
    component.onRemoved(child);
  }

  /**
   * Gets/Sets the number of updates should be done per second.
   *
   * @return {number}
   */
  get ups() {
    return Black.time.mDeltaTimeMs * 0.001;
  }

  /**
   * @param {number} value
   * @return {void}
   */
  set ups(value) {
    Debug.isNumber(value);
    Debug.assert(value > 0);

    Black.time.mDeltaTimeMs = 1000 / value;
    Black.time.mDeltaTime = Black.time.mDeltaTimeMs * 0.001;
  }

  /**
   * Returns the current viewport instance. Used to get size of a game screen, or listen for resize messages.
   *
   * @return {black-engine~Viewport}
   */
  get viewport() {
    return this.mViewport;
  }

  /**
   * Returns the DOM element the engine runs in.
   *
   * @return {Element}
   */
  get containerElement() {
    return this.mContainerElement;
  }

  /**
   * Gets/Sets if engine should be automatically paused when window is hidden.
   *
   * @return {boolean}
   */
  get pauseOnHide() {
    return this.mPauseOnHide;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set pauseOnHide(value) {
    this.mPauseOnHide = value;
  }

  /**
   * Gets/Sets if engine should be automatically paused when container element is blurred.
   *
   * @return {boolean}
   */
  get pauseOnBlur() {
    return this.mPauseOnBlur;
  }

  /**
   * @param {boolean} value
   * @return {void}
   */
  set pauseOnBlur(value) {
    this.mPauseOnBlur = value;
  }

  /**
   * Returns True if engine is paused.
   *
   * @readonly
   * @returns {boolean}
   */
  get isPaused() {
    return this.mPaused;
  }

  /**
   * Returns current stage.
   *
   * @readonly
   * @returns {black-engine~Stage}
   */
  get stage() {
    return this.mStage;
  }

  /**
   * Returns HTML container element id.
   * @returns {string}
   */
  get containerElementId() {
    return this.mContainerElementId;
  }

  /**
   * Gets/sets whenever driver should be created with high DPR support. 
   * NOTE: Cannot be changed at runtime.
   * 
   * @returns {boolean}
   */
  get useHiDPR() {
    return this.mUseHiDPR;
  }

  /**
   * @param {boolean} value
   * @returns {void}
   */
  set useHiDPR(value) {
    this.mUseHiDPR = value;
  }


  /**
   * Returns number of frame since engine start.
   *
   * @readonly
   * @returns {number}
   */
  get frameNum() {
    return this.mFrameNum;
  }

  /**
   * Indicates how many updates will be done during this frame.
   *
   * @readonly
   * @returns {number}
   */
  get numUpdates() {
    return this.mNumUpdates;
  }

  /** 
   * Limit for number of updates to be done per one RAF.
   * @returns {number}
   */
  get maxUpdatesPerFrame() {
    return this.mMaxUpdatesPerFrame;
  }

  /** 
   * Limit for number of updates to be done per one RAF.
   * @param {number} value
   * @returns {void}
   */
  set maxUpdatesPerFrame(value) {
    this.mMaxUpdatesPerFrame = value;
  }
}




/***/ }),

/***/ "./src/assets/textures/particle.png":
/*!******************************************!*\
  !*** ./src/assets/textures/particle.png ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "particle-da074408.png");

/***/ }),

/***/ "./src/assets/textures/popart_anvil.png":
/*!**********************************************!*\
  !*** ./src/assets/textures/popart_anvil.png ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "popart_anvil-ff2e532b.png");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! exports provided: Game */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Game", function() { return Game; });
/* harmony import */ var black_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! black-engine */ "./node_modules/black-engine/dist/black-engine.module.js");
/* harmony import */ var _assets_textures_particle_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/textures/particle.png */ "./src/assets/textures/particle.png");
/* harmony import */ var _assets_textures_popart_anvil_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/textures/popart_anvil.png */ "./src/assets/textures/popart_anvil.png");




class Game extends black_engine__WEBPACK_IMPORTED_MODULE_0__["GameObject"] {
  constructor() {
    super();

    // Pick default AssetManager
    var assets = new black_engine__WEBPACK_IMPORTED_MODULE_0__["AssetManager"]();

    // load images, make sure to import them first
    assets.enqueueImage('anvil', _assets_textures_popart_anvil_png__WEBPACK_IMPORTED_MODULE_2__["default"]);
    assets.enqueueImage('star', _assets_textures_particle_png__WEBPACK_IMPORTED_MODULE_1__["default"]);

    // load font
    assets.enqueueGoogleFont('Titillium Web');

    // Listen for a complete message
    assets.on('complete', this.onAssetsLoadded, this);

    // Start preloading all enqueued assets
    assets.loadQueue();
  }

  onAssetsLoadded(m) {
    // Create a sprite
    let sprite = new black_engine__WEBPACK_IMPORTED_MODULE_0__["Sprite"]('anvil');
    sprite.alignPivotOffset(0.5, 1);

    sprite.x = this.stage.centerX;
    sprite.y = this.stage.centerY + 200;

    // make this game object touchable so children elements can be able to receive input too
    this.touchable = true;

    // sprite also needs to be touchable
    sprite.touchable = true;

    // Create a emitter
    let emitter = new black_engine__WEBPACK_IMPORTED_MODULE_0__["Emitter"]();
    emitter.space = this.parent;
    emitter.blendMode = black_engine__WEBPACK_IMPORTED_MODULE_0__["BlendMode"].ADD;
    emitter.x = this.stage.centerX + 10;

    emitter.emitCount = new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](30);
    emitter.emitDelay = new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](0);
    emitter.emitInterval = new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](0);
    emitter.emitDuration = new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](Infinity);
    emitter.emitNumRepeats = new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](Infinity);
    emitter.textures = [black_engine__WEBPACK_IMPORTED_MODULE_0__["Black"].assets.getTexture('star')];

    emitter.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["InitialLife"](0.3, 0.9));
    emitter.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["InitialVelocity"](-50, 0, 50, -200));
    emitter.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["Acceleration"](-500, -500, 500, 800));
    emitter.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["ColorOverLife"](0xf16c20, 0xfc3aa4));
    emitter.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["ScaleOverLife"](new black_engine__WEBPACK_IMPORTED_MODULE_0__["FloatScatter"](1.2, 0, black_engine__WEBPACK_IMPORTED_MODULE_0__["Ease"].exponentialIn)));

    console.log(this.stage);

    emitter.y = this.stage.bounds.y - 500;

    let tween = new black_engine__WEBPACK_IMPORTED_MODULE_0__["Tween"]({ y: [0, sprite.y - 110] }, 1, { loop: true, repeatDelay: 1 });
    emitter.add(tween);

    // Tween sprite color
    sprite.color = 0xffffff;
    sprite.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["Tween"]({ color: [0xffffaa, 0xff0000, 0xffffaa] }, 0.5, { delay: 0.7, loop: true, repeatDelay: 1.5 }, { color: black_engine__WEBPACK_IMPORTED_MODULE_0__["ColorHelper"].lerpHSV }));
    sprite.add(new black_engine__WEBPACK_IMPORTED_MODULE_0__["Tween"]({ scaleY: [1, 0.9, 1] }, 0.5, { delay: 0.69, loop: true, repeatDelay: 1.5 }));

    let textField = new black_engine__WEBPACK_IMPORTED_MODULE_0__["TextField"]('Black Engine v0.5.10', 'Titillium Web', 0xffffff, 15, black_engine__WEBPACK_IMPORTED_MODULE_0__["FontStyle"].NORMAL, black_engine__WEBPACK_IMPORTED_MODULE_0__["FontWeight"].BOLD);
    textField.highQuality = true;
    textField.x = this.stage.bounds.x;
    textField.y = this.stage.bounds.y;

    // Add sprite, text and emitter onto the stage
    this.add(emitter, sprite, textField);

    this.sprite = sprite;
    this.emitter = emitter;
    this.text = textField;

    this.stage.on('resize', this.onResize, this);
  }

  onResize() {
    this.text.x = this.stage.bounds.x;
    this.text.y = this.stage.bounds.y;
  }
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var black_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! black-engine */ "./node_modules/black-engine/dist/black-engine.module.js");
/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game */ "./src/game.js");



document.addEventListener('deviceready', onDeviceReady, false);

function onDeviceReady() {
    // Cordova is now initialized. Have fun!
    main();
}

function main() {
	// Game will be our starting class and rendering will be done on Canvas
	const engine = new black_engine__WEBPACK_IMPORTED_MODULE_0__["Engine"]('app', _game__WEBPACK_IMPORTED_MODULE_1__["Game"], black_engine__WEBPACK_IMPORTED_MODULE_0__["CanvasDriver"], [black_engine__WEBPACK_IMPORTED_MODULE_0__["Input"]]);

	// Pause simulation when app loses focus
	engine.pauseOnBlur = false;

	// Pause simulation when page is getting hidden
	engine.pauseOnHide = false;

	// Wroom, wroom!
	engine.start();

	// // Set default stage size
	engine.stage.setSize(900, 500);

	// // Makes stage always centered
	engine.stage.scaleMode = black_engine__WEBPACK_IMPORTED_MODULE_0__["StageScaleMode"].LETTERBOX;
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsYWNrLWVuZ2luZS9kaXN0L2JsYWNrLWVuZ2luZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy90ZXh0dXJlcy9wYXJ0aWNsZS5wbmciLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy90ZXh0dXJlcy9wb3BhcnRfYW52aWwucG5nIiwid2VicGFjazovLy8uL3NyYy9nYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0M7QUFD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QUFDN0I7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEs7QUFDZDtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEs7QUFDZDtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEs7QUFDZDtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNk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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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LGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsdUI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9CO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHVCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx3QjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsK0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDhCO0FBQ2Q7QUFDQTtBQUNBOztBQUVB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQSxjQUFjLHVCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx1QjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHlCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxzQztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsNEI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHdCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDRCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMs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O0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGU7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYyxpQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE87QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsOEI7QUFDZDtBQUNBOztBQUVB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QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0M7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdDO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdDO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywwQztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsK0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFB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QTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxjQUFjLDZCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw2QjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDBCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywwQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMEI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDBCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywwQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMEI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9CO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsOEI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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cEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyx1QjtBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEI7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFB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QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsY0FBYywyQkFBMkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixrRUFBa0U7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsY0FBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsYTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLGFBQWE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0I7QUFDZDtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFU7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFU7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsY0FBYywrQjtBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUI7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsdUI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDJCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE87QUFDVjtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE87QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTztBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE87QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7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O0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE87QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkI7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDZCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPO0FBQ2Q7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxjQUFjLHNCO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw2QjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0I7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLHVDO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxtQjtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUcsUUFBUSx3REFBVyxVQUFVO0FBQ3JKLG1CQUFtQixrREFBSyxFQUFFLHNCQUFzQixRQUFRLDRDQUE0Qzs7QUFFcEcsd0JBQXdCLHNEQUFTLHdEQUF3RCxzREFBUyxTQUFTLHVEQUFVO0FBQ3JIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDekZBO0FBQUE7QUFBQTtBQUFrRjtBQUNwRDs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtREFBTSxRQUFRLDBDQUFJLEVBQUUseURBQVksR0FBRyxrREFBSzs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiwyREFBYztBQUN4QyIsImZpbGUiOiJpbmRleC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIi8qKlxyXG4gKiBAcHJlc2VydmVcclxuICogQmxhY2tzbWl0aCAyRCB2MC41LjExXHJcbiAqIFxyXG4gKiBTSU1QTElGSUVEIEJTRCBMSUNFTlNFXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT1cclxuICogXHJcbiAqIENvcHlyaWdodCAyMDE5IEJvcm5hIFRlY2hub2xvZ3kgTHRkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKiBcclxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcclxuICogY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiBcclxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcclxuICogb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHNcclxuICogcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiBcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBCT1JOQSBURUNITk9MT0dZIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxyXG4gKiBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBCT1JOQSBURUNITk9MT0dZIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXHJcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcclxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRlxyXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICogXHJcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXHJcbiAqIGF1dGhvcnMgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgcmVwcmVzZW50aW5nIG9mZmljaWFsIHBvbGljaWVzLCBlaXRoZXIgZXhwcmVzc2VkXHJcbiAqIG9yIGltcGxpZWQsIG9mIEJvcm5hIFRlY2hub2xvZ3kuXHJcbiAqL1xyXG5cclxuLy8gQGlmZGVmIERFQlVHXHJcbi8qKlxyXG4gKiBVdGlsaXR5IGNsYXNzIGZvciBsb2dnaW5nIGFuZCBkZWJ1Z2dpbmcuXHJcbiAqXHJcbiAqIEBjYXQgY29yZVxyXG4gKi9cclxuY2xhc3MgRGVidWcge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgRGVidWcuYXNzZXJ0KGZhbHNlLCAnU3RhdGljIGNsYXNzLicpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGlzTnVtYmVyKC4uLnZhbHVlcykge1xyXG4gICAgdmFsdWVzLmZvckVhY2goeCA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgaXNOYU4ocGFyc2VGbG9hdCh4KSkgPT09IGZhbHNlICYmIGlzRmluaXRlKHgpID09PSB0cnVlKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGxldCBtZXNzYWdlID0gJ05vdCBhIG51bWJlci4nO1xyXG5cclxuICAgICAgaWYgKERlYnVnLmxvZ09uRmFpbClcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbQVNTRVJUXScsIG1lc3NhZ2UpO1xyXG5cclxuICAgICAgaWYgKERlYnVnLnRocm93T25GYWlsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgPT0gbnVsbCA/ICdBc3NlcnRpb24gZmFpbGVkLicgOiBtZXNzYWdlO1xyXG5cclxuICAgIGlmIChEZWJ1Zy5sb2dPbkZhaWwpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBU1NFUlRdJywgbWVzc2FnZSk7XHJcblxyXG4gICAgaWYgKERlYnVnLnRocm93T25GYWlsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXNzZXJ0V2Fybih2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgPT0gbnVsbCA/ICdBc3NlcnRpb24gd2FybmluZy4nIDogbWVzc2FnZTtcclxuICAgIERlYnVnLndhcm4obWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXNzZXJ0SW5mbyh2YWx1ZSwgbWVzc2FnZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgPT0gbnVsbCA/ICdBc3NlcnRpb24gaW5mby4nIDogbWVzc2FnZTtcclxuICAgIERlYnVnLmluZm8obWVzc2FnZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPdXRwdXRzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAgey4uLnN0cmluZ30gbWVzc2FnZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBsb2coLi4ubWVzc2FnZSkge1xyXG4gICAgY29uc29sZS5pbmZvKCclYyVzJywgJ2NvbG9yOiAjMDAwMDAwJywgJ0xPRzonLCAuLi5tZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE91dHB1dHMgYSBpbmZvIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGVcclxuICAgKiBcclxuICAgKiBAcGFyYW0gIHsuLi5zdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuICBzdGF0aWMgaW5mbyguLi5tZXNzYWdlKSB7XHJcbiAgICBjb25zb2xlLmluZm8oJyVjJXMnLCAnY29sb3I6ICMwMDNiZDInLCAnSU5GTzonLCAuLi5tZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE91dHB1dHMgYSB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGVcclxuICAgKiBcclxuICAgKiBAcGFyYW0gIHsuLi5zdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuICBzdGF0aWMgd2FybiguLi5tZXNzYWdlKSB7XHJcbiAgICBjb25zb2xlLmluZm8oJyVjJXMnLCAnY29sb3I6ICNmNjc0MDAnLCAnV0FSTjonLCAuLi5tZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE91dHB1dHMgYSBlcnJvciBtZXNzYWdlIHRvIHRoZSBjb25zb2xlXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7Li4uc3RyaW5nfSBtZXNzYWdlXHJcbiAgICovXHJcbiAgc3RhdGljIGVycm9yKC4uLm1lc3NhZ2UpIHtcclxuICAgIGNvbnNvbGUuaW5mbygnJWMlcycsICdjb2xvcjogI2Q1MDAwMCcsICdFUlJPUjonLCAuLi5tZXNzYWdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxyXG4gICAqL1xyXG4gIHN0YXRpYyB0aW1lKG5hbWUpIHtcclxuICAgIERlYnVnLnRpbWVQcm9maWxlc1tuYW1lXSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICovXHJcbiAgc3RhdGljIHRpbWVFbmQobmFtZSkge1xyXG4gICAgRGVidWcudGltZVByb2ZpbGVzW25hbWVdID0gcGVyZm9ybWFuY2Uubm93KCkgLSBEZWJ1Zy50aW1lUHJvZmlsZXNbbmFtZV07XHJcbiAgfVxyXG59XHJcblxyXG5EZWJ1Zy50aHJvd09uRmFpbCA9IHRydWU7XHJcbkRlYnVnLmxvZ09uRmFpbCA9IGZhbHNlO1xyXG5EZWJ1Zy50aW1lUHJvZmlsZXMgPSB7fTtcclxuLy8gQGVuZGlmXHJcblxyXG4vKipcclxuICogU2V0IG9mIG1hdGggaGVscGVyIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGNhdCBjb3JlXHJcbiAqIEBzdGF0aWNcclxuICovXHJcbmNsYXNzIE1hdGhFeCB7XHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBpbiBnaXZlbiByYW5nZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIEEgbG93ZXIgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgQSBncmVhdGVyIHZhbHVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgcmFuZG9tQmV0d2VlbihhLCBiKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGIgLSBhICsgMSkgKyBhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wcyBnaXZlbiB2YWx1ZSB0byBtaW4gbWF4IHJhbmdlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIEEgdmFsdWUgdG8gY2xhbXAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBBIGxvd2VyIHRocmVzaG9sZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IEEgZ3JlYXRlciB0aHJlc2hvbGQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcclxuICAgIHJldHVybiAodmFsdWUgPCBtaW4pID8gbWluIDogKHZhbHVlID4gbWF4KSA/IG1heCA6IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBGaXJzdCBwb2ludCB4LWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBGaXJzdCBwb2ludCB5LWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBTZWNvbmQgcG9pbnQgeC1jb29yZGluYXRlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgU2Vjb25kIHBvaW50IHktY29vcmRpbmF0ZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICBsZXQgeCA9IHgxIC0geDI7XHJcbiAgICBsZXQgeSA9IHkxIC0geTI7XHJcblxyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgRmlyc3QgcG9pbnQgeC1jb29yZGluYXRlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgRmlyc3QgcG9pbnQgeS1jb29yZGluYXRlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDIgU2Vjb25kIHBvaW50IHgtY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIFNlY29uZCBwb2ludCB5LWNvb3JkaW5hdGUuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBkaXN0YW5jZVNxcih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgbGV0IHggPSB4MSAtIHgyO1xyXG4gICAgbGV0IHkgPSB5MSAtIHkyO1xyXG5cclxuICAgIHJldHVybiAoeCAqIHgpICsgKHkgKiB5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHR3byBwb2ludHMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBGaXJzdCBwb2ludCB4LWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBGaXJzdCBwb2ludCB5LWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBTZWNvbmQgcG9pbnQgeC1jb29yZGluYXRlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgU2Vjb25kIHBvaW50IHktY29vcmRpbmF0ZS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGFuZ2xlQmV0d2Vlbih4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXBzIG9uZSByYW5nZSBvbnRvIGFub3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlIEEgdmFsdWUgdG8gbWFwLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gZnJvbUEgTG93ZXIgdmFsdWUgZnJvbSBmaXJzdCByYW5nZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGZyb21CIEdyZWF0ZXIgdmFsdWUgZnJvbSBmaXJzdCByYW5nZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRvQSBMb3dlciB2YWx1ZSBmcm9tIHNlY29uZCByYW5nZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRvQiBHcmVhdGVyIHZhbHVlIGZyb20gc2Vjb25kIHJhbmdlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgbWFwUmFuZ2UodmFsdWUsIGZyb21BLCBmcm9tQiwgdG9BLCB0b0IpIHtcclxuICAgIHJldHVybiB0b0EgKyAodG9CIC0gdG9BKSAqICh2YWx1ZSAtIGZyb21BKSAvIChmcm9tQiAtIGZyb21BKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpbmVhcmx5IGludGVycG9sYXRlcyBhIG51bWJlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIEZpcnN0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIFNlY29uZCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdCBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGxlcnAoYSwgYiwgdCkge1xyXG4gICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhcmVzIHR3byBudW1iZXJzIHVzaW5nIGdpdmVuIGVwc2lsb24gdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYSBGaXJzdCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiBTZWNvbmQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVwc2lsb24gQ29tcGFyaXNvbiB0aHJlc2hvbGQuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGVxdWFscyhhLCBiLCBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiAoYSAtIGVwc2lsb24gPCBiKSAmJiAoYSArIGVwc2lsb24gPiBiKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQaSBkaXZpZGVkIGJ5IDQuXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xyXG5NYXRoRXguUElfUSA9IE1hdGguUEkgLyA0O1xyXG5cclxuLyoqXHJcbiAqIFBJIG11bHRpcGxpZWQgYnkgMi5cclxuICogQHR5cGUge251bWJlcn1cclxuICovXHJcbk1hdGhFeC5QSTIgPSBNYXRoLlBJICogMjtcclxuXHJcbi8qKlxyXG4gKiBEZWdyZWVzIHRvIHJhZGlhbnMgY29uc3RhbnQuXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cclxuTWF0aEV4LkRFRzJSQUQgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTc2OTIzNjkwNzY4NDg5O1xyXG5cclxuLyoqXHJcbiAqIFJhZGlhbnMgdG8gZGVncmVlcyBjb25zdGFudC5cclxuICogQHR5cGUge251bWJlcn1cclxuICovXHJcbk1hdGhFeC5SQUQyREVHID0gNTcuMjk1Nzc5NTEzMDgyMzIwODc2Nzk4MTU0ODE0MTA1O1xyXG5cclxuY2xhc3MgUGVybGluIHtcclxuICBjb25zdHJ1Y3RvcihyZXBlYXQgPSAwKSB7XHJcbiAgICB0aGlzLm1SZXBlYXQgPSAwO1xyXG4gICAgdGhpcy5tUGVybSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDUxMjsgeCsrKVxyXG4gICAgICB0aGlzLm1QZXJtLnB1c2goUGVybGluLl9fcGVybXV0YXRpb25beCAlIDI1Nl0pO1xyXG4gIH1cclxuXHJcbiAgX19wZXJsaW4oeCwgeSwgeikge1xyXG4gICAgaWYgKHRoaXMubVJlcGVhdCA+IDApIHtcclxuICAgICAgeCA9IHggJSB0aGlzLm1SZXBlYXQ7XHJcbiAgICAgIHkgPSB5ICUgdGhpcy5tUmVwZWF0O1xyXG4gICAgICB6ID0geiAlIHRoaXMubVJlcGVhdDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcCA9IHRoaXMubVBlcm07XHJcblxyXG4gICAgY29uc3QgeGkgPSB+fnggJiAyNTU7XHJcbiAgICBjb25zdCB5aSA9IH5+eSAmIDI1NTtcclxuICAgIGNvbnN0IHppID0gfn56ICYgMjU1O1xyXG4gICAgY29uc3QgeGYgPSB4IC0gfn54O1xyXG4gICAgY29uc3QgeWYgPSB5IC0gfn55O1xyXG4gICAgY29uc3QgemYgPSB6IC0gfn56O1xyXG4gICAgY29uc3QgdSA9IHhmICogeGYgKiB4ZiAqICh4ZiAqICh4ZiAqIDYgLSAxNSkgKyAxMCk7XHJcbiAgICBjb25zdCB2ID0geWYgKiB5ZiAqIHlmICogKHlmICogKHlmICogNiAtIDE1KSArIDEwKTtcclxuICAgIGNvbnN0IHcgPSB6ZiAqIHpmICogemYgKiAoemYgKiAoemYgKiA2IC0gMTUpICsgMTApO1xyXG5cclxuICAgIGNvbnN0IGFhYSA9IHBbcFtwW3hpXSArIHlpXSArIHppXTtcclxuICAgIGNvbnN0IGFiYSA9IHBbcFtwW3hpXSArIHRoaXMuaW5jKHlpKV0gKyB6aV07XHJcbiAgICBjb25zdCBhYWIgPSBwW3BbcFt4aV0gKyB5aV0gKyB0aGlzLmluYyh6aSldO1xyXG4gICAgY29uc3QgYWJiID0gcFtwW3BbeGldICsgdGhpcy5pbmMoeWkpXSArIHRoaXMuaW5jKHppKV07XHJcbiAgICBjb25zdCBiYWEgPSBwW3BbcFt0aGlzLmluYyh4aSldICsgeWldICsgemldO1xyXG4gICAgY29uc3QgYmJhID0gcFtwW3BbdGhpcy5pbmMoeGkpXSArIHRoaXMuaW5jKHlpKV0gKyB6aV07XHJcbiAgICBjb25zdCBiYWIgPSBwW3BbcFt0aGlzLmluYyh4aSldICsgeWldICsgdGhpcy5pbmMoemkpXTtcclxuICAgIGNvbnN0IGJiYiA9IHBbcFtwW3RoaXMuaW5jKHhpKV0gKyB0aGlzLmluYyh5aSldICsgdGhpcy5pbmMoemkpXTtcclxuXHJcbiAgICBsZXQgeDEgPSB0aGlzLmxlcnAodGhpcy5ncmFkKGFhYSwgeGYsIHlmLCB6ZiksIHRoaXMuZ3JhZChiYWEsIHhmIC0gMSwgeWYsIHpmKSwgdSk7XHJcbiAgICBsZXQgeDIgPSB0aGlzLmxlcnAodGhpcy5ncmFkKGFiYSwgeGYsIHlmIC0gMSwgemYpLCB0aGlzLmdyYWQoYmJhLCB4ZiAtIDEsIHlmIC0gMSwgemYpLCB1KTtcclxuICAgIGxldCB5MSA9IHRoaXMubGVycCh4MSwgeDIsIHYpO1xyXG5cclxuICAgIHgxID0gdGhpcy5sZXJwKHRoaXMuZ3JhZChhYWIsIHhmLCB5ZiwgemYgLSAxKSwgdGhpcy5ncmFkKGJhYiwgeGYgLSAxLCB5ZiwgemYgLSAxKSwgdSk7XHJcbiAgICB4MiA9IHRoaXMubGVycCh0aGlzLmdyYWQoYWJiLCB4ZiwgeWYgLSAxLCB6ZiAtIDEpLCB0aGlzLmdyYWQoYmJiLCB4ZiAtIDEsIHlmIC0gMSwgemYgLSAxKSwgdSk7XHJcbiAgICBsZXQgeTIgPSB0aGlzLmxlcnAoeDEsIHgyLCB2KTtcclxuXHJcbiAgICByZXR1cm4gKHRoaXMubGVycCh5MSwgeTIsIHcpICsgMSkgKiAwLjU7XHJcbiAgfVxyXG5cclxuICBwZXJsaW4oeCwgeSwgeiwgb2N0YXZlcyA9IDEsIHBlcnNpc3RlbmNlID0gMSkge1xyXG4gICAgaWYgKG9jdGF2ZXMgPT09IDEgJiYgcGVyc2lzdGVuY2UgPT09IDEpXHJcbiAgICAgIHJldHVybiB0aGlzLl9fcGVybGluKHgsIHksIHopO1xyXG5cclxuICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICBsZXQgZnJlcXVlbmN5ID0gMTtcclxuICAgIGxldCBhbXBsaXR1ZGUgPSAxO1xyXG4gICAgbGV0IG1heFZhbHVlID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2N0YXZlczsgaSsrKSB7XHJcbiAgICAgIHRvdGFsICs9IHRoaXMuX19wZXJsaW4oeCAqIGZyZXF1ZW5jeSwgeSAqIGZyZXF1ZW5jeSwgeiAqIGZyZXF1ZW5jeSkgKiBhbXBsaXR1ZGU7XHJcblxyXG4gICAgICBtYXhWYWx1ZSArPSBhbXBsaXR1ZGU7XHJcblxyXG4gICAgICBhbXBsaXR1ZGUgKj0gcGVyc2lzdGVuY2U7XHJcbiAgICAgIGZyZXF1ZW5jeSAqPSAyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b3RhbCAvIG1heFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgaW5jKG51bSkge1xyXG4gICAgbnVtKys7XHJcbiAgICBpZiAodGhpcy5tUmVwZWF0ID4gMClcclxuICAgICAgbnVtICU9IHRoaXMubVJlcGVhdDtcclxuXHJcbiAgICByZXR1cm4gbnVtO1xyXG4gIH1cclxuXHJcbiAgZ3JhZChoYXNoLCB4LCB5LCB6KSB7XHJcbiAgICBjb25zdCBiID0gaGFzaCAmIDE1O1xyXG5cclxuICAgIHN3aXRjaCAoYikge1xyXG4gICAgICBjYXNlIDA6IHJldHVybiB4ICsgeTtcclxuICAgICAgY2FzZSAxOiByZXR1cm4gLXggKyB5O1xyXG4gICAgICBjYXNlIDI6IHJldHVybiB4IC0geTtcclxuICAgICAgY2FzZSAzOiByZXR1cm4gLXggLSB5O1xyXG4gICAgICBjYXNlIDQ6IHJldHVybiB4ICsgejtcclxuICAgICAgY2FzZSA1OiByZXR1cm4gLXggKyB6O1xyXG4gICAgICBjYXNlIDY6IHJldHVybiB4IC0gejtcclxuICAgICAgY2FzZSA3OiByZXR1cm4gLXggLSB6O1xyXG4gICAgICBjYXNlIDg6IHJldHVybiB5ICsgejtcclxuICAgICAgY2FzZSA5OiByZXR1cm4gLXkgKyB6O1xyXG4gICAgICBjYXNlIDEwOiByZXR1cm4geSAtIHo7XHJcbiAgICAgIGNhc2UgMTE6IHJldHVybiAteSAtIHo7XHJcbiAgICAgIGNhc2UgMTI6IHJldHVybiB5ICsgeDtcclxuICAgICAgY2FzZSAxMzogcmV0dXJuIC15ICsgejtcclxuICAgICAgY2FzZSAxNDogcmV0dXJuIHkgLSB4O1xyXG4gICAgICBjYXNlIDE1OiByZXR1cm4gLXkgLSB6O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGVycChhLCBiLCB0KSB7XHJcbiAgICByZXR1cm4gYSArIHQgKiAoYiAtIGEpO1xyXG4gIH1cclxufVxyXG5cclxuUGVybGluLl9fcGVybXV0YXRpb24gPSBbMTUxLCAxNjAsIDEzNywgOTEsIDkwLCAxNSxcclxuICAxMzEsIDEzLCAyMDEsIDk1LCA5NiwgNTMsIDE5NCwgMjMzLCA3LCAyMjUsIDE0MCwgMzYsIDEwMywgMzAsIDY5LCAxNDIsIDgsIDk5LCAzNywgMjQwLCAyMSwgMTAsIDIzLFxyXG4gIDE5MCwgNiwgMTQ4LCAyNDcsIDEyMCwgMjM0LCA3NSwgMCwgMjYsIDE5NywgNjIsIDk0LCAyNTIsIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLFxyXG4gIDg4LCAyMzcsIDE0OSwgNTYsIDg3LCAxNzQsIDIwLCAxMjUsIDEzNiwgMTcxLCAxNjgsIDY4LCAxNzUsIDc0LCAxNjUsIDcxLCAxMzQsIDEzOSwgNDgsIDI3LCAxNjYsXHJcbiAgNzcsIDE0NiwgMTU4LCAyMzEsIDgzLCAxMTEsIDIyOSwgMTIyLCA2MCwgMjExLCAxMzMsIDIzMCwgMjIwLCAxMDUsIDkyLCA0MSwgNTUsIDQ2LCAyNDUsIDQwLCAyNDQsXHJcbiAgMTAyLCAxNDMsIDU0LCA2NSwgMjUsIDYzLCAxNjEsIDEsIDIxNiwgODAsIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsXHJcbiAgMTM1LCAxMzAsIDExNiwgMTg4LCAxNTksIDg2LCAxNjQsIDEwMCwgMTA5LCAxOTgsIDE3MywgMTg2LCAzLCA2NCwgNTIsIDIxNywgMjI2LCAyNTAsIDEyNCwgMTIzLFxyXG4gIDUsIDIwMiwgMzgsIDE0NywgMTE4LCAxMjYsIDI1NSwgODIsIDg1LCAyMTIsIDIwNywgMjA2LCA1OSwgMjI3LCA0NywgMTYsIDU4LCAxNywgMTgyLCAxODksIDI4LCA0MixcclxuICAyMjMsIDE4MywgMTcwLCAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LFxyXG4gIDEyOSwgMjIsIDM5LCAyNTMsIDE5LCA5OCwgMTA4LCAxMTAsIDc5LCAxMTMsIDIyNCwgMjMyLCAxNzgsIDE4NSwgMTEyLCAxMDQsIDIxOCwgMjQ2LCA5NywgMjI4LFxyXG4gIDI1MSwgMzQsIDI0MiwgMTkzLCAyMzgsIDIxMCwgMTQ0LCAxMiwgMTkxLCAxNzksIDE2MiwgMjQxLCA4MSwgNTEsIDE0NSwgMjM1LCAyNDksIDE0LCAyMzksIDEwNyxcclxuICA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsIDEyMSwgNTAsIDQ1LCAxMjcsIDQsIDE1MCwgMjU0LFxyXG4gIDEzOCwgMjM2LCAyMDUsIDkzLCAyMjIsIDExNCwgNjcsIDI5LCAyNCwgNzIsIDI0MywgMTQxLCAxMjgsIDE5NSwgNzgsIDY2LCAyMTUsIDYxLCAxNTYsIDE4MFxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIEEgZG91YmxlIGtleSBtYXAuXHJcbiAqIEBjYXQgdXRpbHNcclxuICovXHJcbmNsYXNzIE1hcE1hcCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLm1NYXAgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgZm91bmQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleTEgXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleTIgXHJcbiAgICovXHJcbiAgaGFzKGtleTEsIGtleTIpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXAuaGFzKGtleTEpICYmIHRoaXMubU1hcC5nZXQoa2V5MSkuaGFzKGtleTIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBvciB1cGRhdGVzIHZhbHVlIGJ5IGdpdmVuIGtleXMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleTEgXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleTIgXHJcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBcclxuICAgKi9cclxuICBzZXQoa2V5MSwga2V5MiwgdmFsdWUpIHtcclxuICAgIGxldCBtYXAgPSB0aGlzLm1NYXAuZ2V0KGtleTEpO1xyXG5cclxuICAgIGlmIChtYXAgPT0gbnVsbCkge1xyXG4gICAgICBtYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgIHRoaXMubU1hcC5zZXQoa2V5MSwgbWFwKTtcclxuICAgIH1cclxuICAgIG1hcC5zZXQoa2V5MiwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB2YWx1ZSBieSBnaXZlbiBrZXlzLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkxIFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkyIFxyXG4gICAqIEByZXR1cm5zIHsqfVxyXG4gICAqL1xyXG4gIGdldChrZXkxLCBrZXkyKSB7XHJcbiAgICBsZXQgbWFwID0gdGhpcy5tTWFwLmdldChrZXkxKTtcclxuICAgIGlmIChtYXAgIT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tTWFwLmdldChrZXkxKSAmJiB0aGlzLm1NYXAuZ2V0KGtleTEpLmdldChrZXkyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc2ltcGxlIG9iamVjdCBwb29sIGNsYXNzLiBVc2VkIHRvIGF2b2lkIEdDLlxyXG4gKiBcclxuICogQGNhdCB1dGlsc1xyXG4gKi9cclxuY2xhc3MgT2JqZWN0UG9vbCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgT2JqZWN0UG9vbCBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSBcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYXBhY2l0eSA9IDEwMCkge1xyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHR5cGUge0FycmF5PCo+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmVsZWFzZWQgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhcGFjaXR5ID0gY2FwYWNpdHk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVR5cGUgPSB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIGNhcGFjaXR5IG9mIHRoZSBwb29sLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGNhcGFjaXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNhcGFjaXR5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0IGNhcGFjaXR5KHZhbHVlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodmFsdWUgIT09IDAsICdDYXBhY2l0eSBjYW5ub3QgYmUgZXF1YWwgdG8gemVyby4nKTtcclxuICAgIERlYnVnLmFzc2VydCh2YWx1ZSA+IC0xLCAnQ2FwYWNpdHkgY2Fubm90IGJlIHNtYWxsZXIgdGhlbiAtMS4nKTtcclxuXHJcbiAgICB0aGlzLm1DYXBhY2l0eSA9IHZhbHVlO1xyXG5cclxuICAgIGlmICh0aGlzLm1DYXBhY2l0eSA+IHRoaXMubVJlbGVhc2VkLmxlbmd0aClcclxuICAgICAgdGhpcy5tUmVsZWFzZWQuc3BsaWNlKDAsIHRoaXMubVJlbGVhc2VkLmxlbmd0aCAtIHRoaXMubUNhcGFjaXR5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbGVhc2VzIGFsbCBvYmplY3RzIGZyb20gdGhlIHBvb2wuXHJcbiAgICovXHJcbiAgcmVsZWFzZUFsbCgpIHtcclxuICAgIHRoaXMubVJlbGVhc2VkLnNwbGljZSgwLCB0aGlzLm1SZWxlYXNlZC5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBuZXcgb2JqZWN0IGluc3RhbmNlIG9yIGFuIG9iamVjdCBmcm9tIHRoZSBwb29sLlxyXG4gICAqL1xyXG4gIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1SZWxlYXNlZC5sZW5ndGggPiAwID8gdGhpcy5tUmVsZWFzZWQucG9wKCkgOiBuZXcgdGhpcy5tVHlwZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgZ2l2ZW4gb2JqZWN0LlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFxyXG4gICAqL1xyXG4gIHJlbGVhc2Uob2JqZWN0KSB7XHJcbiAgICBpZiAodGhpcy5tQ2FwYWNpdHkgPT09IC0xIHx8IHRoaXMubVJlbGVhc2VkLmxlbmd0aCA8IHRoaXMubUNhcGFjaXR5KVxyXG4gICAgICB0aGlzLm1SZWxlYXNlZC5wdXNoKG9iamVjdCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUkdCIGhlbHBlciBzdHJ1Y3QuXHJcbiAqIFxyXG4gKiBAY2F0IHV0aWxzXHJcbiAqL1xyXG5jbGFzcyBSR0Ige1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IFJHQiBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gciBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZyBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYiBcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihyID0gMCwgZyA9IDAsIGIgPSAwKSB7XHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKiAqL1xyXG4gICAgdGhpcy5yID0gcjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKiAqL1xyXG4gICAgdGhpcy5nID0gZztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKiAqL1xyXG4gICAgdGhpcy5iID0gYjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcyBoZWxwZXIgY2xhc3MuXHJcbiAqIFxyXG4gKiBAY2F0IHV0aWxzXHJcbiAqL1xyXG5jbGFzcyBIU1Yge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEhTViBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGggPSAwLCBzID0gMCwgdiA9IDApIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5oID0gaDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMucyA9IHM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLnYgPSB2O1xyXG4gIH1cclxufVxyXG5cclxuLyoqIFxyXG4gKiBTZXQgb2YgbWV0aG9kcyByZWxhdGVkIHRvIGNvbG9yIHRyYW5zZm9ybWF0aW9ucy5cclxuICogXHJcbiAqIEBjYXQgdXRpbHNcclxuICogQHN0YXRpY1xyXG4qL1xyXG5jbGFzcyBDb2xvckhlbHBlciB7XHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgbnVtYmVyIGNvbG9yIHRvIFJHQiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGV4IFRoZSBjb2xvciB0byBjb252ZXJ0LlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UkdCfSBUaGUgcmVzdWx0aW5nIHN0cmluZy5cclxuICAgKi9cclxuICBzdGF0aWMgaGV4MnJnYihoZXgpIHtcclxuICAgIHJldHVybiBuZXcgUkdCKGhleCA+PiAxNiAmIDI1NSwgaGV4ID4+IDggJiAyNTUsIGhleCAmIDI1NSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0cyBSR0Igb2JqZWN0IGludG8gbnVtYmVyIGNvbG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UkdCfSByZ2IgVGhlIG9iamVjdCwgd2hpY2ggY29udGFpbnMgJ3InLCAnZycgYW5kICdiJyBwcm9wZXJ0aWVzLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZXN1bHRpbmcgdWludC5cclxuICAgKi9cclxuICBzdGF0aWMgcmdiMmhleChyZ2IpIHtcclxuICAgIHJldHVybiByZ2IuciA8PCAxNiB8IHJnYi5nIDw8IDggfCByZ2IuYjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIEhTViBvYmplY3QgaW50byBSR0Igb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+SFNWfSBoc3YgVGhlIG9iamVjdCwgd2hpY2ggY29udGFpbnMgJ2gnLCAncycgYW5kICd2JyBwcm9wZXJ0aWVzLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UkdCfSBUaGUgcmVzdWx0aW5nIFJHQiBvYmplY3QuXHJcbiAgICovXHJcbiAgc3RhdGljIGhzdjJyZ2IoaHN2KSB7XHJcbiAgICBsZXQgeyBoLCBzLCB2IH0gPSBoc3Y7XHJcbiAgICBsZXQgciA9IDA7XHJcbiAgICBsZXQgZyA9IDA7XHJcbiAgICBsZXQgYiA9IDA7XHJcblxyXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKGggKiA2KTtcclxuICAgIGxldCBmID0gaCAqIDYgLSBpO1xyXG4gICAgbGV0IHAgPSB2ICogKDEgLSBzKTtcclxuICAgIGxldCBxID0gdiAqICgxIC0gZiAqIHMpO1xyXG4gICAgbGV0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XHJcblxyXG4gICAgc3dpdGNoIChpICUgNikge1xyXG4gICAgICBjYXNlIDA6IHIgPSB2OyBnID0gdDsgYiA9IHA7IGJyZWFrO1xyXG4gICAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xyXG4gICAgICBjYXNlIDI6IHIgPSBwOyBnID0gdjsgYiA9IHQ7IGJyZWFrO1xyXG4gICAgICBjYXNlIDM6IHIgPSBwOyBnID0gcTsgYiA9IHY7IGJyZWFrO1xyXG4gICAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xyXG4gICAgICBjYXNlIDU6IHIgPSB2OyBnID0gcDsgYiA9IHE7IGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHIgKj0gMjU1O1xyXG4gICAgZyAqPSAyNTU7XHJcbiAgICBiICo9IDI1NTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJHQihyLCBnLCBiKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIFJHQiBvYmplY3QgaW50byBIU1Ygb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UkdCfSByZ2IgVGhlIG9iamVjdCwgd2hpY2ggY29udGFpbnMgJ3InLCAnZycgYW5kICdiJyBwcm9wZXJ0aWVzLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+SFNWfSBUaGUgcmVzdWx0aW5nIEhTViBvYmplY3QuXHJcbiAgICovXHJcbiAgc3RhdGljIHJnYjJoc3YocmdiKSB7XHJcbiAgICBsZXQgeyByLCBnLCBiIH0gPSByZ2I7XHJcbiAgICByIC89IDI1NTtcclxuICAgIGcgLz0gMjU1O1xyXG4gICAgYiAvPSAyNTU7XHJcblxyXG4gICAgbGV0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xyXG4gICAgbGV0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG5cclxuICAgIGxldCBoID0gMDtcclxuICAgIGxldCBzID0gMDtcclxuICAgIGxldCB2ID0gbWF4O1xyXG5cclxuICAgIGxldCBkID0gbWF4IC0gbWluO1xyXG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xyXG5cclxuICAgIGlmIChtYXggPT09IG1pbikge1xyXG4gICAgICBoID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN3aXRjaCAobWF4KSB7XHJcbiAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgaCAvPSA2O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgSFNWKGgsIHMsIHYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIGNvbG9ycyB3aXRoaW4gSFNWIG1vZGVsLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZXgxIEZpcnN0IGNvbG9yIG51bWJlclxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZXgyIFNlY29uZCBjb2xvciBudW1iZXIgXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqL1xyXG4gIHN0YXRpYyBsZXJwSFNWKGhleDEsIGhleDIsIGZhY3RvciA9IDAuNSkge1xyXG4gICAgbGV0IGMxID0gQ29sb3JIZWxwZXIucmdiMmhzdihDb2xvckhlbHBlci5oZXgycmdiKGhleDEpKTtcclxuICAgIGxldCBjMiA9IENvbG9ySGVscGVyLnJnYjJoc3YoQ29sb3JIZWxwZXIuaGV4MnJnYihoZXgyKSk7XHJcblxyXG4gICAgbGV0IGggPSAwO1xyXG4gICAgbGV0IGQgPSBjMi5oIC0gYzEuaDtcclxuXHJcbiAgICBpZiAoYzEuaCA+IGMyLmgpIHtcclxuICAgICAgbGV0IGgzID0gYzIuaDtcclxuICAgICAgYzIuaCA9IGMxLmg7XHJcbiAgICAgIGMxLmggPSBoMztcclxuICAgICAgZCA9IC1kO1xyXG4gICAgICBmYWN0b3IgPSAxIC0gZmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkID4gMC41KSB7XHJcbiAgICAgIGMxLmggPSBjMS5oICsgMTtcclxuICAgICAgaCA9IChjMS5oICsgZmFjdG9yICogKGMyLmggLSBjMS5oKSkgJSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkIDw9IDAuNSlcclxuICAgICAgaCA9IGMxLmggKyBmYWN0b3IgKiBkO1xyXG5cclxuICAgIGxldCBzID0gYzEucyArIGZhY3RvciAqIChjMi5zIC0gYzEucyk7XHJcbiAgICBsZXQgdiA9IGMxLnYgKyBmYWN0b3IgKiAoYzIudiAtIGMxLnYpO1xyXG5cclxuICAgIHJldHVybiBDb2xvckhlbHBlci5yZ2IyaGV4KENvbG9ySGVscGVyLmhzdjJyZ2IobmV3IEhTVihoLCBzLCB2KSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgbnVtYmVyIGNvbG9yIHRvIGhleCBzdHJpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgVGhlIGNvbG9yIHRvIGNvbnZlcnQuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdGluZyBoZXggc3RyaW5nLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBoZXhDb2xvclRvU3RyaW5nKGNvbG9yKSB7XHJcbiAgICBsZXQgcGFyc2VkQ29sb3IgPSBjb2xvci50b1N0cmluZygxNik7XHJcbiAgICByZXR1cm4gJyMwMDAwMDAnLnN1YnN0cmluZygwLCA3IC0gcGFyc2VkQ29sb3IubGVuZ3RoKSArIHBhcnNlZENvbG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydHMgbnVtYmVyIGNvbG9yIHRvIFJHQkEgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIFRoZSBjb2xvciB0byBjb252ZXJ0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gQWxwaGEgdG8gdXNlIGluIFJHQkEgc3RyaW5nXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIGludFRvUkdCQShjb2xvciwgYWxwaGEgPSAxKSB7XHJcbiAgICBjb25zdCByID0gKGNvbG9yID4+IDE2KSAmIDI1NTtcclxuICAgIGNvbnN0IGcgPSAoY29sb3IgPj4gOCkgJiAyNTU7XHJcbiAgICBjb25zdCBiID0gY29sb3IgJiAyNTU7XHJcblxyXG4gICAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YWxwaGF9KWA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgcGF0dGVybnMgPSB7ICcqJzogJ1teL10rJywgJyoqJzogJy4rLz9bXi9dKycsICcqKi8nOiAnLisvPycgfTtcclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZ2xvYiBtYXRjaGluZyBjbGFzcy5cclxuICogXHJcbiAqIEBjYXQgdXRpbHNcclxuICovXHJcbmNsYXNzIEdsb2Ige1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEdsb2IgaW5zdGFuY2UuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xyXG4gICAgdGhpcy5tUmVnRXhwID0gbmV3IFJlZ0V4cChgXiR7cGF0dGVybi5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJykucmVwbGFjZSgvXFwqXFwqJC9nLCAnLisnKS5yZXBsYWNlKC8oPzpcXCpcXCpcXC98XFwqXFwqfFxcKikvZywgcyA9PiB7IHJldHVybiBwYXR0ZXJuc1tzXTsgfSl9JGApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdHMgd2hlbmV2ZXIgc3RyaW5nIG1hdGNoZXMgdGhlIGdsb2IuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRoaXMubVJlZ0V4cC50ZXN0KHN0cmluZyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWF0aGVtYXRpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAY2F0IGdlb21cclxuICovXHJcbmNsYXNzIFZlY3RvciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgVmVjdG9yIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW3g9MF0gWC1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW3k9MF0geS1jb21wb25lbnQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5KTtcclxuICAgIFxyXG4gICAgLyoqIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gWCBjb29yZGluYXRlIG9mIGEgcG9pbnQgaW4gdGhlIHNwYWNlLiBcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBZIGNvb3JkaW5hdGUgb2YgYSBwb2ludCBpbiB0aGUgc3BhY2UuIFxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3Igd2l0aCBhIGdpdmVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbeD0wXSBYLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFt5PTBdIHktY29tcG9uZW50XHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVGhpcy5cclxuICAgKi9cclxuICBzZXQoeCA9IDAsIHkgPSAwKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5KTtcclxuXHJcbiAgICB0aGlzLnggPSB4O1xyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgdHdvIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBUaGUgdmVjdG9yIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGlzLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFRoaXMuXHJcbiAgICovXHJcbiAgYWRkKHZlY3Rvcikge1xyXG4gICAgdGhpcy54ICs9IHZlY3Rvci54O1xyXG4gICAgdGhpcy55ICs9IHZlY3Rvci55O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3VidHJhY3QgdHdvIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBUaGUgdmVjdG9yIG9iamVjdCB0byBiZSBzdWJ0cmFjdGVkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFRoaXMuXHJcbiAgICovXHJcbiAgc3VidHJhY3QodmVjdG9yKSB7XHJcbiAgICB0aGlzLnggLT0gdmVjdG9yLng7XHJcbiAgICB0aGlzLnkgLT0gdmVjdG9yLnk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBTZWNvbmQgdmVjdG9yIHRvIGNoZWNrIGRpc3RhbmNlIHdpdGguXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICAgKi9cclxuICBkaXN0YW5jZSh2ZWN0b3IpIHtcclxuICAgIGxldCB4ID0gdGhpcy54IC0gdmVjdG9yLng7XHJcbiAgICBsZXQgeSA9IHRoaXMueSAtIHZlY3Rvci55O1xyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3IgU2Vjb25kIHZlY3RvciB0byBjaGVjayBkaXN0YW5jZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAgICovXHJcbiAgZGlzdGFuY2VTcXIodmVjdG9yKSB7XHJcbiAgICBsZXQgeCA9IHRoaXMueCAtIHZlY3Rvci54O1xyXG4gICAgbGV0IHkgPSB0aGlzLnkgLSB2ZWN0b3IueTtcclxuXHJcbiAgICByZXR1cm4gKHggKiB4KSArICh5ICogeSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHR3byB2ZWN0b3JzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3IgQSBzZWNvbmQgdmVjdG9yIHRvIG11bHRpcGx5IHdpdGguXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVGhpcy5cclxuICAgKi9cclxuICBtdWx0aXBseSh2ZWN0b3IpIHtcclxuICAgIHRoaXMueCAqPSB2ZWN0b3IueDtcclxuICAgIHRoaXMueSAqPSB2ZWN0b3IueTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgYnkgc2NhbGFyIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhciBUaGUgdmFsdWVzIHRvIG11bCBieS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzLlxyXG4gICAqL1xyXG4gIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoc2NhbGFyKTtcclxuXHJcbiAgICB0aGlzLnggKj0gc2NhbGFyO1xyXG4gICAgdGhpcy55ICo9IHNjYWxhcjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgZG90IHByb2R1Y3QgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yIFNlY29uZCB2ZWN0b3IgdG8gZmluZCBhbmdsZSB3aXRoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBzY2FsYXIgdmFsdWUgcmVwcmVzZW50aW5nIGRvdCBwcm9kdWN0LlxyXG4gICAqL1xyXG4gIGRvdCh2ZWN0b3IpIHtcclxuICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IuXHJcbiAgICovXHJcbiAgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyB2ZWN0b3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgbGVuZ3RoLlxyXG4gICAqL1xyXG4gIGxlbmd0aFNxcigpIHtcclxuICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHVuaXQgdmVjdG9yIG91dCBvZiB0aGlzIG9uZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzLlxyXG4gICAqL1xyXG4gIG5vcm1hbGl6ZSgpIHtcclxuICAgIGxldCBzdW0gPSB0aGlzLmxlbmd0aFNxcigpO1xyXG5cclxuICAgIGlmIChzdW0gPiAwKSB7XHJcbiAgICAgIHN1bSA9IE1hdGguc3FydChzdW0pO1xyXG4gICAgICB0aGlzLnggLz0gc3VtO1xyXG4gICAgICB0aGlzLnkgLz0gc3VtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgdGhpcy55ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wcyB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgdG8gZ2l2ZW4gcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbiB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzLlxyXG4gICAqL1xyXG4gIGNsYW1wKG1pbiwgbWF4KSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihtaW4sIG1heCk7XHJcblxyXG4gICAgdGhpcy54ID0gTWF0aEV4LmNsYW1wKHRoaXMueCwgbWluLCBtYXgpO1xyXG4gICAgdGhpcy55ID0gTWF0aEV4LmNsYW1wKHRoaXMueSwgbWluLCBtYXgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIHZlY3RvciBsZW5ndGggb2YgdGhpcyB2ZWN0b3IgdG8gZ2l2ZW4gcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbiB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCB2YWx1ZS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzLlxyXG4gICAqL1xyXG4gIGNsYW1wTGVuZ3RoKG1pbiwgbWF4KSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihtaW4sIG1heCk7XHJcblxyXG4gICAgbGV0IGxlbmd0aCA9IE1hdGhFeC5jbGFtcCh0aGlzLmxlbmd0aCgpLCBtaW4sIG1heCk7XHJcbiAgICB0aGlzLm5vcm1hbGl6ZSgpO1xyXG4gICAgdGhpcy5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yIFRoZSBzZWNvbmQgdmVjdG9yIHRvIGludGVycG9sYXRlIHZhbHVlcyBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ICAgICAgQWxwaGEgdmFsdWUuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVGhpcy5cclxuICAgKi9cclxuICBsZXJwKHZlY3RvciwgdCkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIodCk7XHJcblxyXG4gICAgdGhpcy54ID0gTWF0aEV4LmxlcnAodGhpcy54LCB2ZWN0b3IueCwgdCk7XHJcbiAgICB0aGlzLnkgPSBNYXRoRXgubGVycCh0aGlzLnksIHZlY3Rvci55LCB0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcGllcyB0aGlzIHZlY3RvciB2YWx1ZXMgaW50byBnaXZlbiB2ZWN0b3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHN0b3JlIHZhbHVlcyBpbi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBHaXZlbiB2ZWN0b3IuXHJcbiAgICovXHJcbiAgY29weVRvKHZlY3Rvcikge1xyXG4gICAgdmVjdG9yLnggPSB0aGlzLng7XHJcbiAgICB2ZWN0b3IueSA9IHRoaXMueTtcclxuXHJcbiAgICByZXR1cm4gdmVjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29waWVzIHZhbHVlcyBmcm9tIGdpdmVuIHZlY3RvciBpbnRvIHRoaXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBUaGUgdmVjdG9yIHRvIGNvcHkgdmFsdWVzIGZyb20uXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVGhpcy5cclxuICAgKi9cclxuICBjb3B5RnJvbSh2ZWN0b3IpIHtcclxuICAgIHRoaXMueCA9IHZlY3Rvci54O1xyXG4gICAgdGhpcy55ID0gdmVjdG9yLnk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyB2ZWN0b3Igb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gTmV3IFZlY3RvciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhcmVzIHR3byB2ZWN0b3JzIGZvciBlcXVhbGl0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yIFNlY29uZCB2ZWN0b3IgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZXBzaWxvbiBUaHJlc2hvbGQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlcXVhbC5cclxuICAgKi9cclxuICBlcXVhbHModmVjdG9yLCBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIHJldHVybiB2ZWN0b3IgIT09IG51bGwgJiYgKE1hdGguYWJzKHZlY3Rvci54IC0gdGhpcy54KSA8IGVwc2lsb24pICYmIChNYXRoLmFicyh2ZWN0b3IueSAtIHRoaXMueSkgPCBlcHNpbG9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIHZlY3RvciBpcyBlbXB0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBjb21wb25lbnRzIGVxdWFsIHRvIHplcm8uXHJcbiAgICovXHJcbiAgaXNFbXB0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUm90YXRlcyB0aGlzIHZlY3RvciBhcm91bmQgc3BlY2lmaWVkIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3IgQ2VudGVyIHZlY3Rvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gQW5nbGUgaW4gcmFkaWFucy5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzIHJvdGF0ZWQgdmVjdG9yLlxyXG4gICAqL1xyXG4gIHNldFJvdGF0aW9uRnJvbSh2ZWN0b3IsIHJvdGF0aW9uKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihyb3RhdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLnN1YnRyYWN0KHZlY3RvcilcclxuICAgICAgLnNldFJvdGF0aW9uKHJvdGF0aW9uKVxyXG4gICAgICAuYWRkKHZlY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgUm90YXRlcyB0aGlzIHZlY3RvciBhcm91bmQgemVybyB2ZWN0b3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gQW5nbGUgaW4gcmFkaWFucy5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzIHJvdGF0ZWQgdmVjdG9yLlxyXG4gICAqL1xyXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihyb3RhdGlvbik7XHJcblxyXG4gICAgbGV0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgIGxldCBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc2V0KHRoaXMueCAqIGNvcyAtIHRoaXMueSAqIHNpbiwgdGhpcy54ICogc2luICsgdGhpcy55ICogY29zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYW5nbGUgaW4gcmFkaWFucyB3aXRoaW4gdGhpcyBhbmQgc3BlY2lmaWVkIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHZlY3RvciBTZWNvbmQgdmVjdG9yLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cclxuICAgKi9cclxuICBhbmdsZUJldHdlZW4odmVjdG9yKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hdGFuMih2ZWN0b3IueSAtIHRoaXMueSwgdmVjdG9yLnggLSB0aGlzLngpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB2ZWN0b3IgYW5nbGUgaW4gcmFkaWFucy4gU2FtZSBhcyBoZWFkaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqL1xyXG4gIGFuZ2xlKCkge1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUm90YXRlcyB0aGlzIHZlY3RvciB0byBub3JtYWwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBUaGlzIHZlY3Rvci5cclxuICAgKi9cclxuICBwZXJwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KHRoaXMueSwgLXRoaXMueCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBWZWN0b3IgZnJvbSBnaXZlbiBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFZlY3RvciBWZWN0b3IgdG8gYmUgcmV0dXJuZWQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gTmV3IFZlY3RvciBvYmplY3QuXHJcbiAgICovXHJcbiAgc3RhdGljIGZyb21BbmdsZShhbmdsZSwgb3V0VmVjdG9yKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihhbmdsZSk7XHJcblxyXG4gICAgb3V0VmVjdG9yID0gb3V0VmVjdG9yIHx8IG5ldyBWZWN0b3IoKTtcclxuICAgIHJldHVybiBvdXRWZWN0b3Iuc2V0KE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyByYW5kb20gbnVtYmVyIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByYW5kb20oKSB7XHJcbiAgICByZXR1cm4gTWF0aEV4LnJhbmRvbUJldHdlZW4odGhpcy54LCB0aGlzLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yTWluXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3JNYXhcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3I9fSBvdXRWZWN0b3JcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAqL1xyXG4gIHN0YXRpYyByYW5kb21SYW5nZSh2ZWN0b3JNaW4sIHZlY3Rvck1heCwgb3V0VmVjdG9yKSB7XHJcbiAgICBvdXRWZWN0b3IgPSBvdXRWZWN0b3IgfHwgbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIG91dFZlY3Rvci54ID0gTWF0aC5yYW5kb20oKSAqICh2ZWN0b3JNYXgueCAtIHZlY3Rvck1pbi54KSArIHZlY3Rvck1pbi54O1xyXG4gICAgb3V0VmVjdG9yLnkgPSBNYXRoLnJhbmRvbSgpICogKHZlY3Rvck1heC55IC0gdmVjdG9yTWluLnkpICsgdmVjdG9yTWluLnk7XHJcblxyXG4gICAgcmV0dXJuIG91dFZlY3RvcjtcclxuICB9XHJcblxyXG4gIC8vIEBpZmRlZiBERUJVR1xyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkaWdpdHM9Ml0gRGVzY3JpcHRpb25cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IERlc2NyaXB0aW9uXHJcbiAgICovXHJcbiAgdG9TdHJpbmcoZGlnaXRzID0gMikge1xyXG4gICAgcmV0dXJuIGBWZWN0b3I6IHsgeDogJHt0aGlzLngudG9GaXhlZChkaWdpdHMpfSwgeTogJHt0aGlzLnkudG9GaXhlZChkaWdpdHMpfSB9YDtcclxuICB9XHJcbiAgLy8gQGVuZGlmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuVmVjdG9yLl9fY2FjaGUgPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4vKipcclxuICogUmVjeWNsZWQgdmVjdG9ycyBwb29sLlxyXG4gKlxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfk9iamVjdFBvb2x9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5WZWN0b3IucG9vbCA9IG5ldyBPYmplY3RQb29sKFZlY3Rvcik7XHJcblxyXG4vKipcclxuICogTWF0aGVtYXRpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgYmV6aWVyIGN1cnZlLlxyXG4gKlxyXG4gKiBAY2F0IGdlb21cclxuICovXHJcbmNsYXNzIExpbmUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IExpbmUgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lflZlY3Rvcn0gc3RhcnQgU3RhcnQgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lflZlY3Rvcn0gZW5kIEVuZCBwb2ludC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFRoZSBzdGFydCBwb2ludCBjb29yZGluYXRlcyAqL1xyXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn0gVGhlIGVuZCBwb2ludCBjb29yZGluYXRlcyAqL1xyXG4gICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzZXQgLSBTZXRzIG5ldyBsaW5lIHByb3BlcnRpZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHN0YXJ0IFN0YXJ0IHBvaW50LlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5WZWN0b3J9IGVuZCBFbmQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TGluZX0gVGhpcyBjaXJjbGUuXHJcbiAgICovXHJcbiAgc2V0KHN0YXJ0LCBlbmQpIHtcclxuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgIHRoaXMuZW5kID0gZW5kO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmVzIHRoaXMgbGluZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5MaW5lfSBDcmVhdGVkIGxpbmUuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IExpbmUodGhpcy5zdGFydC5jbG9uZSgpLCB0aGlzLmVuZC5jbG9uZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcHkgdGhpcyBwcm9wZXJ0aWVzIHRvIGFub3RoZXIgbGluZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkxpbmV9IGxpbmUgT2JqZWN0IHRvIGNvcHkgdG8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TGluZX0gUGFzc2VkIGxpbmUuXHJcbiAgICovXHJcbiAgY29weVRvKGxpbmUpIHtcclxuICAgIHJldHVybiBsaW5lLnNldCh0aGlzLnN0YXJ0LmNsb25lKCksIHRoaXMuZW5kLmNsb25lKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29weSBhbm90aGVyIGxpbmUgcHJvcGVydGllcyB0byB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TGluZX0gbGluZSBPYmplY3QgdG8gY29weSBmcm9tLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkxpbmV9IFRoaXMgY2lyY2xlLlxyXG4gICAqL1xyXG4gIGNvcHlGcm9tKGxpbmUpIHtcclxuICAgIHJldHVybiB0aGlzLnNldChsaW5lLnN0YXJ0LmNsb25lKCksIGxpbmUuZW5kLmNsb25lKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvd3Mgd2hldGhlciBsaW5lcyBhcmUgaWRlbnRpY2FsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TGluZX0gbGluZSBPYmplY3QgdG8gY29tcGFyaXNvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IGVwc2lsb24gQ29tcGFyZSBwcmVjaXNpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGxpbmVzIGFyZSBpZGVudGljYWwuXHJcbiAgICovXHJcbiAgZXF1YWxzKGxpbmUsIGVwc2lsb24gPSBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgcmV0dXJuICh0aGlzLnN0YXJ0LmVxdWFscyhsaW5lLnN0YXJ0LCBlcHNpbG9uKSAmJiB0aGlzLmVuZC5lcXVhbHMobGluZS5lbmQsIGVwc2lsb24pKSB8fFxyXG4gICAgICAodGhpcy5zdGFydC5lcXVhbHMobGluZS5lbmQsIGVwc2lsb24pICYmIHRoaXMuZW5kLmVxdWFscyhsaW5lLnN0YXJ0LCBlcHNpbG9uKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBsZWZ0IFggcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IExlZnQgWCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXQgbGVmdCgpIHtcclxuICAgIHJldHVybiBNYXRoLm1pbih0aGlzLnN0YXJ0LngsIHRoaXMuZW5kLngpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgcmlnaHQgWCBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmlnaHQgWCBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXQgcmlnaHQoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5zdGFydC54LCB0aGlzLmVuZC54KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRvcCBZIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUb3AgWSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXQgdG9wKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWluKHRoaXMuc3RhcnQueSwgdGhpcy5lbmQueSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBib3R0b20gWSBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQm90dG9tIFkgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgZ2V0IGJvdHRvbSgpIHtcclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnN0YXJ0LnksIHRoaXMuZW5kLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwbGFjZSBsaW5lIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkxpbmV9IFRoaXMgbGluZS5cclxuICAgKi9cclxuICByZXZlcnNlKCkge1xyXG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydDtcclxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZDtcclxuICAgIHRoaXMuZW5kID0gc3RhcnQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGFuZ2UgbGluZSdzIGxlbmd0aCB0byBvbmUuIE1vdmVzIGVuZCBwb2ludC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5MaW5lfSBUaGlzIGxpbmUuXHJcbiAgICovXHJcbiAgbm9ybWFsaXplKCkge1xyXG4gICAgdGhpcy5lbmRcclxuICAgICAgLnN1YnRyYWN0KHRoaXMuc3RhcnQpXHJcbiAgICAgIC5ub3JtYWxpemUoKVxyXG4gICAgICAuYWRkKHRoaXMuc3RhcnQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlIGxpbmUncyBsZW5ndGggdG8gc2NhbGVkLiBNb3ZlcyBlbmQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TGluZX0gVGhpcyBsaW5lLlxyXG4gICAqL1xyXG4gIHNjYWxlKG11bHRpcGxpZXIpIHtcclxuICAgIHRoaXMuZW5kXHJcbiAgICAgIC5zdWJ0cmFjdCh0aGlzLnN0YXJ0KVxyXG4gICAgICAubXVsdGlwbHlTY2FsYXIobXVsdGlwbGllcilcclxuICAgICAgLmFkZCh0aGlzLnN0YXJ0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgemVybyBsZW5ndGggbGluZSBhdCB6ZXJvIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkxpbmV9IERlc2NyaXB0aW9uXHJcbiAgICovXHJcbiAgemVybygpIHtcclxuICAgIHJldHVybiB0aGlzLnNldChuZXcgVmVjdG9yKCksIG5ldyBWZWN0b3IoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMZW5ndGggb2YgdGhpcyBsaW5lLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBsZW5ndGguXHJcbiAgICovXHJcbiAgbGVuZ3RoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2UodGhpcy5lbmQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVwcmVzZW50cyBjZW50ZXIgYXMgdmVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yPX0gb3V0VmVjdG9yIE9iamVjdCBmb3IgcmVzdWx0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gQ2VudGVyIHBvaW50LlxyXG4gICAqL1xyXG4gIGNlbnRlcihvdXRWZWN0b3IgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFZlY3RvciA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcbiAgICByZXR1cm4gb3V0VmVjdG9yLnNldCgodGhpcy5zdGFydC54ICsgdGhpcy5lbmQueCkgLyAyLCAodGhpcy5zdGFydC55ICsgdGhpcy5lbmQueSkgLyAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgJ2xpbmUnLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBEZXNjcmlwdGlvblxyXG4gICAqL1xyXG4gIGdldCB0eXBlKCkge1xyXG4gICAgcmV0dXJuICdMaW5lJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgcG9pbnQgaXMgb24gbGluZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFBvaW50IHBvc2l0aW9uIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgUG9pbnQgcG9zaXRpb24geS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbGluZSBjb250YWlucyBwb2ludC5cclxuICAgKi9cclxuICBjb250YWluc1hZKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKG5ldyBWZWN0b3IoeCwgeSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvd3Mgd2hldGhlciBwb2ludCBpcyBvbiBsaW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3IgUG9pbnQgdG8gY2hlY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGxpbmUgY29udGFpbnMgcG9pbnQuXHJcbiAgICovXHJcbiAgY29udGFpbnModmVjdG9yKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZSh2ZWN0b3IpICsgdGhpcy5lbmQuZGlzdGFuY2UodmVjdG9yKSA9PT0gdGhpcy5sZW5ndGgoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgdGhpcyBsaW5lIGludGVyc2VjdHMgYW5vdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkxpbmV9IGxpbmUgTGluZSB0byBjaGVjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaW50ZXJzZWN0cy5cclxuICAgKi9cclxuICBpbnRlcnNlY3RzKGxpbmUpIHtcclxuICAgIGxldCBzdGFydDEgPSB0aGlzLnN0YXJ0O1xyXG4gICAgbGV0IGVuZDEgPSB0aGlzLmVuZDtcclxuICAgIGxldCBzdGFydDIgPSBsaW5lLnN0YXJ0O1xyXG4gICAgbGV0IGVuZDIgPSBsaW5lLmVuZDtcclxuXHJcbiAgICBsZXQgZGVub21pbmF0b3IgPSAoKGVuZDIueSAtIHN0YXJ0Mi55KSAqIChlbmQxLnggLSBzdGFydDEueCkpIC0gKChlbmQyLnggLSBzdGFydDIueCkgKiAoZW5kMS55IC0gc3RhcnQxLnkpKTtcclxuXHJcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBhID0gc3RhcnQxLnkgLSBzdGFydDIueTtcclxuICAgIGxldCBiID0gc3RhcnQxLnggLSBzdGFydDIueDtcclxuICAgIGxldCBudW1lcmF0b3IxID0gKChlbmQyLnggLSBzdGFydDIueCkgKiBhKSAtICgoZW5kMi55IC0gc3RhcnQyLnkpICogYik7XHJcbiAgICBsZXQgbnVtZXJhdG9yMiA9ICgoZW5kMS54IC0gc3RhcnQxLngpICogYSkgLSAoKGVuZDEueSAtIHN0YXJ0MS55KSAqIGIpO1xyXG4gICAgYSA9IG51bWVyYXRvcjEgLyBkZW5vbWluYXRvcjtcclxuICAgIGIgPSBudW1lcmF0b3IyIC8gZGVub21pbmF0b3I7XHJcblxyXG4gICAgcmV0dXJuIGEgPj0gMCAmJiBhIDw9IDEgJiYgYiA+IDAgJiYgYiA8IDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaG93cyB3aGV0aGVyIHRoaXMgbGluZSBpbnRlcnNlY3RzIGNpcmNsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNpcmNsZX0gY2lyY2xlIENpcmNsZSB0byBjaGVjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaW50ZXJzZWN0cy5cclxuICAgKi9cclxuICBpbnRlcnNlY3RzQ2lyY2xlKGNpcmNsZSkge1xyXG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydDtcclxuICAgIGxldCBlbmQgPSB0aGlzLmVuZDtcclxuXHJcbiAgICBpZiAoY2lyY2xlLmNvbnRhaW5zKHN0YXJ0KSB8fCBjaXJjbGUuY29udGFpbnMoZW5kKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZGlzdGFuY2UgPSBzdGFydC5kaXN0YW5jZShlbmQpO1xyXG4gICAgbGV0IGRpcmVjdGlvblggPSAoZW5kLnggLSBzdGFydC54KSAvIGRpc3RhbmNlO1xyXG4gICAgbGV0IGRpcmVjdGlvblkgPSAoZW5kLnkgLSBzdGFydC55KSAvIGRpc3RhbmNlO1xyXG5cclxuICAgIGxldCB0ID0gZGlyZWN0aW9uWCAqIChjaXJjbGUueCAtIHN0YXJ0LngpICsgZGlyZWN0aW9uWSAqIChjaXJjbGUueSAtIHN0YXJ0LnkpO1xyXG5cclxuICAgIGxldCBuZWFyZXN0ID0gbmV3IFZlY3RvcigodCAqIGRpcmVjdGlvblgpICsgc3RhcnQueCwgKHQgKiBkaXJlY3Rpb25ZKSArIHN0YXJ0LnkpO1xyXG4gICAgbGV0IG5lYXJlc3REaXN0YW5jZSA9IG5lYXJlc3QuZGlzdGFuY2UobmV3IFZlY3RvcihjaXJjbGUueCwgY2lyY2xlLnkpKTtcclxuXHJcbiAgICBpZiAobmVhcmVzdERpc3RhbmNlIDwgY2lyY2xlLnIpIHtcclxuICAgICAgbGV0IGR0ID0gTWF0aC5zcXJ0KE1hdGgucG93KGNpcmNsZS5yLCAyKSAtIE1hdGgucG93KG5lYXJlc3REaXN0YW5jZSwgMikpO1xyXG5cclxuICAgICAgbGV0IHgxID0gKCh0IC0gZHQpICogZGlyZWN0aW9uWCArIHN0YXJ0LngpO1xyXG4gICAgICBsZXQgeTEgPSAoKHQgLSBkdCkgKiBkaXJlY3Rpb25ZICsgc3RhcnQueSk7XHJcbiAgICAgIGxldCB4MiA9ICgodCArIGR0KSAqIGRpcmVjdGlvblggKyBzdGFydC54KTtcclxuICAgICAgbGV0IHkyID0gKCh0ICsgZHQpICogZGlyZWN0aW9uWSArIHN0YXJ0LnkpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuX19pc0luQm91bmRzWFkoeDEsIHkxKSB8fCB0aGlzLl9faXNJbkJvdW5kc1hZKHgyLCB5Mik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgX19pc0luQm91bmRzWFkoeCwgeSkge1xyXG4gICAgbGV0IHgxID0gdGhpcy5zdGFydC54O1xyXG4gICAgbGV0IHkxID0gdGhpcy5zdGFydC55O1xyXG4gICAgbGV0IHgyID0gdGhpcy5lbmQueDtcclxuICAgIGxldCB5MiA9IHRoaXMuZW5kLnk7XHJcblxyXG4gICAgcmV0dXJuIHggPiBNYXRoLm1pbih4MSwgeDIpICYmIHggPCBNYXRoLm1heCh4MSwgeDIpICYmIHkgPiBNYXRoLm1pbih5MSwgeTIpICYmIHkgPCBNYXRoLm1heCh5MSwgeTIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQGlmZGVmIERFQlVHXHJcbiAgLyoqXHJcbiAgICogdG9TdHJpbmcgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBsaW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbZGlnaXRzPTJdIE51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZmxvYXQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IERlc2NyaXB0aW9uLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKGRpZ2l0cyA9IDIpIHtcclxuICAgIHJldHVybiBgTGluZSB7IHN0YXJ0OiAke3RoaXMuc3RhcnQudG9TdHJpbmcoZGlnaXRzKX0sIGVuZDogJHt0aGlzLmVuZC50b1N0cmluZyhkaWdpdHMpfSB9YDtcclxuICB9XHJcbiAgLy8gQGVuZGlmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfkxpbmV9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkxpbmUuX19jYWNoZSA9IG5ldyBMaW5lKG5ldyBWZWN0b3IoKSwgbmV3IFZlY3RvcigpKTtcclxuXHJcbi8qKlxyXG4gKiBNYXRoZW1hdGljYWwgcmVwcmVzZW50YXRpb24gb2YgYSByZWN0YW5nbGUuXHJcbiAqXHJcbiAqIEBjYXQgZ2VvbVxyXG4gKi9cclxuY2xhc3MgUmVjdGFuZ2xlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBSZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbeT0wXSBYLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbeD0wXSBZLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbdz0wXSBUaGUgd2lkdGguXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW2g9MF0gVGhlIGhlaWdodC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHcgPSAwLCBoID0gMCkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoeCwgeSwgdywgaCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmVjdGFuZ2xlLiBcclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByZWN0YW5nbGUuIFxyXG4gICAgICovXHJcbiAgICB0aGlzLnkgPSB5O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLiBcclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHc7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLiBcclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHJlY3RhbmdsZSB2YWx1ZXMgd2l0aCBhIGdpdmVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHcgVGhlIHdpZHRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIFRoZSBoZWlnaHQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gVGhpcy5cclxuICAgKi9cclxuICBzZXQoeCwgeSwgdywgaCkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoeCwgeSwgdywgaCk7XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLndpZHRoID0gdztcclxuICAgIHRoaXMuaGVpZ2h0ID0gaDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcGllcyB2YWx1ZXMgZnJvbSBnaXZlbiByZWN0YW5nbGUgaW50byB0aGlzIG9uZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gcmVjdCBUaGUgUmVjdGFuZ2xlIHRvIGNvcHkgdmFsdWVzIGZyb20uXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gVGhpcy5cclxuICAgKi9cclxuICBjb3B5RnJvbShyZWN0KSB7XHJcbiAgICB0aGlzLnggPSByZWN0Lng7XHJcbiAgICB0aGlzLnkgPSByZWN0Lnk7XHJcbiAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgdmFsdWVzIGZyb20gdGhpcyByZWN0YW5nbGUgaW50byBnaXZlbiByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHJlY3QgVGhlIGRlc3RpbmF0aW9uIHJlY3QuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gR2l2ZW4gcmVjdCBvYmplY3QuXHJcbiAgICovXHJcbiAgY29weVRvKHJlY3QpIHtcclxuICAgIHJlY3QueCA9IHRoaXMueDtcclxuICAgIHJlY3QueSA9IHRoaXMueTtcclxuICAgIHJlY3Qud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgcmVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gcmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXRzIHRoZSBsZWZ0bW9zdCBwb2ludCBvZiB0aGlzIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbGVmdCgpIHtcclxuICAgIHJldHVybiB0aGlzLng7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxyXG4gICAqL1xyXG4gIHNldCBsZWZ0KGxlZnQpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKGxlZnQpO1xyXG4gICAgdGhpcy54ID0gbGVmdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXRzIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcclxuICAgKi9cclxuICBzZXQgcmlnaHQocmlnaHQpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHJpZ2h0KTtcclxuICAgIHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXRzIHRoZSB0b3Btb3N0IHBvaW50IG9mIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB0b3AoKSB7XHJcbiAgICByZXR1cm4gdGhpcy55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvcFxyXG4gICAqL1xyXG4gIHNldCB0b3AodG9wKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih0b3ApO1xyXG4gICAgdGhpcy55ID0gdG9wO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldHMgdGhlIGJvdHRvbW1vc3QgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGJvdHRvbSgpIHtcclxuICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21cclxuICAgKi9cclxuICBzZXQgYm90dG9tKGJvdHRvbSkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoYm90dG9tKTtcclxuXHJcbiAgICB0aGlzLnkgPSBib3R0b20gLSB0aGlzLmhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXRzIHRoZSB0b3AgbGVmdCBwb2ludCBmb3IgdGhpcyByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAqL1xyXG4gIGdldCB0b3BMZWZ0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3JcclxuICAgKi9cclxuICBzZXQgdG9wTGVmdCh2ZWN0b3IpIHtcclxuICAgIHRoaXMubGVmdCA9IHZlY3Rvci54O1xyXG4gICAgdGhpcy50b3AgPSB2ZWN0b3IueTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXRzIHRoZSB0b3AgcmlnaHQgcG9pbnQgZm9yIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnZXQgdG9wUmlnaHQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnJpZ2h0LCB0aGlzLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3JcclxuICAgKi9cclxuICBzZXQgdG9wUmlnaHQodmVjdG9yKSB7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdmVjdG9yLng7XHJcbiAgICB0aGlzLnRvcCA9IHZlY3Rvci55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldHMgdGhlIHRvcCBsZWZ0IHBvaW50IGZvciB0aGlzIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICovXHJcbiAgZ2V0IGJvdHRvbVJpZ2h0KCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3JcclxuICAgKi9cclxuICBzZXQgYm90dG9tUmlnaHQodmVjdG9yKSB7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdmVjdG9yLng7XHJcbiAgICB0aGlzLmJvdHRvbSA9IHZlY3Rvci55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldHMgdGhlIHRvcCBsZWZ0IHBvaW50IGZvciB0aGlzIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICovXHJcbiAgZ2V0IGJvdHRvbUxlZnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMuYm90dG9tKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yXHJcbiAgICovXHJcbiAgc2V0IGJvdHRvbUxlZnQodmVjdG9yKSB7XHJcbiAgICB0aGlzLnggPSB2ZWN0b3IueDtcclxuICAgIHRoaXMuYm90dG9tID0gdmVjdG9yLnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IFJlY3RhbmdsZSBpbnN0YW5jZSB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgZXF1YWwgdG8gY3VycmVudCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFZlY3RvciBSZXN1bHRpbmcgcmVjdCB0byBzYXZlIHZhbHVlcyBpbi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBOZXcgUmVjdGFuZ2xlIGluc3RhbmNlIG9yIGBvdXRWZWN0b3JgIGlmIHBhc3NlZC5cclxuICAgKi9cclxuICBzaXplKG91dFZlY3RvciA9IHVuZGVmaW5lZCkge1xyXG4gICAgb3V0VmVjdG9yID0gb3V0VmVjdG9yIHx8IG5ldyBWZWN0b3IoKTtcclxuICAgIHJldHVybiBvdXRWZWN0b3Iuc2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYWxsIGNvbXBvbmVudHMgb2YgdGhpcyBSZWN0YW5nbGUgdG8gemVyby5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFRoaXMuXHJcbiAgICovXHJcbiAgemVybygpIHtcclxuICAgIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBhcmVzIHRoaXMgUmVjdGFuZ2xlIHdpdGggYSBnaXZlbiBvbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHJlY3QgUmVjdCB0byBjb21wYXJlIHZhbHVlcyB3aXRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZXBzaWxvbj1OdW1iZXIuRVBTSUxPTl0gQ29tcGFyaXNvbiB0aHJlc2hvbGQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiByZWN0YW5nbGVzIGFyZSBlcXVhbC5cclxuICAgKi9cclxuICBlcXVhbHMocmVjdCwgZXBzaWxvbiA9IE51bWJlci5FUFNJTE9OKSB7XHJcbiAgICByZXR1cm4gcmVjdCAhPT0gbnVsbCAmJiAoTWF0aC5hYnModGhpcy54IC0gcmVjdC54KSA8IGVwc2lsb24pICYmIChNYXRoLmFicyh0aGlzLnkgLSByZWN0LnkpIDwgZXBzaWxvbikgJiZcclxuICAgICAgKE1hdGguYWJzKHRoaXMud2lkdGggLSByZWN0LndpZHRoKSA8IGVwc2lsb24pICYmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIHJlY3QuaGVpZ2h0KSA8IGVwc2lsb24pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGlzIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSB4LWNvbXBvbmVudCBvZiBhIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSB5LWNvbXBvbmVudCBvZiBhIHBvaW50LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9pbnQgaXMgaW5zaWRlLlxyXG4gICAqL1xyXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xyXG4gICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy5yaWdodCAmJiB5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMuYm90dG9tO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIHJlY3RhbmdsZSBpcyBpbnNpZGUgdGhpcyByZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSByZWN0IFJlY3RhbmdsZSB0byBjaGVjayB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZ2l2ZW4gcmVjdGFuZ2xlIGlzIGluc2lkZSB0aGlzIG9uZS5cclxuICAgKi9cclxuICBjb250YWlucyhyZWN0KSB7XHJcbiAgICByZXR1cm4gcmVjdC54ID49IHRoaXMueCAmJiByZWN0LnkgPj0gdGhpcy55ICYmIHJlY3QucmlnaHQgPD0gdGhpcy5yaWdodCAmJiByZWN0LmJvdHRvbSA8PSB0aGlzLmJvdHRvbTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIHJlY3QgaW50ZXJzZWN0cyB3aXRoIGEgZ2l2ZW4gcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0IHRvIGNoZWNrIGludGVyc2VjdGlvbiB3aXRoLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaW50ZXJzZWN0cy5cclxuICAgKi9cclxuICBpbnRlcnNlY3RzKHJlY3QpIHtcclxuICAgIHJldHVybiByZWN0LnJpZ2h0ID4gdGhpcy54ICYmIHJlY3QuYm90dG9tID4gdGhpcy55ICYmXHJcbiAgICAgIHJlY3QueCA8IHRoaXMucmlnaHQgJiYgcmVjdC55IDwgdGhpcy5ib3R0b207XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYWtlcyByZWN0YW5nbGUsIHdoaWNoIHJlcHJlc2VudHMgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhpcyBhbmQgcGFzc2VkIHJlY3RhbmdsZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHRvSW50ZXJzZWN0IFJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aC5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGU9fSBvdXRSZWN0IFJlY3RhbmdsZSB0byBiZSByZXR1cm5lZC5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgKi9cclxuICBpbnRlcnNlY3Rpb24odG9JbnRlcnNlY3QsIG91dFJlY3QpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBsZXQgeDAgPSB0aGlzLnggPCB0b0ludGVyc2VjdC54ID8gdG9JbnRlcnNlY3QueCA6IHRoaXMueDtcclxuICAgIGxldCB4MSA9IHRoaXMucmlnaHQgPiB0b0ludGVyc2VjdC5yaWdodCA/IHRvSW50ZXJzZWN0LnJpZ2h0IDogdGhpcy5yaWdodDtcclxuXHJcbiAgICBpZiAoeDEgPD0geDApXHJcbiAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgbGV0IHkwID0gdGhpcy55IDwgdG9JbnRlcnNlY3QueSA/IHRvSW50ZXJzZWN0LnkgOiB0aGlzLnk7XHJcbiAgICBsZXQgeTEgPSB0aGlzLmJvdHRvbSA+IHRvSW50ZXJzZWN0LmJvdHRvbSA/IHRvSW50ZXJzZWN0LmJvdHRvbSA6IHRoaXMuYm90dG9tO1xyXG5cclxuICAgIGlmICh5MSA8PSB5MClcclxuICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBvdXRSZWN0LnNldCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xyXG4gICAgcmV0dXJuIG91dFJlY3Q7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBnaXZlbiByZWN0YW5nbGUgaW50byB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSB0b1VuaW9uIEEgcmVjdGFuZ2xlIG9iamVjdCB0byBhZGQgdG8gdGhpcyByZWN0LlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IE5ldyByZWN0YW5nbGUgb2JqZWN0IHRoYXQgaXMgdGhlIHVuaW9uLlxyXG4gICAqL1xyXG4gIHVuaW9uKHRvVW5pb24pIHtcclxuICAgIGxldCB4MCA9IHRoaXMueCA+IHRvVW5pb24ueCA/IHRvVW5pb24ueCA6IHRoaXMueDtcclxuICAgIGxldCB4MSA9IHRoaXMucmlnaHQgPCB0b1VuaW9uLnJpZ2h0ID8gdG9Vbmlvbi5yaWdodCA6IHRoaXMucmlnaHQ7XHJcbiAgICBsZXQgeTAgPSB0aGlzLnkgPiB0b1VuaW9uLnkgPyB0b1VuaW9uLnkgOiB0aGlzLnk7XHJcbiAgICBsZXQgeTEgPSB0aGlzLmJvdHRvbSA8IHRvVW5pb24uYm90dG9tID8gdG9Vbmlvbi5ib3R0b20gOiB0aGlzLmJvdHRvbTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXQoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdm9sdW1lIG9mIHRoaXMgUmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB2b2x1bWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhwYW5kcyB0aGlzIHJlY3RhbmdsZSBvYmplY3QgYnkgZ2l2ZW4gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICBYLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgIFktY29tcG9uZW50XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0LlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFRoaXMuXHJcbiAgICovXHJcbiAgZXhwYW5kKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGlmICh0aGlzLnZvbHVtZSA9PT0gMClcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIGxldCBjYWNoZVJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgIGxldCBjYWNoZUJvdHRvbSA9IHRoaXMuYm90dG9tO1xyXG5cclxuICAgIGlmICh0aGlzLnggPiB4KSB7XHJcbiAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgIHRoaXMud2lkdGggPSBjYWNoZVJpZ2h0IC0geDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy55ID4geSkge1xyXG4gICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGNhY2hlQm90dG9tIC0geTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FjaGVSaWdodCA8IHggKyB3aWR0aClcclxuICAgICAgdGhpcy53aWR0aCA9IHggKyB3aWR0aCAtIHRoaXMueDtcclxuXHJcbiAgICBpZiAoY2FjaGVCb3R0b20gPCB5ICsgaGVpZ2h0KVxyXG4gICAgICB0aGlzLmhlaWdodCA9IHkgKyBoZWlnaHQgLSB0aGlzLnk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHBhbmRzIHRoaXMgcmVjdGFuZ2xlIHdpdGggYSBnaXZlbiBwb2ludC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCBcclxuICAgKiBAcGFyYW0ge251bWJlcn0geSBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgKi9cclxuICBleHBhbmRYWSh4LCB5KSB7XHJcbiAgICBpZiAoeCA8IHRoaXMueCkge1xyXG4gICAgICB0aGlzLndpZHRoICs9IHRoaXMueCAtIHg7XHJcbiAgICAgIHRoaXMueCA9IHg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHkgPCB0aGlzLnkpIHtcclxuICAgICAgdGhpcy5oZWlnaHQgKz0gdGhpcy55IC0geTtcclxuICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeCA+IHRoaXMueCArIHRoaXMud2lkdGgpXHJcbiAgICAgIHRoaXMud2lkdGggPSB4IC0gdGhpcy54O1xyXG5cclxuICAgIGlmICh5ID4gdGhpcy55ICsgdGhpcy5oZWlnaHQpXHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0geSAtIHRoaXMueTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGlzIHJlY3RhbmdsZSBieSBnaXZlbiB4LSBhbmQgeS0gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbeD0wXSBYLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFt5PTBdIFktY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFRoaXMuXHJcbiAgICovXHJcbiAgaW5mbGF0ZSh4ID0gMCwgeSA9IDApIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHgsIHkpO1xyXG5cclxuICAgIHRoaXMueCAtPSB4O1xyXG4gICAgdGhpcy55IC09IHk7XHJcbiAgICB0aGlzLndpZHRoICs9IDIgKiB4O1xyXG4gICAgdGhpcy5oZWlnaHQgKz0gMiAqIHk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9uZXMgdGhpcyBSZWN0YW5nbGUgb2JqZWN0IGludG8gbmV3IG9uZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IE5ldyByZWN0YW5nbGUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgcmVjdGFuZ2xlIHBlcmltZXRlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcGVyaW1ldGVyKCkge1xyXG4gICAgcmV0dXJuIDIgKiAodGhpcy53aWR0aCArIHRoaXMuaGVpZ2h0KTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhpcyByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3I9fSBvdXRWZWN0b3IgVGhlIG91dC1WZWN0b3IgdG8gc3RvcmUgdmFsdWVzIGluLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IE5ldyByZWN0YW5nbGUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNlbnRlcihvdXRWZWN0b3IgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFZlY3RvciA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcbiAgICByZXR1cm4gb3V0VmVjdG9yLnNldCh0aGlzLnggKyB0aGlzLndpZHRoICogMC41LCB0aGlzLnkgKyB0aGlzLmhlaWdodCAqIDAuNSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAgU2NhbGVzIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggV2lkdGggbXVsdGlwbGllci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSBIZWlnaHQgbXVsdGlwbGllci5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBUaGlzIHJlY3RhbmdsZS5cclxuICAgKi9cclxuICBzY2FsZSh4LCB5KSB7XHJcbiAgICB0aGlzLndpZHRoICo9IHg7XHJcbiAgICB0aGlzLmhlaWdodCAqPSB5O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHJlY3RhbmdsZSBoYXMgYXJlYS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaGFzLlxyXG4gICAqL1xyXG4gIGdldCBpc0VtcHR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhIGxpc3Qgb2YgbGluZXMsIHdoaWNoIG1ha2UgdXAgdGhpcyByZWN0YW5nbGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXk8YmxhY2stZW5naW5lfkxpbmU+fVxyXG4gICAqL1xyXG4gIGdldCBsaW5lcygpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgIG5ldyBMaW5lKHRoaXMudG9wTGVmdCwgdGhpcy50b3BSaWdodCksXHJcbiAgICAgIG5ldyBMaW5lKHRoaXMudG9wUmlnaHQsIHRoaXMuYm90dG9tUmlnaHQpLFxyXG4gICAgICBuZXcgTGluZSh0aGlzLmJvdHRvbVJpZ2h0LCB0aGlzLmJvdHRvbUxlZnQpLFxyXG4gICAgICBuZXcgTGluZSh0aGlzLmJvdHRvbUxlZnQsIHRoaXMudG9wTGVmdClcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHJhbmRvbSBudW1iZXIgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAqIEByZXR1cm5zIHtWZWN0b3J9XHJcbiAgICovXHJcbiAgZ2V0IHJhbmRvbSgpIHtcclxuICAgIGNvbnN0IHJ4ID0gTWF0aEV4LnJhbmRvbUJldHdlZW4odGhpcy54LCB0aGlzLndpZHRoKTtcclxuICAgIGNvbnN0IHJ5ID0gTWF0aEV4LnJhbmRvbUJldHdlZW4odGhpcy55LCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IocngsIHJ5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYSBib25kaW5nIGJveCBlbmNsb3NpbmcgdGhlIGdpdmVuIGxpc3Qgb2YgcG9pbnRzLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8VmVjdG9yPn0gcG9pbnRzIFxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tUG9pbnRzKHBvaW50cykge1xyXG4gICAgbGV0IHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICBsZXQgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcclxuICAgIGxldCBtaW5YID0gcG9pbnRzWzBdLng7XHJcbiAgICBsZXQgbWluWSA9IHBvaW50c1swXS55O1xyXG4gICAgbGV0IG1heFggPSBwb2ludHNbMF0ueDtcclxuICAgIGxldCBtYXhZID0gcG9pbnRzWzBdLnk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgcCA9IHBvaW50c1tpXTtcclxuICAgICAgbGV0IHggPSBwLng7XHJcbiAgICAgIGxldCB5ID0gcC55O1xyXG5cclxuICAgICAgbWluWCA9IE1hdGgubWluKHgsIG1pblgpO1xyXG4gICAgICBtYXhYID0gTWF0aC5tYXgoeCwgbWF4WCk7XHJcbiAgICAgIG1pblkgPSBNYXRoLm1pbih5LCBtaW5ZKTtcclxuICAgICAgbWF4WSA9IE1hdGgubWF4KHksIG1heFkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC54ID0gbWluWDtcclxuICAgIHJlc3VsdC55ID0gbWluWTtcclxuICAgIHJlc3VsdC53aWR0aCA9IG1heFggLSBtaW5YO1xyXG4gICAgcmVzdWx0LmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYSBib25kaW5nIGJveCBlbmNsb3NpbmcgdGhlIGdpdmVuIGxpc3Qgb2YgeC15IHBhaXJzLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcG9pbnRzIFxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tUG9pbnRzWFkocG9pbnRzKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZSgpO1xyXG5cclxuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMilcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICBsZXQgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcclxuICAgIGxldCBtaW5YID0gcG9pbnRzWzBdO1xyXG4gICAgbGV0IG1pblkgPSBwb2ludHNbMV07XHJcbiAgICBsZXQgbWF4WCA9IHBvaW50c1swXTtcclxuICAgIGxldCBtYXhZID0gcG9pbnRzWzFdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgbGV0IHggPSBwb2ludHNbaV07XHJcbiAgICAgIGxldCB5ID0gcG9pbnRzW2kgKyAxXTtcclxuXHJcbiAgICAgIG1pblggPSBNYXRoLm1pbih4LCBtaW5YKTtcclxuICAgICAgbWF4WCA9IE1hdGgubWF4KHgsIG1heFgpO1xyXG4gICAgICBtaW5ZID0gTWF0aC5taW4oeSwgbWluWSk7XHJcbiAgICAgIG1heFkgPSBNYXRoLm1heCh5LCBtYXhZKTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQueCA9IG1pblg7XHJcbiAgICByZXN1bHQueSA9IG1pblk7XHJcbiAgICByZXN1bHQud2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgIHJlc3VsdC5oZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyBAaWZkZWYgREVCVUdcclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbZGlnaXRzPTJdIERlc2NyaXB0aW9uXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBEZXNjcmlwdGlvblxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKGRpZ2l0cyA9IDIpIHtcclxuICAgIHJldHVybiBgUmVjdGFuZ2xlIHsgeDogJHt0aGlzLngudG9GaXhlZChkaWdpdHMpfSwgeTogJHt0aGlzLnkudG9GaXhlZChkaWdpdHMpfSwgd2lkdGg6ICR7dGhpcy53aWR0aC50b0ZpeGVkKGRpZ2l0cyl9LCBoZWlnaHQ6ICR7dGhpcy5oZWlnaHQudG9GaXhlZChkaWdpdHMpfSB9YDtcclxuICB9XHJcbiAgLy8gQGVuZGlmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuUmVjdGFuZ2xlLl9fY2FjaGUgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4vKipcclxuICogUmVjeWNsZWQgcmVjdGFuZ2xlcyBwb29sLlxyXG4gKlxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfk9iamVjdFBvb2x9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5SZWN0YW5nbGUucG9vbCA9IG5ldyBPYmplY3RQb29sKFJlY3RhbmdsZSk7XHJcblxyXG4vKipcclxuICogQSAyeDMgbWF0cml4IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIG9iamVjdHMgaW4gc3BhY2UuXHJcbiAqXHJcbiAqIEBjYXQgZ2VvbVxyXG4gKi9cclxuY2xhc3MgTWF0cml4IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBNYXRyaXggaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFthPTFdICBBLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtiPTBdICBCLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtjPTBdICBDLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtkPTFdICBELWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt0eD0wXSBUWC1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbdHk9MF0gVFktY29tcG9uZW50LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7RmxvYXQzMkFycmF5fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcclxuICAgIHRoaXMuc2V0KGEsIGIsIGMsIGQsIHR4LCB0eSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGNvbXBvbmVudHMgb2YgdGhpcyBtYXRyaXggdG8gdGhlIGdpdmVuIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gYSAgQS1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBiICBCLWNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGMgIEMtY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gZCAgRC1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0eCBUWC1jb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0eSBUWS1jb21wb25lbnQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBzZXQoYSA9IDEsIGIgPSAwLCBjID0gMCwgZCA9IDEsIHR4ID0gMCwgdHkgPSAwKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihhLCBiLCBjLCBkLCB0eCwgdHkpO1xyXG5cclxuICAgIGxldCBtID0gdGhpcy5kYXRhO1xyXG5cclxuICAgIG1bMF0gPSBhO1xyXG4gICAgbVsxXSA9IGI7XHJcbiAgICBtWzJdID0gYztcclxuICAgIG1bM10gPSBkO1xyXG4gICAgbVs0XSA9IHR4O1xyXG4gICAgbVs1XSA9IHR5O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IGJ5IHggYW5kIHkgYXhlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBBbW91bnQgYWxvbmcgeC1heGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBBbW91bnQgYWxvbmcgeS1heGlzLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFRoaXMuXHJcbiAgICovXHJcbiAgdHJhbnNsYXRlKGR4LCBkeSkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoZHgsIGR5KTtcclxuXHJcbiAgICBsZXQgYSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEwID0gYVswXTsgLy8gYVxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhMSA9IGFbMV07IC8vIGJcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYTIgPSBhWzJdOyAvLyBjXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEzID0gYVszXTsgLy8gZFxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhNCA9IGFbNF07IC8vIHR4XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGE1ID0gYVs1XTsgLy8gdHlcclxuXHJcbiAgICB0aGlzLmRhdGFbNF0gPSBhMCAqIGR4ICsgYTIgKiBkeSArIGE0O1xyXG4gICAgdGhpcy5kYXRhWzVdID0gYTEgKiBkeCArIGEzICogZHkgKyBhNTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdHggYW5kIHR5IGNvbXBvbmVudHMgdG8gZ2l2ZW4gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHR4IGNvbXBvbmVudCB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHR5IGNvbXBvbmVudCB0byB1cGRhdGUuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBzZXRUcmFuc2xhdGlvbih4LCB5KSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5KTtcclxuXHJcbiAgICB0aGlzLmRhdGFbNF0gPSB4O1xyXG4gICAgdGhpcy5kYXRhWzVdID0geTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYWJzb2x1dGUgcm90YXRpb24gb2YgdGhpcyBtYXRyaXggdG8gc3BlY2lmaWVkIGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aGV0YSAgICAgVGhldGEgdmFsdWUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzY2FsZSA9IDEgU2NhbGUgdmFsdWUuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBzZXRSb3RhdGlvbih0aGV0YSwgc2NhbGUgPSAxKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih0aGV0YSwgc2NhbGUpO1xyXG5cclxuICAgIGxldCBtID0gdGhpcy5kYXRhO1xyXG4gICAgbVswXSA9IE1hdGguY29zKHRoZXRhKSAqIHNjYWxlO1xyXG4gICAgbVsyXSA9IE1hdGguc2luKHRoZXRhKSAqIHNjYWxlO1xyXG4gICAgbVsxXSA9IC1tWzJdO1xyXG4gICAgbVszXSA9IG1bMF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIHJvdGF0aW9uIHRvIHRoaXMgbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFRoaXMuXHJcbiAgICovXHJcbiAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihhbmdsZSk7XHJcblxyXG4gICAgbGV0IGEgPSB0aGlzLmRhdGE7XHJcbiAgICBsZXQgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgbGV0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIGxldCBhMCA9IGFbMF07XHJcbiAgICBsZXQgYTIgPSBhWzJdO1xyXG4gICAgbGV0IGE0ID0gYVs0XTtcclxuXHJcbiAgICBhWzBdID0gYTAgKiBjb3MgLSBhWzFdICogc2luO1xyXG4gICAgYVsxXSA9IGEwICogc2luICsgYVsxXSAqIGNvcztcclxuICAgIGFbMl0gPSBhMiAqIGNvcyAtIGFbM10gKiBzaW47XHJcbiAgICBhWzNdID0gYTIgKiBzaW4gKyBhWzNdICogY29zO1xyXG4gICAgYVs0XSA9IGE0ICogY29zIC0gYVs1XSAqIHNpbjtcclxuICAgIGFbNV0gPSBhNCAqIHNpbiArIGFbNV0gKiBjb3M7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2FsZXMgY3VycmVudCBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3ggQWJzY2lzc2Egb2YgdGhlIHNjYWxpbmcgdmVjdG9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzeSBPcmRpbmF0ZSBvZiB0aGUgc2NhbGluZyB2ZWN0b3IuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBzY2FsZShzeCwgc3kpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHN4LCBzeSk7XHJcblxyXG4gICAgbGV0IGEgPSB0aGlzLmRhdGE7XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEwID0gYVswXTsgLy8gYVxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhMSA9IGFbMV07IC8vIGJcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYTIgPSBhWzJdOyAvLyBjXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEzID0gYVszXTsgLy8gZFxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhNCA9IGFbNF07IC8vIHR4XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGE1ID0gYVs1XTsgLy8gdHlcclxuXHJcbiAgICB0aGlzLmRhdGFbMF0gPSBhMCAqIHN4O1xyXG4gICAgdGhpcy5kYXRhWzFdID0gYTEgKiBzeDtcclxuICAgIHRoaXMuZGF0YVsyXSA9IGEyICogc3k7XHJcbiAgICB0aGlzLmRhdGFbM10gPSBhMyAqIHN5O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgc2tldyhzeCwgc3kpIHtcclxuICAgIGxldCBzaW5YID0gTWF0aC5zaW4oc3gpO1xyXG4gICAgbGV0IGNvc1ggPSBNYXRoLmNvcyhzeCk7XHJcbiAgICBsZXQgc2luWSA9IE1hdGguc2luKHN5KTtcclxuICAgIGxldCBjb3NZID0gTWF0aC5jb3Moc3kpO1xyXG4gICAgbGV0IGQgPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgdGhpcy5zZXQoXHJcbiAgICAgIGRbMF0gKiBjb3NZIC0gZFsxXSAqIHNpblgsXHJcbiAgICAgIGRbMF0gKiBzaW5ZICsgZFsxXSAqIGNvc1gsXHJcbiAgICAgIGRbMl0gKiBjb3NZIC0gZFszXSAqIHNpblgsXHJcbiAgICAgIGRbMl0gKiBzaW5ZICsgZFszXSAqIGNvc1gsXHJcbiAgICAgIGRbNF0gKiBjb3NZIC0gZFs1XSAqIHNpblgsXHJcbiAgICAgIGRbNF0gKiBzaW5ZICsgZFs1XSAqIGNvc1gpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIGN1cnJlbnQgbWF0cml4IHRvIGlkZW50aXR5IHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBpZGVudGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLnNldCgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWNpZmllcyBpZiBjdXJyZW50IG1hdHJpeCBpcyBpZGVudGl0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc0lkZW50aXR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZXhhY3RFcXVhbHMoTWF0cml4Ll9faWRlbnRpdHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uY2F0ZW5hdGVzIGEgZ2l2ZW4gbWF0cml4IHdpdGggdGhlIGN1cnJlbnQgb25lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfk1hdHJpeH0gYiBUaGUgbWF0cml4IHRvIGJlIGNvbmNhdGVuYXRlZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fSAgIFRoaXMuXHJcbiAgICovXHJcbiAgcHJlcGVuZChiKSB7XHJcbiAgICBsZXQgYSA9IHRoaXMuZGF0YTtcclxuICAgIGxldCBidiA9IGIuZGF0YTtcclxuXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEwID0gYVswXTsgLy8gYVxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhMSA9IGFbMV07IC8vIGJcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYTIgPSBhWzJdOyAvLyBjXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGEzID0gYVszXTsgLy8gZFxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhNCA9IGFbNF07IC8vIHR4XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGE1ID0gYVs1XTsgLy8gdHlcclxuXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGIwID0gYnZbMF07IC8vIGFcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYjEgPSBidlsxXTsgLy8gYlxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiMiA9IGJ2WzJdOyAvLyBjXHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGIzID0gYnZbM107IC8vIGRcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYjQgPSBidls0XTsgLy8gdHhcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYjUgPSBidls1XTsgLy8gdHlcclxuXHJcbiAgICBpZiAoYjAgIT09IDEgfHwgYjEgIT09IDAgfHwgYjIgIT09IDAgfHwgYjMgIT09IDEpIHtcclxuICAgICAgbGV0IGExMSA9IChhMCAqIGIwICsgYTEgKiBiMik7XHJcbiAgICAgIGFbMV0gPSBhMCAqIGIxICsgYTEgKiBiMztcclxuICAgICAgYVswXSA9IGExMTtcclxuXHJcbiAgICAgIGxldCBjMTEgPSAoYTIgKiBiMCArIGEzICogYjIpO1xyXG4gICAgICBhWzNdID0gYTIgKiBiMSArIGEzICogYjM7XHJcbiAgICAgIGFbMl0gPSBjMTE7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxldCB0eDExID0gKGE0ICogYjAgKyBhNSAqIGIyICsgYjQpO1xyXG4gICAgYVs1XSA9IGE0ICogYjEgKyBhNSAqIGIzICsgYjU7XHJcbiAgICBhWzRdID0gdHgxMTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwZW5kcyB2YWx1ZXMgdG8gdGhpcyBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+TWF0cml4fSBiIFRoZSBtYXRyaXggdG8gYmUgYXBwZW5kZWQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1hdHJpeH0gVGhpcy5cclxuICAgKi9cclxuICBhcHBlbmQoYikge1xyXG4gICAgbGV0IGEgPSB0aGlzLmRhdGE7XHJcbiAgICBsZXQgYnYgPSBiLmRhdGE7XHJcblxyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhMCA9IGFbMF07XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGExID0gYVsxXTtcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYTIgPSBhWzJdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBhMyA9IGFbM107XHJcbiAgICBsZXQgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGE0ID0gYVs0XTtcclxuICAgIGxldCAvKiogQHR5cGUge251bWJlcn0gKi8gYTUgPSBhWzVdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiMCA9IGJ2WzBdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiMSA9IGJ2WzFdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiMiA9IGJ2WzJdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiMyA9IGJ2WzNdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiNCA9IGJ2WzRdO1xyXG4gICAgbGV0IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBiNSA9IGJ2WzVdO1xyXG5cclxuICAgIGFbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcclxuICAgIGFbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcclxuICAgIGFbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcclxuICAgIGFbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcclxuICAgIGFbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xyXG4gICAgYVs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgZ2l2ZW4gYW5kIHgtIGFuZCB5LSBjb21wb25lbnRzIG9mIGEgcG9pbnQgZnJvbSBhIGxvY2FsIHNwYWNlIHRvIHdvcmxkIHNwYWNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgICAgIFRoZSB4LSBjb21wb25lbnQgb2YgYSBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgICAgVGhlIHktIGNvbXBvbmVudCBvZiBhIHBvaW50LlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5WZWN0b3I9fSBvdXRWZWN0b3IgSWYgZ2l2ZW4gc3RvcmVzIHJlc3VsdGluZyB2YWx1ZXMgaW4gaXQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVHJhbnNmb3JtZWQgVmVjdG9yIG9iamVjdC5cclxuICAgKi9cclxuICB0cmFuc2Zvcm1YWSh4LCB5LCBvdXRWZWN0b3IpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHgsIHkpO1xyXG5cclxuICAgIG91dFZlY3RvciA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcbiAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuXHJcbiAgICBvdXRWZWN0b3IueCA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xyXG4gICAgb3V0VmVjdG9yLnkgPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcclxuXHJcbiAgICByZXR1cm4gb3V0VmVjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyBnaXZlbiBwb2ludCBmcm9tIGEgbG9jYWwgc3BhY2UgdG8gd29ybGQgc3BhY2Ugd2l0aG91dCBhcHBseWluZyBzY2FsaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgICAgIFRoZSB4LSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgICAgIFRoZSB5LSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFZlY3RvciBJZiBnaXZlbiBzdG9yZXMgcmVzdWx0cyBpbiBpdC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBKdXN0IHRyYW5zZm9ybWVkIFZlY3RvciBvYmplY3QuXHJcbiAgICovXHJcbiAgdHJhbnNmb3JtRGlyZWN0aW9uWFkoeCwgeSwgb3V0VmVjdG9yKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5KTtcclxuXHJcbiAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgIG91dFZlY3RvciA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgb3V0VmVjdG9yLnggPSBtWzBdICogeCArIG1bMl0gKiB5O1xyXG4gICAgb3V0VmVjdG9yLnkgPSBtWzFdICogeCArIG1bM10gKiB5O1xyXG5cclxuICAgIHJldHVybiBvdXRWZWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIHZlY3RvciBieSBjdXJyZW50IG1hdHJpeCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+VmVjdG9yfSB2ZWN0b3IgICAgIFZlY3RvciB0byBhcHBseSB0cmFuc2Zvcm1hdGlvbiBvbi5cclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+VmVjdG9yPX0gb3V0VmVjdG9yIE91dCBWZWN0b3IgdG8gc3RvcmUgcmVzdWx0cyBpbi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBOZXcgdHJhbnNmb3JtZWQgdmVjdG9yLlxyXG4gICAqL1xyXG4gIHRyYW5zZm9ybVZlY3Rvcih2ZWN0b3IsIG91dFZlY3Rvcikge1xyXG4gICAgb3V0VmVjdG9yID0gb3V0VmVjdG9yIHx8IG5ldyBWZWN0b3IoKTtcclxuICAgIGNvbnN0IG0gPSB0aGlzLmRhdGE7XHJcblxyXG4gICAgY29uc3QgeCA9IG1bMF0gKiB2ZWN0b3IueCArIG1bMl0gKiB2ZWN0b3IueSArIG1bNF07XHJcbiAgICBjb25zdCB5ID0gbVsxXSAqIHZlY3Rvci54ICsgbVszXSAqIHZlY3Rvci55ICsgbVs1XTtcclxuXHJcbiAgICByZXR1cm4gb3V0VmVjdG9yLnNldCh4LCB5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgcmVjdGFuZ2xlIGJ5IGN1cnJlbnQgbWF0cml4IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHJlY3QgICAgICAgICBSZWN0YW5nbGUgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb24gb24uXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lflJlY3RhbmdsZXxudWxsfSBvdXRSZWN0IFdoZW4gZ2l2ZW4gc3RvcmVzIHJlc3VsdHMgaW4gaXQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gVHJhbnNmb3JtZWQgIFJlY3RhbmdsZSBvYmplY3QuXHJcbiAgICovXHJcbiAgdHJhbnNmb3JtUmVjdChyZWN0LCBvdXRSZWN0KSB7XHJcbiAgICBvdXRSZWN0ID0gb3V0UmVjdCB8fCBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgbGV0IG1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1heFggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBtaW5ZID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBtYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgIGxldCB0bXBWZWN0b3IgPSBWZWN0b3IucG9vbC5nZXQoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXHJcbiAgICBsZXQgcG9pbnRzID0gW3JlY3QueCwgcmVjdC55LCByZWN0LnggKyByZWN0LndpZHRoLCByZWN0LnksIHJlY3QueCwgcmVjdC55ICsgcmVjdC5oZWlnaHQsIHJlY3QueCArIHJlY3Qud2lkdGgsIHJlY3QueSArIHJlY3QuaGVpZ2h0XTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICB0bXBWZWN0b3IueCA9IG1bMF0gKiBwb2ludHNbaV0gKyBtWzJdICogcG9pbnRzW2kgKyAxXSArIG1bNF07XHJcbiAgICAgIHRtcFZlY3Rvci55ID0gbVsxXSAqIHBvaW50c1tpXSArIG1bM10gKiBwb2ludHNbaSArIDFdICsgbVs1XTtcclxuXHJcbiAgICAgIGlmIChtaW5YID4gdG1wVmVjdG9yLngpXHJcbiAgICAgICAgbWluWCA9IHRtcFZlY3Rvci54O1xyXG4gICAgICBpZiAobWF4WCA8IHRtcFZlY3Rvci54KVxyXG4gICAgICAgIG1heFggPSB0bXBWZWN0b3IueDtcclxuICAgICAgaWYgKG1pblkgPiB0bXBWZWN0b3IueSlcclxuICAgICAgICBtaW5ZID0gdG1wVmVjdG9yLnk7XHJcbiAgICAgIGlmIChtYXhZIDwgdG1wVmVjdG9yLnkpXHJcbiAgICAgICAgbWF4WSA9IHRtcFZlY3Rvci55O1xyXG4gICAgfVxyXG5cclxuICAgIFZlY3Rvci5wb29sLnJlbGVhc2UodG1wVmVjdG9yKTtcclxuXHJcbiAgICByZXR1cm4gb3V0UmVjdC5zZXQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludmVydHMgY3VycmVudCBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fSBUaGlzLlxyXG4gICAqL1xyXG4gIGludmVydCgpIHtcclxuICAgIGxldCBhID0gdGhpcy5kYXRhO1xyXG5cclxuICAgIGxldCBhYSA9IGFbMF07XHJcbiAgICBsZXQgYWIgPSBhWzFdO1xyXG4gICAgbGV0IGFjID0gYVsyXTtcclxuICAgIGxldCBhZCA9IGFbM107XHJcbiAgICBsZXQgYXR4ID0gYVs0XTtcclxuICAgIGxldCBhdHkgPSBhWzVdO1xyXG5cclxuICAgIGxldCBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcclxuICAgIGlmIChkZXQgPT09IDApIHtcclxuICAgICAgYVswXSA9IGFbMV0gPSBhWzJdID0gYVszXSA9IDA7XHJcbiAgICAgIGFbNF0gPSAtYXR4O1xyXG4gICAgICBhWzVdID0gLWF0eTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcblxyXG4gICAgYVswXSA9IGFkICogZGV0O1xyXG4gICAgYVsxXSA9IC1hYiAqIGRldDtcclxuICAgIGFbMl0gPSAtYWMgKiBkZXQ7XHJcbiAgICBhWzNdID0gYWEgKiBkZXQ7XHJcbiAgICBhWzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xyXG4gICAgYVs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IHJlbW92ZSBvciBmaW5pc2hcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IERlc2NyaXB0aW9uXHJcbiAgICovXHJcbiAgX19kZWNvbXBvc2UoKSB7XHJcbiAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgIGxldCBhID0gbVswXTtcclxuICAgIGxldCBiID0gbVsxXTtcclxuICAgIGxldCBjID0gbVsyXTtcclxuICAgIGxldCBkID0gbVszXTtcclxuICAgIGxldCB0eCA9IG1bNF07XHJcbiAgICBsZXQgdHkgPSBtWzVdO1xyXG5cclxuICAgIGxldCBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcclxuICAgIGxldCBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XHJcblxyXG4gICAgbGV0IGRlbHRhID0gTWF0aC5hYnMoc2tld1ggKyBza2V3WSk7XHJcblxyXG4gICAgbGV0IHJfcm90YXRpb24gPSAwO1xyXG4gICAgbGV0IHJfc2tld1ggPSAwO1xyXG4gICAgbGV0IHJfc2tld1kgPSAwO1xyXG4gICAgbGV0IHJfc2NhbGVYID0gMDtcclxuICAgIGxldCByX3NjYWxlWSA9IDA7XHJcbiAgICBsZXQgcl94ID0gMDtcclxuICAgIGxldCByX3kgPSAwO1xyXG5cclxuICAgIGlmIChkZWx0YSA8IDAuMDAwMDEpIHtcclxuICAgICAgcl9yb3RhdGlvbiA9IHNrZXdZO1xyXG5cclxuICAgICAgaWYgKGEgPCAwICYmIGQgPj0gMClcclxuICAgICAgICByX3JvdGF0aW9uICs9IChyX3JvdGF0aW9uIDw9IDApID8gTWF0aC5QSSA6IC1NYXRoLlBJO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcl9za2V3WCA9IHNrZXdYO1xyXG4gICAgICByX3NrZXdZID0gc2tld1k7XHJcbiAgICB9XHJcblxyXG4gICAgcl9zY2FsZVggPSBNYXRoLnNxcnQoKGEgKiBhKSArIChiICogYikpO1xyXG4gICAgcl9zY2FsZVkgPSBNYXRoLnNxcnQoKGMgKiBjKSArIChkICogZCkpO1xyXG5cclxuICAgIHJfeCA9IHR4O1xyXG4gICAgcl95ID0gdHk7XHJcblxyXG4gICAgcmV0dXJuIFtyX3gsIHJfeSwgcl9yb3RhdGlvbiwgcl9zY2FsZVgsIHJfc2NhbGVZLCByX3NrZXdYLCByX3NrZXdZXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGUgY3VycmVudCBtYXRyaXggYW5kIHJldHVybnMgbmV3IGNsb25lZCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fSBOZXcgY2xvbmVkIG9iamVjdC5cclxuICAgKi9cclxuICBjbG9uZSgpIHtcclxuICAgIGxldCBtID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgbGV0IHYgPSB0aGlzLmRhdGE7XHJcbiAgICBtLnNldCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcclxuICAgIHJldHVybiBtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29waWVzIHZhbHVlcyB0byBnaXZlbiBtYXRyaXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+TWF0cml4fSBtYXRyaXggVGhlIGRlc3RpbmF0aW9uIG1hdHJpeC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fSBUaGlzLlxyXG4gICAqL1xyXG4gIGNvcHlUbyhtYXRyaXgpIHtcclxuICAgIGxldCBhID0gdGhpcy5kYXRhO1xyXG4gICAgbGV0IGIgPSBtYXRyaXguZGF0YTtcclxuXHJcbiAgICBiWzBdID0gYVswXTtcclxuICAgIGJbMV0gPSBhWzFdO1xyXG4gICAgYlsyXSA9IGFbMl07XHJcbiAgICBiWzNdID0gYVszXTtcclxuICAgIGJbNF0gPSBhWzRdO1xyXG4gICAgYls1XSA9IGFbNV07XHJcblxyXG4gICAgcmV0dXJuIG1hdHJpeDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcGllcyB2YWx1ZXMgZnJvbSBnaXZlbiBtYXRyaXggaW50byB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfk1hdHJpeH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29weSB2YWx1ZXMgZnJvbS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fSBUaGlzLlxyXG4gICAqL1xyXG4gIGNvcHlGcm9tKG1hdHJpeCkge1xyXG4gICAgcmV0dXJuIG1hdHJpeC5jb3B5VG8odGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wYXJlcyB0aGlzIG1hdHJpeCB2YWx1ZXMgd2l0aCBnaXZlbiBtYXRyaXggYW5kIGNoZWNrcyBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1hdHJpeH0gbWF0cml4IE1hdHJpeCBvYmplY3QgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGV4YWN0RXF1YWxzKG1hdHJpeCkge1xyXG4gICAgaWYgKCFtYXRyaXgpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBsZXQgYSA9IHRoaXMuZGF0YTtcclxuICAgIGxldCBiID0gbWF0cml4LmRhdGE7XHJcblxyXG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGFyZXMgdGhpcyBtYXRyaXggdmFsdWVzIHdpdGggZ2l2ZW4gbWF0cml4IGFuZCBjaGVja3MgaWYgdGhleSBhcmUgdGhlIHNhbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+TWF0cml4fSBtYXRyaXggICAgICAgICAgICAgICAgICAgTWF0cml4IG9iamVjdCB0byBjb21wYXJlIHdpdGguXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT04gQ29tcGFyaXNvbiB0aHJlc2hvbGQuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlcXVhbC5cclxuICAgKi9cclxuICBlcXVhbHMobWF0cml4LCBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT04pIHtcclxuICAgIGlmICghbWF0cml4KVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgbGV0IGEgPSB0aGlzLmRhdGE7XHJcbiAgICBsZXQgYiA9IG1hdHJpeC5kYXRhO1xyXG5cclxuICAgIHJldHVybiAoTWF0aC5hYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbikgJiYgKE1hdGguYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb24pICYmIChNYXRoLmFicyhhWzJdIC0gYlsyXSkgPCBlcHNpbG9uKSAmJlxyXG4gICAgICAoTWF0aC5hYnMoYVszXSAtIGJbM10pIDwgZXBzaWxvbikgJiYgKE1hdGguYWJzKGFbNF0gLSBiWzRdKSA8IGVwc2lsb24pICYmIChNYXRoLmFicyhhWzVdIC0gYls1XSkgPCBlcHNpbG9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHJlcHJlc2VudGluZyB0aGlzIG1hdHJpeCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9XHJcbiAgICovXHJcbiAgZ2V0IHZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICB9XHJcblxyXG4gIC8vIEBpZmRlZiBERUJVR1xyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBkaWdpdHMgPSAyXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKGRpZ2l0cyA9IDIpIHtcclxuICAgIHJldHVybiBgICAgICAgICB8ICR7dGhpcy52YWx1ZVswXS50b0ZpeGVkKGRpZ2l0cyl9IHwgJHt0aGlzLnZhbHVlWzFdLnRvRml4ZWQoZGlnaXRzKX0gfCAke3RoaXMudmFsdWVbNF0udG9GaXhlZChkaWdpdHMpfSB8XHJcbk1hdHJpeDogfCAke3RoaXMudmFsdWVbMl0udG9GaXhlZChkaWdpdHMpfSB8ICR7dGhpcy52YWx1ZVszXS50b0ZpeGVkKGRpZ2l0cyl9IHwgJHt0aGlzLnZhbHVlWzVdLnRvRml4ZWQoZGlnaXRzKX0gfGA7XHJcbiAgfVxyXG4gIC8vIEBlbmRpZlxyXG59XHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeH1cclxuICogQG5vY29sbGFwc2VcclxuICovXHJcbk1hdHJpeC5fX2NhY2hlID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5NYXRyaXguX19pZGVudGl0eSA9IG5ldyBNYXRyaXgoKTtcclxuXHJcbi8qKlxyXG4gKiBSZWN5Y2xlZCBtYXRyaWNlcyBwb29sLlxyXG4gKlxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfk9iamVjdFBvb2x9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5NYXRyaXgucG9vbCA9IG5ldyBPYmplY3RQb29sKE1hdHJpeCk7XHJcblxyXG4vKipcclxuICogTWF0aGVtYXRpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgY2lyY2xlLlxyXG4gKlxyXG4gKiBAY2F0IGdlb21cclxuICovXHJcbmNsYXNzIENpcmNsZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ2lyY2xlIGluc3RhbmNlLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSAge251bWJlcj19IFt4ID0gMF0gUG9zaXRpb24geC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbeSA9IDBdIFBvc2l0aW9uIHkuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW3IgPSAxXSBSYWRpdXMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCByID0gMSkge1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLnIgPSByO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBuZXcgY2lyY2xlIHByb3BlcnRpZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFBvc2l0aW9uIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgUG9zaXRpb24geS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gciBSYWRpdXMuXHJcbiAgICogQHJldHVybiB7Q2lyY2xlfSBUaGlzIGNpcmNsZS5cclxuICAgKi9cclxuICBzZXQoeCwgeSwgcikge1xyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLnIgPSByO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmVzIHRoaXMgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkNpcmNsZX0gQ3JlYXRlZCBjaXJjbGUuXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcHkgdGhpcyBwcm9wZXJ0aWVzIHRvIGFub3RoZXIgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlfSBjaXJjbGUgT2JqZWN0IHRvIGNvcHkgdG8uXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkNpcmNsZX0gUGFzc2VkIGNpcmNsZS5cclxuICAgKi9cclxuICBjb3B5VG8oY2lyY2xlKSB7XHJcbiAgICByZXR1cm4gY2lyY2xlLnNldCh0aGlzLngsIHRoaXMueSwgdGhpcy5yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvcHkgYW5vdGhlciBjaXJjbGUgcHJvcGVydGllcyB0byB0aGlzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlfSBjaXJjbGUgT2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Q2lyY2xlfSBUaGlzIGNpcmNsZS5cclxuICAgKi9cclxuICBjb3B5RnJvbShjaXJjbGUpIHtcclxuICAgIHJldHVybiB0aGlzLnNldChjaXJjbGUueCwgY2lyY2xlLnksIGNpcmNsZS5yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgY2lyY2xlcyBhcmUgaWRlbnRpY2FsLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlfSBjaXJjbGUgT2JqZWN0IHRvIGNvbXBhcmlzb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBlcHNpbG9uIENvbXBhcmUgcHJlY2lzaW9uLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2lyY2xlcyBhcmUgaWRlbnRpY2FsLlxyXG4gICAqL1xyXG4gIGVxdWFscyhjaXJjbGUsIGVwc2lsb24gPSBOdW1iZXIuRVBTSUxPTikge1xyXG4gICAgcmV0dXJuIGNpcmNsZSAhPT0gbnVsbCAmJiAoTWF0aC5hYnModGhpcy54IC0gY2lyY2xlLngpIDwgZXBzaWxvbikgJiYgKE1hdGguYWJzKHRoaXMueSAtIGNpcmNsZS55KSA8IGVwc2lsb24pICYmXHJcbiAgICAgIChNYXRoLmFicyh0aGlzLnIgLSBjaXJjbGUucikgPCBlcHNpbG9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgcG9pbnQgaXMgaW4gY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggUG9pbnQgcG9zaXRpb24geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSBQb2ludCBwb3NpdGlvbiB5LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2lyY2xlIGNvbnRhaW5zIHBvaW50LlxyXG4gICAqL1xyXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnMobmV3IFZlY3Rvcih4LCB5KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTaG93cyB3aGV0aGVyIHBvaW50IGlzIGluIGNpcmNsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yIFBvaW50IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2lyY2xlIGNvbnRhaW5zIHBvaW50LlxyXG4gICAqL1xyXG4gIGNvbnRhaW5zKHZlY3Rvcikge1xyXG4gICAgLy8gVE9ETzogcmVtb3ZlIG5ldyBWZWN0b3IgaW5pdFxyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpLnN1YnRyYWN0KHZlY3RvcikubGVuZ3RoKCkgPD0gdGhpcy5yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIGFsbCB2YWx1ZXMgdG8gemVyby5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5DaXJjbGV9IFJldHVybnMgdGhpcy5cclxuICAgKi9cclxuICB6ZXJvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvd3Mgd2hldGhlciB0aGlzIGNpcmNsZSBpbnRlcnNlY3RzIGFub3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5DaXJjbGV9IGNpcmNsZSBDaXJjbGUgdG8gY2hlY2suXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbnRlcnNlY3RzLlxyXG4gICAqL1xyXG4gIGludGVyc2VjdHMoY2lyY2xlKSB7XHJcbiAgICBsZXQgZCA9IG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpLmRpc3RhbmNlKG5ldyBWZWN0b3IoY2lyY2xlLngsIGNpcmNsZS55KSk7XHJcbiAgICByZXR1cm4gZCA8PSB0aGlzLnIgKyBjaXJjbGUuciAmJiBkID49IHRoaXMuciAtIGNpcmNsZS5yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvd3Mgd2hldGhlciB0aGlzIGNpcmNsZSBjb2xsaWRlIHdpdGggYW5vdGhlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNpcmNsZX0gY2lyY2xlIENpcmNsZSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNvbGxpZGUuXHJcbiAgICovXHJcbiAgY29sbGlkZShjaXJjbGUpIHtcclxuICAgIGxldCBkID0gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSkuZGlzdGFuY2UobmV3IFZlY3RvcihjaXJjbGUueCwgY2lyY2xlLnkpKTtcclxuICAgIHJldHVybiBkIDw9IHRoaXMuciArIGNpcmNsZS5yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hvd3Mgd2hldGhlciB0aGlzIGNpcmNsZSBvdmVybGFwIGFub3RoZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5DaXJjbGV9IGNpcmNsZSBDaXJjbGUgdG8gY2hlY2suXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvdmVybGFwLlxyXG4gICAqL1xyXG4gIG92ZXJsYXAoY2lyY2xlKSB7XHJcbiAgICBpZiAodGhpcy5yIDwgY2lyY2xlLnIpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkID0gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSkuZGlzdGFuY2UobmV3IFZlY3RvcihjaXJjbGUueCwgY2lyY2xlLnkpKTtcclxuICAgIHJldHVybiBkIDw9IHRoaXMuciAtIGNpcmNsZS5yO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcHJlc2VudHMgY2VudGVyIGFzIHZlY3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFZlY3RvciBPYmplY3QgZm9yIHJlc3VsdC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBDZW50ZXIgcG9pbnQuXHJcbiAgICovXHJcbiAgY2VudGVyKG91dFZlY3RvciA9IHVuZGVmaW5lZCkge1xyXG4gICAgb3V0VmVjdG9yID0gb3V0VmVjdG9yIHx8IG5ldyBWZWN0b3IoKTtcclxuICAgIHJldHVybiBvdXRWZWN0b3Iuc2V0KHRoaXMueCwgdGhpcy55KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRDaXJjdW1mZXJlbmNlUG9pbnQoeCwgeSwgciwgYW5nbGUsIG91dFZlY3RvciA9IHVuZGVmaW5lZCkge1xyXG4gICAgb3V0VmVjdG9yID0gb3V0VmVjdG9yIHx8IG5ldyBWZWN0b3IoKTtcclxuICAgIG91dFZlY3Rvci5zZXQoeCArIHIgKiBNYXRoLnNpbihhbmdsZSksIHkgKyByICogLU1hdGguY29zKGFuZ2xlKSk7XHJcbiAgICByZXR1cm4gb3V0VmVjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhcmVhIG9mIHRoaXMgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBhcmVhLlxyXG4gICAqL1xyXG4gIGdldCB2b2x1bWUoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5QSSAqIHRoaXMuciAqIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcGVyaW1ldGVyIG9mIHRoaXMgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBwZXJpbWV0ZXIuXHJcbiAgICovXHJcbiAgZ2V0IHBlcmltZXRlcigpIHtcclxuICAgIHJldHVybiAyICogTWF0aC5QSSAqIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIGxlZnQgWCBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVmdCBYIHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGdldCBsZWZ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMueCAtIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHJpZ2h0IFggcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJpZ2h0IFggcG9zaXRpb24uXHJcbiAgICovXHJcbiAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMueCArIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIHRvcCBZIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUb3AgWSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXQgdG9wKCkge1xyXG4gICAgcmV0dXJuIHRoaXMueSAtIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIGJvdHRvbSBZIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBCb3R0b20gWSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXQgYm90dG9tKCkge1xyXG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMucjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdG9wIHBvaW50IG9mIHRoaXMgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnZXQgdG9wUG9pbnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMudG9wKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYm90dG9tIHBvaW50IG9mIHRoaXMgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnZXQgYm90dG9tUG9pbnQoKSB7XHJcbiAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMuYm90dG9tKTtcclxuICB9XHJcblxyXG4gIC8vIEBpZmRlZiBERUJVR1xyXG4gIC8qKlxyXG4gICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNpcmNsZS5cclxuICAgKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkaWdpdHM9Ml0gTnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmbG9hdCBwb2ludC5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY2lyY2xlLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKGRpZ2l0cyA9IDIpIHtcclxuICAgIHJldHVybiBgQ2lyY2xlIHsgeDogJHt0aGlzLngudG9GaXhlZChkaWdpdHMpfSwgeTogJHt0aGlzLnkudG9GaXhlZChkaWdpdHMpfSwgcjogJHt0aGlzLnIudG9GaXhlZChkaWdpdHMpfSB9YDtcclxuICB9XHJcbiAgLy8gQGVuZGlmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEB0eXBlIHtibGFjay1lbmdpbmV+Q2lyY2xlfVxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuQ2lyY2xlLl9fY2FjaGUgPSBuZXcgQ2lyY2xlKCk7XHJcblxyXG4vKipcclxuICogQGNhdCBnZW9tXHJcbiAqL1xyXG5jbGFzcyBQb2x5Z29uIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBQb2x5Z29uIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7QXJyYXk8YmxhY2stZW5naW5lflZlY3Rvcj59IHZlcnRpY2VzID0gW10gQXJyYXkgb2YgdmVydGV4IHBvaW50cztcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcyA9IFtdKSB7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8YmxhY2stZW5naW5lflZlY3Rvcj59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1WZXJ0aWNlcyA9IHZlcnRpY2VzO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5MaW5lPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxpbmVzID0gW107XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2VudGVyID0gbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAyKVxyXG4gICAgICB0aGlzLnJlZnJlc2goKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IHZlcnRpY2VzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheTxibGFjay1lbmdpbmV+VmVjdG9yPn0gdmVydGljZXMgTmV3IHBvaW50cy5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UG9seWdvbn0gVGhpcyBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIHNldCh2ZXJ0aWNlcykge1xyXG4gICAgdGhpcy5tVmVydGljZXMgPSB2ZXJ0aWNlcztcclxuICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgdGhpcyBwcm9wZXJ0aWVzIHRvIGFub3RoZXIgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflBvbHlnb259IHBvbHlnb24gT2JqZWN0IHRvIGNvcHkgdG8uXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflBvbHlnb259IFBhc3NlZCBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIGNvcHlUbyhwb2x5Z29uKSB7XHJcbiAgICBsZXQgbGVuID0gdGhpcy5tVmVydGljZXMubGVuZ3RoO1xyXG4gICAgbGV0IHZlcnRpY2VzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKHRoaXMubVZlcnRpY2VzW2ldLmNsb25lKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2x5Z29uLnNldCh2ZXJ0aWNlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb3BpZXMgYW5vdGhlciBwb2x5Z29uIHByb3BlcnRpZXMgdG8gdGhpcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflBvbHlnb259IHBvbHlnb24gT2JqZWN0IHRvIGNvcHkgZnJvbS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UG9seWdvbn0gVGhpcyBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIGNvcHlGcm9tKHBvbHlnb24pIHtcclxuICAgIGxldCBwb2x5Z29uVmVydGljZXMgPSBwb2x5Z29uLm1WZXJ0aWNlcztcclxuICAgIGxldCBsZW4gPSBwb2x5Z29uVmVydGljZXMubGVuZ3RoO1xyXG4gICAgbGV0IHZlcnRpY2VzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKHBvbHlnb25WZXJ0aWNlc1tpXS5jbG9uZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zZXQodmVydGljZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvbmVzIHRoaXMgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Qb2x5Z29ufSBDcmVhdGVkIHBvbHlnb24uXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICBsZXQgdGhpc1ZlcnRpY2VzID0gdGhpcy5tVmVydGljZXM7XHJcbiAgICBsZXQgbGVuID0gdGhpc1ZlcnRpY2VzLmxlbmd0aDtcclxuICAgIGxldCB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgdmVydGljZXMucHVzaCh0aGlzVmVydGljZXNbaV0uY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHZlcnRpY2VzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoaXMgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUJvdW5kcy53aWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGlzIHBvbHlnb24uXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBoZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQm91bmRzLmhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgcG9pbnQgaXMgd2l0aGluIHBvbHlnb24gYXJlYS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFBvaW50IHBvc2l0aW9uIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgUG9pbnQgcG9zaXRpb24geS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBvbHlnb24gY29udGFpbnMgcG9pbnQuXHJcbiAgICovXHJcbiAgY29udGFpbnNYWSh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWlucyhuZXcgVmVjdG9yKHgsIHkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3dzIHdoZXRoZXIgcG9pbnQgaXMgd2l0aGluIHBvbHlnb24gYXJlYS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmVjdG9yIFBvaW50IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9seWdvbiBjb250YWlucyBwb2ludC5cclxuICAgKi9cclxuICBjb250YWlucyh2ZWN0b3IpIHtcclxuICAgIGxldCBjZW50ZXIgPSB0aGlzLm1DZW50ZXI7XHJcbiAgICBsZXQgbGluZXMgPSB0aGlzLm1MaW5lcztcclxuICAgIGxldCBsZW4gPSBsaW5lcy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGNlbnRlci5lcXVhbHModmVjdG9yKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaW50ZXJzZWN0aW9uTGluZSA9IG5ldyBMaW5lKHZlY3RvciwgY2VudGVyLmNsb25lKCkpO1xyXG4gICAgbGV0IGludGVyc2VjdHMgPSAwO1xyXG4gICAgaW50ZXJzZWN0aW9uTGluZS5zY2FsZSgodGhpcy53aWR0aCArIHRoaXMuaGVpZ2h0KSAvIGludGVyc2VjdGlvbkxpbmUubGVuZ3RoKCkpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaW50ZXJzZWN0cyArPSBsaW5lc1tpXS5pbnRlcnNlY3RzKGludGVyc2VjdGlvbkxpbmUpID8gMSA6IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGludGVyc2VjdHMgJSAyICE9PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGVyaW1ldGVyIG9mIHRoaXMgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gcGVyaW1ldGVyLlxyXG4gICAqL1xyXG4gIGdldCBwZXJpbWV0ZXIoKSB7XHJcbiAgICBsZXQgdGhpc0xpbmVzID0gdGhpcy5tTGluZXM7XHJcbiAgICBsZXQgbGVuID0gdGhpc0xpbmVzLmxlbmd0aDtcclxuICAgIGxldCBwZXJpbWV0ZXIgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgcGVyaW1ldGVyICs9IHRoaXNMaW5lc1tpXS5sZW5ndGgoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGVyaW1ldGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGNvbGxpc2lvbiBiZXR3ZWVuIHR3byBwb2x5Z29ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflBvbHlnb259IHBvbHlnb24gT2JqZWN0IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9seWdvbiBjb2xsaWRlcyB3aXRoIGFub3RoZXIgcG9seWdvbi5cclxuICAgKi9cclxuICBjb2xsaWRlKHBvbHlnb24pIHtcclxuICAgIGlmICghdGhpcy5tQm91bmRzLmludGVyc2VjdHMocG9seWdvbi5tQm91bmRzKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRoaXNMaW5lcyA9IHRoaXMubUxpbmVzO1xyXG4gICAgbGV0IHRoaXNMZW4gPSB0aGlzTGluZXMubGVuZ3RoO1xyXG4gICAgbGV0IHBvbHlnb25MaW5lcyA9IHBvbHlnb24ubUxpbmVzO1xyXG4gICAgbGV0IHBvbHlnb25MZW4gPSBwb2x5Z29uTGluZXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpc0xlbjsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9seWdvbkxlbjsgaisrKSB7XHJcbiAgICAgICAgaWYgKHRoaXNMaW5lc1tpXS5pbnRlcnNlY3RzKHBvbHlnb25MaW5lc1tqXSkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBjb2xsaXNpb24gYmV0d2VlbiB0aGlzIHBvbHlnb24gYW5kIGNpcmNsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNpcmNsZX0gY2lyY2xlIE9iamVjdCB0byBjaGVjay5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBvbHlnb24gY29sbGlkZXMgd2l0aCBjaXJjbGUuXHJcbiAgICovXHJcbiAgY29sbGlkZUNpcmNsZShjaXJjbGUpIHtcclxuICAgIGxldCBib3VuZHMgPSB0aGlzLm1Cb3VuZHM7XHJcbiAgICBsZXQgbGluZXMgPSB0aGlzLm1MaW5lcztcclxuXHJcbiAgICBpZiAoYm91bmRzLmxlZnQgPiBjaXJjbGUucmlnaHQgfHwgYm91bmRzLnJpZ2h0IDwgY2lyY2xlLmxlZnQgfHwgYm91bmRzLnRvcCA+IGNpcmNsZS5ib3R0b20gfHwgYm91bmRzLmJvdHRvbSA8IGNpcmNsZS50b3ApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBsZW4gPSBsaW5lcy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChsaW5lc1tpXS5pbnRlcnNlY3RzQ2lyY2xlKGNpcmNsZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBjb2xsaXNpb24gYmV0d2VlbiB0aGlzIHBvbHlnb24gYW5kIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gcmVjdGFuZ2xlIE9iamVjdCB0byBjaGVjay5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBvbHlnb24gY29sbGlkZXMgd2l0aCByZWN0YW5nbGUuXHJcbiAgICovXHJcbiAgY29sbGlkZVJlY3RhbmdsZShyZWN0YW5nbGUpIHtcclxuICAgIGlmICghdGhpcy5tQm91bmRzLmludGVyc2VjdHMocmVjdGFuZ2xlKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRoaXNMaW5lcyA9IHRoaXMubUxpbmVzO1xyXG4gICAgbGV0IHRoaXNMZW4gPSB0aGlzTGluZXMubGVuZ3RoO1xyXG4gICAgbGV0IHJlY3RhbmdsZUxpbmVzID0gcmVjdGFuZ2xlLmxpbmVzO1xyXG4gICAgbGV0IHJlY3RhbmdsZUxlbiA9IHJlY3RhbmdsZUxpbmVzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNMZW47IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlY3RhbmdsZUxlbjsgaisrKSB7XHJcbiAgICAgICAgaWYgKHRoaXNMaW5lc1tpXS5pbnRlcnNlY3RzKHJlY3RhbmdsZUxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgcG9seWdvbiBvdmVybGFwcyBhbm90aGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UG9seWdvbn0gcG9seWdvbiBPYmplY3QgdG8gY2hlY2suXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwb2x5Z29uIG92ZXJsYXBzIHNlY29uZC5cclxuICAgKi9cclxuICBvdmVybGFwKHBvbHlnb24pIHtcclxuICAgIGlmICh0aGlzLm1Cb3VuZHMud2lkdGggPCBwb2x5Z29uLm1Cb3VuZHMud2lkdGggfHwgdGhpcy5tQm91bmRzLmhlaWdodCA8IHBvbHlnb24ubUJvdW5kcy5oZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5jb250YWlucyhwb2x5Z29uLm1DZW50ZXIpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdGhpc0xpbmVzID0gdGhpcy5tTGluZXM7XHJcbiAgICBsZXQgdGhpc0xlbiA9IHRoaXNMaW5lcy5sZW5ndGg7XHJcbiAgICBsZXQgcG9seWdvbkxpbmVzID0gcG9seWdvbi5tTGluZXM7XHJcbiAgICBsZXQgcG9seWdvbkxlbiA9IHBvbHlnb25MaW5lcy5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzTGVuOyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2x5Z29uTGVuOyBqKyspIHtcclxuICAgICAgICBpZiAodGhpc0xpbmVzW2ldLmludGVyc2VjdHMocG9seWdvbkxpbmVzW2pdKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoaXMgcG9seWdvbiBvdmVybGFwcyBwYXNzZWQgY2lyY2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlfSBjaXJjbGUgT2JqZWN0IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9seWdvbiBvdmVybGFwcyBjaXJjbGUuXHJcbiAgICovXHJcbiAgb3ZlcmxhcENpcmNsZShjaXJjbGUpIHtcclxuICAgIGlmICghdGhpcy5jb250YWluc1hZKGNpcmNsZS54LCBjaXJjbGUueSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB0aGlzTGluZXMgPSB0aGlzLm1MaW5lcztcclxuICAgIGxldCBsZW4gPSB0aGlzTGluZXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKHRoaXNMaW5lc1tpXS5pbnRlcnNlY3RzQ2lyY2xlKGNpcmNsZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiB0aGlzIHBvbHlnb24gb3ZlcmxhcHMgZ2l2ZW4gcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSByZWN0YW5nbGUgT2JqZWN0IHRvIGNoZWNrLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcG9seWdvbiBvdmVybGFwcyByZWN0YW5nbGUuXHJcbiAgICovXHJcbiAgb3ZlcmxhcFJlY3RhbmdsZShyZWN0YW5nbGUpIHtcclxuICAgIGlmICghdGhpcy5jb250YWlucyhyZWN0YW5nbGUuY2VudGVyKCkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdGhpc0xpbmVzID0gdGhpcy5tTGluZXM7XHJcbiAgICBsZXQgdGhpc0xlbiA9IHRoaXNMaW5lcy5sZW5ndGg7XHJcbiAgICBsZXQgcmVjdGFuZ2xlTGluZXMgPSByZWN0YW5nbGUubGluZXM7XHJcbiAgICBsZXQgcmVjdGFuZ2xlTGVuID0gcmVjdGFuZ2xlTGluZXMubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpc0xlbjsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdGFuZ2xlTGVuOyBqKyspIHtcclxuICAgICAgICBpZiAodGhpc0xpbmVzW2ldLmludGVyc2VjdHMocmVjdGFuZ2xlTGluZXNbal0pKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIGNlbnRlciwgYm91bmRzLCBhbmQgZWRnZXMgb2YgdGhpcyBwb2x5Z29uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflBvbHlnb259IFRoaXMgcG9seWdvbi5cclxuICAgKi9cclxuICByZWZyZXNoKCkge1xyXG4gICAgbGV0IGNlbnRlciA9IHRoaXMubUNlbnRlcjtcclxuICAgIGxldCBib3VuZHMgPSB0aGlzLm1Cb3VuZHM7XHJcbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAgIGxldCBsaW5lcyA9IHRoaXMubUxpbmVzID0gW107XHJcbiAgICBjZW50ZXIuc2V0KDAsIDApO1xyXG5cclxuICAgIC8vIGJvdW5kc1xyXG4gICAgbGV0IG1heFggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBtYXhZID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWluWCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWluWSA9IE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgdmVjdG9yID0gdmVydGljZXNbaV07XHJcbiAgICAgIGNlbnRlci5hZGQodmVjdG9yKTtcclxuXHJcbiAgICAgIC8vIGJvdW5kc1xyXG4gICAgICBsZXQge1xyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeVxyXG4gICAgICB9ID0gdmVjdG9yO1xyXG4gICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuXHJcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUodmVjdG9yLCB2ZXJ0aWNlc1tpICsgMV0gfHwgdmVydGljZXNbMF0pKTtcclxuICAgIH1cclxuXHJcbiAgICBjZW50ZXIubXVsdGlwbHlTY2FsYXIoMSAvIHZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICBib3VuZHMuc2V0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIGNlbnRlciBvZiB0aGlzIHBvbHlnb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UG9seWdvbn0gVGhpcyBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIHJlZnJlc2hDZW50ZXIoKSB7XHJcbiAgICBsZXQgY2VudGVyID0gdGhpcy5tQ2VudGVyO1xyXG4gICAgbGV0IHZlcnRpY2VzID0gdGhpcy5tVmVydGljZXM7XHJcbiAgICBsZXQgbGVuID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgY2VudGVyLnNldCgwLCAwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGNlbnRlci5hZGQodmVydGljZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNlbnRlci5tdWx0aXBseVNjYWxhcigxIC8gdmVydGljZXMubGVuZ3RoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgYm91bmRzIG9mIHRoaXMgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Qb2x5Z29ufSBUaGlzIHBvbHlnb24uXHJcbiAgICovXHJcbiAgcmVmcmVzaEJvdW5kcygpIHtcclxuICAgIGxldCBib3VuZHMgPSB0aGlzLm1Cb3VuZHM7XHJcbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAgIGxldCBtYXhYID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1pblggPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1pblkgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IGxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuICAgIGxldCB4O1xyXG4gICAgbGV0IHk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICB4ID0gdmVydGljZXNbaV0ueDtcclxuICAgICAgeSA9IHZlcnRpY2VzW2ldLnk7XHJcbiAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgfVxyXG5cclxuICAgIGJvdW5kcy5zZXQobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgZWRnZXMgb2YgdGhpcyBwb2x5Z29uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflBvbHlnb259IFRoaXMgcG9seWdvbi5cclxuICAgKi9cclxuICByZWZyZXNoTGluZXMoKSB7XHJcbiAgICBsZXQgdmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAgIGxldCBsaW5lcyA9IHRoaXMubUxpbmVzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0gfHwgdmVydGljZXNbMF0pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgUG9seWdvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE51bWJlcnMgeCB5IGRpdmlkZWQgd2l0aCBzcGFjZS5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UG9seWdvbn0gQ3JlYXRlZCBwb2x5Z29uLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tUGF0aChwYXRoKSB7XHJcbiAgICBsZXQgdmVydGljZXMgPSBbXTtcclxuICAgIGxldCBwYXRoMiA9IHBhdGguc3BsaXQoJyAnKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgyLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgIHZlcnRpY2VzLnB1c2gobmV3IFZlY3RvcihOdW1iZXIocGF0aDJbaV0pLCBOdW1iZXIocGF0aDJbaSArIDFdKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgUG9seWdvbih2ZXJ0aWNlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHJvdGF0aW9uLiBSb3RhdGVzIHRoaXMgcG9seWdvbiBhcm91bmQgaXQgY2VudGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIEFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflBvbHlnb259IFRoaXMgcG9seWdvbi5cclxuICAgKi9cclxuICBzZXRSb3RhdGlvbihyb3RhdGlvbikge1xyXG4gICAgbGV0IGNlbnRlciA9IHRoaXMubUNlbnRlcjtcclxuICAgIGxldCB2ZXJ0aWNlcyA9IHRoaXMubVZlcnRpY2VzO1xyXG4gICAgbGV0IGNvcyA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgIGxldCBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbik7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGxldCB2ZWN0b3IgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgdmVjdG9yXHJcbiAgICAgICAgLnN1YnRyYWN0KGNlbnRlcilcclxuICAgICAgICAuc2V0KHZlY3Rvci54ICogY29zIC0gdmVjdG9yLnkgKiBzaW4sIHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3MpXHJcbiAgICAgICAgLmFkZChjZW50ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnJlZnJlc2goKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zbGF0ZXMgdGhpcyBwb2x5Z29uIHRvIHNwZWNpZmllZCBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9pbnQgVHJhbnNsYXRpb24gdmVjdG9yLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Qb2x5Z29ufSBUaGlzIHZlcnRpY2VzLlxyXG4gICAqL1xyXG4gIHNldFRyYW5zbGF0aW9uKHBvaW50KSB7XHJcbiAgICBsZXQgY2VudGVyID0gdGhpcy5tQ2VudGVyO1xyXG4gICAgbGV0IHZlcnRpY2VzID0gdGhpcy5tVmVydGljZXM7XHJcbiAgICBsZXQgbGVuID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHZlcnRpY2VzW2ldLmFkZChwb2ludCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhcnJheSBvZiB2ZXJ0aWNlcy5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7QXJyYXk8YmxhY2stZW5naW5lflZlY3Rvcj59XHJcbiAgICovXHJcbiAgZ2V0IHZlcnRpY2VzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVZlcnRpY2VzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjZW50ZXIgcG9pbnRzIG9mIHRoaXMgcG9seWdvbi5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnZXQgY2VudGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNlbnRlcjsgIFxyXG4gIH1cclxuXHJcbiAgLy8gQGlmZGVmIERFQlVHXHJcbiAgLyoqXHJcbiAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9seWdvbi5cclxuICAgKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkaWdpdHM9Ml0gTnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmbG9hdCBwb2ludC5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IERlc2NyaXB0aW9uLlxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKGRpZ2l0cyA9IDIpIHtcclxuICAgIGxldCB0aGlzTGluZXMgPSB0aGlzLm1MaW5lcztcclxuICAgIGxldCB0aGlzVmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAgIGxldCBsZW4gPSB0aGlzTGluZXMubGVuZ3RoO1xyXG4gICAgbGV0IHZlcnRpY2VzID0gJyc7XHJcbiAgICBsZXQgbGluZXMgPSAnJztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGxpbmVzICs9IHRoaXNMaW5lc1tpXS50b1N0cmluZyhkaWdpdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGxlbiA9IHRoaXNWZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIHZlcnRpY2VzICs9IHRoaXNWZXJ0aWNlc1tpXS50b1N0cmluZyhkaWdpdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBgUG9seWdvbiB7IHZlcnRpY2VzOiAke3ZlcnRpY2VzfSwgYm91bmRzOiAke3RoaXMubUJvdW5kcy50b1N0cmluZyhkaWdpdHMpfSwgY2VudGVyOiAke3RoaXMubUNlbnRlci50b1N0cmluZygpfSwgbGluZXM6ICR7bGluZXN9IH1gO1xyXG4gIH1cclxuXHJcbiAgLy8gQGVuZGlmXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEB0eXBlIHtibGFjay1lbmdpbmV+UG9seWdvbn1cclxuICogQG5vY29sbGFwc2VcclxuICovXHJcblBvbHlnb24uX19jYWNoZSA9IG5ldyBQb2x5Z29uKCk7XHJcblxyXG4vKipcclxuICogTWF0aGVtYXRpY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgYmV6aWVyIGN1cnZlLlxyXG4gKlxyXG4gKiBAY2F0IGdlb21cclxuICovXHJcbmNsYXNzIEN1cnZlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBDdXJ2ZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Qb2ludHMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+VmVjdG9yPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvb2t1cCA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJha2VkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RlcCA9IDEgLyA2MDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRWFjaFQgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IHBvaW50cyBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgey4uLm51bWJlcn0gcG9pbnRzIENvb3JkaW5hdGVzOiBzdGFydFgsIHN0YXJ0WSwgY3BTdGFydFgsIGNwU3RhcnRZLCBjcEVuZFgsIGNwRW5kWSwgZW5kWC9zdGFydDJYLCBlbmRZL3N0YXJ0MlksIGNwMlN0YXJ0WCwgY3AyU3RhcnRYLi4uIDggb3IgMTQgb3IgMjAuLi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Q3VydmV9IFRoaXMgY3VydmUuXHJcbiAgICovXHJcbiAgc2V0KC4uLnBvaW50cykge1xyXG4gICAgdGhpcy5tUG9pbnRzID0gdGhpcy5fX2luaXRQb2ludHMocG9pbnRzKTtcclxuICAgIHRoaXMuX19yZWZyZXNoRWFjaFQoKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQmFrZWQpXHJcbiAgICAgIHRoaXMuX19yZWZyZXNoQ2FjaGUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGludGVycG9sYXRpb24gZnJvbSBjYWNoZSAobG9va3VwKS5cclxuICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgZGVwZW5kaW5nIG9uIGJha2VkIGlzIGVuYWJsZWQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgYmFrZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQmFrZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBsYWJlbFxyXG4gICAqL1xyXG4gIHNldCBiYWtlZChsYWJlbCkge1xyXG4gICAgdGhpcy5tQmFrZWQgPSBsYWJlbDtcclxuXHJcbiAgICBpZiAoIXRoaXMubUxvb2t1cCAmJiB0aGlzLm1Qb2ludHMpIHtcclxuICAgICAgdGhpcy5fX3JlZnJlc2hDYWNoZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2lkZXMgcG9pbnRzIGFycmF5LiBTZXRzIGZpcnN0IHBvaW50IGZvciBuZXh0IGJlemllciBzYW1lIGFzIGxhc3Qgb2YgcHJldmlvdXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSAge0FycmF5PG51bWJlcj59IHBvaW50cyBBcnJheSBvZiBwb2ludHMgY29vcmRpbmF0ZXMuXHJcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUG9pbnRzIGNvb3JkaW5hdGVzIGFycmF5LlxyXG4gICAqL1xyXG4gIF9faW5pdFBvaW50cyhwb2ludHMpIHtcclxuICAgIGxldCByZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gNjsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gNikge1xyXG4gICAgICByZXMgPSByZXMuY29uY2F0KHBvaW50cy5zbGljZShpIC0gNiwgaSArIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVmcmVzaCBjYWNoZSAobG9va3VwKSBmb3IgZmFzdCBpbnRlcnBvbGF0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkN1cnZlfSBUaGlzIGN1cnZlLlxyXG4gICAqL1xyXG4gIF9fcmVmcmVzaENhY2hlKCkge1xyXG4gICAgbGV0IGxvb2t1cCA9IHRoaXMubUxvb2t1cCA9IFtdO1xyXG4gICAgbGV0IGdldEZ1bGxMZW5ndGggPSB0aGlzLmdldEZ1bGxMZW5ndGgoKTtcclxuICAgIGxldCBwb2ludHMgPSB0aGlzLm1Qb2ludHM7XHJcbiAgICBsZXQgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSArPSA4KSB7XHJcbiAgICAgIGxldCBsZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgoLi4ucG9pbnRzLnNsaWNlKGksIGkgKyA4KSk7XHJcbiAgICAgIGxldCBzdGVwID0gdGhpcy5tU3RlcCAqIGdldEZ1bGxMZW5ndGggLyBsZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKGxldCB0ID0gc3RlcDsgdCA8IDE7IHQgKz0gc3RlcClcclxuICAgICAgICBsb29rdXAucHVzaChDdXJ2ZS5sZXJwKHQsIC4uLnBvaW50cy5zbGljZShpLCBpICsgOCkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoIGxvY2FsIGludGVycG9sYXRpb24ga29mIGZvciBlYWNoIGJlemllciBpbiBjdXJ2ZS5cclxuICAgKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5DdXJ2ZX0gVGhpcyBjdXJ2ZS5cclxuICAgKi9cclxuICBfX3JlZnJlc2hFYWNoVCgpIHtcclxuICAgIGxldCBwb2ludHMgPSB0aGlzLm1Qb2ludHM7XHJcbiAgICBsZXQgZWFjaFQgPSB0aGlzLm1FYWNoVCA9IFtdO1xyXG4gICAgbGV0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICBsZXQgZWFjaExlbmd0aCA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpICs9IDgpXHJcbiAgICAgIGVhY2hMZW5ndGgucHVzaChDdXJ2ZS5nZXRMZW5ndGgoLi4ucG9pbnRzLnNsaWNlKGksIGkgKyA4KSkpO1xyXG5cclxuICAgIGxldCBsZW5ndGggPSB0aGlzLmdldEZ1bGxMZW5ndGgoKTtcclxuICAgIGxldCBzID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpICs9IDgpIHtcclxuICAgICAgcyArPSBlYWNoTGVuZ3RoW2kgLyA4XTtcclxuICAgICAgZWFjaFQucHVzaChzIC8gbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycG9sYXRlcyBzaW5nbGUgYmV6aWVyIG9uIHQgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBwb3NpdGlvbiAoMC4uLjEpLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gc3RhcnRYXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdGFydFlcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNwU3RhcnRYXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjcFN0YXJ0WVxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gY3BFbmRYXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjcEVuZFlcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVuZFhcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVuZFlcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+VmVjdG9yPX0gb3V0VmVjdG9yXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gUG9zaXRpb24gb24gYmV6aWVyLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBsZXJwKHQsIHN0YXJ0WCwgc3RhcnRZLCBjcFN0YXJ0WCwgY3BTdGFydFksIGNwRW5kWCwgY3BFbmRZLCBlbmRYLCBlbmRZLCBvdXRWZWN0b3IpIHtcclxuICAgIGxldCB1ID0gMSAtIHQ7XHJcbiAgICBsZXQgdHQgPSB0ICogdDtcclxuICAgIGxldCB1dSA9IHUgKiB1O1xyXG4gICAgbGV0IHV1dSA9IHV1ICogdTtcclxuICAgIGxldCB0dHQgPSB0dCAqIHQ7XHJcblxyXG4gICAgbGV0IHAgPSBvdXRWZWN0b3IgfHwgbmV3IFZlY3RvcigpO1xyXG4gICAgcC5zZXQoc3RhcnRYLCBzdGFydFkpO1xyXG4gICAgcC54ICo9IHV1dTtcclxuICAgIHAueSAqPSB1dXU7XHJcblxyXG4gICAgLy8gZmlyc3RcclxuICAgIHAueCArPSAzICogdXUgKiB0ICogY3BTdGFydFg7XHJcbiAgICBwLnkgKz0gMyAqIHV1ICogdCAqIGNwU3RhcnRZO1xyXG5cclxuICAgIC8vIHNlY29uZFxyXG4gICAgcC54ICs9IDMgKiB1ICogdHQgKiBjcEVuZFg7XHJcbiAgICBwLnkgKz0gMyAqIHUgKiB0dCAqIGNwRW5kWTtcclxuXHJcbiAgICAvLyB0aGlyZFxyXG4gICAgcC54ICs9IHR0dCAqIGVuZFg7XHJcbiAgICBwLnkgKz0gdHR0ICogZW5kWTtcclxuXHJcbiAgICByZXR1cm4gcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycG9sYXRlcyBhY3Jvc3Mgd2hvbGUgY3VydmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBwb3NpdGlvbiAoMC4uLjEpLlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5WZWN0b3I9fSBvdXRWZWN0b3IgVmVjdG9yIHRvIGJlIHJldHVybmVkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFBvc2l0aW9uIG9uIGN1cnZlLlxyXG4gICAqL1xyXG4gIGludGVycG9sYXRlKHQsIG91dFZlY3Rvcikge1xyXG4gICAgbGV0IHJlcyA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcbiAgICBsZXQgbG9va3VwID0gdGhpcy5tTG9va3VwO1xyXG5cclxuICAgIGlmICh0aGlzLm1CYWtlZCkge1xyXG4gICAgICBsZXQgaSA9IE1hdGguY2VpbCgobG9va3VwLmxlbmd0aCAtIDEpICogdCk7XHJcbiAgICAgIGxldCBwID0gbG9va3VwW2ldO1xyXG4gICAgICByZXMuY29weUZyb20ocCk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG5vdCBiYWNrZWRcclxuICAgIGxldCB7IG1FYWNoVCwgbVBvaW50cyB9ID0gdGhpcztcclxuICAgIGxldCBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAobUVhY2hUW2ldIDwgdClcclxuICAgICAgaSsrO1xyXG5cclxuICAgIGxldCBtaW5UID0gbUVhY2hUW2kgLSAxXSB8fCAwO1xyXG4gICAgbGV0IG1heFQgPSBtRWFjaFRbaV07XHJcbiAgICBsZXQgYmV6aWVyID0gbVBvaW50cy5zbGljZShpICogOCwgaSAqIDggKyA4KTtcclxuXHJcbiAgICByZXR1cm4gQ3VydmUubGVycCgodCAtIG1pblQpIC8gKG1heFQgLSBtaW5UKSwgLi4uYmV6aWVyLCByZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBzaW5nbGUgYmV6aWVyIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgey4uLm51bWJlcn0gcG9pbnRzIENvb3JkaW5hdGVzOiBzdGFydFgsIHN0YXJ0WSwgY3BTdGFydFgsIGNwU3RhcnRZLCBjcEVuZFgsIGNwRW5kWSwgZW5kWCwgZW5kWVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRMZW5ndGgoLi4ucG9pbnRzKSB7XHJcbiAgICBsZXQgcDAgPSBuZXcgVmVjdG9yKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgIGxldCBwMSA9IG5ldyBWZWN0b3IocG9pbnRzWzJdLCBwb2ludHNbM10pO1xyXG4gICAgbGV0IHAyID0gbmV3IFZlY3Rvcihwb2ludHNbNF0sIHBvaW50c1s1XSk7XHJcbiAgICBsZXQgcDMgPSBuZXcgVmVjdG9yKHBvaW50c1s2XSwgcG9pbnRzWzddKTtcclxuXHJcbiAgICByZXR1cm4gKHAzLmRpc3RhbmNlKHAwKSArIHAwLmRpc3RhbmNlKHAxKSArIHAxLmRpc3RhbmNlKHAyKSArIHAyLmRpc3RhbmNlKHAzKSkgLyAyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGlzIGN1cnZlIGxlbmd0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoLlxyXG4gICAqL1xyXG4gIGdldEZ1bGxMZW5ndGgoKSB7XHJcbiAgICBsZXQgcG9pbnRzID0gdGhpcy5tUG9pbnRzO1xyXG4gICAgbGV0IG1Qb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgbGV0IHJlcyA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtUG9pbnRzTGVuOyBpICs9IDgpXHJcbiAgICAgIHJlcyArPSBDdXJ2ZS5nZXRMZW5ndGgoLi4ucG9pbnRzLnNsaWNlKGksIGkgKyA4KSk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEB0eXBlIHtibGFjay1lbmdpbmV+Q3VydmV9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5DdXJ2ZS5fX2NhY2hlID0gbmV3IEN1cnZlKCk7XHJcblxyXG4vKipcclxuICogVGhlIHR5cGUgb2YgdGhlIG1lc3NhZ2UuIFxyXG4gKiBAY2F0IGNvcmVcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IE1lc3NhZ2VUeXBlID0ge1xyXG4gIERJUkVDVDogJ2RpcmVjdCcsXHJcbiAgQlVCQkxFOiAnYnViYmxlJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHRoZSBiaW5kaW5nLiBcclxuICogQGNhdCBjb3JlXHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBCaW5kaW5nVHlwZSA9IHtcclxuICBSRUdVTEFSOiAncmVndWxhcicsXHJcbiAgT1ZFUkhFQVJEOiAnb3ZlcmhlYXJkJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1lc3NhZ2UgaG9sZHMgYWxsIGluZm9ybWF0aW9uIGFib3V0IGRpc3BhdGNoZWQgZXZlbnQuIFRoaXMgaXMgYSBwb29sZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAY2F0IGNvcmVcclxuICovXHJcbmNsYXNzIE1lc3NhZ2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+TWVzc2FnZURpc3BhdGNoZXJ9IFRoZSBgTWVzc2FnZURpc3BhdGNoZXJgIG9iamVjdCwgd2hpY2ggcG9zdGVkIHRoaXMgbWVzc2FnZS4gKi9cclxuICAgIHRoaXMuc2VuZGVyID0gbnVsbDtcclxuXHJcbiAgICAvKiogQHR5cGUge3N0cmluZ30gVGhlIG5hbWUgb2YgbWVzc2FnZS4gKi9cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0fSBgR2FtZU9iamVjdGAgd2hpY2ggcmVjZWl2ZXMgdGhpcyBtZXNzYWdlLiAqL1xyXG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0fSBUaGUgcG9pbnQgZnJvbSB3aGljaCBzZW5kaW5nIGlzIGJlZ3VuLiAqL1xyXG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gU3BlY2lmaWVzIGlmIGludm9jYXRpb24gb2YgdGhpcyBtZXNzYWdlIHdhcyBjYW5jZWxlZC4gKi9cclxuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5NZXNzYWdlVHlwZX0gTWVzc2FnZSB0eXBlLiBTZWUgYE1lc3NhZ2VUeXBlYCBlbnVtLiAqL1xyXG4gICAgdGhpcy50eXBlID0gTWVzc2FnZVR5cGUuRElSRUNUO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VscyBtZXNzYWdlIGludm9jYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQGlmZGVmIERFQlVHXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIG1lc3NhZ2Ugc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgbGV0IG5hbWUgPSB0aGlzLnNlbmRlci5uYW1lICE9PSB1bmRlZmluZWQgPyB0aGlzLnNlbmRlci5uYW1lIDogJyc7XHJcbiAgICByZXR1cm4gYE1FU1NBR0U6IHsgbmFtZTogJyR7dGhpcy5uYW1lfScsIHNlbmRlcjogJyR7bmFtZX0nLCB0YXJnZXQ6ICcke3RoaXMudGFyZ2V0Lm5hbWV9JywgcGF0aDogJyR7dGhpcy5wYXRofScgfWA7XHJcbiAgfVxyXG4gIC8vIEBlbmRpZlxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5NZXNzYWdlfVxyXG4gICAqL1xyXG4gIF9fcmVzZXQoKSB7XHJcbiAgICB0aGlzLnNlbmRlciA9IG51bGw7XHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMudHlwZSA9IE1lc3NhZ2VUeXBlLkRJUkVDVDtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIEBjb25zdCBcclxuICAgKiBAcHVibGljIFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgUFJPR1JFU1MoKSB7XHJcbiAgICByZXR1cm4gJ3Byb2dyZXNzJztcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBAY29uc3QgXHJcbiAgICogQHB1YmxpYyBcclxuICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IENPTVBMRVRFKCkge1xyXG4gICAgcmV0dXJuICdjb21wbGV0ZSc7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogQGNvbnN0IFxyXG4gICAqIEBwdWJsaWMgXHJcbiAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBFUlJPUigpIHtcclxuICAgIHJldHVybiAnZXJyb3InO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIEBjb25zdCBcclxuICAgKiBAcHVibGljIFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgQ0hBTkdFKCkge1xyXG4gICAgcmV0dXJuICdjaGFuZ2UnO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIEBjb25zdCBcclxuICAgKiBAcHVibGljIFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgUkVBRFkoKSB7XHJcbiAgICByZXR1cm4gJ3JlYWR5JztcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBAY29uc3QgXHJcbiAgICogQHB1YmxpYyBcclxuICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IFVQREFURSgpIHtcclxuICAgIHJldHVybiAndXBkYXRlJztcclxuICB9XHJcblxyXG4gIC8qKiBcclxuICAgKiBAY29uc3QgXHJcbiAgICogQHB1YmxpYyBcclxuICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IFJFU0laRSgpIHtcclxuICAgIHJldHVybiAncmVzaXplJztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXQgcG9vbCgpIHtcclxuICAgIHJldHVybiBwb29sO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBvb2wgZm9yIG1lc3NhZ2VzLlxyXG4gKlxyXG4gKiBAdHlwZSB7YmxhY2stZW5naW5lfk9iamVjdFBvb2x9XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBwb29sID0gbmV3IE9iamVjdFBvb2woTWVzc2FnZSk7XHJcblxyXG4vKipcclxuICogQSBicmlkZ2UgYmV0d2VlbiBjYWxsYmFjayBhbmQgY29udGV4dC5cclxuICogXHJcbiAqIEBjYXQgY29yZVxyXG4gKi9cclxuY2xhc3MgTWVzc2FnZUJpbmRpbmcge1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyfSBvd25lciAgICAgICAgICAgICAgICBUaGUgb3duZXIgb2YgdGhpcyBiaW5kaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5hbWUgb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgICAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc09uY2UgICAgICAgICAgICAgICAgICAgICAgICAgSW5kaWNhdGVzIHdoZW5ldmVyIHRoaXMgYmluZGluZyBzaG91bGQgYmUgYXV0byBkZXN0cm95ZWQgYWZ0ZXIgZmlyc3QgZXhlY3V0aW9uLlxyXG4gICAqIEBwYXJhbSB7Kj19IFtjb250ZXh0PW51bGxdICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsIGNvbnRleHQgKHVzdWFsbHkgdGhpcykuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+QmluZGluZ1R5cGV9IFt0eXBlPUJpbmRpbmdUeXBlLlJFR1VMQVJdIFR5cGUgb2YgdGhlIGJpbmRpbmcuXHJcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBbcGF0aFBhdHRlcm49bnVsbF0gICAgICAgICAgICAgR2xvYiBwYXR0ZXJuIHRvIGZpbHRlciBzZW5kZXIgYnkgbmFtZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihvd25lciwgbmFtZSwgY2FsbGJhY2ssIGlzT25jZSwgY29udGV4dCA9IG51bGwsIHR5cGUgPSBCaW5kaW5nVHlwZS5SRUdVTEFSLCBwYXRoUGF0dGVybiA9IG51bGwpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNPbmNlID0gaXNPbmNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7Kn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEB0eXBlIHs/c3RyaW5nfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5wYXRoUGF0dGVybiA9IHBhdGhQYXR0ZXJuO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkdsb2J8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2xvYiA9IHBhdGhQYXR0ZXJuID09IG51bGwgPyBudWxsIDogbmV3IEdsb2IocGF0aFBhdHRlcm4pO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkJpbmRpbmdUeXBlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIHRoaXMgYmluZGluZy5cclxuICAgKi9cclxuICBvZmYoKSB7XHJcbiAgICB0aGlzLm93bmVyLl9fb2ZmKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+TWVzc2FnZUJpbmRpbmd9XHJcbiAgICovXHJcbiAgX19yZXNldCgpIHtcclxuICAgIHRoaXMub3duZXIgPSBudWxsO1xyXG4gICAgdGhpcy5wYXRoUGF0dGVybiA9IG51bGw7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuXHJcbnZhciBtSW5zdGFuY2UgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIENvbm5lY3RzIGFsbCB0aGUgZG90cy5cclxuICogXHJcbiAqIEBzdGF0aWNcclxuICogQHN0YXRpY0NsYXNzXHJcbiAqL1xyXG5jbGFzcyBCbGFjayB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBtSW5zdGFuY2UgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RW5naW5lfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1FbmdpbmUgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+SW5wdXR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlucHV0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hc3RlckF1ZGlvfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BdWRpbyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5UaW1lfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UaW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkRldmljZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tRGV2aWNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkFzc2V0TWFuYWdlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQXNzZXRzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2ZSBjYW1lcmEgaW5zdGFuY2UuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkNhbWVyYX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FtZXJhID0gbnVsbDtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IEJsYWNrIEVuZ2luZSBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkVuZ2luZX1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGVuZ2luZSgpIHtcclxuICAgIHJldHVybiBtSW5zdGFuY2UubUVuZ2luZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IEVuZ2luZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5FbmdpbmV9IHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIHNldCBlbmdpbmUodmFsdWUpIHtcclxuICAgIG1JbnN0YW5jZS5tRW5naW5lID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgYWN0aXZlIElucHV0IFN5c3RlbSBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfklucHV0fVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgaW5wdXQoKSB7XHJcbiAgICByZXR1cm4gbUluc3RhbmNlLm1JbnB1dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IElucHV0IFN5c3RlbS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5JbnB1dH0gdmFsdWVcclxuICAgKi9cclxuICBzdGF0aWMgc2V0IGlucHV0KHZhbHVlKSB7XHJcbiAgICBtSW5zdGFuY2UubUlucHV0ID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgYWN0aXZlIEF1ZGlvIFN5c3RlbSBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfk1hc3RlckF1ZGlvfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgYXVkaW8oKSB7XHJcbiAgICByZXR1cm4gbUluc3RhbmNlLm1BdWRpbztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IEF1ZGlvIFN5c3RlbS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NYXN0ZXJBdWRpb30gdmFsdWVcclxuICAgKi9cclxuICBzdGF0aWMgc2V0IGF1ZGlvKHZhbHVlKSB7XHJcbiAgICBtSW5zdGFuY2UubUF1ZGlvID0gdmFsdWU7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBUaW1lIG1hbmFnZW1lbnQgaW5zdGFuY2UuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5UaW1lfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgdGltZSgpIHtcclxuICAgIHJldHVybiBtSW5zdGFuY2UubVRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIG5ldyBUaW1lIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflRpbWV9IHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIHNldCB0aW1lKHZhbHVlKSB7XHJcbiAgICBtSW5zdGFuY2UubVRpbWUgPSB2YWx1ZTtcclxuICB9ICBcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IERldmljZSBpbnN0YW5jZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkRldmljZX1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGRldmljZSgpIHtcclxuICAgIHJldHVybiBtSW5zdGFuY2UubURldmljZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbmV3IERldmljZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5EZXZpY2V9IHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIHNldCBkZXZpY2UodmFsdWUpIHtcclxuICAgIG1JbnN0YW5jZS5tRGV2aWNlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IEFzc2V0TWFuYWdlciBpbnN0YW5jZS4gU3ByaXRlIGFuZCBvdGhlciBjbGFzc2VzIHVzZXMgdGhpcyBpbnN0YW5jZSB0byBmaW5kIHRleHR1cmVzIGJ5IG5hbWUuXHJcbiAgICogSXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlLWFzc2lnbmVkIHdoZW4gbmV3IEFzc2V0TWFuYWdlciBpcyBjcmVhdGVkLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+QXNzZXRNYW5hZ2VyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgYXNzZXRzKCkge1xyXG4gICAgcmV0dXJuIG1JbnN0YW5jZS5tQXNzZXRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBuZXcgQXNzZXRNYW5hZ2VyLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkFzc2V0TWFuYWdlcn0gdmFsdWVcclxuICAgKi9cclxuICBzdGF0aWMgc2V0IGFzc2V0cyh2YWx1ZSkge1xyXG4gICAgbUluc3RhbmNlLm1Bc3NldHMgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBzdGFnZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+U3RhZ2V9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBzdGFnZSgpIHtcclxuICAgIHJldHVybiBtSW5zdGFuY2UubUVuZ2luZS5tU3RhZ2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGN1cnJlbnQgdmlkZW8gZHJpdmVyLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5WaWRlb051bGxEcml2ZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBkcml2ZXIoKSB7XHJcbiAgICByZXR1cm4gbUluc3RhbmNlLm1FbmdpbmUubVZpZGVvO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhY3RpdmUgY2FtZXJhIGluc3RhbmNlLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+Q2FtZXJhfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgY2FtZXJhKCkge1xyXG4gICAgaWYgKG1JbnN0YW5jZS5tQ2FtZXJhICE9PSBudWxsICYmIG1JbnN0YW5jZS5tQ2FtZXJhLm1BZGRlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuIG1JbnN0YW5jZS5tQ2FtZXJhO1xyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBkZWZhdWx0IGNhbWVyYTtcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5DYW1lcmF9IHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIHNldCBjYW1lcmEodmFsdWUpIHtcclxuICAgIG1JbnN0YW5jZS5tQ2FtZXJhID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgbWFnaWMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcclxuICB9XHJcbn1cclxuXHJcbm5ldyBCbGFjaygpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBNZXNzYWdlRGlzcGF0Y2hlciBjbGFzcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGNsYXNzZXMgdGhhdCBwb3N0cyBtZXNzYWdlcy5cclxuICpcclxuICogR2xvYmFsIG1lc3NhZ2VzIHdpbGwgbm90IGJlIGRpc3BhdGNoZWQgb24gbm9uIEdhbWVPYmplY3Qgb2JqZWN0cy5cclxuICpcclxuICogQGNhdCBjb3JlXHJcbiAqL1xyXG5jbGFzcyBNZXNzYWdlRGlzcGF0Y2hlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgTWVzc2FnZURpc3BhdGNoZXIgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGVja0ZvclN0YWdlPWZhbHNlXVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNoZWNrRm9yU3RhZ2UgPSBmYWxzZSkge1xyXG4gICAgdGhpcy5tQmluZGluZ3MgPSBudWxsO1xyXG4gICAgdGhpcy5jaGVja0ZvclN0YWdlID0gY2hlY2tGb3JTdGFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgbGlzdGVuZXIgYnkgZ2l2ZW4gbmFtZSBhbmQgY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgTWVzc2FnZSBuYW1lLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBtZXNzYWdlIHNlbmQuXHJcbiAgICogQHBhcmFtIHsqfSBbY29udGV4dD1udWxsXSAgT2JqZWN0IHRvIGJlIHVzZWQgYXMgYHRoaXNgIGluIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5NZXNzYWdlQmluZGluZ31cclxuICAgKi9cclxuICBvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19vbihuYW1lLCBjYWxsYmFjaywgZmFsc2UsIGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgYmluZGluZ3MgYnkgZ2l2ZW4gbWVzc2FnZSBuYW1lLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gey4uLnN0cmluZ30gbmFtZXMgT25lIG9yIG1vcmUgbWVzc2FnZSBuYW1lLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9mZiguLi5uYW1lcykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XHJcblxyXG4gICAgICBsZXQgZWFySW5kZXggPSBuYW1lLmluZGV4T2YoJ0AnKTtcclxuICAgICAgaWYgKGVhckluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIERlYnVnLmVycm9yKCdSZW1vdmluZyBvdmVyaGVhcmQgYmluZGluZ3MgaXMgbm90IGFsbG93ZWQuJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5tQmluZGluZ3MgIT09IG51bGwgJiYgdGhpcy5tQmluZGluZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IHRydWUpIHtcclxuICAgICAgICBsZXQgYmluZGluZ3MgPSB0aGlzLm1CaW5kaW5nc1tuYW1lXS5zbGljZSgpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgdGhpcy5fX29mZihiaW5kaW5nc1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgbGlzdGVuZXIgYnkgZ2l2ZW4gbmFtZSBhbmQgY2FsbGJhY2suIEJpbmRpbmcgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgZmlyc3QgZXhlY3V0aW9uLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIE1lc3NhZ2UgbmFtZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gbWVzc2FnZSBzZW5kLlxyXG4gICAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9bnVsbF0gIE9iamVjdCB0byBiZSB1c2VkIGFzIGB0aGlzYCBpbiBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWVzc2FnZUJpbmRpbmd9XHJcbiAgICovXHJcbiAgb25jZShuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19vbihuYW1lLCBjYWxsYmFjaywgdHJ1ZSwgY29udGV4dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3N0cyBtZXNzYWdlIHdpdGggYSBnaXZlbiBwYXJhbXMuXHJcbiAgICogXHJcbiAgICogQWRkaW5nIGB+YCBjaGFyYWN0ZXIgdG8gdGhlIGJlZ2dpbmcgb2YgdGhlIG5hbWUgd2lsbCBidWJibGUgbWVzc2FnZSB0byB0aGUgdG9wIG9mIHRoZSB0cmVlLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICBUaGUgbmFtZSBvZiBhIG1lc3NhZ2VcclxuICAgKiBAcGFyYW0gey4uLip9IHBhcmFtcyAgQSBsaXN0IG9mIHBhcmFtcyB0byBzZW5kXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBwb3N0KG5hbWUsIC4uLnBhcmFtcykge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSB0aGlzLl9fZHJhZnRNZXNzYWdlKG5hbWUpO1xyXG5cclxuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkRJUkVDVClcclxuICAgICAgdGhpcy5fX2ludm9rZSh0aGlzLCBtZXNzYWdlLCAuLi5wYXJhbXMpO1xyXG4gICAgZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBNZXNzYWdlVHlwZS5CVUJCTEUpXHJcbiAgICAgIHRoaXMuX19wb3N0QnViYmxlcyh0aGlzLCBtZXNzYWdlLCB0cnVlLCAuLi5wYXJhbXMpO1xyXG5cclxuICAgIGlmIChtZXNzYWdlLmNhbmNlbGVkID09PSBmYWxzZSlcclxuICAgICAgdGhpcy5fX2ludm9rZU92ZXJoZWFyZCh0aGlzLCBtZXNzYWdlLCAuLi5wYXJhbXMpO1xyXG5cclxuICAgIE1lc3NhZ2UucG9vbC5yZWxlYXNlKG1lc3NhZ2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBwYXJlbnQgTWVzc2FnZURpc3BhdGNoZXIuXHJcbiAgICogXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHBhcmVudCgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc3RhZ2UgR2FtZSBPYmplY3QgdG8gd2hpY2ggdGhpcyBiZWxvbmdzIHRvIG9yIG51bGwgaWYgbm90IGFkZGVkIG9udG8gc3RhZ2UuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+U3RhZ2V8bnVsbH1cclxuICAgKi9cclxuICBnZXQgc3RhZ2UoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGluZyBhIHVybCBsaWtlIHBhdGggdG8gdGhpcyBvYmplY3QgaW4gdGhlIGRpc3BsYXlcclxuICAgKiB0cmVlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGgoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc09uY2U9ZmFsc2VdXHJcbiAgICogQHBhcmFtIHsqfSBbY29udGV4dD1udWxsXVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5NZXNzYWdlQmluZGluZ31cclxuICAgKi9cclxuICBfX29uKG5hbWUsIGNhbGxiYWNrLCBpc09uY2UgPSBmYWxzZSwgY29udGV4dCA9IG51bGwpIHtcclxuICAgIERlYnVnLmFzc2VydChuYW1lICE9PSBudWxsLCAnbmFtZSBjYW5ub3QgYmUgbnVsbC4nKTtcclxuICAgIERlYnVnLmFzc2VydChuYW1lLnRyaW0oKS5sZW5ndGggPiAwLCAnbmFtZSBjYW5ub3QgYmUgbnVsbC4nKTtcclxuICAgIERlYnVnLmFzc2VydCghKG5hbWUuaW5kZXhPZignficpID09PSAwKSwgJ1VzaW5nIGB+YCBpcyBub3QgdG90IGFsbG93ZWQgaGVyZS4nKTtcclxuICAgIERlYnVnLmFzc2VydChjYWxsYmFjayAhPT0gbnVsbCwgJ2NhbGxiYWNrIGNhbm5vdCBiZSBudWxsLicpO1xyXG5cclxuICAgIGxldCBlYXJJbmRleCA9IG5hbWUuaW5kZXhPZignQCcpO1xyXG4gICAgaWYgKGVhckluZGV4ICE9PSAtMSkge1xyXG4gICAgICBsZXQgbWVzc2FnZU5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBlYXJJbmRleCk7XHJcbiAgICAgIGxldCBwYXRoUGF0dGVybiA9IG5hbWUuc3Vic3RyaW5nKGVhckluZGV4ICsgMSk7XHJcbiAgICAgIGxldCBnbG9iYWwgPSBNZXNzYWdlRGlzcGF0Y2hlci5tT3ZlcmhlYXJkSGFuZGxlcnM7XHJcblxyXG4gICAgICBpZiAoZ2xvYmFsLmhhc093blByb3BlcnR5KG1lc3NhZ2VOYW1lKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgZ2xvYmFsW21lc3NhZ2VOYW1lXSA9IFtdO1xyXG5cclxuICAgICAgbGV0IGJpbmRpbmdzID0gZ2xvYmFsW21lc3NhZ2VOYW1lXTtcclxuICAgICAgbGV0IGJpbmRpbmcgPSBuZXcgTWVzc2FnZUJpbmRpbmcodGhpcywgbWVzc2FnZU5hbWUsIGNhbGxiYWNrLCBpc09uY2UsIGNvbnRleHQsIEJpbmRpbmdUeXBlLk9WRVJIRUFSRCwgcGF0aFBhdHRlcm4pO1xyXG4gICAgICBiaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xyXG4gICAgICByZXR1cm4gYmluZGluZztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5tQmluZGluZ3MgPT09IG51bGwpXHJcbiAgICAgIHRoaXMubUJpbmRpbmdzID0ge307XHJcblxyXG4gICAgaWYgKHRoaXMubUJpbmRpbmdzLmhhc093blByb3BlcnR5KG5hbWUpID09PSBmYWxzZSlcclxuICAgICAgdGhpcy5tQmluZGluZ3NbbmFtZV0gPSBbXTtcclxuXHJcbiAgICBsZXQgYmluZGluZyA9IG5ldyBNZXNzYWdlQmluZGluZyh0aGlzLCBuYW1lLCBjYWxsYmFjaywgaXNPbmNlLCBjb250ZXh0LCBCaW5kaW5nVHlwZS5SRUdVTEFSKTtcclxuICAgIHRoaXMubUJpbmRpbmdzW25hbWVdLnB1c2goYmluZGluZyk7XHJcblxyXG4gICAgcmV0dXJuIGJpbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NZXNzYWdlQmluZGluZ30gYmluZGluZyBcclxuICAgKi9cclxuICBfX29mZihiaW5kaW5nKSB7XHJcbiAgICBpZiAoYmluZGluZy50eXBlID09PSBCaW5kaW5nVHlwZS5SRUdVTEFSKSB7XHJcbiAgICAgIGlmICh0aGlzLm1CaW5kaW5ncyA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAodGhpcy5tQmluZGluZ3MuaGFzT3duUHJvcGVydHkoYmluZGluZy5uYW1lKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGJpbmRpbmdzID0gdGhpcy5tQmluZGluZ3NbYmluZGluZy5uYW1lXTtcclxuICAgICAgY29uc3QgaXggPSBiaW5kaW5ncy5pbmRleE9mKGJpbmRpbmcpO1xyXG4gICAgICBpZiAoaXggPT09IC0xKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGJpbmRpbmdzLnNwbGljZShpeCwgMSk7XHJcbiAgICB9IGVsc2UgaWYgKGJpbmRpbmcudHlwZSA9PT0gQmluZGluZ1R5cGUuT1ZFUkhFQVJEKSB7XHJcbiAgICAgIGxldCBnbG9iYWwgPSBNZXNzYWdlRGlzcGF0Y2hlci5tT3ZlcmhlYXJkSGFuZGxlcnM7XHJcbiAgICAgIGlmIChnbG9iYWwuaGFzT3duUHJvcGVydHkoYmluZGluZy5uYW1lKSA9PT0gZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgbGV0IGJpbmRpbmdzID0gZ2xvYmFsW2JpbmRpbmcubmFtZV07XHJcblxyXG4gICAgICBjb25zdCBpeCA9IGJpbmRpbmdzLmluZGV4T2YoYmluZGluZyk7XHJcbiAgICAgIGlmIChpeCA9PT0gLTEpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgYmluZGluZ3Muc3BsaWNlKGl4LCAxKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyfSBzZW5kZXIgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWVzc2FnZX0gbWVzc2FnZSBcclxuICAgKiBAcGFyYW0gey4uLip9IHBhcmFtcyBcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9faW52b2tlKHNlbmRlciwgbWVzc2FnZSwgLi4ucGFyYW1zKSB7XHJcbiAgICBpZiAobWVzc2FnZS5jYW5jZWxlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLm1CaW5kaW5ncyA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLmNoZWNrRm9yU3RhZ2UgPT09IHRydWUgJiYgdGhpcyAhPT0gQmxhY2suc3RhZ2UgJiYgdGhpcy5zdGFnZSA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBiaW5kaW5ncyA9ICh0aGlzLm1CaW5kaW5nc1ttZXNzYWdlLm5hbWVdKTtcclxuXHJcbiAgICBpZiAoYmluZGluZ3MgPT09IHVuZGVmaW5lZCB8fCBiaW5kaW5ncy5sZW5ndGggPT09IDApXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBsZXQgY2xvbmVkID0gYmluZGluZ3Muc2xpY2UoMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbWVzc2FnZS50YXJnZXQgPSB0aGlzO1xyXG5cclxuICAgICAgbGV0IGJpbmRpbmcgPSBjbG9uZWRbaV07XHJcblxyXG4gICAgICBpZiAodGhpcy5jaGVja0ZvclN0YWdlID09PSB0cnVlICYmIGJpbmRpbmcub3duZXIuc3RhZ2UgPT09IEJsYWNrLnN0YWdlICYmIGJpbmRpbmcub3duZXIuc3RhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBiaW5kaW5nLmNhbGxiYWNrLmNhbGwoYmluZGluZy5jb250ZXh0LCBtZXNzYWdlLCAuLi5wYXJhbXMpO1xyXG5cclxuICAgICAgaWYgKGJpbmRpbmcuaXNPbmNlID09PSB0cnVlKVxyXG4gICAgICAgIHRoaXMuX19vZmYoYmluZGluZyk7XHJcblxyXG4gICAgICBpZiAobWVzc2FnZS5jYW5jZWxlZCA9PT0gdHJ1ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NZXNzYWdlRGlzcGF0Y2hlcn0gIHNlbmRlclxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1lc3NhZ2V9ICBtZXNzYWdlXHJcbiAgICogQHBhcmFtIHsuLi4qfSBwYXJhbXNcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9faW52b2tlT3ZlcmhlYXJkKHNlbmRlciwgbWVzc2FnZSwgLi4ucGFyYW1zKSB7XHJcbiAgICBpZiAobWVzc2FnZS5jYW5jZWxlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBiaW5kaW5ncyA9IE1lc3NhZ2VEaXNwYXRjaGVyLm1PdmVyaGVhcmRIYW5kbGVyc1ttZXNzYWdlLm5hbWVdO1xyXG5cclxuICAgIGlmIChiaW5kaW5ncyA9PT0gdW5kZWZpbmVkIHx8IGJpbmRpbmdzLmxlbmd0aCA9PT0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBjbG9uZWQgPSBiaW5kaW5ncy5zbGljZSgwKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgYmluZGluZyA9IGNsb25lZFtpXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNoZWNrRm9yU3RhZ2UgPT09IHRydWUgJiYgYmluZGluZy5vd25lci5zdGFnZSA9PT0gQmxhY2suc3RhZ2UgJiYgYmluZGluZy5vd25lci5zdGFnZSA9PT0gbnVsbClcclxuICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5fX2NoZWNrUGF0aChzZW5kZXIucGF0aCwgYmluZGluZykpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBtZXNzYWdlLnRhcmdldCA9IHRoaXM7XHJcbiAgICAgIGJpbmRpbmcuY2FsbGJhY2suY2FsbChiaW5kaW5nLmNvbnRleHQsIG1lc3NhZ2UsIC4uLnBhcmFtcyk7XHJcblxyXG4gICAgICBpZiAoYmluZGluZy5pc09uY2UgPT09IHRydWUpXHJcbiAgICAgICAgdGhpcy5fX29mZihiaW5kaW5nKTtcclxuXHJcbiAgICAgIGlmIChtZXNzYWdlLmNhbmNlbGVkID09PSB0cnVlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lc3NhZ2Ugd2lsbCBhbHdheXMgcmVhY2ggdGhlIHN0YWdlIGV2ZW4gaWYgc29tZSBvZiB0aGUgbWlkZGxlIG5vZGVzIHdlcmUgcmVtb3ZlZCBkdXJpbmcgcHJvY2VzcyBvZiBpbnZvY2F0aW9uLlxyXG4gICAqIFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7Kn0gIHNlbmRlclxyXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gIG1lc3NhZ2VcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICB0b1RvcFxyXG4gICAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3Bvc3RCdWJibGVzKHNlbmRlciwgbWVzc2FnZSwgdG9Ub3AsIC4uLnBhcmFtcykge1xyXG4gICAgbWVzc2FnZS5vcmlnaW4gPSB0aGlzO1xyXG5cclxuICAgIGxldCBsaXN0ID0gW3RoaXNdO1xyXG5cclxuICAgIGxldCBjdXJyZW50ID0gdGhpcztcclxuICAgIHdoaWxlIChjdXJyZW50LnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICBsaXN0LnB1c2goY3VycmVudC5wYXJlbnQpO1xyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBkaXNwYXRjaGVyID0gbGlzdFtpXTtcclxuICAgICAgZGlzcGF0Y2hlci5fX2ludm9rZShzZW5kZXIsIG1lc3NhZ2UsIC4uLnBhcmFtcyk7XHJcblxyXG4gICAgICBpZiAobWVzc2FnZS5jYW5jZWxlZCA9PT0gdHJ1ZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfk1lc3NhZ2V9XHJcbiAgICovXHJcbiAgX19kcmFmdE1lc3NhZ2UobmFtZSkge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9IE1lc3NhZ2UucG9vbC5nZXQoKTtcclxuICAgIG1lc3NhZ2UuX19yZXNldCgpO1xyXG5cclxuICAgIG1lc3NhZ2Uuc2VuZGVyID0gdGhpcztcclxuXHJcbiAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICd+Jykge1xyXG4gICAgICBtZXNzYWdlLm5hbWUgPSBuYW1lLnN1YnN0cigxKTtcclxuICAgICAgbWVzc2FnZS50eXBlID0gTWVzc2FnZVR5cGUuQlVCQkxFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWVzc2FnZS5uYW1lID0gbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHBhdGhcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NZXNzYWdlQmluZGluZ30gYmluZGluZ1xyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIF9fY2hlY2tQYXRoKHBhdGgsIGJpbmRpbmcpIHtcclxuICAgIGlmIChwYXRoID09PSBudWxsIHx8IGJpbmRpbmcucGF0aFBhdHRlcm4gPT09IG51bGwpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBpZiAocGF0aCA9PT0gYmluZGluZy5wYXRoUGF0dGVybilcclxuICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgaWYgKGJpbmRpbmcucGF0aFBhdHRlcm4uaW5kZXhPZignKicpID09PSAtMSlcclxuICAgICAgcmV0dXJuIHBhdGggPT09IGJpbmRpbmcucGF0aFBhdHRlcm47XHJcblxyXG4gICAgcmV0dXJuIGJpbmRpbmcuZ2xvYi50ZXN0KHBhdGgpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGRpc3Bvc2UoKSB7XHJcbiAgICBNZXNzYWdlRGlzcGF0Y2hlci5tT3ZlcmhlYXJkSGFuZGxlcnMgPSB7fTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5Pn1cclxuICovXHJcbk1lc3NhZ2VEaXNwYXRjaGVyLm1PdmVyaGVhcmRIYW5kbGVycyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBjYXQgZGlzcGxheS50ZXh0XHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBGb250U3R5bGUgPSB7XHJcbiAgTk9STUFMOiAnbm9ybWFsJyxcclxuICBJVEFMSUM6ICdpdGFsaWMnXHJcbn07XHJcblxyXG4vKipcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IEZvbnRXZWlnaHQgPSB7XHJcbiAgTk9STUFMOiAnNDAwJyxcclxuICBCT0xEOiAnNzAwJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBpZ25vcmVcclxuICogQHR5cGUge1RleHRTdHlsZXxudWxsfVxyXG4gKi9cclxubGV0IGRlZmF1bHRTdHlsZSA9IG51bGw7XHJcblxyXG4vKipcclxuICogSG9sZHMgVGV4dEZpZWxkJ3Mgc3R5bGUgZGV0YWlscy5cclxuICpcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICovXHJcbmNsYXNzIFRleHRTdHlsZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBUZXh0U3R5bGUuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nPX0gZmFtaWx5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9udCBuYW1lXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW2NvbG9yPTB4MF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dCBjb2xvciBhcyBoZXhhZGVjaW1hbCBudW1iZXIgZWcgMHhmZjAwMDAgKHRvdGFsIHJlZClcclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbc2l6ZT0xNF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0IHNpemVcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+Rm9udFN0eWxlPX0gW3N0eWxlPUZvbnRTdHlsZS5OT1JNQUxdICAgICAgICAgICAgICAgICAgICAgICAgVGV4dCBzdHlsZSBlZyBpdGFsaWNcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+Rm9udFdlaWdodD19IFt3ZWlnaHQ9Rm9udFdlaWdodC5OT1JNQUxdICAgICAgICAgICAgICAgICAgICAgRm9udCB0aGlja25lc3MuIFRoZSB2YWx1ZSBpcyBzZXQgZnJvbSAxMDAgdG8gOTAwIGluIGluY3JlbWVudHMgb2YgMTAwLlxyXG4gICAqIEBwYXJhbSAge251bWJlcj19IFtzdHJva2VUaGlja25lc3M9MF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLiAwIG1lYW5zIHRoYXQgbm8gc3Ryb2tlXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW3N0cm9rZUNvbG9yPTB4ZmZmZmZmXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3Ryb2tlIGNvbG9yIGFzIGhleGFkZWNpbWFsIG51bWJlciBlZyAweDAwZmYwMCAodG90YWwgZ3JlZW4pXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZmFtaWx5ID0gJ3NhbnMtc2VyaWYnLCBjb2xvciA9IDB4MDAwMDAwLCBzaXplID0gMTQsIHN0eWxlID0gRm9udFN0eWxlLk5PUk1BTCwgd2VpZ2h0ID0gRm9udFdlaWdodC5OT1JNQUwsIHN0cm9rZVRoaWNrbmVzcyA9IDAsIHN0cm9rZUNvbG9yID0gMHhmZmZmZmYpIHtcclxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgdGhpcy5uYW1lID0gJ2RlZic7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXHJcbiAgICB0aGlzLmZhbWlseSA9IGZhbWlseTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmFscGhhID0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5Gb250U3R5bGV9ICovXHJcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+Rm9udFdlaWdodH0gKi9cclxuICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3M7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXHJcbiAgICB0aGlzLmRyb3BTaGFkb3cgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2hhZG93RGlzdGFuY2VYID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2hhZG93RGlzdGFuY2VZID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2hhZG93Q29sb3IgPSAweDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnNoYWRvd0FscGhhID0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuc2hhZG93Qmx1ciA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xyXG4gIGNsb25lKGZhbWlseSA9IG51bGwsIGNvbG9yID0gTmFOLCBzaXplID0gTmFOLCBzdHlsZSA9IG51bGwsIHdlaWdodCA9IG51bGwsIHN0cm9rZVRoaWNrbmVzcyA9IE5hTiwgc3Ryb2tlQ29sb3IgPSBOYU4pIHtcclxuICAgIGxldCByZXQgPSBuZXcgVGV4dFN0eWxlKCk7XHJcbiAgICByZXQuZmFtaWx5ID0gZmFtaWx5ID09PSBudWxsID8gdGhpcy5mYW1pbHkgOiBmYW1pbHk7XHJcbiAgICByZXQuc2l6ZSA9IGlzTmFOKHNpemUpID8gdGhpcy5zaXplIDogc2l6ZTtcclxuICAgIHJldC5jb2xvciA9IGlzTmFOKGNvbG9yKSA/IHRoaXMuY29sb3IgOiBjb2xvcjtcclxuICAgIHJldC5zdHlsZSA9IHN0eWxlID09PSBudWxsID8gdGhpcy5zdHlsZSA6IHN0eWxlO1xyXG4gICAgcmV0LndlaWdodCA9IHdlaWdodCA9PT0gbnVsbCA/IHRoaXMud2VpZ2h0IDogd2VpZ2h0O1xyXG4gICAgcmV0LnN0cm9rZVRoaWNrbmVzcyA9IGlzTmFOKHN0cm9rZVRoaWNrbmVzcykgPyB0aGlzLnN0cm9rZVRoaWNrbmVzcyA6IHN0cm9rZVRoaWNrbmVzcztcclxuICAgIHJldC5zdHJva2VDb2xvciA9IGlzTmFOKHN0cm9rZUNvbG9yKSA/IHRoaXMuc3Ryb2tlQ29sb3IgOiBzdHJva2VDb2xvcjtcclxuXHJcbiAgICByZXQuZHJvcFNoYWRvdyA9IHRoaXMuZHJvcFNoYWRvdztcclxuICAgIHJldC5zaGFkb3dBbHBoYSA9IHRoaXMuc2hhZG93QWxwaGE7XHJcbiAgICByZXQuc2hhZG93Qmx1ciA9IHRoaXMuc2hhZG93Qmx1cjtcclxuICAgIHJldC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93Q29sb3I7XHJcbiAgICByZXQuc2hhZG93RGlzdGFuY2VYID0gdGhpcy5zaGFkb3dEaXN0YW5jZVg7XHJcbiAgICByZXQuc2hhZG93RGlzdGFuY2VZID0gdGhpcy5zaGFkb3dEaXN0YW5jZVk7XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZGVmYXVsdCBUZXh0U3R5bGUgaW5zdGFuY2UuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5UZXh0U3R5bGV9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBkZWZhdWx0KCkge1xyXG4gICAgaWYgKGRlZmF1bHRTdHlsZSA9PT0gbnVsbClcclxuICAgICAgZGVmYXVsdFN0eWxlID0gbmV3IFRleHRTdHlsZSgnc2Fucy1zZXJpZicsIDB4MCwgMTQsIEZvbnRTdHlsZS5OT1JNQUwsIEZvbnRXZWlnaHQuTk9STUFMLCAwLCAweDApO1xyXG5cclxuICAgIHJldHVybiBkZWZhdWx0U3R5bGU7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogXHJcbiAqIEBpZ25vcmUgXHJcbiAqIEBzdGF0aWMgXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5sZXQgQ0FDSEUgPSB7fTtcclxuXHJcbi8qKiBcclxuICogQGlnbm9yZSBcclxuICogQHN0YXRpYyBcclxuICogQHByaXZhdGVcclxuICovXHJcbmxldCBDT05URVhUID0gbnVsbDtcclxuXHJcbi8qKiBcclxuICogQGlnbm9yZSBcclxuICogQHN0YXRpYyBcclxuICogQHByaXZhdGVcclxuICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhc31cclxuICovXHJcbmxldCBDQU5WQVMgPSBudWxsO1xyXG5cclxubGV0IHVzZU9mZnNjcmVlbkNhbnZhcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEZvbnQgbWVhc3VyZW1lbnQgdG9vbHMuXHJcbiAqXHJcbiAqIEBjYXQgZGlzcGxheS50ZXh0XHJcbiAqL1xyXG5jbGFzcyBGb250TWV0cmljcyB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgRm9udE1ldHJpY3MuIERvIG5vdCB1c2UgY29uc3RydWN0b3IgZGlyZWN0bHkgaW5zdGVhZCB1c2Uge0BsaW5rIEZvbnRNZXRyaWNzI2dldH0gbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dFN0eWxlfSBzdHlsZSBEZWZhdWx0IHRleHQgaW5mbyB3aXRoIDI0IGZvbnQgc2l6ZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzdHlsZSkge1xyXG4gICAgaWYgKENPTlRFWFQgPT09IG51bGwpIHtcclxuICAgICAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIHVzZU9mZnNjcmVlbkNhbnZhcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIENBTlZBUyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMTAsIDIwMCk7XHJcbiAgICAgICAgQ09OVEVYVCA9IENBTlZBUy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIENBTlZBUyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcclxuICAgICAgICBDT05URVhUID0gQ0FOVkFTLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICAgIENBTlZBUy53aWR0aCA9IDEwO1xyXG4gICAgICAgIENBTlZBUy5oZWlnaHQgPSAyMDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdHlsZS5zaXplID0gMjQ7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLm1DYW52YXMgPSBDQU5WQVM7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlICovXHJcbiAgICB0aGlzLm1DdHggPSBDT05URVhUO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5UZXh0U3R5bGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdHlsZSA9IHN0eWxlO1xyXG5cclxuICAgIGNvbnN0IGRyYXdZID0gTWF0aC5mbG9vcihDQU5WQVMuaGVpZ2h0ICogMC43NzY2KTtcclxuICAgIHRoaXMubUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5tQ2FudmFzLndpZHRoLCB0aGlzLm1DYW52YXMuaGVpZ2h0KTtcclxuICAgIHRoaXMubUN0eC5mb250ID0gYCR7c3R5bGUud2VpZ2h0fSAke3N0eWxlLnNpemV9cHggJHtzdHlsZS5mYW1pbHl9YDtcclxuICAgIHRoaXMubUN0eC5maWxsVGV4dCgneCcsIDAsIGRyYXdZLCAxKTtcclxuXHJcbiAgICBsZXQgZGF0YSA9IHRoaXMubUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgdGhpcy5tQ2FudmFzLmhlaWdodCkuZGF0YTtcclxuXHJcbiAgICBjb25zdCB4SGVpZ2h0ID0gdGhpcy5fX2dldEJvdHRvbShkYXRhKSAtIHRoaXMuX19nZXRUb3AoZGF0YSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDMyOyBpIDw9IDEyNjsgaSsrKSB7XHJcbiAgICAgIHRoaXMubUN0eC5maWxsVGV4dChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCAwLCBkcmF3WSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YSA9IHRoaXMubUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgdGhpcy5tQ2FudmFzLmhlaWdodCkuZGF0YTtcclxuXHJcbiAgICBjb25zdCB0b3AgPSB0aGlzLl9fZ2V0VG9wKGRhdGEpO1xyXG4gICAgY29uc3QgYm90dG9tID0gdGhpcy5fX2dldEJvdHRvbShkYXRhKTtcclxuICAgIGNvbnN0IGJhc2VMaW5lID0gZHJhd1kgLSB0b3A7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGluZSB1cG9uIHdoaWNoIG1vc3QgbGV0dGVycyBcInNpdFwiIGFuZCBiZWxvdyB3aGljaCBkZXNjZW5kZXIgZXh0ZW5kLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5iYXNlbGluZSA9IGJhc2VMaW5lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0geSBwb3NpdGlvbiBmb3IgdGhlIGxvd2VzdCBnbHlwaCBpbiB0aGUgZm9udC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm90dG9tID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlY29tbWVuZGVkIGRpc3RhbmNlIGFib3ZlIHRoZSBtZWFuIGxpbmUgKHRvcCBvZiBsb3dlciBjYXNlIGNoYXJhY3RlcnMpIGZvciBzaW5nbGVkIHNwYWNlZCB0ZXh0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5hc2NlbnQgPSBiYXNlTGluZSAtIHhIZWlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVjb21tZW5kZWQgZGlzdGFuY2UgYmVsb3cgdGhlIGJhc2VsaW5lIGZvciBzaW5nbGVkIHNwYWNlZCB0ZXh0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXNjZW50ID0gaGVpZ2h0IC0gYmFzZUxpbmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJhc2VsaW5lIGFuZCB0aGUgbWVhbiBsaW5lIG9mIGxvd2VyLWNhc2UgbGV0dGVycywgaS5lIGhlaWdodCBvZiBgeGAgY2hhcmFjdGVyLlxyXG4gICAgICAqIEBwdWJsaWNcclxuICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAqL1xyXG4gICAgdGhpcy54SGVpZ2h0ID0geEhlaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgYSBjYXBpdGFsIGxldHRlciBhYm92ZSB0aGUgYmFzZWxpbmUuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNhcEhlaWdodCA9IGJhc2VMaW5lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9zZXRzIGlmIE9mZnNjcmVlbkNhbnZhcyBzaG91bGQgYmUgdXNlZCB0byBtZWFzdXJlIHRleHQgd2lkdGguIFVzZWZ1bGwgd2hlbiBydW5uaW5nIEJsYWNrIEVuZ2luZSBpbnNpZGUgd29ya2VyLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgdXNlT2Zmc2NyZWVuQ2FudmFzKCkge1xyXG4gICAgcmV0dXJuIHVzZU9mZnNjcmVlbkNhbnZhcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzdGF0aWMgc2V0IHVzZU9mZnNjcmVlbkNhbnZhcyh2YWx1ZSkge1xyXG4gICAgdXNlT2Zmc2NyZWVuQ2FudmFzID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBgY2FwSGVpZ2h0YCBub3JtYWxpemVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGNhcEhlaWdodE5vcm1hbGl6ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jYXBIZWlnaHQgLyB0aGlzLm1TdHlsZS5zaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYHhIZWlnaHRgIG5vcm1hbGl6ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgeEhlaWdodE5vcm1hbGl6ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy54SGVpZ2h0IC8gdGhpcy5tU3R5bGUuc2l6ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGBhc2NlbnRgIG5vcm1hbGl6ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgYXNjZW50Tm9ybWFsaXplZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmFzY2VudCAvIHRoaXMubVN0eWxlLnNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBgZGVzY2VudGAgbm9ybWFsaXplZC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBkZXNjZW50Tm9ybWFsaXplZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRlc2NlbnQgLyB0aGlzLm1TdHlsZS5zaXplO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYGJhc2VsaW5lYCBub3JtYWxpemVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGJhc2VsaW5lTm9ybWFsaXplZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJhc2VsaW5lIC8gdGhpcy5tU3R5bGUuc2l6ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGBib3R0b21gIG5vcm1hbGl6ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgYm90dG9tTm9ybWFsaXplZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJvdHRvbSAvIHRoaXMubVN0eWxlLnNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1VpbnQ4Q2xhbXBlZEFycmF5fSBkYXRhXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfX2dldFRvcChkYXRhKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMywgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgaSArPSA0KSB7XHJcbiAgICAgIGlmIChkYXRhW2ldID4gMCkge1xyXG4gICAgICAgIHJldHVybiAoaSAtIDMpIC8gNDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhLmxlbmd0aCAvIDQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1VpbnQ4Q2xhbXBlZEFycmF5fSBkYXRhXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfX2dldEJvdHRvbShkYXRhKSB7XHJcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID4gMDsgaSAtPSA0KSB7XHJcbiAgICAgIGlmIChkYXRhW2ldID4gMCkge1xyXG4gICAgICAgIHJldHVybiAoaSArIDEpIC8gNDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2YgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnROYW1lIE5hbWUgb2YgZm9udC5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkZvbnRNZXRyaWNzfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQoZm9udE5hbWUpIHtcclxuICAgIGxldCBjYWNoZSA9IENBQ0hFW2ZvbnROYW1lXTtcclxuXHJcbiAgICBpZiAoY2FjaGUgPT0gbnVsbCkge1xyXG4gICAgICBsZXQgc3R5bGUgPSBuZXcgVGV4dFN0eWxlKGZvbnROYW1lLCAwLCAyNCk7XHJcbiAgICAgIGNhY2hlID0gbmV3IEZvbnRNZXRyaWNzKHN0eWxlKTtcclxuICAgICAgQ0FDSEVbZm9udE5hbWVdID0gY2FjaGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNhY2hlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgdGV4dCBtZWFzdXJlbWVudCByZXN1bHQuXHJcbiAqIFxyXG4gKiBAY2F0IGRpc3BsYXkudGV4dFxyXG4gKi9cclxuY2xhc3MgVGV4dE1ldHJpY3NEYXRhIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIFRleHRTZWdtZW50TWV0cmljc0RhdGEgb2JqZWN0cyBjb250YWluaW5nIHN0eWxlLCBib3VuZHMgYW5kIG90aGVyIG1ldHJpY3MgaW5mb3JtYXRpb24gZm9yIGVhY2ggc2VnbWVudCxcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+VGV4dFNlZ21lbnRNZXRyaWNzRGF0YT59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VnbWVudHMgPSBbXTsgLy8gVGV4dFBhcnRNZXRyaWNzRGF0YVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN1bSBib3VuZHMsIGluY2x1ZGluZyBhbGwgc2VnbWVudHMuXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCb3VuZHMgcGx1cyBzdHJva2Ugc2l6ZS5cclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0cm9rZUJvdW5kcyA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCb3VuZHMgb2YgdGV4dCBzaGFkb3cuXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaGFkb3dCb3VuZHMgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgaWYgd2lkdGhzIGZvciBlYWNoIGxpbmUuXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lV2lkdGggPSBbXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHRleHQgc2VnbWVudCBtZWFzdXJlbWVudCByZXN1bHQuXHJcbiAqIFxyXG4gKiBAY2F0IGRpc3BsYXkudGV4dFxyXG4gKi9cclxuY2xhc3MgVGV4dFNlZ21lbnRNZXRyaWNzRGF0YSB7XHJcbiAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIGxpbmVJbmRleCwgYm91bmRzKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXh0IHZhbHVlIGZvciB0aGlzIHNlZ21lbnQuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHN0eWxlIG9mIHRoaXMgc2VnbWVudC5cclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VGV4dFN0eWxlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGluZSBpbmRleCBmb3IgdGhpcyBzZWdtZW50LlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lSW5kZXggPSBsaW5lSW5kZXg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYm91bmRzIG9mIHRoaXMgc2VnbWVudC5cclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEB0eXBlIHtIVE1MRWxlbWVudHxFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5sZXQgY2FudmFzRWxlbWVudCA9IG51bGw7XHJcbmxldCBjb250ZXh0ID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBuYXRpdmUgdGV4dCBtZWFzdXJlbWVudCB0b29sc1xyXG4gKiBcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICogQHN0YXRpY1xyXG4gKi9cclxuY2xhc3MgVGV4dE1ldHJpY3NFeCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpbmdsZXRvbicpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWVhc3VyZXMgdGhlIGFyZWEgb2YgcHJvdmlkZWQgdGV4dC4gSW4gY2FzZSBzdHlsZSBpcyBub3QgZGVmaW5lZCB0aGUgZGVmYXVsdCBzdHlsZSB3aWxsIGJlIHVzZWQuIFRleHQgaXMgdmVydGljYWxseVxyXG4gICAqIGFsaWduZWQgYnkgaXRzIGJhc2VsaW5lLiBcclxuICAgKiBcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHRleHQgdG8gbWVhc3VyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUhlaWdodCAgICAgICAgICAgICAgICAgICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBsaW5lLlxyXG4gICAqIEBwYXJhbSB7Li4uYmxhY2stZW5naW5lflRleHRTdHlsZX0gc3R5bGVzIFRoZSBUZXh0U3R5bGUgb2JqZWN0IHJlcHJlc2VudGluZyB0ZXh0IHByb3BlcnRpZXMgYW5kIGZvcm1hdHRpbmcuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5UZXh0TWV0cmljc0RhdGF9IE9iamVjdCByZXByZXNlbnRpbmcgYm91bmRzIGZvciBlYWNoIHJpY2ggdGV4dCBwYXJ0LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBtZWFzdXJlKHRleHQsIGxpbmVIZWlnaHQsIC4uLnN0eWxlcykge1xyXG4gICAgbGV0IHBhcnRzID0gW107XHJcblxyXG4gICAgY29uc3QgcmVnZXggPSAvKH57KFtefV0rKX18XikoLis/KD89fnsuK318JHxeKSl8KFxcbikvZ207XHJcblxyXG4gICAgbGV0IG07XHJcbiAgICBsZXQgY3VyclRhZyA9ICdkZWYnO1xyXG4gICAgbGV0IGxpbmVJeCA9IDA7XHJcblxyXG4gICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgICAgaWYgKG1bNF0pXHJcbiAgICAgICAgbGluZUl4Kys7XHJcblxyXG4gICAgICBpZiAobVsyXSlcclxuICAgICAgICBjdXJyVGFnID0gbVsyXTtcclxuXHJcbiAgICAgIGlmIChtWzNdKVxyXG4gICAgICAgIHBhcnRzLnB1c2goeyB0YWc6IGN1cnJUYWcsIHRleHQ6IG1bM10sIHN0eWxlOiBzdHlsZXMuZmlsdGVyKHggPT4geC5uYW1lID09PSBjdXJyVGFnKVswXSwgbGluZUluZGV4OiBsaW5lSXggfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGEgPSBuZXcgVGV4dE1ldHJpY3NEYXRhKCk7XHJcbiAgICBsZXQgZGVmYXVsdFN0eWxlID0gc3R5bGVzLmZpbHRlcih4ID0+IHgubmFtZSA9PT0gJ2RlZicpWzBdIHx8IFRleHRTdHlsZS5kZWZhdWx0O1xyXG4gICAgbGV0IGxpbmVIZWlnaHRQeCA9IGRlZmF1bHRTdHlsZS5zaXplICogbGluZUhlaWdodDtcclxuICAgIGxldCBzdW1Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcbiAgICBsZXQgc3VtU3Ryb2tlQm91bmRzID0gbmV3IFJlY3RhbmdsZSgpO1xyXG4gICAgbGV0IHN1bVNoYWRvd0JvdW5kcyA9IG51bGw7XHJcblxyXG4gICAgbGV0IGxhc3RMaW5lSW5kZXggPSAtMTtcclxuICAgIGxldCBjdXJyZW50WCA9IDA7XHJcbiAgICBsZXQgY3VycmVudFkgPSAwO1xyXG5cclxuICAgIGxldCBkZWZhdWx0Rm9udE1ldHJpY3MgPSBGb250TWV0cmljcy5nZXQoZGVmYXVsdFN0eWxlLmZhbWlseSk7XHJcbiAgICBsZXQgZGVmYXVsdEJhc2VsaW5lID0gZGVmYXVsdEZvbnRNZXRyaWNzLmJhc2VsaW5lTm9ybWFsaXplZCAqIGRlZmF1bHRTdHlsZS5zaXplO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcclxuICAgICAgbGV0IHN0eWxlID0gcGFydC5zdHlsZTtcclxuICAgICAgbGV0IGJvdW5kcyA9IFRleHRNZXRyaWNzRXguX19tZWFzdXJlKHBhcnQudGV4dCwgc3R5bGUpO1xyXG4gICAgICBsZXQgYmFzZWxpbmUgPSBGb250TWV0cmljcy5nZXQoc3R5bGUuZmFtaWx5KS5iYXNlbGluZU5vcm1hbGl6ZWQgKiBzdHlsZS5zaXplO1xyXG5cclxuICAgICAgaWYgKGxhc3RMaW5lSW5kZXggIT09IHBhcnQubGluZUluZGV4KSB7XHJcbiAgICAgICAgZGF0YS5saW5lV2lkdGhbcGFydC5saW5lSW5kZXhdID0gMDtcclxuICAgICAgICBjdXJyZW50WCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1cnJlbnRZID0gKGxpbmVIZWlnaHRQeCAqIHBhcnQubGluZUluZGV4KSArIGRlZmF1bHRCYXNlbGluZSAtIGJhc2VsaW5lO1xyXG5cclxuICAgICAgYm91bmRzLnggPSBjdXJyZW50WCArIDI7XHJcbiAgICAgIGJvdW5kcy55ID0gY3VycmVudFkgKyAyO1xyXG5cclxuICAgICAgY3VycmVudFggKz0gYm91bmRzLndpZHRoO1xyXG5cclxuICAgICAgbGFzdExpbmVJbmRleCA9IHBhcnQubGluZUluZGV4O1xyXG5cclxuICAgICAgcGFydC5ib3VuZHMgPSBib3VuZHM7XHJcbiAgICAgIGRhdGEubGluZVdpZHRoW3BhcnQubGluZUluZGV4XSArPSBib3VuZHMud2lkdGg7XHJcblxyXG4gICAgICBzdW1Cb3VuZHMudW5pb24oYm91bmRzKTtcclxuICAgICAgc3VtU3Ryb2tlQm91bmRzLnVuaW9uKGJvdW5kcy5jbG9uZSgpLmluZmxhdGUoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzLCBzdHlsZS5zdHJva2VUaGlja25lc3MpKTtcclxuXHJcbiAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93ID09PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IHNoYWRvd0JvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xyXG4gICAgICAgIHNoYWRvd0JvdW5kcy5pbmZsYXRlKHN0eWxlLnNoYWRvd0JsdXIsIHN0eWxlLnNoYWRvd0JsdXIpO1xyXG4gICAgICAgIHNoYWRvd0JvdW5kcy54ICs9IHN0eWxlLnNoYWRvd0Rpc3RhbmNlWDtcclxuICAgICAgICBzaGFkb3dCb3VuZHMueSArPSBzdHlsZS5zaGFkb3dEaXN0YW5jZVk7XHJcbiAgICAgICAgc3VtU2hhZG93Qm91bmRzID0gc3VtU2hhZG93Qm91bmRzIHx8IHNoYWRvd0JvdW5kcztcclxuICAgICAgICBzdW1TaGFkb3dCb3VuZHMudW5pb24oc2hhZG93Qm91bmRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YS5zZWdtZW50cy5wdXNoKG5ldyBUZXh0U2VnbWVudE1ldHJpY3NEYXRhKHBhcnQudGV4dCwgc3R5bGUsIHBhcnQubGluZUluZGV4LCBwYXJ0LmJvdW5kcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGEuYm91bmRzID0gc3VtQm91bmRzO1xyXG4gICAgZGF0YS5zdHJva2VCb3VuZHMgPSBzdW1TdHJva2VCb3VuZHM7XHJcbiAgICBkYXRhLnNoYWRvd0JvdW5kcyA9IHN1bVNoYWRvd0JvdW5kcyB8fCBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZWFzdXJlcyB0aGUgYXJlYSBvZiBwcm92aWRlZCB0ZXh0LiBNdWx0aWxpbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICAgKiBcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgICAgICAgICBUaGUgdGV4dCB0byBtZWFzdXJlLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflRleHRTdHlsZX0gc3R5bGUgICAgIFRoZSBUZXh0U3R5bGUgb2JqZWN0IHJlcHJlc2VudGluZyB0ZXh0IHByb3BlcnRpZXMgYW5kIGZvcm1hdHRpbmcuXHJcbiAgICogQHBhcmFtIHs/YmxhY2stZW5naW5lflJlY3RhbmdsZX0gW291dEJvdW5kcz1udWxsXSBPdXQgcGFyYW0gaW50byB3aGljaCBib3VuZHMgb2YgdGhlIHRleHQgd2lsbCBiZSBzdG9yZWQuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IEJvdW5kcyBvZiB0aGUgdGV4dDtcclxuICAgKi9cclxuICBzdGF0aWMgX19tZWFzdXJlKHRleHQsIHN0eWxlLCBvdXRCb3VuZHMgPSBudWxsKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoc3R5bGUgIT0gbnVsbCwgJ1N0eWxlIGNhbm5vdCBiZSBudWxsJyk7XHJcblxyXG4gICAgb3V0Qm91bmRzID0gb3V0Qm91bmRzIHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuICAgIG91dEJvdW5kcy56ZXJvKCk7XHJcblxyXG4gICAgbGV0IGZvbnRNZXRyaWNzID0gRm9udE1ldHJpY3MuZ2V0KHN0eWxlLmZhbWlseSk7XHJcblxyXG4gICAgaWYgKGNhbnZhc0VsZW1lbnQgPT09IG51bGwpIHtcclxuICAgICAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIEZvbnRNZXRyaWNzLnVzZU9mZnNjcmVlbkNhbnZhcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIHRoaXMgaXMgb25seSBmb3Igd29ya2VyXHJcbiAgICAgICAgY2FudmFzRWxlbWVudCA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBleHRyYVggPSAwO1xyXG4gICAgaWYgKHN0eWxlLnN0eWxlID09PSBGb250U3R5bGUuSVRBTElDKVxyXG4gICAgICBleHRyYVggPSAoZm9udE1ldHJpY3MuYm90dG9tTm9ybWFsaXplZCAqIHN0eWxlLnNpemUpIC8gNDtcclxuXHJcbiAgICBjb250ZXh0LmZvbnQgPSBgJHtzdHlsZS53ZWlnaHR9ICR7c3R5bGUuc3R5bGV9ICR7c3R5bGUuc2l6ZX1weCAke3N0eWxlLmZhbWlseX1gO1xyXG4gICAgbGV0IHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGgpO1xyXG5cclxuICAgIHJldHVybiBvdXRCb3VuZHMuc2V0KDAsIGZvbnRNZXRyaWNzLmJhc2VsaW5lTm9ybWFsaXplZCAqIHN0eWxlLnNpemUsIHdpZHRoICsgMiArIGV4dHJhWCwgZm9udE1ldHJpY3MuYm90dG9tTm9ybWFsaXplZCAqIHN0eWxlLnNpemUgKyAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lYXN1cmVzIHRoZSBhcmVhIG9mIHByb3ZpZGVkIHRleHRcclxuICAgKiBcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Qml0bWFwRm9udERhdGF9IGRhdGEgXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVIZWlnaHQgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBvdXRCb3VuZHMgXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9XHJcbiAgICovXHJcbiAgc3RhdGljIG1lYXN1cmVCaXRtYXAodGV4dCwgZGF0YSwgbGluZUhlaWdodCwgb3V0Qm91bmRzKSB7XHJcbiAgICBvdXRCb3VuZHMgPSBvdXRCb3VuZHMgfHwgbmV3IFJlY3RhbmdsZSgpO1xyXG5cclxuICAgIGxldCBwcmV2Q2hhckNvZGUgPSAtMTtcclxuICAgIGxldCBjeCA9IDA7XHJcbiAgICBsZXQgY3kgPSAwO1xyXG5cclxuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xyXG4gICAgbGV0IG1heFdpZHRoID0gMDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgaWYgKC8oPzpcXHJcXG58XFxyfFxcbikvLnRlc3QodGV4dC5jaGFyQXQoaSkpKSB7XHJcbiAgICAgICAgY3ggPSAwO1xyXG4gICAgICAgIGN5ICs9IGRhdGEubGluZUhlaWdodCAqIGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgcHJldkNoYXJDb2RlID0gLTE7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjaGFyRGF0YSA9IGRhdGEuY2hhcnNbY2hhckNvZGVdO1xyXG5cclxuICAgICAgaWYgKGNoYXJEYXRhID09IG51bGwpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBpZiAocHJldkNoYXJDb2RlID49IDAgJiYgY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdKVxyXG4gICAgICAgIGN4ICs9IGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXTtcclxuXHJcbiAgICAgIGN4ICs9IGNoYXJEYXRhLnhBZHZhbmNlO1xyXG5cclxuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgY3ggKyBjaGFyRGF0YS54T2Zmc2V0KTtcclxuICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBjeSArIGNoYXJEYXRhLmhlaWdodCArIGNoYXJEYXRhLnlPZmZzZXQpO1xyXG5cclxuICAgICAgcHJldkNoYXJDb2RlID0gY2hhckNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dEJvdW5kcy5zZXQoMCwgMCwgbWF4V2lkdGgsIG1heEhlaWdodCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgdGltZSByZWxhdGVkIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBjYXQgY29yZVxyXG4gKiBcclxuICogQHN0YXRpY1xyXG4gKi9cclxuY2xhc3MgVGltZSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQWN0dWFsVGltZSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EZWx0YVRpbWVNcyA9IDEwMDAgLyA2MDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubURlbHRhVGltZSA9ICgxMDAwIC8gNjApICogMC4wMDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TY2FsZSA9IDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BbHBoYVRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmVuZGVyT2Zmc2V0ID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWUgc2luY2Ugc3RhcnQgaW4gc2Vjb25kcy5cclxuICAgKiBcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbm93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaW1lIHNpbmNlIGxhc3QgZnJhbWUuXHJcbiAgICogXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGR0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlbHRhVGltZSAqIHRoaXMubVNjYWxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cclxuICAgKiBcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgYWxwaGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQWxwaGFUaW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZSBzaW5jZSBsYXN0IGZyYW1lLlxyXG4gICAqIFxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBkZWx0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWx0YVRpbWUgKiB0aGlzLm1TY2FsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aW1lc2NhbGUgZm9yIGVuZ2luZVxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNjYWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNjYWxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0IHNjYWxlKHZhbHVlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodmFsdWUgPj0gMCwgJ1RpbWUgc2NhbGUgbXVzdCBiZSA+PSAwLicpO1xyXG5cclxuICAgIHRoaXMubVNjYWxlID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgY3VzdG9tIHN5c3RlbXMuIFN5c3RlbSBpcyB1c2VkIHRvIGxpc3RlbiBzY2VuZSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBAY2F0IGNvcmVcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyXHJcbiAqL1xyXG5jbGFzcyBTeXN0ZW0gZXh0ZW5kcyBNZXNzYWdlRGlzcGF0Y2hlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gZW5naW5lIGlzIHBhdXNlZC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJuIHt2b2lkfSBcclxuICAgKi9cclxuICBvblBhdXNlKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGVuZ2luZSBpcyByZXN1bWVkLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm4ge3ZvaWR9IFxyXG4gICAqL1xyXG4gIG9uUmVzdW1lKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG9uVXBkYXRlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybiB7dm9pZH0gXHJcbiAgICovXHJcbiAgb25VcGRhdGUoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogb25Qb3N0VXBkYXRlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvblBvc3RVcGRhdGUoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogb25SZW5kZXJcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uUmVuZGVyKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG9uQ2hpbGRyZW5BZGRlZFxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGdhbWVPYmplY3QgR2FtZU9iamVjdCBpbnN0YW5jZS5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uQ2hpbGRyZW5BZGRlZChnYW1lT2JqZWN0KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogb25DaGlsZHJlblJlbW92ZWRcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0IEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvbkNoaWxkcmVuUmVtb3ZlZChnYW1lT2JqZWN0KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogb25DaGlsZHJlblJlbW92ZWRcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0IEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvbkNoaWxkcmVuQ2hhbmdlZChnYW1lT2JqZWN0KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogb25Db21wb25lbnRBZGRlZFxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IGluc3RhbmNlIGFkZGVkIHRvIGdhbWUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9IFxyXG4gICAqL1xyXG4gIG9uQ29tcG9uZW50QWRkZWQoY2hpbGQsIGNvbXBvbmVudCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG9uQ29tcG9uZW50UmVtb3ZlZFxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IGluc3RhbmNlIHJlbW92ZWQgZnJvbSBnYW1lIG9iamVjdC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uQ29tcG9uZW50UmVtb3ZlZChjaGlsZCwgY29tcG9uZW50KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcG9zZXMgYWxsIGFsbG9jYXRlZCByZXNvdXJjZXMuXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHsgfVxyXG59XHJcblxyXG4vKipcclxuICogT3JpZW50YXRpb25cclxuICogQGNhdCBkaXNwbGF5XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqL1xyXG5jb25zdCBPcmllbnRhdGlvbiA9IHtcclxuICAvKiogQXV0b21hdGljYWxseSBkZXRlY3RzIG9yaWVudGF0aW9uIGFuZCBzd2l0Y2hlcyB3aWR0aCBhbmQgaGVpZ2h0IGRlcGVuZGluZyBvbiBkZXZpY2Ugb3JpZW50YXRpb24uICovXHJcbiAgVU5JVkVSU0FMOiAndW5pdmVyc2FsJyxcclxuICBMQU5EU0NBUEU6ICdsYW5kc2NhcGUnLFxyXG4gIFBPUlRSQUlUOiAncG9ydHJhaXQnXHJcbn07XHJcblxyXG4vKipcclxuICogTWFuYWdlcyB2aWV3cG9ydCwgaGFuZGxlcyBET00gY29udGFpbmVyIHJlc2l6ZSBldmVudHMgYW5kIHVwZGF0ZXMgaW50ZXJuYWwgZGF0YS5cclxuICogV2hlbiBmaXJpbmcgYHJlc2l6ZWAgZXZlbnQgc3RhZ2UgYm91bmRzIHdpbGwgYmUgbm90IHVwIHRvIGRhdGUuIExpc3RlbiBmb3Igc3RhZ2UncyBgcmVzaXplYCBtZXNzYWdlIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBjYXQgY29yZVxyXG4gKiBAZmlyZXMgVmlld3BvcnQjcmVzaXplXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5NZXNzYWdlRGlzcGF0Y2hlclxyXG4gKi9cclxuY2xhc3MgVmlld3BvcnQgZXh0ZW5kcyBNZXNzYWdlRGlzcGF0Y2hlciB7XHJcbiAgLyoqXHJcbiAgICogY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fG51bGx9IGNvbnRhaW5lckVsZW1lbnQgVGhlIG5hdGl2ZSBIVE1MIGVsZW1lbnQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbGVtZW50ID0gbnVsbCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lckVsZW1lbnQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RWxlbWVudHxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVmlld3BvcnRFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU2l6ZSA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNoZWNrc0xlZnRTZWNvbmRzID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+T3JpZW50YXRpb259IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1PcmllbnRhdGlvbiA9IE9yaWVudGF0aW9uLlVOSVZFUlNBTDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tT3JpZW50YXRpb25Mb2NrID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUm90YXRpb24gPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc1ByaW1hcnkgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmVmbGVjdCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQm91bmRSZXNpemU7XHJcblxyXG4gICAgdGhpcy5fX2luaXRpYWxpemUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cclxuICBfX2luaXRpYWxpemUoKSB7XHJcbiAgICB0aGlzLm1WaWV3cG9ydEVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xyXG4gICAgdGhpcy5tVmlld3BvcnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgIHRoaXMubUNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5tVmlld3BvcnRFbGVtZW50KTtcclxuXHJcbiAgICBsZXQgc3R5bGUgPSB0aGlzLm1Db250YWluZXJFbGVtZW50LnN0eWxlO1xyXG4gICAgc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcclxuICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgc3R5bGUuY3Vyc29yID0gJ2F1dG8nO1xyXG4gICAgc3R5bGUuV2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IgPSAncmdiYSgwLCAwLCAwLCAwKSc7XHJcblxyXG4gICAgbGV0IHNpemUgPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdGhpcy5tU2l6ZS5zZXQoc2l6ZS5sZWZ0LCBzaXplLnRvcCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xyXG5cclxuICAgIHRoaXMubUlzUHJpbWFyeSA9IHRoaXMuaXNQcmltYXJ5KCk7XHJcblxyXG4gICAgdGhpcy5fX29uUmVzaXplKCk7XHJcblxyXG4gICAgdGhpcy5tQm91bmRSZXNpemUgPSB4ID0+IHRoaXMuX19vblJlc2l6ZSgpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMubUJvdW5kUmVzaXplKTtcclxuICB9XHJcblxyXG4gIGlzUHJpbWFyeSgpIHtcclxuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gc2NyZWVuLm1zT3JpZW50YXRpb24gfHwgKHNjcmVlbi5vcmllbnRhdGlvbiB8fCBzY3JlZW4ubW96T3JpZW50YXRpb24gfHwge30pLnR5cGU7XHJcblxyXG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAnbGFuZHNjYXBlLXByaW1hcnknIHx8IG9yaWVudGF0aW9uID09PSAncG9ydHJhaXQtcHJpbWFyeScpXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUtc2Vjb25kYXJ5JyB8fCBvcmllbnRhdGlvbiA9PT0gJ3BvcnRyYWl0LXNlY29uZGFyeScpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBEZWJ1Zy53YXJuKCdUaGUgb3JpZW50YXRpb24gQVBJIGlzblxcJ3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHN0YWdlIG9yaWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5PcmllbnRhdGlvbn1cclxuICAgKi9cclxuICBnZXQgb3JpZW50YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tT3JpZW50YXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5PcmllbnRhdGlvbn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgb3JpZW50YXRpb24odmFsdWUpIHtcclxuICAgIHRoaXMubU9yaWVudGF0aW9uID0gdmFsdWU7XHJcbiAgICB0aGlzLl9fb25SZXNpemUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyB3aGVuZXZlciBzdGFnZSBvcmllbnRhdGlvbiBzaG91bGQgYmUgbG9ja2VkLiBJZiBmYWxzZSBhbmQgb3JpZW50YXRpb24gaXMgbm90IHVuaXZlcnNhbCBzdGFnZSB3aWxsIHJlbWFpbiBzYW1lIHNpemUgaW4gYm90aCBvcmllbnRhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgb3JpZW50YXRpb25Mb2NrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubU9yaWVudGF0aW9uTG9jaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgb3JpZW50YXRpb25Mb2NrKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1PcmllbnRhdGlvbkxvY2sgPSB2YWx1ZTtcclxuICAgIHRoaXMuX19vblJlc2l6ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAaWdub3JlXHJcbiAgICovXHJcbiAgX191cGRhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5tQ2hlY2tzTGVmdFNlY29uZHMgPD0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuX19vblJlc2l6ZSgpO1xyXG5cclxuICAgIHRoaXMubUNoZWNrc0xlZnRTZWNvbmRzIC09IEJsYWNrLnRpbWUuZGVsdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoZXMgdmlld3BvcnQgc2l6ZSBhbmQgcG9zdHMgTWVzc2FnZS5SRVNJWkUgbWVzc2FnZS4gTWFrZSBzdXJlIHRvIHJlZnJlc2ggc3RhZ2UgdG9vIGluIGNhc2UgY29udGFpbmVyIGhhcyBjaGFuZ2VkIGl0cyBzaXplLlxyXG4gICAqL1xyXG4gIHJlZnJlc2goKSB7XHJcbiAgICB0aGlzLl9fb25SZXNpemUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGlnbm9yZVxyXG4gICAqL1xyXG4gIF9fb25SZXNpemUoKSB7XHJcbiAgICBjb25zdCB2aWV3cG9ydEVsZW1lbnRTdHlsZSA9IHRoaXMubVZpZXdwb3J0RWxlbWVudC5zdHlsZTtcclxuICAgIGNvbnN0IHNpemUgPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZGV2aWNlT3JpZW50YXRpb24gPSBzaXplLndpZHRoID4gc2l6ZS5oZWlnaHQgPyBPcmllbnRhdGlvbi5MQU5EU0NBUEUgOiBPcmllbnRhdGlvbi5QT1JUUkFJVDtcclxuXHJcbiAgICBjb25zdCBkaXNwYXRjaFNpemUgPSBSZWN0YW5nbGUucG9vbC5nZXQoKS5jb3B5RnJvbShzaXplKTtcclxuICAgIGNvbnN0IHdhc1ByaW1hcnkgPSB0aGlzLm1Jc1ByaW1hcnk7XHJcbiAgICB0aGlzLm1Jc1ByaW1hcnkgPSB0aGlzLmlzUHJpbWFyeSgpO1xyXG5cclxuICAgIGlmICh0aGlzLm1Jc1ByaW1hcnkgIT09IHdhc1ByaW1hcnkpXHJcbiAgICAgIHRoaXMubVJlZmxlY3QgPSAhdGhpcy5tUmVmbGVjdDtcclxuXHJcbiAgICBpZiAodGhpcy5tT3JpZW50YXRpb25Mb2NrICYmIHRoaXMubU9yaWVudGF0aW9uICE9PSBkZXZpY2VPcmllbnRhdGlvbikge1xyXG4gICAgICB0aGlzLm1Sb3RhdGlvbiA9IHRoaXMubVJlZmxlY3QgPyAtMSA6IDE7XHJcblxyXG4gICAgICB2aWV3cG9ydEVsZW1lbnRTdHlsZS50cmFuc2Zvcm0gPSB0aGlzLm1SZWZsZWN0ID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJztcclxuICAgICAgdmlld3BvcnRFbGVtZW50U3R5bGUubGVmdCA9IChzaXplLndpZHRoIC0gc2l6ZS5oZWlnaHQpICogMC41ICsgJ3B4JztcclxuICAgICAgdmlld3BvcnRFbGVtZW50U3R5bGUudG9wID0gKHNpemUuaGVpZ2h0IC0gc2l6ZS53aWR0aCkgKiAwLjUgKyAncHgnO1xyXG4gICAgICB2aWV3cG9ydEVsZW1lbnRTdHlsZS53aWR0aCA9IHNpemUuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgdmlld3BvcnRFbGVtZW50U3R5bGUuaGVpZ2h0ID0gc2l6ZS53aWR0aCArICdweCc7XHJcblxyXG4gICAgICBkaXNwYXRjaFNpemUud2lkdGggPSBzaXplLmhlaWdodDtcclxuICAgICAgZGlzcGF0Y2hTaXplLmhlaWdodCA9IHNpemUud2lkdGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1Sb3RhdGlvbiA9IDA7XHJcblxyXG4gICAgICB0aGlzLm1SZWZsZWN0ID0gZmFsc2U7XHJcbiAgICAgIHZpZXdwb3J0RWxlbWVudFN0eWxlLnRyYW5zZm9ybSA9ICdyb3RhdGUoMGRlZyknO1xyXG4gICAgICB2aWV3cG9ydEVsZW1lbnRTdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgIHZpZXdwb3J0RWxlbWVudFN0eWxlLnRvcCA9ICcwcHgnO1xyXG4gICAgICB2aWV3cG9ydEVsZW1lbnRTdHlsZS53aWR0aCA9IHNpemUud2lkdGggKyAncHgnO1xyXG4gICAgICB2aWV3cG9ydEVsZW1lbnRTdHlsZS5oZWlnaHQgPSBzaXplLmhlaWdodCArICdweCc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubVNpemUuZXF1YWxzKGRpc3BhdGNoU2l6ZSkgPT09IHRydWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1TaXplLmNvcHlGcm9tKGRpc3BhdGNoU2l6ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0ZWQgZXZlcnkgdGltZSB2aWV3cG9ydCBzaXplIGhhcyBjaGFuZ2VkLlxyXG4gICAgICogQGV2ZW50IFZpZXdwb3J0I3Jlc2l6ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5SRVNJWkUsIGRpc3BhdGNoU2l6ZSk7XHJcblxyXG4gICAgdGhpcy5tQ2hlY2tzTGVmdFNlY29uZHMgPSAxO1xyXG4gICAgUmVjdGFuZ2xlLnBvb2wucmVsZWFzZShkaXNwYXRjaFNpemUpO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMubVZpZXdwb3J0RWxlbWVudC5yZW1vdmUoKTtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm1Cb3VuZFJlc2l6ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIGEgdmlld3BvcnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIGdldCBzaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBIVE1MIGNvbnRhaW5lciBlbGVtZW50IHRoZSB2aWV3cG9ydCBydW5zIGluLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKi9cclxuICBnZXQgbmF0aXZlRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1WaWV3cG9ydEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHZpZXdwb3J0IG9yaWVudGF0aW9uLiBcclxuICAgKiBcclxuICAgKiAtMSBpcyBmb3IgLTkwIGRlZ3JlZXNcclxuICAgKiAwIGlzIGZvciAwIGRlZ3JlZXNcclxuICAgKiAxIGlzIGZvciA5MCBkZWdyZWVzXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcm90YXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUm90YXRpb247XHJcbiAgfVxyXG4gIC8vIFRPRE86IGRpc3Bvc2UsIHJlbW92ZSByZXNpemUgZXZlbnRcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGRldmljZSBpcyBpbiBsYW5kc2NhcGUgb3JpZW50YXRpb24uXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc0xhbmRzY2FwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnNpemUud2lkdGggPj0gdGhpcy5zaXplLmhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBkZXZpY2UgaXMgaW4gcG9ydHJhaXQgb3JpZW50YXRpb24uXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc1BvcnRyYWl0KCkge1xyXG4gICAgcmV0dXJuICF0aGlzLmlzTGFuZHNjYXBlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBpZ25vcmVcclxuICogQHR5cGUge251bWJlcn1cclxuICovXHJcbmxldCBJRCA9IDA7XHJcblxyXG4vKipcclxuICogQSBiYXNlIGNsYXNzIGZvciBjdXN0b20gY29tcG9uZW50cy5cclxuICpcclxuICogQGNhdCBjb3JlXHJcbiAqIEB1bnJlc3RyaWN0ZWRcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBNZXNzYWdlRGlzcGF0Y2hlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ29tcG9uZW50IGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIodHJ1ZSk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSWQgPSArK0lEO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1HYW1lT2JqZWN0ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQWRkZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGVuZXZlciB0aGlzIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90LlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGF0dGFjaGVkIHRvIEdhbWVPYmplY3QuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGdhbWVPYmplY3QgVGhlIG93bmVyIG9mIHRoaXMgY29tcG9uZW50LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgb25BZGRlZChnYW1lT2JqZWN0KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gZGV0YWNoZWQgZnJvbSBHYW1lT2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0IFRoZSBvd25lciBvZiB0aGlzIGNvbXBvbmVudC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uUmVtb3ZlZChnYW1lT2JqZWN0KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIGF0IGV2ZXJ5IHVwZGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uVXBkYXRlKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBhZnRlciBhbGwgdXBkYXRlcyBoYXZlIGJlZW4gZXhlY3V0ZWQgYnV0IGJlZm9yZSBEaXNwbGF5T2JqZWN0J3Mgb25SZW5kZXIuIEdhbWVPYmplY3QgaXRzZWxmIGRvZXMgbm90IGhhdmUgb25SZW5kZXIgbWV0aG9kIHNvIENvbXBvbmVudCNvblJlbmRlciB3aWxsIG5vdCBiZSBjYWxsZWQgb24gR2FtZU9iamVjdHMuXHJcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gaW50ZXJwb2xhdGUvZXh0cmFwb2xhdGUgdmFsdWVzIHdoZW4gbG93IGBCbGFjayN1cHNgIHZhbHVlIGlzIHVzZWQuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvblJlbmRlcigpIHsgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyB0aGlzIENvbXBvbmVudCBmcm9tIGl0cyBwYXJlbnQgR2FtZU9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7XHJcbiAgICBpZiAodGhpcy5tR2FtZU9iamVjdCA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUdhbWVPYmplY3QucmVtb3ZlQ29tcG9uZW50KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvd25lciBvZiB0aGlzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH1cclxuICAgKi9cclxuICBnZXQgZ2FtZU9iamVjdCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1HYW1lT2JqZWN0O1xyXG4gIH1cclxuICBcclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgQ29tcG9uZW50IG93bmVyIEdhbWVPYmplY3QuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R8bnVsbH1cclxuICAgKi9cclxuICBnZXQgcGFyZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUdhbWVPYmplY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdGFnZSBHYW1lIE9iamVjdCB0byB3aGljaCB0aGlzIGNvbXBvbmVudCBiZWxvbmdzIHRvIG9yIG51bGwgaWYgbm90IG9uIHRoZSBzdGFnZS5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5TdGFnZXxudWxsfVxyXG4gICAqL1xyXG4gIGdldCBzdGFnZSgpIHtcclxuICAgIGlmICh0aGlzLm1HYW1lT2JqZWN0ID09PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tR2FtZU9iamVjdC5zdGFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGluZyBhIHVybCBsaWtlIHBhdGggdG8gdGhpcyBvYmplY3QgaW4gdGhlIGRpc3BsYXkgdHJlZS5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxyXG4gICAqL1xyXG4gIGdldCBwYXRoKCkge1xyXG4gICAgaWYgKHRoaXMubUdhbWVPYmplY3QgIT09IG51bGwpXHJcbiAgICAgIHJldHVybiB0aGlzLm1HYW1lT2JqZWN0LnBhdGggKyAnIycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGJsZW5kIG1vZGUgZW51bS5cclxuICogQGNhdCBkcml2ZXJzXHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBCbGVuZE1vZGUgPSB7XHJcbiAgLyoqIEluaGVyaXRzIGJsZW5kIG1vZGUgZnJvbSBwYXJlbnQgZGlzcGxheSBvYmplY3QgKi9cclxuICBBVVRPICAgICAgIDogJ2F1dG8nLFxyXG4gIE5PUk1BTCAgICAgOiAnbm9ybWFsJyxcclxuICBBREQgICAgICAgIDogJ2FkZCcsXHJcbiAgTVVMVElQTFkgICA6ICdtdWx0aXBseScsXHJcbiAgU0NSRUVOICAgICA6ICdzY3JlZW4nLFxyXG4gIE9WRVJMQVkgICAgOiAnb3ZlcmxheScsXHJcbiAgREFSS0VOICAgICA6ICdkYXJrZW4nLFxyXG4gIExJR0hURU4gICAgOiAnbGlnaHRlbicsXHJcbiAgQ09MT1JfRE9ER0U6ICdjb2xvckRvZGdlJyxcclxuICBDT0xPUl9CVVJOIDogJ2NvbG9yQnVybicsXHJcbiAgSEFSRF9MSUdIVCA6ICdoYXJkTGlnaHQnLFxyXG4gIFNPRlRfTElHSFQgOiAnc29mdExpZ2h0JyxcclxuICBESUZGRVJFTkNFIDogJ2RpZmZlcmVuY2UnLFxyXG4gIEVYQ0xVU0lPTiAgOiAnZXhjbHVzaW9uJyxcclxuICBIVUUgICAgICAgIDogJ2h1ZScsXHJcbiAgU0FUVVJBVEUgICA6ICdzYXR1cmF0ZScsXHJcbiAgQ09MT1IgICAgICA6ICdjb2xvcicsXHJcbiAgTFVNSU5PU0lUWSA6ICdsdW1pbm9zaXR5JyxcclxuICBNQVNLICAgICAgIDogJ21hc2snLFxyXG4gIE1BU0tfSU5WICAgOiAnbWFza0ludidcclxufTtcclxuXHJcbi8qKiBcclxuICogQHN0YXRpYyBcclxuICogQGNvbnN0YW50IFxyXG4gKiBAZGljdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgQ2FudmFzQmxlbmRNb2RlID0ge1xyXG4gICdhdXRvJyAgICAgICA6ICdhdXRvJyxcclxuICAnbm9ybWFsJyAgICAgOiAnc291cmNlLW92ZXInLFxyXG4gICdhZGQnICAgICAgICA6ICdsaWdodGVyJyxcclxuICAnbXVsdGlwbHknICAgOiAnbXVsdGlwbHknLFxyXG4gICdzY3JlZW4nICAgICA6ICdzY3JlZW4nLFxyXG4gICdvdmVybGF5JyAgICA6ICdvdmVybGF5JyxcclxuICAnZGFya2VuJyAgICAgOiAnZGFya2VuJyxcclxuICAnbGlnaHRlbicgICAgOiAnbGlnaHRlbicsXHJcbiAgJ2NvbG9yRG9kZ2UnIDogJ2NvbG9yLWRvZGdlJyxcclxuICAnY29sb3JCdXJuJyAgOiAnY29sb3ItYnVybicsXHJcbiAgJ2hhcmRMaWdodCcgIDogJ2hhcmQtbGlnaHQnLFxyXG4gICdzb2Z0TGlnaHQnICA6ICdzb2Z0LWxpZ2h0JyxcclxuICAnZGlmZmVyZW5jZScgOiAnZGlmZmVyZW5jZScsXHJcbiAgJ2V4Y2x1c2lvbicgIDogJ2V4Y2x1c2lvbicsXHJcbiAgJ2R1ZScgICAgICAgIDogJ2h1ZScsXHJcbiAgJ3NhdHVyYXRlJyAgIDogJ3NhdHVyYXRlJyxcclxuICAnY29sb3InICAgICAgOiAnY29sb3InLFxyXG4gICdsdW1pbm9zaXR5JyA6ICdsdW1pbm9zaXR5JyxcclxuICAnbWFzaycgICAgICAgOiAnc291cmNlLWluJyxcclxuICAnbWFza0ludicgICAgOiAnc291cmNlLW91dCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxubGV0IF9fSUQgPSAwO1xyXG5cclxuLyoqXHJcbiAqIEEgYmFzZSB0ZXh0dXJlIGNsYXNzLlxyXG4gKlxyXG4gKiBAY2F0IHRleHR1cmVzXHJcbiAqL1xyXG5jbGFzcyBUZXh0dXJlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0ZXh0dXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IG5hdGl2ZUVsZW1lbnQgVGhlIG5hdGl2ZSBlbGVtZW50IHRvIGdldCBpbWFnZSBkYXRhIGZyb20uXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlPX0gW3JlZ2lvbj1udWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBhcmVhIG9mIHRleHR1cmUgdG8gYmUgZHJhd24uXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlPX0gW3VudHJpbW1lZFJlZ2lvbj1udWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvcmlnaW5hbCBhcmVhIG9mIHRleHR1cmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbc2NhbGU9MV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW52ZXJ0ZWQgc2NhbGUgZmFjdG9yLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IFtyZWdpc3RyYXRpb25Qb2ludD1udWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IGFuY2hvciBmb3IgbmV3bHkgY3JlYXRlZCBzcHJpdGVzIHdpdGggdGhlIHRleHR1cmUuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlPX0gW3NsaWNlOWJvcmRlcnM9bnVsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgc2xpY2UgOSBncmlkIGZvciBuZXdseSBjcmVhdGVkIHNwcml0ZXMgd2l0aCB0aGUgdGV4dHVyZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihuYXRpdmVFbGVtZW50LCByZWdpb24gPSBudWxsLCB1bnRyaW1tZWRSZWdpb24gPSBudWxsLCBzY2FsZSA9IDEsIHJlZ2lzdHJhdGlvblBvaW50ID0gbnVsbCwgc2xpY2U5Ym9yZGVycyA9IG51bGwpIHtcclxuICAgIHRoaXMubUlkID0gKytfX0lEO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gKi9cclxuICAgIHRoaXMubU5hdGl2ZSA9IG5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gKi9cclxuICAgIHRoaXMubVZhbGlkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gKi9cclxuICAgIHRoaXMubVJlZ2lvbiA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSAqL1xyXG4gICAgdGhpcy5tVW50cmltbWVkUmVnaW9uID0gbmV3IFJlY3RhbmdsZSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubU5hdGl2ZVdpZHRoID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLm1OYXRpdmVIZWlnaHQgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubURpc3BsYXlXaWR0aCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5tRGlzcGxheUhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5tUmVuZGVyV2lkdGggPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubVJlbmRlckhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5tU2NhbGUgPSBzY2FsZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfG51bGx9ICovXHJcbiAgICB0aGlzLm1SZWdpc3RyYXRpb25Qb2ludCA9IHJlZ2lzdHJhdGlvblBvaW50O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH0gKi9cclxuICAgIHRoaXMubVNsaWNlOWJvcmRlcnMgPSBzbGljZTlib3JkZXJzO1xyXG5cclxuICAgIHRoaXMuc2V0KG5hdGl2ZUVsZW1lbnQsIHJlZ2lvbiwgdW50cmltbWVkUmVnaW9uLCBzY2FsZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgdGV4dHVyZSB3aXRoIG5ldyBuYXRpdmUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBuYXRpdmVFbGVtZW50IFRoZSBuYXRpdmUgZWxlbWVudCB0byBnZXQgaW1hZ2UgZGF0YSBmcm9tLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZT19IFtyZWdpb249bnVsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYXJlYSBvZiB0ZXh0dXJlIHRvIGJlIGRyYXduLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZT19IFt1bnRyaW1tZWRSZWdpb249bnVsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb3JpZ2luYWwgYXJlYSBvZiB0ZXh0dXJlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW3NjYWxlPTFdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludmVydGVkIHNjYWxlIGZhY3Rvci5cclxuICAgKi9cclxuICBzZXQobmF0aXZlRWxlbWVudCwgcmVnaW9uID0gbnVsbCwgdW50cmltbWVkUmVnaW9uID0gbnVsbCwgc2NhbGUgPSAxKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQobmF0aXZlRWxlbWVudCAhPSBudWxsLCAnbmF0aXZlRWxlbWVudCBjYW5ub3QgYmUgbnVsbCcpO1xyXG4gICAgRGVidWcuYXNzZXJ0KCFpc05hTihzY2FsZSksICdzY2FsZSBjYW5ub3QgYmUgTmFOJyk7XHJcblxyXG4gICAgdGhpcy5tU2NhbGUgPSBzY2FsZTtcclxuICAgIHRoaXMubU5hdGl2ZSA9IG5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgdGhpcy5tTmF0aXZlV2lkdGggPSBuYXRpdmVFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBuYXRpdmVFbGVtZW50LnZpZGVvV2lkdGggfHwgbmF0aXZlRWxlbWVudC53aWR0aDtcclxuICAgIHRoaXMubU5hdGl2ZUhlaWdodCA9IG5hdGl2ZUVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBuYXRpdmVFbGVtZW50LnZpZGVvSGVpZ2h0IHx8IG5hdGl2ZUVsZW1lbnQuaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMubVJlZ2lvbiA9IHJlZ2lvbiB8fCB0aGlzLm1SZWdpb24uc2V0KDAsIDAsIHRoaXMubU5hdGl2ZVdpZHRoLCB0aGlzLm1OYXRpdmVIZWlnaHQpO1xyXG4gICAgdGhpcy5tVW50cmltbWVkUmVnaW9uID0gdW50cmltbWVkUmVnaW9uIHx8IHRoaXMubVVudHJpbW1lZFJlZ2lvbi5zZXQoMCwgMCwgdGhpcy5tUmVnaW9uLndpZHRoLCB0aGlzLm1SZWdpb24uaGVpZ2h0KTtcclxuXHJcbiAgICB0aGlzLm1EaXNwbGF5V2lkdGggPSBNYXRoLmNlaWwodGhpcy5tVW50cmltbWVkUmVnaW9uLndpZHRoICogdGhpcy5tU2NhbGUpO1xyXG4gICAgdGhpcy5tRGlzcGxheUhlaWdodCA9IE1hdGguY2VpbCh0aGlzLm1VbnRyaW1tZWRSZWdpb24uaGVpZ2h0ICogdGhpcy5tU2NhbGUpO1xyXG5cclxuICAgIHRoaXMubVJlbmRlcldpZHRoID0gTWF0aC5jZWlsKHRoaXMubVJlZ2lvbi53aWR0aCAqIHRoaXMubVNjYWxlKTtcclxuICAgIHRoaXMubVJlbmRlckhlaWdodCA9IE1hdGguY2VpbCh0aGlzLm1SZWdpb24uaGVpZ2h0ICogdGhpcy5tU2NhbGUpO1xyXG5cclxuICAgIHRoaXMubVZhbGlkID0gbmF0aXZlRWxlbWVudCAhPSBudWxsICYmIHRoaXMubURpc3BsYXlXaWR0aCA+IDAgJiYgdGhpcy5tRGlzcGxheUhlaWdodCA+IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRTY2FsZUZhY3RvckZyb21OYW1lKG5hbWUpIHtcclxuICAgIGxldCBpeFN0YXJ0ID0gbmFtZS5pbmRleE9mKCdAJyk7XHJcbiAgICBpZiAoaXhTdGFydCA9PT0gLTEpXHJcbiAgICAgIHJldHVybiAxO1xyXG5cclxuICAgIGxldCBpeEVuZCA9IG5hbWUuaW5kZXhPZigneCcsIGl4U3RhcnQpO1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobmFtZS5zdWJzdHJpbmcoaXhTdGFydCArIDEsIGl4RW5kKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHN0YXRpYyByZW1vdmVTY2FsZUZhY3RvckZyb21OYW1lKG5hbWUpIHtcclxuICAgIGxldCBpeFN0YXJ0ID0gbmFtZS5pbmRleE9mKCdAJyk7XHJcbiAgICBpZiAoaXhTdGFydCA9PT0gLTEpXHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG5cclxuICAgIGxldCBpeEVuZCA9IG5hbWUuaW5kZXhPZigneCcsIGl4U3RhcnQpO1xyXG4gICAgcmV0dXJuIG5hbWUuc3Vic3RyaW5nKDAsIGl4U3RhcnQpICsgbmFtZS5zdWJzdHJpbmcoaXhFbmQgKyAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IHRleHR1cmUgZnJvbSBCYXNlNjQgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VGV4dHVyZX1cclxuICAgKi9cclxuICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyhzdHJpbmcpIHtcclxuICAgIGxldCBpbWdFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWdFbGVtZW50LnNyYyA9IHN0cmluZztcclxuICAgIHJldHVybiBuZXcgVGV4dHVyZShpbWdFbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNhbnZhc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHlcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflRleHR1cmV9XHJcbiAgICovXHJcbiAgc3RhdGljIGZyb21DYW52YXNBc0ltYWdlKGNhbnZhcywgdHlwZSA9ICdpbWFnZS9wbmcnLCBxdWFsaXR5ID0gMSkge1xyXG4gICAgbGV0IGltZ0VsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGltZ0VsZW1lbnQuc3JjID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8oY2FudmFzKS50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKGltZ0VsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VGV4dHVyZXxudWxsfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tQ2FudmFzKGNhbnZhcykge1xyXG4gICAgcmV0dXJuIEJsYWNrLmRyaXZlci5nZXRUZXh0dXJlRnJvbUNhbnZhcyhjYW52YXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgd2lkdGggb2YgdGhlIHRleHR1cmUgbXVsdGlwbGllZCBieSBzY2FsZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURpc3BsYXlXaWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGhlaWdodCBvZiB0aGUgdGV4dHVyZSBtdWx0aXBsaWVkIGJ5IHNjYWxlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURpc3BsYXlIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0dXJlIHNjYWxlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc2NhbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU2NhbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYXJlYSBvZiB0aGUgdGV4dHVyZSB0byBiZSBkcmF3bi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIGdldCByZWdpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUmVnaW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG9yaWdpbmFsIGFyZWEgb2YgdGhlIHRleHR1cmUuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgKi9cclxuICBnZXQgdW50cmltbWVkUmVnaW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVVudHJpbW1lZFJlZ2lvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbmF0aXZlV2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tTmF0aXZlV2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHRleHR1cmUuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBuYXRpdmVIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tTmF0aXZlSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNhbWUgYXMgVGV4dHVyZS53aWR0aFxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZGlzcGxheVdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURpc3BsYXlXaWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBzYW1lIGFzIFRleHR1cmUuaGVpZ2h0XHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBkaXNwbGF5SGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURpc3BsYXlIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW5kZXJhYmxlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlIG11bHRpcGxpZWQgYnkgc2NhbGUuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZW5kZXJXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1SZW5kZXJXaWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcmFibGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlIG11bHRpcGxpZWQgYnkgc2NhbGUuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZW5kZXJIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUmVuZGVySGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdGV4dHVyZSBjYW4gYmUgZHJhd24uXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNWYWxpZCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1WYWxpZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuY2hvciBvZiB0aGUgdGV4dHVyZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflZlY3RvcnxudWxsfVxyXG4gICAqL1xyXG4gIGdldCByZWdpc3RyYXRpb25Qb2ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1SZWdpc3RyYXRpb25Qb2ludDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc2xpY2UgOSBib3JkZXJzIGZvciB0aGlzIHRleHR1cmUuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH1cclxuICAgKi9cclxuICBnZXQgc2xpY2U5Ym9yZGVycygpIHtcclxuICAgIHJldHVybiB0aGlzLm1TbGljZTlib3JkZXJzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTmF0aXZlIEhUTUwgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0IG5hdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1OYXRpdmU7XHJcbiAgfVxyXG5cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSWQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIHJlbmRlcmluZyBzdXJmYWNlLlxyXG4gKlxyXG4gKiBAY2F0IGRyaXZlcnNcclxuICovXHJcbmNsYXNzIFJlbmRlclRhcmdldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2UgZm8gUmVuZGVyVGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHN1cmZhY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzdXJmYWNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1IZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2l6ZXMgc3VyZmFjZSB0byB0aGUgZ2l2ZW4gc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHN1cmZhY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzdXJmYWNlLlxyXG4gICAqL1xyXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB0aGlzLm1XaWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5tSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXJzIHdob2xlIHN1cmZhY2UuXHJcbiAgICovXHJcbiAgY2xlYXIoKSB7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgd2lkdGggb2YgdGhlIHN1cmZhY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB3aWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1XaWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tV2lkdGggPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBoZWlnaHQgb2YgdGhlIHN1cmZhY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBoZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tSGVpZ2h0ID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2FudmFzIHJlbmRlcmluZyBzdXJmYWNlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+UmVuZGVyVGFyZ2V0XHJcbiAqIEBjYXQgZHJpdmVycy5jYW52YXNcclxuICovXHJcbmNsYXNzIFJlbmRlclRhcmdldENhbnZhcyBleHRlbmRzIFJlbmRlclRhcmdldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgUmVuZGVyVGFyZ2V0Q2FudmFzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHN1cmZhY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzdXJmYWNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUN0eCA9IC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAodGhpcy5tQ2FudmFzLmdldENvbnRleHQoJzJkJykpO1xyXG5cclxuICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5tQ2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcclxuICAgIHRoaXMubUNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLm1DdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgdGhpcy5tQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLm1DYW52YXMud2lkdGgsIHRoaXMubUNhbnZhcy5oZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBzdXJmYWNlLlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNhbnZhcy53aWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tQ2FudmFzLndpZHRoID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzdXJmYWNlLlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNhbnZhcy5oZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICB0aGlzLm1DYW52YXMuaGVpZ2h0ID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIVE1MIGNhbnZhcyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldCBuYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQ2FudmFzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FudmFzIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cclxuICAgKi9cclxuICBnZXQgY29udGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1DdHg7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSByZW5kZXIgdW5pdC4gQmFzZSBjbGFzcyBmb3IgYWxsIHJlbmRlcmFibGVzLlxyXG4gKlxyXG4gKiBAY2F0IGRyaXZlcnNcclxuICovXHJcbmNsYXNzIFJlbmRlcmVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBSZW5kZXJlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkRpc3BsYXlPYmplY3R8bnVsbH0gKi9cclxuICAgIHRoaXMuZ2FtZU9iamVjdCA9IG51bGw7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVuZGVyZXJ8bnVsbH0gKi9cclxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLnNraXBDaGlsZHJlbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2tpcFNlbGYgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmRQYXNzUmVxdWlyZWRBdCA9IC0xO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5hbHBoYSA9IDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+QmxlbmRNb2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGUuTk9STUFMO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLmNvbG9yID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgcmVuZGVyZXIgbmVlZHMgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WaWRlb051bGxEcml2ZXJ9IGRyaXZlciBBY3RpdmUgdmlkZW8gZHJpdmVyLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlbmRlclNlc3Npb259IHNlc3Npb24gQWN0aXZlIHNlc3Npb24uXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgcHJlUmVuZGVyKGRyaXZlciwgc2Vzc2lvbikge1xyXG4gICAgdGhpcy5lbmRQYXNzUmVxdWlyZWQgPSB0aGlzLmdhbWVPYmplY3QubUNsaXBSZWN0ICE9PSBudWxsICYmIHRoaXMuZ2FtZU9iamVjdC5tQ2xpcFJlY3QuaXNFbXB0eSA9PT0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5za2lwQ2hpbGRyZW4gPSAhKHRoaXMuZ2FtZU9iamVjdC5tQWxwaGEgPiAwICYmIHRoaXMuZ2FtZU9iamVjdC5tVmlzaWJsZSA9PT0gdHJ1ZSk7XHJcbiAgICB0aGlzLnNraXBTZWxmID0gdGhpcy5za2lwQ2hpbGRyZW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYWZ0ZXIgYHByZVJlbmRlcmAgYnV0IGJlZm9yZSBgR2FtZU9iamVjdCNvblJlbmRlcmAuIFVzZWQgdG8gY29tcHV0ZSB3b3JsZCBhbHBoYSwgY29sb3IgYW5kIGJsZW5kIG1vZGUuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmlkZW9OdWxsRHJpdmVyfSBkcml2ZXIgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVuZGVyU2Vzc2lvbn0gc2Vzc2lvbiBcclxuICAgKi9cclxuICBiZWdpbihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIHRoaXMuYWxwaGEgPSB0aGlzLmdhbWVPYmplY3QubUFscGhhICogdGhpcy5wYXJlbnQuYWxwaGE7XHJcbiAgICB0aGlzLmNvbG9yID0gdGhpcy5nYW1lT2JqZWN0Lm1Db2xvciA9PT0gbnVsbCA/IHRoaXMucGFyZW50LmNvbG9yIDogdGhpcy5nYW1lT2JqZWN0Lm1Db2xvcjtcclxuICAgIHRoaXMuYmxlbmRNb2RlID0gdGhpcy5nYW1lT2JqZWN0Lm1CbGVuZE1vZGUgPT09IEJsZW5kTW9kZS5BVVRPID8gdGhpcy5wYXJlbnQuYmxlbmRNb2RlIDogdGhpcy5nYW1lT2JqZWN0Lm1CbGVuZE1vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgaWYgYHNraXBTZWxmYCBlcXVhbHMgdG8gZmFsc2UuIFVzZWQgdG8gdXBsb2FkIGV2ZXJ5dGhpbmcgb250byBncHUuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmlkZW9OdWxsRHJpdmVyfSBkcml2ZXIgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVuZGVyU2Vzc2lvbn0gc2Vzc2lvbiBcclxuICAgKi9cclxuICB1cGxvYWQoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7RGlzcGxheU9iamVjdH0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICBsZXQgdHJhbnNmb3JtID0gZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uO1xyXG5cclxuICAgIGRyaXZlci5zZXRTbmFwVG9QaXhlbHMoZ2FtZU9iamVjdC5zbmFwVG9QaXhlbHMpO1xyXG4gICAgZHJpdmVyLnNldEdsb2JhbEFscGhhKHRoaXMuYWxwaGEpO1xyXG4gICAgZHJpdmVyLnNldEdsb2JhbEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XHJcbiAgICBkcml2ZXIuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcblxyXG4gICAgaWYgKHRoaXMuZW5kUGFzc1JlcXVpcmVkID09PSB0cnVlKVxyXG4gICAgICBkcml2ZXIuYmVnaW5DbGlwKGdhbWVPYmplY3QubUNsaXBSZWN0LCBnYW1lT2JqZWN0Lm1QaXZvdFgsIGdhbWVPYmplY3QubVBpdm90WSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgaWYgYHNraXBTZWxmYCBlcXVhbHMgdG8gZmFsc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WaWRlb051bGxEcml2ZXJ9IGRyaXZlciBBY3RpdmUgdmlkZW8gZHJpdmVyLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlbmRlclNlc3Npb259IHNlc3Npb25cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICByZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGNoaWxkcmVuIG9iamVjdHMgZ290IHJlbmRlcmVkLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlcn0gZHJpdmVyIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlbmRlclNlc3Npb259IHNlc3Npb24gXHJcbiAgICovXHJcbiAgZW5kKGRyaXZlciwgc2Vzc2lvbikge1xyXG4gICAgZHJpdmVyLmVuZENsaXAoKTtcclxuXHJcbiAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZEF0ID0gLTE7XHJcbiAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGludHMgZ2l2ZW4gdGV4dHVyZSB3aXRoIGEgZ2l2ZW4gY29sb3IuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dHVyZX0gdGV4dHVyZSBcclxuICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBjb2xvciBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflRleHR1cmV9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldENvbG9yZWRUZXh0dXJlKHRleHR1cmUsIGNvbG9yKSB7XHJcbiAgICBpZiAoY29sb3IgPT09IDB4RkZGRkZGIHx8IGNvbG9yID09PSBudWxsKVxyXG4gICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICBsZXQgY29sb3JTdHJpbmcgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgaWYgKFJlbmRlcmVyLl9fY29sb3JDYWNoZS5oYXModGV4dHVyZS5pZCwgY29sb3JTdHJpbmcpKVxyXG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtUZXh0dXJlfSovIChSZW5kZXJlci5fX2NvbG9yQ2FjaGUuZ2V0KHRleHR1cmUuaWQsIGNvbG9yU3RyaW5nKSk7XHJcblxyXG4gICAgbGV0IHJlZ2lvbiA9IHRleHR1cmUucmVnaW9uO1xyXG4gICAgbGV0IHcgPSByZWdpb24ud2lkdGg7XHJcbiAgICBsZXQgaCA9IHJlZ2lvbi5oZWlnaHQ7XHJcblxyXG4gICAgbGV0IHJ0ID0gbmV3IFJlbmRlclRhcmdldENhbnZhcyh3LCBoKTtcclxuICAgIGxldCBjdHggPSBydC5jb250ZXh0O1xyXG5cclxuICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvckhlbHBlci5oZXhDb2xvclRvU3RyaW5nKGNvbG9yKTtcclxuICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcclxuXHJcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ211bHRpcGx5JztcclxuICAgIGN0eC5kcmF3SW1hZ2UodGV4dHVyZS5uYXRpdmUsIHJlZ2lvbi54LCByZWdpb24ueSwgcmVnaW9uLndpZHRoLCByZWdpb24uaGVpZ2h0LCAwLCAwLCByZWdpb24ud2lkdGgsIHJlZ2lvbi5oZWlnaHQpO1xyXG5cclxuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tYXRvcCc7XHJcbiAgICBjdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCByZWdpb24ueCwgcmVnaW9uLnksIHJlZ2lvbi53aWR0aCwgcmVnaW9uLmhlaWdodCwgMCwgMCwgcmVnaW9uLndpZHRoLCByZWdpb24uaGVpZ2h0KTtcclxuXHJcbiAgICBsZXQgdCA9IG5ldyBUZXh0dXJlKHJ0Lm5hdGl2ZSwgbnVsbCwgdGV4dHVyZS51bnRyaW1tZWRSZWdpb24uY2xvbmUoKSwgdGV4dHVyZS5zY2FsZSk7XHJcbiAgICBSZW5kZXJlci5fX2NvbG9yQ2FjaGUuc2V0KHRleHR1cmUuaWQsIGNvbG9yU3RyaW5nLCB0KTtcclxuXHJcbiAgICByZXR1cm4gdDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXBNYXB9XHJcbiAqL1xyXG5SZW5kZXJlci5fX2NvbG9yQ2FjaGUgPSBuZXcgTWFwTWFwKCk7XHJcblxyXG4vKipcclxuICogVXNlZCB0byBvcHRpbWl6ZSBiYXR0ZXJ5LWxpZmUgb24gc3RhdGljIHNjZW5lcy5cclxuICogQHByaXZhdGVcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBub2NvbGxhcHNlXHJcbiAqL1xyXG5SZW5kZXJlci5fX2RpcnR5ID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBJbmRpY2F0ZXMgd2hlbmV2ZXIgZW5naW5lIHNob3VsZCByZW5kZXIgdGhlIHN0YWdlIGlmIG5vdGhpbmcgd2VyZSBjaGFuZ2VkIGluIHRoaXMgZnJhbWUuIERlZmF1bHQgaXMgZmFsc2UuXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKi9cclxuUmVuZGVyZXIuc2tpcFVuY2hhbmdlZEZyYW1lcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbGxpZGVyIGNvbXBvbmVudC5cclxuICpcclxuICogQGNhdCBjb2xsaWRlcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkNvbXBvbmVudFxyXG4gKi9cclxuY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIGZvciBDb2xsaWRlci5cclxuICAgKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXJ0eSBmbGFnLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DaGFuZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBpbiBzdGFnZSBjb29yZGluYXRlcyBjZW50ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNlbnRlciA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBpbiBzdGFnZSBjb29yZGluYXRlcyBtaW4geCBhbmQgeSB2ZXJ0ZXguXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubU1pbiA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBpbiBzdGFnZSBjb29yZGluYXRlcyBtYXggeCBhbmQgeSB2ZXJ0ZXguIFxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfSAqL1xyXG4gICAgdGhpcy5tTWF4ID0gbmV3IFZlY3RvcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGdpdmVuIGdsb2JhbCBjb29yZGluYXRlcyBhcmUgbG9jYXRlZCB3aXRoaW4gY29sbGlkZXIncyBhcmVhLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9pbnQgR2xvYmFsIGNvb3JkaW5hdGVzLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgIERlYnVnLmVycm9yKCdBYnN0cmFjdCBtZXRob2QuJyk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIG1pbiwgbWF4LCBjZW50ZXIgb2YgdGhpcyBjb2xsaWRlciwgdG8gcHJlcGFyZSB0byBjb2xsaXNpb24gdGVzdFxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1hdHJpeH0gdHJhbnNmb3JtIEdhbWUgb2JqZWN0IHdvcmxkIHRyYW5zZm9ybWF0aW9uIHdpdGggemVybyBwb3NpdGlvbi5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHBvc2l0aW9uICBSaWdpZCBib2R5IHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIHJlZnJlc2godHJhbnNmb3JtLCBwb3NpdGlvbikgeyB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGFsbG93IHlvdSB0byBzdWJzY3JpYmUgZm9yIHNvbWUgaW5wdXQgbWVzc2FnZXMuXHJcbiAqXHJcbiAqIEBjYXQgaW5wdXRcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkNvbXBvbmVudFxyXG4gKi9cclxuY2xhc3MgSW5wdXRDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhY3RpdmUuICovXHJcbiAgICB0aGlzLnRvdWNoYWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyogSU5URVJOQUwgKi9cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvaW50ZXJJbkRpc3BhdGNoZWQgPSBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY2F0IGNvcmVcclxuICogQGVudW0ge251bWJlcn1cclxuICovXHJcbmNvbnN0IERpcnR5RmxhZyA9IHtcclxuICBDTEVBTjogMCwgICAgICAgICAvLyBPYmplY3QgaXMgMTAwJSBjYWNoZWRcclxuICBMT0NBTDogMSwgICAgICAgICAvLyBMb2NhbCB0cmFuc2Zvcm1hdGlvbiBpcyBkaXJ0eSBcclxuICBXT1JMRDogMiwgICAgICAgICAvLyBXb3JsZCB0cmFuc2Zvcm1hdGlvbiBpcyBkaXJ0eSBcclxuICBXT1JMRF9JTlY6IDQsICAgICAvLyBJbnZlcnRlZCB3b3JsZCB0cmFuc2Zvcm1hdGlvbiBpcyBkaXJ0eSBcclxuICBSRU5ERVI6IDgsICAgICAgICAvLyBPYmplY3QgbmVlZHMgdG8gYmUgcmVuZGVyZWQgXHJcbiAgUkVOREVSX0NBQ0hFOiAxNiwgLy8gSW4gY2FzZSBvYmplY3QgcmVuZGVycyB0byBiaXRtYXAgaW50ZXJuYWxseSwgYml0bWFwIG5lZWRzIHRvIGJlIHVwZGF0ZWRcclxuICBBTkNIT1I6IDMyLCAgICAgICAvLyBcclxuICBCT1VORFM6IDY0LCAgICAgICAvLyBQYXJlbnQtcmVsYXRpdmUgYm91bmRzIG5lZWRzIHVwZGF0ZVxyXG4gIERJUlRZOiAweGZmZmZmZiwgIC8vIEV2ZXJ5dGhpbmcgaXMgZGlydHksIHlvdSwgbWUsIGV2ZXJ5dGhpbmchXHJcbiAgV0lSQjogNzhcclxufTtcclxuXHJcbmxldCBJRCQxID0gMDtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZGluZyBibG9jayBpbiBCbGFjayBFbmdpbmUuXHJcbiAqXHJcbiAqIEBjYXQgY29yZVxyXG4gKiBAdW5yZXN0cmljdGVkXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5NZXNzYWdlRGlzcGF0Y2hlclxyXG4gKi9cclxuY2xhc3MgR2FtZU9iamVjdCBleHRlbmRzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBHYW1lT2JqZWN0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIodHJ1ZSk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSWQgPSArK0lEJDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1OYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+Q29tcG9uZW50Pn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbXBvbmVudHMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5HYW1lT2JqZWN0Pn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNoaWxkcmVuID0gW107XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tWCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tWSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU2NhbGVYID0gMTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TY2FsZVkgPSAxO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGl2b3RYID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBpdm90WSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ta2V3WCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ta2V3WSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUFuY2hvclggPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BbmNob3JZID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBpdm90T2Zmc2V0WCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QaXZvdE9mZnNldFkgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVJvdGF0aW9uID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Cb3VuZHNDYWNoZSA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTG9jYWxUcmFuc2Zvcm0gPSBuZXcgTWF0cml4KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVdvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Xb3JsZFRyYW5zZm9ybUludmVydGVkID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5EaXJ0eUZsYWd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EaXJ0eSA9IERpcnR5RmxhZy5ESVJUWTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGFyZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRhZyA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUFkZGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTnVtQ2hpbGRyZW5SZW1vdmVkID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1OdW1Db21wb25lbnRzUmVtb3ZlZCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRGlydHlGcmFtZU51bSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN1c3BlbmREaXJ0eSA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGNhY2hlIGFsbCBjb2xsaWRlcnMgZm9yIGZhc3QgYWNjZXNzXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+Q29sbGlkZXI+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29sbGlkZXJzQ2FjaGUgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2hpbGRPckNvbXBvbmVudEJlZW5BZGRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5HYW1lT2JqZWN0Pn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNoaWxkcmVuQ2xvbmUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5Db21wb25lbnQ+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29tcG9uZW50Q2xvbmUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgbWFrZSh2YWx1ZXMpIHtcclxuICAgIC8vIGNhbiBiZSBoZWxwZnVsIGlmIHRoZXJlIGFyZSBtYW55IGNoaWxkcmVuXHJcbiAgICB0aGlzLm1TdXNwZW5kRGlydHkgPSB0cnVlO1xyXG5cclxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIHZhbHVlcykge1xyXG4gICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdmFsdWVzW3Byb3BlcnR5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubVN1c3BlbmREaXJ0eSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB1bmlxdWUgb2JqZWN0IGlkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHdhcyBjbGVhbiBmb3IgYXQgbGVhc3QgMSB1cGRhdGUuXHJcbiAgICogXHJcbiAgICogTm90ZTogTWFrZSBzdXJlIHRvIGFwcGx5IGFsbCBjaGFuZ2VzIHRvIHRoaXMgZ2FtZSBvYmplY3QgYmVmb3JlIGNoZWNraW5nIGZvciBzdGF0aWMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUNoaWxkcmVuPXRydWVdXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2hlY2tTdGF0aWMoaW5jbHVkZUNoaWxkcmVuID0gdHJ1ZSkge1xyXG4gICAgaWYgKGluY2x1ZGVDaGlsZHJlbiA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybiB0aGlzLm1EaXJ0eUZyYW1lTnVtIDwgQmxhY2suZW5naW5lLmZyYW1lTnVtO1xyXG5cclxuICAgIGxldCBpc0R5bmFtaWMgPSBmYWxzZTtcclxuICAgIEdhbWVPYmplY3QuZm9yRWFjaCh0aGlzLCB4ID0+IHtcclxuICAgICAgaWYgKHgubURpcnR5RnJhbWVOdW0gPj0gQmxhY2suZW5naW5lLmZyYW1lTnVtKSB7XHJcbiAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuICFpc0R5bmFtaWM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjYWxsZWQgZWFjaCB0aW1lIG9iamVjdCBhZGRlZCB0byBzdGFnZS5cclxuICAgKlxyXG4gICAqIEBhY3Rpb25cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uQWRkZWQoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBzdGFnZS5cclxuICAgKlxyXG4gICAqIEBhY3Rpb25cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uUmVtb3ZlZCgpIHsgfVxyXG5cclxuICAvKipcclxuICAgKiBTdWdhciBtZXRob2QgZm9yIGFkZGluZyBjaGlsZCBgR2FtZU9iamVjdHNgIG9yIGBDb21wb25lbnRzYCBpbiBhIHNpbXBsZSBtYW5uZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihibGFjay1lbmdpbmV+R2FtZU9iamVjdHxibGFjay1lbmdpbmV+Q29tcG9uZW50KX0gZ2FtZU9iamVjdHNBbmRPckNvbXBvbmVudHMgQSBgR2FtZU9iamVjdGAgb3IgYENvbXBvbmVudGAgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBUaGlzIGdhbWUgb2JqZWN0XHJcbiAgICovXHJcbiAgYWRkKC4uLmdhbWVPYmplY3RzQW5kT3JDb21wb25lbnRzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdhbWVPYmplY3RzQW5kT3JDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBnb29jID0gZ2FtZU9iamVjdHNBbmRPckNvbXBvbmVudHNbaV07XHJcblxyXG4gICAgICBpZiAoZ29vYyBpbnN0YW5jZW9mIEdhbWVPYmplY3QpXHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCggLyoqIEB0eXBlIHshR2FtZU9iamVjdH0gKi8oZ29vYykpO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoIC8qKiBAdHlwZSB7IUNvbXBvbmVudH0gKi8oZ29vYykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGNoaWxkIGBHYW1lT2JqZWN0YCBpbnN0YW5jZSB0byB0aGlzIGBHYW1lT2JqZWN0YCBpbnN0YW5jZS4gVGhlIGNoaWxkIGlzIGFkZGVkIHRvIHRoZSB0b3Agb2YgYWxsIG90aGVyIFxyXG4gICAqIGNoaWxkcmVuIGluIHRoaXMgR2FtZU9iamVjdCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBjaGlsZCBUaGUgR2FtZU9iamVjdCBpbnN0YW5jZSB0byBhZGQgYXMgYSBjaGlsZCBvZiB0aGlzIEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9XHJcbiAgICovXHJcbiAgYWRkQ2hpbGQoY2hpbGQpIHtcclxuICAgIHJldHVybiB0aGlzLmFkZENoaWxkQXQoY2hpbGQsIHRoaXMubUNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgY2hpbGQgYEdhbWVPYmplY3RgIGluc3RhbmNlIHRvIHRoaXMgYEdhbWVPYmplY3RgIGluc3RhbmNlLiBUaGUgY2hpbGQgaXMgYWRkZWQgdG8gdGhlIHRvcCBvZiBhbGwgb3RoZXIgXHJcbiAgICogY2hpbGRyZW4gaW4gdGhpcyBHYW1lT2JqZWN0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIFRoZSBHYW1lT2JqZWN0IGluc3RhbmNlIHRvIGFkZCBhcyBhIGNoaWxkIG9mIHRoaXMgR2FtZU9iamVjdCBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbaW5kZXg9MF0gVGhlIGluZGV4IHBvc2l0aW9uIHRvIHdoaWNoIHRoZSBjaGlsZCBpcyBhZGRlZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gVGhlIEdhbWVPYmplY3QgaW5zdGFuY2UgdGhhdCB5b3UgcGFzcyBpbiB0aGUgY2hpbGQgcGFyYW1ldGVyLlxyXG4gICAqL1xyXG4gIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4ID0gMCkge1xyXG4gICAgRGVidWcuYXNzZXJ0KGNoaWxkIGluc3RhbmNlb2YgR2FtZU9iamVjdCwgJ1R5cGUgZXJyb3IuJyk7XHJcblxyXG4gICAgbGV0IG51bUNoaWxkcmVuID0gdGhpcy5tQ2hpbGRyZW4ubGVuZ3RoO1xyXG5cclxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBudW1DaGlsZHJlbilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBpbmRleCBpcyBvdXQgb2YgYm91bmRzLicpO1xyXG5cclxuICAgIGlmIChjaGlsZC5tUGFyZW50ID09PSB0aGlzKVxyXG4gICAgICByZXR1cm4gdGhpcy5zZXRDaGlsZEluZGV4KGNoaWxkLCBpbmRleCk7XHJcblxyXG4gICAgLy8gdGhpcyBvcGVyYXRpb24gc2hvdWxkIGJlIGF0b21pYy4gc2luY2UgX19zZXRQYXJlbnQgY2FuIHRocm93IGV4Y2VwdGlvbi5cclxuICAgIHRoaXMubUNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG5cclxuICAgIGNoaWxkLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICAgIGNoaWxkLl9fc2V0UGFyZW50KHRoaXMpO1xyXG5cclxuICAgIEJsYWNrLmVuZ2luZS5vbkNoaWxkcmVuQWRkZWQoY2hpbGQsIHRoaXMpO1xyXG5cclxuICAgIHRoaXMubUNoaWxkT3JDb21wb25lbnRCZWVuQWRkZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBjaGlsZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IHZhbHVlXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBfX3NldFBhcmVudCh2YWx1ZSkge1xyXG4gICAgbGV0IHAgPSB2YWx1ZTtcclxuXHJcbiAgICB3aGlsZSAocCAhPT0gbnVsbCAmJiBwICE9PSB0aGlzKVxyXG4gICAgICBwID0gcC5tUGFyZW50O1xyXG5cclxuICAgIGlmIChwID09PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBjYW5ub3QgYmUgYSBjaGlsZCB0byBpdHNlbGYuJyk7XHJcblxyXG4gICAgdGhpcy5tUGFyZW50ID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGluZGV4IChsYXllcikgb2YgdGhlIHNwZWNpZmllZCBgR2FtZU9iamVjdGAgdG8gdGhlIHNwZWNpZmllZCBpbmRleCAobGF5ZXIpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gY2hpbGQgVGhlIGBHYW1lT2JqZWN0YCBpbnN0YW5jZSB0byBjaGFuZ2UgaW5kZXggZm9yLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBEZXNpcmVkIGluZGV4LlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gVGhlIGBHYW1lT2JqZWN0YCBpbnN0YW5jZSB0aGF0IHlvdSBwYXNzIGluIHRoZSBjaGlsZCBwYXJhbWV0ZXIuXHJcbiAgICovXHJcbiAgc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcclxuICAgIGxldCBpeCA9IHRoaXMubUNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xyXG5cclxuICAgIGlmIChpeCA8IDApXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gY2hpbGQgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIGNoaWxkcmVuIGxpc3QuJyk7XHJcblxyXG4gICAgaWYgKGl4ID09PSBpbmRleClcclxuICAgICAgcmV0dXJuIGNoaWxkO1xyXG5cclxuICAgIC8vIE5PVEU6IHN5c3RlbXMgbmVlZHMgdG8ga25vdyB3aGVuIHRyZWVzIGNoYW5nZXNcclxuICAgIHRoaXMubUNoaWxkcmVuLnNwbGljZShpeCwgMSk7XHJcbiAgICB0aGlzLm1DaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHJcbiAgICBpZiAodGhpcy5zdGFnZSAhPT0gbnVsbClcclxuICAgICAgQmxhY2suZW5naW5lLm9uQ2hpbGRyZW5DaGFuZ2VkKGNoaWxkKTtcclxuXHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyB0aGlzIGBHYW1lT2JqZWN0YCBpbnN0YW5jZSBmcm9tIGl0cyBwYXJlbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH1cclxuICAgKi9cclxuICByZW1vdmVGcm9tUGFyZW50KCkge1xyXG4gICAgaWYgKHRoaXMubVBhcmVudCAhPT0gbnVsbClcclxuICAgICAgdGhpcy5tUGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzcGVjaWZpZWQgY2hpbGQgYEdhbWVPYmplY3RgIGluc3RhbmNlIGZyb20gY2hpbGRyZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBjaGlsZCBgR2FtZU9iamVjdGAgaW5zdGFuY2UgdG8gcmVtb3ZlLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBUaGUgYEdhbWVPYmplY3RgIGluc3RhbmNlIHRoYXQgeW91IHBhc3MgaW4gdGhlIGNoaWxkIHBhcmFtZXRlci5cclxuICAgKi9cclxuICByZW1vdmVDaGlsZChjaGlsZCkge1xyXG4gICAgbGV0IGl4ID0gdGhpcy5tQ2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XHJcblxyXG4gICAgaWYgKGl4IDwgMClcclxuICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hpbGRBdChpeCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgY2hpbGRyZW4gYnkgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkIG9iamVjdCB0byBmaW5kLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fG51bGx9IEdhbWVPYmplY3QgaW5zdGFuY2Ugb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICovXHJcbiAgZ2V0Q2hpbGRCeU5hbWUobmFtZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodGhpcy5tQ2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tQ2hpbGRyZW5baV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGBHYW1lT2JqZWN0c2AgaW5zdGFuY2UgZnJvbSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgY2hpbGQuIE5lZ2F0aXZlIGluZGV4IHdpbGwgcmVtb3ZlIG9iamVjdCBmcm9tIGl0IGVuZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdHxudWxsfSBUaGUgcmVtb3ZlZCBgR2FtZU9iamVjdGAgaW5zdGFuY2Ugb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICovXHJcbiAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xyXG4gICAgbGV0IGNoaWxkID0gdGhpcy5tQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKVswXTtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBsZXQgaGFkUm9vdCA9IHRoaXMuc3RhZ2UgIT09IG51bGw7XHJcblxyXG4gICAgY2hpbGQuX19zZXRQYXJlbnQobnVsbCk7XHJcblxyXG4gICAgaWYgKGhhZFJvb3QgPT09IHRydWUpXHJcbiAgICAgIEJsYWNrLmVuZ2luZS5vbkNoaWxkcmVuUmVtb3ZlZChjaGlsZCk7XHJcblxyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgdGhpcy5tTnVtQ2hpbGRyZW5SZW1vdmVkKys7XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gb2JqZWN0cy5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IFJldHVybnMgdGhpcy5cclxuICAgKi9cclxuICByZW1vdmVBbGxDaGlsZHJlbigpIHtcclxuICAgIHdoaWxlICh0aGlzLm1DaGlsZHJlbi5sZW5ndGggPiAwKVxyXG4gICAgICB0aGlzLnJlbW92ZUNoaWxkQXQoMCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGBHYW1lT2JqZWN0YCBhdCBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIGNoaWxkIGBHYW1lT2JqZWN0YC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gVGhlIGBHYW1lT2JqZWN0YCBhdCBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICovXHJcbiAgZ2V0Q2hpbGRBdChpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNoaWxkcmVuW2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgQ29tcG9uZW50IGluc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIHtFcnJvcn1cclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGluc3RhbmNlcyBvZiBDb21wb25lbnQgdG8gYmUgYWRkZWQsXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkNvbXBvbmVudH0gVGhlIGBDb21wb25lbnRgIGluc3RhbmNlIHlvdSBwYXNzIGluIHRoZSBpbnN0YW5jZXMgcGFyYW1ldGVyLlxyXG4gICAqL1xyXG4gIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLmFkZENvbXBvbmVudEF0KGNvbXBvbmVudCwgdGhpcy5tQ29tcG9uZW50cy5sZW5ndGgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBDb21wb25lbnQgdG8gdGhlIGxpc3QgYXQgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICogXHJcbiAgICogQHRocm93cyB7RXJyb3J9XHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGluc3RhbmNlcyBvZiBDb21wb25lbnQgdG8gYmUgYWRkZWQsXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSBQb3NpdGlvbiBpbiB0aGUgbGlzdC5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkNvbXBvbmVudH0gVGhlIGBDb21wb25lbnRgIGluc3RhbmNlIHlvdSBwYXNzIGluIHRoZSBpbnN0YW5jZXMgcGFyYW1ldGVyLlxyXG4gICAqL1xyXG4gIGFkZENvbXBvbmVudEF0KGNvbXBvbmVudCwgaW5kZXggPSAwKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoY29tcG9uZW50IGluc3RhbmNlb2YgQ29tcG9uZW50LCAnVHlwZSBlcnJvci4nKTtcclxuXHJcbiAgICBpZiAoY29tcG9uZW50LmdhbWVPYmplY3QpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGNhbm5vdCBiZSBhZGRlZCB0byB0d28gZ2FtZSBvYmplY3RzIGF0IHRoZSBzYW1lIHRpbWUuJyk7XHJcblxyXG4gICAgbGV0IG51bUNvbXBvbmVudHMgPSB0aGlzLm1Db21wb25lbnRzLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gbnVtQ29tcG9uZW50cylcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy4nKTtcclxuXHJcbiAgICB0aGlzLm1Db21wb25lbnRzLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcclxuICAgIGNvbXBvbmVudC5tR2FtZU9iamVjdCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIENvbGxpZGVyKVxyXG4gICAgICB0aGlzLm1Db2xsaWRlcnNDYWNoZS5wdXNoKGNvbXBvbmVudCk7XHJcblxyXG4gICAgaWYgKHRoaXMuc3RhZ2UgIT09IG51bGwgfHwgQmxhY2suc3RhZ2UgPT09IHRoaXMpXHJcbiAgICAgIEJsYWNrLmVuZ2luZS5vbkNvbXBvbmVudEFkZGVkKHRoaXMsIGNvbXBvbmVudCk7XHJcblxyXG4gICAgdGhpcy5tQ2hpbGRPckNvbXBvbmVudEJlZW5BZGRlZCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgY29tcG9uZW50IGF0IGdpdmVuIGluZGV4LlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBOZWdhdGl2ZSBpbmRleCB3aWxsIHJlbW92ZSBjb21wb25lbnQgZnJvbSB0aGUgZW5kLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fG51bGx9IFJldHVybnMgcmVtb3ZlZCBjb21wb25lbnQgb2YgbnVsbC5cclxuICAgKi9cclxuICByZW1vdmVDb21wb25lbnRBdChpbmRleCkge1xyXG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tQ29tcG9uZW50cy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xyXG5cclxuICAgIGlmIChpbnN0YW5jZSA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAvLyBkZXRhY2ggZ2FtZSBvYmplY3QgYWZ0ZXIgb3IgYmVmb3JlP1xyXG4gICAgaW5zdGFuY2UubUdhbWVPYmplY3QgPSBudWxsO1xyXG5cclxuICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIENvbGxpZGVyKSB7XHJcbiAgICAgIGxldCBjb2xsaWRlckl4ID0gdGhpcy5tQ29sbGlkZXJzQ2FjaGUuaW5kZXhPZihpbnN0YW5jZSk7XHJcbiAgICAgIGlmIChjb2xsaWRlckl4ID4gLTEpXHJcbiAgICAgICAgdGhpcy5tQ29sbGlkZXJzQ2FjaGUuc3BsaWNlKGNvbGxpZGVySXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnN0YWdlICE9PSBudWxsIHx8IEJsYWNrLnN0YWdlID09PSB0aGlzKVxyXG4gICAgICBCbGFjay5lbmdpbmUub25Db21wb25lbnRSZW1vdmVkKHRoaXMsIGluc3RhbmNlKTtcclxuXHJcbiAgICB0aGlzLm1OdW1Db21wb25lbnRzUmVtb3ZlZCsrO1xyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBzcGVjaWZpZWQgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBpbnN0YW5jZSBUaGUgYENvbXBvbmVudGAgaW5zdGFuY2UuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Db21wb25lbnR8bnVsbH0gUmV0dXJucyByZW1vdmVkIGNvbXBvbmVudCBvZiBudWxsLlxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbXBvbmVudChpbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlID09IG51bGwpXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIERlYnVnLmFzc2VydChpbnN0YW5jZSBpbnN0YW5jZW9mIENvbXBvbmVudCwgJ1R5cGUgZXJyb3IuJyk7XHJcblxyXG4gICAgbGV0IGluZGV4ID0gdGhpcy5tQ29tcG9uZW50cy5pbmRleE9mKGluc3RhbmNlKTtcclxuICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21wb25lbnRBdChpbmRleCk7XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHJlbW92ZUFsbENvbXBvbmVudHMoKSB7XHJcbiAgICB3aGlsZSAodGhpcy5tQ29tcG9uZW50cy5sZW5ndGggPiAwKVxyXG4gICAgICB0aGlzLnJlbW92ZUNvbXBvbmVudEF0KDApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGNvbXBvbmVudCBieSB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZU5hbWUgVGhlIGNvbXBvbmVudCB0eXBlLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Db21wb25lbnR8bnVsbH0gVGhlIGBDb21wb25lbnRgIGluc3RhbmNlIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAqL1xyXG4gIGdldENvbXBvbmVudCh0eXBlTmFtZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1Db21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBjID0gdGhpcy5tQ29tcG9uZW50c1tpXTtcclxuICAgICAgaWYgKGMgaW5zdGFuY2VvZiB0eXBlTmFtZSlcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIGNvbXBvbmVudCdzIG9mIHRoaXMgR2FtZU9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbnVtQ29tcG9uZW50cygpIHtcclxuICAgIHJldHVybiB0aGlzLm1Db21wb25lbnRzLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlcyBgQ29tcG9uZW50YCBhdCBnaXZlbiBpbmRleC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiBjb21wb25lbnQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkNvbXBvbmVudHxudWxsfVxyXG4gICAqL1xyXG4gIGdldENvbXBvbmVudEF0KGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMubUNvbXBvbmVudHMubGVuZ3RoKVxyXG4gICAgICByZXR1cm4gdGhpcy5tQ29tcG9uZW50c1tpbmRleF07XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGBNYXRyaXhgXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fVxyXG4gICAqL1xyXG4gIGdldCBsb2NhbFRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMubURpcnR5ICYgRGlydHlGbGFnLkxPQ0FMKSB7XHJcbiAgICAgIHRoaXMubURpcnR5IF49IERpcnR5RmxhZy5MT0NBTDtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1Ta2V3WCA9PT0gMC4wICYmIHRoaXMubVNrZXdZID09PSAwLjApIHtcclxuICAgICAgICBpZiAodGhpcy5tUm90YXRpb24gPT09IDApIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLm1Mb2NhbFRyYW5zZm9ybS5zZXQodGhpcy5tU2NhbGVYLCAwLCAwLCB0aGlzLm1TY2FsZVksIHRoaXMubVggLSB0aGlzLm1QaXZvdFggKiB0aGlzLm1TY2FsZVgsIHRoaXMubVkgLSB0aGlzLm1QaXZvdFkgKiB0aGlzLm1TY2FsZVkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBsZXQgY29zID0gTWF0aC5jb3ModGhpcy5tUm90YXRpb24pO1xyXG4gICAgICAgICAgbGV0IHNpbiA9IE1hdGguc2luKHRoaXMubVJvdGF0aW9uKTtcclxuICAgICAgICAgIGxldCBhID0gdGhpcy5tU2NhbGVYICogY29zO1xyXG4gICAgICAgICAgbGV0IGIgPSB0aGlzLm1TY2FsZVggKiBzaW47XHJcbiAgICAgICAgICBsZXQgYyA9IHRoaXMubVNjYWxlWSAqIC1zaW47XHJcbiAgICAgICAgICBsZXQgZCA9IHRoaXMubVNjYWxlWSAqIGNvcztcclxuICAgICAgICAgIGxldCB0eCA9IHRoaXMubVggLSB0aGlzLm1QaXZvdFggKiBhIC0gdGhpcy5tUGl2b3RZICogYztcclxuICAgICAgICAgIGxldCB0eSA9IHRoaXMubVkgLSB0aGlzLm1QaXZvdFggKiBiIC0gdGhpcy5tUGl2b3RZICogZDtcclxuICAgICAgICAgIHJldHVybiB0aGlzLm1Mb2NhbFRyYW5zZm9ybS5zZXQoYSwgYiwgYywgZCwgdHgsIHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5tTG9jYWxUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcclxuICAgICAgICB0aGlzLm1Mb2NhbFRyYW5zZm9ybS5zY2FsZSh0aGlzLm1TY2FsZVgsIHRoaXMubVNjYWxlWSk7XHJcbiAgICAgICAgdGhpcy5tTG9jYWxUcmFuc2Zvcm0uc2tldyh0aGlzLm1Ta2V3WCwgdGhpcy5tU2tld1kpO1xyXG4gICAgICAgIHRoaXMubUxvY2FsVHJhbnNmb3JtLnJvdGF0ZSh0aGlzLm1Sb3RhdGlvbik7XHJcblxyXG4gICAgICAgIGxldCBhID0gdGhpcy5tTG9jYWxUcmFuc2Zvcm0uZGF0YVswXTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMubUxvY2FsVHJhbnNmb3JtLmRhdGFbMV07XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLm1Mb2NhbFRyYW5zZm9ybS5kYXRhWzJdO1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5tTG9jYWxUcmFuc2Zvcm0uZGF0YVszXTtcclxuICAgICAgICBsZXQgdHggPSB0aGlzLm1YO1xyXG4gICAgICAgIGxldCB0eSA9IHRoaXMubVk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1QaXZvdFggIT09IDAuMCB8fCB0aGlzLm1QaXZvdFkgIT09IDAuMCkge1xyXG4gICAgICAgICAgdHggPSB0aGlzLm1YIC0gYSAqIHRoaXMubVBpdm90WCAtIGMgKiB0aGlzLm1QaXZvdFk7XHJcbiAgICAgICAgICB0eSA9IHRoaXMubVkgLSBiICogdGhpcy5tUGl2b3RYIC0gZCAqIHRoaXMubVBpdm90WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubUxvY2FsVHJhbnNmb3JtLmRhdGFbNF0gPSB0eDtcclxuICAgICAgICB0aGlzLm1Mb2NhbFRyYW5zZm9ybS5kYXRhWzVdID0gdHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5tTG9jYWxUcmFuc2Zvcm07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NYXRyaXh9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgbG9jYWxUcmFuc2Zvcm1hdGlvbih2YWx1ZSkge1xyXG4gICAgY29uc3QgUElfUSA9IE1hdGguUEkgLyA0LjA7XHJcblxyXG4gICAgbGV0IGEgPSB2YWx1ZS5kYXRhWzBdO1xyXG4gICAgbGV0IGIgPSB2YWx1ZS5kYXRhWzFdO1xyXG4gICAgbGV0IGMgPSB2YWx1ZS5kYXRhWzJdO1xyXG4gICAgbGV0IGQgPSB2YWx1ZS5kYXRhWzNdO1xyXG4gICAgbGV0IHR4ID0gdmFsdWUuZGF0YVs0XTtcclxuICAgIGxldCB0eSA9IHZhbHVlLmRhdGFbNV07XHJcblxyXG4gICAgdGhpcy5tUGl2b3RPZmZzZXRYID0gdGhpcy5tUGl2b3RPZmZzZXRZID0gMDtcclxuICAgIHRoaXMubUFuY2hvclggPSB0aGlzLm1BbmNob3JYID0gbnVsbDtcclxuICAgIHRoaXMubVggPSB0eDtcclxuICAgIHRoaXMubVkgPSB0eTtcclxuXHJcbiAgICBsZXQgc2tld1ggPSBNYXRoLmF0YW4oLWMgLyBkKTtcclxuICAgIGxldCBza2V3WSA9IE1hdGguYXRhbihiIC8gYSk7XHJcblxyXG4gICAgaWYgKHNrZXdYICE9IHNrZXdYKVxyXG4gICAgICBza2V3WCA9IDAuMDtcclxuICAgIGlmIChza2V3WSAhPSBza2V3WSlcclxuICAgICAgc2tld1kgPSAwLjA7XHJcblxyXG4gICAgdGhpcy5tU2NhbGVZID0gKHNrZXdYID4gLVBJX1EgJiYgc2tld1ggPCBQSV9RKSA/IGQgLyBNYXRoLmNvcyhza2V3WCkgOiAtYyAvIE1hdGguc2luKHNrZXdYKTtcclxuICAgIHRoaXMubVNjYWxlWCA9IChza2V3WSA+IC1QSV9RICYmIHNrZXdZIDwgUElfUSkgPyBhIC8gTWF0aC5jb3Moc2tld1kpIDogYiAvIE1hdGguc2luKHNrZXdZKTtcclxuXHJcbiAgICBpZiAoTWF0aEV4LmVxdWFscyhza2V3WCwgc2tld1kpKSB7XHJcbiAgICAgIHRoaXMubVJvdGF0aW9uID0gc2tld1g7XHJcbiAgICAgIHRoaXMubVNrZXdYID0gdGhpcy5tU2tld1kgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tUm90YXRpb24gPSAwO1xyXG4gICAgICB0aGlzLm1Ta2V3WCA9IHNrZXdYO1xyXG4gICAgICB0aGlzLm1Ta2V3WSA9IHNrZXdZO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgY2xvbmVkIE1hdHJpeCBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBvYmplY3Qgb3JpZW50YXRpb24gaW4gd29ybGQgc3BhY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fVxyXG4gICAqL1xyXG4gIGdldCB3b3JsZFRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMubURpcnR5ICYgRGlydHlGbGFnLkFOQ0hPUiAmJiAodGhpcy5tQW5jaG9yWCAhPT0gbnVsbCB8fCB0aGlzLm1BbmNob3JZICE9PSBudWxsKSkge1xyXG4gICAgICB0aGlzLm1EaXJ0eSBePSBEaXJ0eUZsYWcuQU5DSE9SO1xyXG5cclxuICAgICAgdGhpcy5fX3VwZGF0ZVBpdm90cyh0aGlzKTtcclxuXHJcbiAgICAgIHRoaXMuc2V0RGlydHkoLyoqIEB0eXBlIHtEaXJ0eUZsYWd9ICovKERpcnR5RmxhZy5MT0NBTCB8IERpcnR5RmxhZy5XSVJCKSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubURpcnR5ICYgRGlydHlGbGFnLldPUkxEKSB7XHJcbiAgICAgIHRoaXMubURpcnR5IF49IERpcnR5RmxhZy5XT1JMRDtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1QYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgdGhpcy5tUGFyZW50LndvcmxkVHJhbnNmb3JtYXRpb24uY29weVRvKHRoaXMubVdvcmxkVHJhbnNmb3JtKS5hcHBlbmQodGhpcy5sb2NhbFRyYW5zZm9ybWF0aW9uKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm1hdGlvbi5jb3B5VG8odGhpcy5tV29ybGRUcmFuc2Zvcm0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubVdvcmxkVHJhbnNmb3JtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9uZWQgYW5kIGludmVydGVkIE1hdHJpeCBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyBvYmplY3Qgb3JpZW50YXRpb24gaW4gd29ybGQgc3BhY2VcclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5NYXRyaXh9XHJcbiAgICovXHJcbiAgZ2V0IHdvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZCgpIHtcclxuICAgIGlmICgodGhpcy5tRGlydHkgJiBEaXJ0eUZsYWcuV09STERfSU5WKSkge1xyXG4gICAgICB0aGlzLm1EaXJ0eSBePSBEaXJ0eUZsYWcuV09STERfSU5WO1xyXG5cclxuICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybWF0aW9uLmNvcHlUbyh0aGlzLm1Xb3JsZFRyYW5zZm9ybUludmVydGVkKS5pbnZlcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5tV29ybGRUcmFuc2Zvcm1JbnZlcnRlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX191cGRhdGUoKSB7XHJcbiAgICB0aGlzLm9uVXBkYXRlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMubUNoaWxkT3JDb21wb25lbnRCZWVuQWRkZWQgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMubUNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLm1Db21wb25lbnRDbG9uZSA9IHRoaXMubUNvbXBvbmVudHMuc2xpY2UoKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5tQ29tcG9uZW50Q2xvbmUubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICBpZiAodGhpcy5tQWRkZWQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGxldCBjID0gdGhpcy5tQ29tcG9uZW50Q2xvbmVba107XHJcblxyXG4gICAgICAgIGlmIChjLm1BZGRlZCA9PT0gZmFsc2UgfHwgYy5lbmFibGVkID09PSBmYWxzZSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjLm9uVXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5tQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLm1DaGlsZHJlbkNsb25lID0gdGhpcy5tQ2hpbGRyZW4uc2xpY2UoKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tQ2hpbGRyZW5DbG9uZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXMubUNoaWxkcmVuQ2xvbmVbaV07XHJcblxyXG4gICAgICAgIGlmIChjaGlsZC5tQWRkZWQgPT09IHRydWUpXHJcbiAgICAgICAgICBjaGlsZC5fX3VwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYXQgZXZlcnkgZW5naW5lIHVwZGF0ZS4gVGhlIGV4ZWN1dGlvbiBvcmRlciBvZiBvbkZpeGVkVXBkYXRlLCBvblVwZGF0ZSBhbmQgb25Qb3N0VXBkYXRlIGlzXHJcbiAgICogZ29pbmcgZnJvbSB0b3AgdG8gYm90dG9tIG9mIHRoZSBkaXNwbGF5IGxpc3QuXHJcbiAgICogXHJcbiAgICogQGFjdGlvblxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uVXBkYXRlKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSBuZWVkIHRvIHNwZWNpZnkgR2FtZU9iamVjdCBzaXplLiBTaG91bGQgYmUgYWx3YXlzIGJlIGEgbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBAYWN0aW9uXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZT19IFtvdXRSZWN0PXVuZGVmaW5lZF0gUmVjdGFuZ2xlIHRvIGJlIHJldHVybmVkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IGJvdW5kcyBpbiBsb2NhbCBzcGFjZSB3aXRob3V0IHRha2luZyBjYXJlIGFib3V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAqL1xyXG4gIG9uR2V0TG9jYWxCb3VuZHMob3V0UmVjdCA9IHVuZGVmaW5lZCkge1xyXG4gICAgb3V0UmVjdCA9IG91dFJlY3QgfHwgbmV3IFJlY3RhbmdsZSgpO1xyXG4gICAgcmV0dXJuIG91dFJlY3Quc2V0KDAsIDAsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3b3JsZCBib3VuZHMgb2YgdGhpcyBvYmplY3QgYW5kIGFsbCBjaGlsZHJlbiBpZiBzcGVjaWZpZWQgKHRydWUgYnkgZGVmYXVsdCkuXHJcbiAgICogXHJcbiAgICogYG9iamVjdC5nZXRCb3VuZHMoKWAgLSByZWxhdGl2ZSB0byBwYXJlbnQgKGRlZmF1bHQpLjxicj5cclxuICAgKiBgb2JqZWN0LmdldEJvdW5kcyhvYmplY3QpYCAtIGxvY2FsIGJvdW5kcy48YnI+XHJcbiAgICogYG9iamVjdC5nZXRCb3VuZHMob2JqZWN0LnBhcmVudClgIC0gcmVsYXRpdmUgdG8gcGFyZW50Ljxicj5cclxuICAgKiBgb2JqZWN0LmdldEJvdW5kcyhvYmplY3RCKWAgLSByZWxhdGl2ZSB0byBvYmplY3RCIHNwYWNlLjxicj5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IFtzcGFjZT1udWxsXSBUaGUgYEdhbWVPYmplY3RgIHJlbGF0aXZlIHRvLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVDaGlsZHJlbj10cnVlXSBTcGVjaWZpZXMgaWYgaW5jbHVkZSBjaGlsZHJlbiBpbiBjYWxjdWxhdGlvbnMuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlPX0gW291dFJlY3Q9bnVsbF0gUmVjdGFuZ2xlIHRvIGJlIHJldHVybmVkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFJldHVybnMgYm91bmRzIG9mIHRoZSBvYmplY3Qgd2l0aC93aXRob3V0IGFsbCBjaGlsZHJlbi5cclxuICAgKi9cclxuICBnZXRCb3VuZHMoc3BhY2UgPSBudWxsLCBpbmNsdWRlQ2hpbGRyZW4gPSB0cnVlLCBvdXRSZWN0ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBvdXRSZWN0ID0gb3V0UmVjdCB8fCBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgdGhpcy5vbkdldExvY2FsQm91bmRzKG91dFJlY3QpO1xyXG5cclxuICAgIGlmIChzcGFjZSA9PSBudWxsKVxyXG4gICAgICBzcGFjZSA9IHRoaXMubVBhcmVudDtcclxuXHJcbiAgICBpZiAoc3BhY2UgPT0gdGhpcykgOyBlbHNlIGlmIChzcGFjZSA9PSB0aGlzLm1QYXJlbnQpIHtcclxuICAgICAgaWYgKGluY2x1ZGVDaGlsZHJlbiA9PT0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gTWF0cml4LnBvb2wuZ2V0KCk7XHJcbiAgICAgICAgbWF0cml4LmNvcHlGcm9tKHRoaXMubG9jYWxUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICAgICAgbWF0cml4LnRyYW5zZm9ybVJlY3Qob3V0UmVjdCwgb3V0UmVjdCk7XHJcbiAgICAgICAgTWF0cml4LnBvb2wucmVsZWFzZShtYXRyaXgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGluY2x1ZGVDaGlsZHJlbiA9PT0gdHJ1ZSAmJiB0aGlzLm1EaXJ0eSAmIERpcnR5RmxhZy5CT1VORFMpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gTWF0cml4LnBvb2wuZ2V0KCk7XHJcbiAgICAgICAgbWF0cml4LmNvcHlGcm9tKHRoaXMubG9jYWxUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICAgICAgbWF0cml4LnRyYW5zZm9ybVJlY3Qob3V0UmVjdCwgb3V0UmVjdCk7XHJcbiAgICAgICAgTWF0cml4LnBvb2wucmVsZWFzZShtYXRyaXgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dFJlY3QuY29weUZyb20odGhpcy5tQm91bmRzQ2FjaGUpO1xyXG4gICAgICAgIHJldHVybiBvdXRSZWN0O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgbWF0cml4ID0gTWF0cml4LnBvb2wuZ2V0KCk7XHJcbiAgICAgIG1hdHJpeC5jb3B5RnJvbSh0aGlzLndvcmxkVHJhbnNmb3JtYXRpb24pO1xyXG4gICAgICBtYXRyaXgucHJlcGVuZChzcGFjZS53b3JsZFRyYW5zZm9ybWF0aW9uSW52ZXJ0ZWQpO1xyXG4gICAgICBtYXRyaXgudHJhbnNmb3JtUmVjdChvdXRSZWN0LCBvdXRSZWN0KTtcclxuICAgICAgTWF0cml4LnBvb2wucmVsZWFzZShtYXRyaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4gPT09IHRydWUpIHtcclxuICAgICAgbGV0IGNoaWxkQm91bmRzID0gUmVjdGFuZ2xlLnBvb2wuZ2V0KCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2hpbGRCb3VuZHMuemVybygpO1xyXG5cclxuICAgICAgICB0aGlzLm1DaGlsZHJlbltpXS5nZXRCb3VuZHMoc3BhY2UsIGluY2x1ZGVDaGlsZHJlbiwgY2hpbGRCb3VuZHMpO1xyXG4gICAgICAgIG91dFJlY3QudW5pb24oY2hpbGRCb3VuZHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN0YW5nbGUucG9vbC5yZWxlYXNlKGNoaWxkQm91bmRzKTtcclxuXHJcbiAgICAgIGlmIChzcGFjZSA9PSB0aGlzLm1QYXJlbnQgJiYgdGhpcy5tRGlydHkgJiBEaXJ0eUZsYWcuQk9VTkRTKSB7XHJcbiAgICAgICAgdGhpcy5tQm91bmRzQ2FjaGUuY29weUZyb20ob3V0UmVjdCk7XHJcbiAgICAgICAgdGhpcy5tRGlydHkgXj0gRGlydHlGbGFnLkJPVU5EUztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXRSZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBzdGFnZSByZWxhdGl2ZSBib3VuZHMgb2YgdGhpcyBvYmplY3QgZXhjbHVkaW5nIGl0J3MgY2hpbGRyZW47XHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlPX0gW291dFJlY3Q9bnVsbF0gUmVjdGFuZ2xlIHRvIGJlIHN0b3JlIHJlc3VsdGluZyBib3VuZHMgaW4uXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IFxyXG4gICAqL1xyXG4gIGdldFN0YWdlQm91bmRzKG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICB0aGlzLm9uR2V0TG9jYWxCb3VuZHMob3V0UmVjdCk7XHJcblxyXG4gICAgbGV0IG1hdHJpeCA9IE1hdHJpeC5wb29sLmdldCgpO1xyXG4gICAgbWF0cml4LmNvcHlGcm9tKHRoaXMud29ybGRUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICBtYXRyaXgucHJlcGVuZCh0aGlzLnN0YWdlLndvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZCk7IC8vIDEyMG1zXHJcbiAgICBtYXRyaXgudHJhbnNmb3JtUmVjdChvdXRSZWN0LCBvdXRSZWN0KTsgLy8gMjUwbXNcclxuICAgIE1hdHJpeC5wb29sLnJlbGVhc2UobWF0cml4KTtcclxuXHJcbiAgICByZXR1cm4gb3V0UmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIHRoZSBnYW1lIG9iamVjdCBvciBvbmUgb2YgaXRzIGNoaWxkcmVuIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gbG9jYWxQb2ludCBDb29yZGluYXRlcyB2ZWN0b3IuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R8bnVsbH1cclxuICAgKi9cclxuICBoaXRUZXN0KGxvY2FsUG9pbnQpIHtcclxuICAgIGxldCBjID0gLyoqIEB0eXBlIHtJbnB1dENvbXBvbmVudH0qLyAodGhpcy5nZXRDb21wb25lbnQoSW5wdXRDb21wb25lbnQpKTtcclxuICAgIGxldCB0b3VjaGFibGUgPSBjICE9PSBudWxsICYmIGMudG91Y2hhYmxlO1xyXG4gICAgbGV0IGluc2lkZU1hc2sgPSB0aGlzLm9uSGl0VGVzdE1hc2sobG9jYWxQb2ludCk7XHJcblxyXG4gICAgaWYgKHRvdWNoYWJsZSA9PT0gZmFsc2UgfHwgaW5zaWRlTWFzayA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGxldCB0YXJnZXQgPSBudWxsO1xyXG4gICAgbGV0IG51bUNoaWxkcmVuID0gdGhpcy5tQ2hpbGRyZW4ubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBudW1DaGlsZHJlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgIGxldCBjaGlsZCA9IHRoaXMubUNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgdGFyZ2V0ID0gY2hpbGQuaGl0VGVzdChsb2NhbFBvaW50KTtcclxuXHJcbiAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vbkhpdFRlc3QobG9jYWxQb2ludCkgPT09IHRydWUpXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGFjdGlvblxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IGxvY2FsUG9pbnQgXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBvbkhpdFRlc3QobG9jYWxQb2ludCkge1xyXG4gICAgbGV0IGNvbnRhaW5zID0gZmFsc2U7XHJcblxyXG4gICAgLy8gQkVHSU5PRjogV1RGXHJcbiAgICBsZXQgdG1wVmVjdG9yID0gLyoqIEB0eXBlIHtWZWN0b3J9Ki8gKFZlY3Rvci5wb29sLmdldCgpKTtcclxuICAgIHRoaXMud29ybGRUcmFuc2Zvcm1hdGlvbkludmVydGVkLnRyYW5zZm9ybVZlY3Rvcihsb2NhbFBvaW50LCB0bXBWZWN0b3IpO1xyXG4gICAgLy8gRU5ET0Y6IFdURlxyXG5cclxuICAgIGlmICh0aGlzLm1Db2xsaWRlcnNDYWNoZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tQ29sbGlkZXJzQ2FjaGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY29sbGlkZXIgPSB0aGlzLm1Db2xsaWRlcnNDYWNoZVtpXTtcclxuXHJcbiAgICAgICAgY29udGFpbnMgPSBjb2xsaWRlci5jb250YWluc1BvaW50KHRtcFZlY3Rvcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zID09PSB0cnVlKVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRhaW5zID0gdGhpcy5sb2NhbEJvdW5kcy5jb250YWluc1hZKHRtcFZlY3Rvci54LCB0bXBWZWN0b3IueSk7XHJcbiAgICB9XHJcblxyXG4gICAgVmVjdG9yLnBvb2wucmVsZWFzZSh0bXBWZWN0b3IpO1xyXG4gICAgcmV0dXJuIGNvbnRhaW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGFjdGlvblxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IGxvY2FsUG9pbnQgXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBvbkhpdFRlc3RNYXNrKGxvY2FsUG9pbnQpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBsb2NhbCBib3VuZHMgb2YgdGhpcyBvYmplY3QgKHdpdGhvdXQgY2hpbGRyZW4pLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyh0aGlzLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHBhcmVudC1yZWxhdGl2ZSBib3VuZHMgKGluY2x1ZGluZyBjaGlsZHJlbikuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9XHJcbiAgICovXHJcbiAgZ2V0IGJvdW5kcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEJvdW5kcyh0aGlzLm1QYXJlbnQsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBpbiBvbmUgbGluZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAgICAgICBDb3JkIFguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdICAgICAgIENvcmQgWS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3I9MF0gICAgICAgUm90YXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVg9MV0gIFNjYWxlIFguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9MV0gIFNjYWxlIFkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthbmNob3JYPTBdIEFuY2hvciBYLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYW5jaG9yWT0wXSBBbmNob3IgWS5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlQ2hpbGRyZW49dHJ1ZV0gSW5jbHVkZSBjaGlsZHJlbiB3aGVuIGFkanVzdGluZyBwaXZvdD9cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBUaGlzLlxyXG4gICAqL1xyXG4gIHNldFRyYW5zZm9ybSh4ID0gMCwgeSA9IDAsIHIgPSAwLCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBhbmNob3JYID0gMCwgYW5jaG9yWSA9IDAsIGluY2x1ZGVDaGlsZHJlbiA9IHRydWUpIHtcclxuICAgIHRoaXMubVggPSB4O1xyXG4gICAgdGhpcy5tWSA9IHk7XHJcbiAgICB0aGlzLm1Sb3RhdGlvbiA9IHI7XHJcbiAgICB0aGlzLm1TY2FsZVggPSBzY2FsZVg7XHJcbiAgICB0aGlzLm1TY2FsZVkgPSBzY2FsZVk7XHJcbiAgICB0aGlzLm1BbmNob3JYID0gYW5jaG9yWDtcclxuICAgIHRoaXMubUFuY2hvclkgPSBhbmNob3JZO1xyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyBHYW1lT2JqZWN0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gYW5vdGhlciBHYW1lT2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ2FtZU9iamVjdCBDb29yZGluYXRlcyB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfG51bGx9IFtvdXRWZWN0b3I9bnVsbF0gVmVjdG9yIHRvIGJlIHJldHVybmVkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICovXHJcbiAgcmVsYXRpdmVUbyhnYW1lT2JqZWN0LCBvdXRWZWN0b3IgPSBudWxsKSB7XHJcbiAgICBvdXRWZWN0b3IgPSBvdXRWZWN0b3IgfHwgbmV3IFZlY3RvcigpO1xyXG4gICAgb3V0VmVjdG9yLnNldCh0aGlzLngsIHRoaXMueSk7XHJcblxyXG4gICAgaWYgKHRoaXMucGFyZW50ID09IG51bGwgfHwgZ2FtZU9iamVjdCA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gb3V0VmVjdG9yO1xyXG5cclxuICAgIHRoaXMucGFyZW50LmxvY2FsVG9HbG9iYWwob3V0VmVjdG9yLCBvdXRWZWN0b3IpO1xyXG4gICAgZ2FtZU9iamVjdC5nbG9iYWxUb0xvY2FsKG91dFZlY3Rvciwgb3V0VmVjdG9yKTtcclxuICAgIHJldHVybiBvdXRWZWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IGxvY2FsUG9pbnQgQ29vcmRpbmF0ZXMgdmVjdG9yLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3RvcnxudWxsfSBbb3V0VmVjdG9yPW51bGxdIFZlY3RvciB0byBiZSByZXR1cm5lZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAqL1xyXG4gIGxvY2FsVG9HbG9iYWwobG9jYWxQb2ludCwgb3V0VmVjdG9yID0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm1hdGlvbi50cmFuc2Zvcm1WZWN0b3IobG9jYWxQb2ludCwgb3V0VmVjdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IGdsb2JhbFBvaW50IENvb3JkaW5hdGVzIHZlY3Rvci5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J8bnVsbH0gW291dFZlY3Rvcj1udWxsXSBWZWN0b3IgdG8gYmUgcmV0dXJuZWQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnbG9iYWxUb0xvY2FsKGdsb2JhbFBvaW50LCBvdXRWZWN0b3IgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybWF0aW9uSW52ZXJ0ZWQudHJhbnNmb3JtVmVjdG9yKGdsb2JhbFBvaW50LCBvdXRWZWN0b3IpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBHZXRzIGEgY291bnQgb2YgY2hpbGRyZW4gZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG51bUNoaWxkcmVuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNoaWxkcmVuLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgbmFtZSBvZiB0aGlzIEdhbWVPYmplY3QgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cclxuICAgKi9cclxuICBnZXQgbmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1OYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBuYW1lKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1OYW1lID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgR2FtZU9iamVjdCBpbnN0YW5jZSByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudCBHYW1lT2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgeCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1YO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubVggPT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBEZWJ1Zy5hc3NlcnQoIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICB0aGlzLm1YID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgR2FtZU9iamVjdCBpbnN0YW5jZSByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudCBHYW1lT2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB5KHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tWSA9PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIERlYnVnLmFzc2VydCghaXNOYU4odmFsdWUpLCAnVmFsdWUgY2Fubm90IGJlIE5hTicpO1xyXG5cclxuICAgIHRoaXMubVkgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogR2V0cy9zZXRzIG9iamVjdCBwb3NpdGlvbi5cclxuICAgKiBcclxuICAgKiBOT1RFOiBzZXR0aW5nIGluZGl2aWR1YWwgdmFsdWVzIG9uIHRoaXMgdmVjdG9yIHdpbGwgZ2l2ZSB6ZXJvIHJlc3VsdHMuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICovXHJcbiAgZ2V0IHh5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5tWCwgdGhpcy5tWSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgb2JqZWN0IHBvc2l0aW9uLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgeHkodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1YID09PSB2YWx1ZS54ICYmIHRoaXMubVkgPT09IHZhbHVlLnkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1YID0gdmFsdWUueDtcclxuICAgIHRoaXMubVkgPSB2YWx1ZS55O1xyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QncyBvcmlnaW4gaW4gaXRzIGxvY2FsIHNwYWNlIGluIHBpeGVscy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcGl2b3RPZmZzZXRYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBpdm90T2Zmc2V0WDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHBpdm90T2Zmc2V0WCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubVBpdm90T2Zmc2V0WCA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBEZWJ1Zy5hc3NlcnQoIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICB0aGlzLm1QaXZvdE9mZnNldFggPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLl9fdXBkYXRlUGl2b3RzKHRoaXMpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCdzIG9yaWdpbiBpbiBpdHMgbG9jYWwgc3BhY2UgaW4gcGl4ZWxzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBwaXZvdE9mZnNldFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUGl2b3RPZmZzZXRZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcGl2b3RPZmZzZXRZKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tUGl2b3RPZmZzZXRZID09PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIERlYnVnLmFzc2VydCghaXNOYU4odmFsdWUpLCAnVmFsdWUgY2Fubm90IGJlIE5hTicpO1xyXG5cclxuICAgIHRoaXMubVBpdm90T2Zmc2V0WSA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuX191cGRhdGVQaXZvdHModGhpcyk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0J3Mgb3JpZ2luIGluIGl0cyBsb2NhbCBzcGFjZSBpbiBwZXJjZW50LlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgYW5jaG9yWCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubUFuY2hvclggPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgRGVidWcuYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSksICdWYWx1ZSBjYW5ub3QgYmUgTmFOJyk7XHJcblxyXG4gICAgdGhpcy5tQW5jaG9yWCA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgeS1jb29yZGluYXRlIG9mIHRoZSBvYmplY3QncyBvcmlnaW4gaW4gaXRzIGxvY2FsIHNwYWNlIGluIHBlcmNlbnQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBhbmNob3JZKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tQW5jaG9yWSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBEZWJ1Zy5hc3NlcnQodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICB0aGlzLm1BbmNob3JZID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGFuY2hvci14IHZhbHVlIGluIHJhbmdlIGZyb20gMCB0byAxLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cclxuICAgKi9cclxuICBnZXQgYW5jaG9yWCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1BbmNob3JYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGFuY2hvci15IHZhbHVlIGluIHJhbmdlIGZyb20gMCB0byAxLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cclxuICAgKi9cclxuICBnZXQgYW5jaG9yWSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1BbmNob3JZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IHBpdm90LXggdmFsdWUgaW4gcmFuZ2UgZnJvbSAwIHRvIDEuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcGl2b3RYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBpdm90WDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBwaXZvdC15IHZhbHVlIGluIHJhbmdlIGZyb20gMCB0byAxLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHBpdm90WSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1QaXZvdFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBvcmlnaW4gcG9pbnQgcmVsYXRpdmVseSB0byBpdHMgYm91bmRzLiBGb3IgZXhhbXBsZSwgc2V0dGluZyB4IGFuZCB5IHZhbHVlIHRvIDAuNSB3aWxsIHNldCBvcmlnaW4gdG8gdGhlIFxyXG4gICAqIGNlbnRlciBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBbYXg9MC41XSAgICAgICAgICAgICAgIEFsaWduIGFsb25nIHgtYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIFtheT0wLjVdICAgICAgICAgICAgICAgQWxpZ24gYWxvbmcgeS1heGlzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IFRoaXMuXHJcbiAgICovXHJcbiAgYWxpZ25BbmNob3IoYXggPSAwLjUsIGF5ID0gMC41KSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcihheCwgYXkpO1xyXG5cclxuICAgIHRoaXMubUFuY2hvclggPSBheDtcclxuICAgIHRoaXMuYW5jaG9yWSA9IGF5O1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhbmNob3IgcG9pbnQgdG8gZ2l2ZW4gcG9zaXRpb24uIFNlZSBgYWxpZ25QaXZvdE9mZnNldGAuXHJcbiAgICogXHJcbiAgICogQGRlcHJlY2F0ZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgW2F4PTAuNV0gICAgICAgICAgICAgICBBbGlnbiBhbG9uZyB4LWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBbYXk9MC41XSAgICAgICAgICAgICAgIEFsaWduIGFsb25nIHktYXhpcy5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gVGhpcy5cclxuICAgKi9cclxuICBhbGlnblBpdm90KGF4ID0gMC41LCBheSA9IDAuNSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWxpZ25QaXZvdE9mZnNldChheCwgYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mZnNldCBmcm9tIGN1cnJlbnQgYW5jaG9yIHZhbHVlLiBGb3IgZXhhbXBsZSwgc2V0dGluZyBhbmNob3IteCB2YWx1ZSB0byAwLjUgYW5kIHBpdm90T2Zmc2V0WFxyXG4gICAqIHRvIDEwIHdpbGwgY2VudGVyIG9iamVjdCBieSB4LWF4aXMgYW5kIHdpbGwgc2hpZnQgb2JqZWN0IHRvIHRoZSBsZWZ0IGJ5IDEwIHBpeGVscyBmcm9tIGhhbGYgb2YgdGhlIHdpZHRoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBbYXg9MC41XSAgICAgICAgICAgICAgIEFsaWduIGFsb25nIHgtYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIFtheT0wLjVdICAgICAgICAgICAgICAgQWxpZ24gYWxvbmcgeS1heGlzLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVDaGlsZHJlbj10cnVlXSBJbmNsdWRlIGNoaWxkcmVuIGVsZW1lbnRzIHdoZW4gY2FsY3VsYXRpbmcgYm91bmRzP1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IFRoaXMuXHJcbiAgICovXHJcbiAgYWxpZ25QaXZvdE9mZnNldChheCA9IDAuNSwgYXkgPSAwLjUsIGluY2x1ZGVDaGlsZHJlbiA9IHRydWUpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKGF4LCBheSk7XHJcblxyXG4gICAgdGhpcy5nZXRCb3VuZHModGhpcywgaW5jbHVkZUNoaWxkcmVuLCBSZWN0YW5nbGUuX19jYWNoZS56ZXJvKCkpO1xyXG5cclxuICAgIHRoaXMubVBpdm90T2Zmc2V0WCA9IChSZWN0YW5nbGUuX19jYWNoZS53aWR0aCAqIGF4KSArIFJlY3RhbmdsZS5fX2NhY2hlLng7XHJcbiAgICB0aGlzLm1QaXZvdE9mZnNldFkgPSAoUmVjdGFuZ2xlLl9fY2FjaGUuaGVpZ2h0ICogYXkpICsgUmVjdGFuZ2xlLl9fY2FjaGUueTtcclxuXHJcbiAgICB0aGlzLl9fdXBkYXRlUGl2b3RzKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgc2NhbGUgZmFjdG9yIG9mIHRoaXMgb2JqZWN0IGFsb25nIHgtYXhpcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc2NhbGVYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNjYWxlWDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2NhbGVYKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tU2NhbGVYID09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgRGVidWcuYXNzZXJ0KCFpc05hTih2YWx1ZSksICdWYWx1ZSBjYW5ub3QgYmUgTmFOJyk7XHJcblxyXG4gICAgdGhpcy5tU2NhbGVYID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIHNjYWxlIGZhY3RvciBvZiB0aGlzIG9iamVjdCBhbG9uZyB5LWF4aXMuXHJcbiAgICpcclxuICAgKiBcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNjYWxlWSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1TY2FsZVk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBzY2FsZVkodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1TY2FsZVkgPT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBEZWJ1Zy5hc3NlcnQoIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICB0aGlzLm1TY2FsZVkgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyBib3RoIGBzY2FsZVhgIGFuZCBgc2NhbGVZYC4gR2V0dGVyIHdpbGwgcmV0dXJuIGBzY2FsZVhgIHZhbHVlO1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNjYWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NhbGVYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNjYWxlKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tU2NhbGVYID09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgRGVidWcuYXNzZXJ0KCFpc05hTih2YWx1ZSksICdWYWx1ZSBjYW5ub3QgYmUgTmFOJyk7XHJcblxyXG4gICAgdGhpcy5tU2NhbGVYID0gdGhpcy5tU2NhbGVZID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgaG9yaXpvbnRhbCBza2V3IGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc2tld1goKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU2tld1g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2tld1godmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1Ta2V3WCA9PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIERlYnVnLmFzc2VydCghaXNOYU4odmFsdWUpLCAnVmFsdWUgY2Fubm90IGJlIE5hTicpO1xyXG5cclxuICAgIHRoaXMubVNrZXdYID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgdmVydGljYWwgc2tldyBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNrZXdZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNrZXdZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNrZXdZKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tU2tld1kgPT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBEZWJ1Zy5hc3NlcnQoIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICB0aGlzLm1Ta2V3WSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHJvdGF0aW9uIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKiBcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVJvdGF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcm90YXRpb24odmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1Sb3RhdGlvbiA9PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIERlYnVnLmFzc2VydCghaXNOYU4odmFsdWUpLCAnVmFsdWUgY2Fubm90IGJlIE5hTicpO1xyXG5cclxuICAgIHRoaXMubVJvdGF0aW9uID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgR2FtZU9iamVjdCBwYXJlbnQgR2FtZU9iamVjdCBvciBudWxsLlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHBhcmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1QYXJlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRvcCBtb3N0IHBhcmVudCBvYmplY3Qgb3IgdGhpcyBpZiB0aGVyZSBpcyBubyBwYXJlbnRzLlxyXG4gICAqIFxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldCByb290KCkge1xyXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xyXG5cclxuICAgIHdoaWxlIChjdXJyZW50Lm1QYXJlbnQgIT0gbnVsbClcclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubVBhcmVudDtcclxuXHJcbiAgICByZXR1cm4gY3VycmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHN0YWdlIEdhbWUgT2JqZWN0IHRvIHdoaWNoIHRoaXMgZ2FtZSBvYmplY3QgYmVsb25ncyB0byBvciBudWxsIGlmIG5vdCBhZGRlZCBvbiBzdGFnZS5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5TdGFnZXxudWxsfVxyXG4gICAqL1xyXG4gIGdldCBzdGFnZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1BZGRlZCA9PT0gdHJ1ZSA/IEJsYWNrLnN0YWdlIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyB0aGUgd2lkdGggb2YgdGhpcyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKHRoaXMubVBhcmVudCkud2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgRGVidWcuYXNzZXJ0KCFpc05hTih2YWx1ZSksICdWYWx1ZSBjYW5ub3QgYmUgTmFOJyk7XHJcblxyXG4gICAgdGhpcy5zY2FsZVggPSAxO1xyXG4gICAgY29uc3QgY3VycmVudFdpZHRoID0gdGhpcy53aWR0aDtcclxuXHJcbiAgICBpZiAoY3VycmVudFdpZHRoICE9IDAuMClcclxuICAgICAgdGhpcy5zY2FsZVggPSB2YWx1ZSAvIGN1cnJlbnRXaWR0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyB0aGUgaGVpZ2h0IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBoZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHModGhpcy5tUGFyZW50KS5oZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgIERlYnVnLmFzc2VydCghaXNOYU4odmFsdWUpLCAnVmFsdWUgY2Fubm90IGJlIE5hTicpO1xyXG5cclxuICAgIHRoaXMuc2NhbGVZID0gMTtcclxuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuXHJcbiAgICBpZiAoY3VycmVudEhlaWdodCAhPSAwKVxyXG4gICAgICB0aGlzLnNjYWxlWSA9IHZhbHVlIC8gY3VycmVudEhlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2lkdGggb2YgdGhpcyBHYW1lT2JqZWN0IGluIGxvY2FsIHNwYWNlIHdpdGhvdXQgaW5jbHVkaW5nIGNoaWxkcmVuXHJcbiAgICogZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGxvY2FsV2lkdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHModGhpcywgZmFsc2UpLndpZHRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBoZWlnaHQgb2YgdGhpcyBHYW1lT2JqZWN0IGluIGxvY2FsIHNwYWNlIHdpdGhvdXQgaW5jbHVkaW5nIGNoaWxkcmVuXHJcbiAgICogZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGxvY2FsSGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKHRoaXMsIGZhbHNlKS5oZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBwcmVjYWNoZVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGluZyBhIHVybCBsaWtlIHBhdGggdG8gdGhpcyBvYmplY3QgaW4gdGhlIGRpc3BsYXlcclxuICAgKiB0cmVlLlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHBhdGgoKSB7XHJcbiAgICBpZiAodGhpcy5tUGFyZW50ICE9PSBudWxsKVxyXG4gICAgICByZXR1cm4gdGhpcy5tUGFyZW50LnBhdGggKyAnLycgKyB0aGlzLm1OYW1lO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1OYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBHZXRzL1NldHMgdGFnIG9mIHRoaXMgR2FtZU9iamVjdC5cclxuICAqXHJcbiAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cclxuICAqL1xyXG4gIGdldCB0YWcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVGFnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB0YWcodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1UYWcgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd8bnVsbH0gKi9cclxuICAgIGxldCBvbGQgPSB0aGlzLm1UYWc7XHJcbiAgICB0aGlzLm1UYWcgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAodGhpcy5tQWRkZWQpXHJcbiAgICAgIEJsYWNrLmVuZ2luZS5vblRhZ1VwZGF0ZWQodGhpcywgb2xkLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgY29yb3V0aW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuICBHZW5lcmF0b3IgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHsqPX0gW2N0eD1udWxsXSBDb250ZXh0IGZvciBHZW5lcmF0b3IgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7Kn1cclxuICAgKi9cclxuICBzcGF3bihnZW4sIGN0eCA9IG51bGwpIHtcclxuICAgIGxldCBpdGVyID0gZ2VuLmFwcGx5KGN0eCA9PSBudWxsID8gdGhpcyA6IGN0eCk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3RlcChpdCkge1xyXG4gICAgICBpZiAoaXQuZG9uZSlcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGl0LnZhbHVlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGl0LnZhbHVlKHggPT4gc3RlcChpdGVyLm5leHQoeCkpKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHN0ZXAoaXRlci5uZXh0KGl0LnZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RlcChpdGVyLm5leHQoKSk7XHJcbiAgICByZXR1cm4gaXRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdhaXRzIGZvciBnaXZlbiBhbW91bnQgb2Ygc2Vjb25kcyBiZWZvcmUgcHJvY2Vzc2luZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0xXSBEdXJhdGlvblxyXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKCopOip9XHJcbiAgICovXHJcbiAgd2FpdChzZWNvbmRzID0gMSkge1xyXG4gICAgcmV0dXJuIGNiID0+IHNldFRpbWVvdXQoY2IuYmluZCh0aGlzLCAoLyoqIEB0eXBlIHtudW1iZXJ9ICovKHNlY29uZHMpICogMTAwMCkpLCAoLyoqIEB0eXBlIHtudW1iZXJ9ICovKHNlY29uZHMpICogMTAwMCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2FpdHMgZm9yIGEgc3BlY2lmaWMgbWVzc2FnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIHRvIHdhaXQgZm9yLlxyXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKCopOip9XHJcbiAgICovXHJcbiAgd2FpdE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIGNiID0+IHRoaXMub25jZShtZXNzYWdlLCBjYi5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtzIHRoaXMgR2FtZU9iamVjdCBhbmQvb3IgaXRzIGNoaWxkcmVuIGVsZW1lbnRzIGFzIGRpcnR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+RGlydHlGbGFnfSBmbGFnIFRoZSBmbGFnIG9yIGZsYWcgYml0IG1hc2suXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUNoaWxkcmVuPXRydWVdIFNwZWNpZmllcyBpZiB0aGUgZmxhZyBuZWVkZWQgZm9yIGFsbCBjaGlsZHJlbi5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldERpcnR5KGZsYWcsIGluY2x1ZGVDaGlsZHJlbiA9IHRydWUpIHtcclxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcclxuICAgICAgR2FtZU9iamVjdC5mb3JFYWNoKHRoaXMsIHggPT4ge1xyXG4gICAgICAgIHgubURpcnR5IHw9IGZsYWc7XHJcbiAgICAgICAgeC5tRGlydHlGcmFtZU51bSA9IEJsYWNrLmVuZ2luZS5mcmFtZU51bTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1EaXJ0eSB8PSBmbGFnO1xyXG4gICAgICB0aGlzLm1EaXJ0eUZyYW1lTnVtID0gQmxhY2suZW5naW5lLmZyYW1lTnVtO1xyXG4gICAgfVxyXG5cclxuICAgIFJlbmRlcmVyLl9fZGlydHkgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ28gXHJcbiAgICovXHJcbiAgX191cGRhdGVQaXZvdHMoZ28pIHtcclxuICAgIGdvLmdldEJvdW5kcyhnbywgdHJ1ZSwgUmVjdGFuZ2xlLl9fY2FjaGUuemVybygpKTtcclxuXHJcbiAgICBnby5tUGl2b3RYID0gZ28ubUFuY2hvclggPT09IG51bGwgPyBnby5tUGl2b3RPZmZzZXRYIDogZ28ubVBpdm90T2Zmc2V0WCArIChSZWN0YW5nbGUuX19jYWNoZS53aWR0aCAqIGdvLm1BbmNob3JYKSArIFJlY3RhbmdsZS5fX2NhY2hlLng7XHJcbiAgICBnby5tUGl2b3RZID0gZ28ubUFuY2hvclkgPT09IG51bGwgPyBnby5tUGl2b3RPZmZzZXRZIDogZ28ubVBpdm90T2Zmc2V0WSArIChSZWN0YW5nbGUuX19jYWNoZS5oZWlnaHQgKiBnby5tQW5jaG9yWSkgKyBSZWN0YW5nbGUuX19jYWNoZS55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFya3MgdGhlIEdhbWVPYmplY3QncyBwYXJlbnQgYXMgZGlydHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5EaXJ0eUZsYWd9IGZsYWcgVGhlIGZsYWcgb3IgZmxhZyBiaXQgbWFzay5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldFBhcmVudERpcnR5KGZsYWcpIHtcclxuICAgIGxldCBjdXJyZW50ID0gdGhpcztcclxuICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwpIHtcclxuICAgICAgY3VycmVudC5tRGlydHkgfD0gZmxhZztcclxuICAgICAgY3VycmVudC5tRGlydHlGcmFtZU51bSA9IEJsYWNrLmVuZ2luZS5mcmFtZU51bTtcclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubVBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICBSZW5kZXJlci5fX2RpcnR5ID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcmtzIHRoaXMgR2FtZU9iamVjdCBhcyBMb2NhbCBkaXJ0eSBhbmQgYWxsIGNoaWxkcmVuIGVsZW1lbnRzIGFzIFdvcmxkIGRpcnR5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0VHJhbnNmb3JtRGlydHkoKSB7XHJcbiAgICBpZiAodGhpcy5tU3VzcGVuZERpcnR5ID09PSB0cnVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eSgvKiogQHR5cGUge0RpcnR5RmxhZ30gKi8oRGlydHlGbGFnLkxPQ0FMIHwgRGlydHlGbGFnLkJPVU5EUyksIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLldJUkIsIHRydWUpO1xyXG5cclxuICAgIHRoaXMuc2V0UGFyZW50RGlydHkoLyoqIEB0eXBlIHtEaXJ0eUZsYWd9ICovKERpcnR5RmxhZy5CT1VORFMgfCBEaXJ0eUZsYWcuQU5DSE9SKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYXJrcyB0aGlzIEdhbWVPYmplY3Qgd2l0aCBSZW5kZXIgZGlydHkgZmxhZyBpZiBpdCBpcyBub3Qgc3VzcGVuZGVkIGZvciBkaXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldFJlbmRlckRpcnR5KCkge1xyXG4gICAgaWYgKHRoaXMubVN1c3BlbmREaXJ0eSA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUiwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgdG91Y2hhYmxlKHZhbHVlKSB7XHJcbiAgICBsZXQgYyA9IC8qKiBAdHlwZSB7SW5wdXRDb21wb25lbnR9Ki8gKHRoaXMuZ2V0Q29tcG9uZW50KElucHV0Q29tcG9uZW50KSk7XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgIGlmIChjID09PSBudWxsKVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBJbnB1dENvbXBvbmVudCgpKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIGMudG91Y2hhYmxlID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChjICE9PSBudWxsKVxyXG4gICAgICAgIHRoaXMucmVtb3ZlQ29tcG9uZW50KGMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIG9iamVjdCB3aWxsIGxpc3RlbiBmb3IgdXNlciBpbnB1dCBtZXNzYWdlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHRvdWNoYWJsZSgpIHtcclxuICAgIGxldCBjID0gLyoqIEB0eXBlIHtJbnB1dENvbXBvbmVudH0gKi8gKHRoaXMuZ2V0Q29tcG9uZW50KElucHV0Q29tcG9uZW50KSk7XHJcbiAgICByZXR1cm4gYyAhPT0gbnVsbCAmJiBjLnRvdWNoYWJsZSA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IHJlbmFtZSBtZXRob2RcclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50c1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1hdHJpeH0gd29ybGRUcmFuc2Zvcm1hdGlvblxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZT19IG91dFJlY3RcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRCb3VuZHNXaXRoUG9pbnRzKHBvaW50cywgd29ybGRUcmFuc2Zvcm1hdGlvbiwgb3V0UmVjdCkge1xyXG4gICAgb3V0UmVjdCA9IG91dFJlY3QgfHwgbmV3IFJlY3RhbmdsZSgpO1xyXG5cclxuICAgIGxldCBtaW5YID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBtYXhYID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWluWSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWF4WSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IHRtcFZlY3RvciA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICB3b3JsZFRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybVhZKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgdG1wVmVjdG9yKTtcclxuXHJcbiAgICAgIGlmIChtaW5YID4gdG1wVmVjdG9yLngpXHJcbiAgICAgICAgbWluWCA9IHRtcFZlY3Rvci54O1xyXG5cclxuICAgICAgaWYgKG1heFggPCB0bXBWZWN0b3IueClcclxuICAgICAgICBtYXhYID0gdG1wVmVjdG9yLng7XHJcblxyXG4gICAgICBpZiAobWluWSA+IHRtcFZlY3Rvci55KVxyXG4gICAgICAgIG1pblkgPSB0bXBWZWN0b3IueTtcclxuXHJcbiAgICAgIGlmIChtYXhZIDwgdG1wVmVjdG9yLnkpXHJcbiAgICAgICAgbWF4WSA9IHRtcFZlY3Rvci55O1xyXG4gICAgfVxyXG5cclxuICAgIG91dFJlY3Quc2V0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XHJcbiAgICByZXR1cm4gb3V0UmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgd2hlbmV2ZXIgYSBnaXZlbiBHYW1lT2JqZWN0IGludGVyc2VjdHMgd2l0aCBhIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ2FtZU9iamVjdCBHYW1lT2JqZWN0IHRvIHRlc3QuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yfSBwb2ludCBBIHBvaW50IHRvIHRlc3QuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbnRlcnNlY3RzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBpbnRlcnNlY3RzKGdhbWVPYmplY3QsIHBvaW50KSB7XHJcbiAgICBsZXQgdG1wVmVjdG9yID0gbmV3IFZlY3RvcigpO1xyXG4gICAgbGV0IGludiA9IGdhbWVPYmplY3Qud29ybGRUcmFuc2Zvcm1hdGlvbkludmVydGVkO1xyXG5cclxuICAgIGludi50cmFuc2Zvcm1WZWN0b3IocG9pbnQsIHRtcFZlY3Rvcik7XHJcblxyXG4gICAgcmV0dXJuIGdhbWVPYmplY3QubG9jYWxCb3VuZHMuY29udGFpbnNYWSh0bXBWZWN0b3IueCwgdG1wVmVjdG9yLnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHBvaW50IHdoZXJlIGludGVyc2VjdGlvbiB3ZXJlIG1hZGUgaW4gbG9jYWwgc3BhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0IEdhbWVPYmplY3QgdG8gdGVzdCBpbnRlcnNlY3Rpb24gd2l0aC5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IHBvaW50IFRoZSBwb2ludCB0byB0ZXN0LlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFZlY3RvciBJZiBwYXNzZWQgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIHdpbGwgYmUgc3RvcmVkIGluIGl0LlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaW50ZXJzZWN0cy5cclxuICAgKi9cclxuICBzdGF0aWMgaW50ZXJzZWN0c0F0KGdhbWVPYmplY3QsIHBvaW50LCBvdXRWZWN0b3IgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFZlY3RvciA9IG91dFZlY3RvciB8fCBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgVmVjdG9yLl9fY2FjaGUuc2V0KCk7XHJcblxyXG4gICAgZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uSW52ZXJ0ZWQudHJhbnNmb3JtVmVjdG9yKHBvaW50LCBWZWN0b3IuX19jYWNoZSk7XHJcbiAgICBsZXQgY29udGFpbnMgPSBnYW1lT2JqZWN0LmxvY2FsQm91bmRzLmNvbnRhaW5zWFkoVmVjdG9yLl9fY2FjaGUueCwgVmVjdG9yLl9fY2FjaGUueSk7XHJcblxyXG4gICAgaWYgKGNvbnRhaW5zID09PSBmYWxzZSlcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIG91dFZlY3Rvci54ID0gVmVjdG9yLl9fY2FjaGUueCAtIGdhbWVPYmplY3QubG9jYWxCb3VuZHMueDtcclxuICAgIG91dFZlY3Rvci55ID0gVmVjdG9yLl9fY2FjaGUueSAtIGdhbWVPYmplY3QubG9jYWxCb3VuZHMueTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIEdhbWVPYmplY3Qgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiBlbGVtZW50cyBpbnRlcnNlY3RzIHRoZSBnaXZlbiBwb2ludC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGdhbWVPYmplY3QgR2FtZU9iamVjdCB0byB0ZXN0LlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9pbnQgUG9pbnQgdG8gdGVzdC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdHxudWxsfSBJbnRlcnNlY3Rpbmcgb2JqZWN0IG9yIG51bGwuXHJcbiAgICovXHJcbiAgc3RhdGljIGludGVyc2VjdHNXaXRoKGdhbWVPYmplY3QsIHBvaW50KSB7XHJcbiAgICBsZXQgb2JqID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSBnYW1lT2JqZWN0Lm51bUNoaWxkcmVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgbGV0IGNoaWxkID0gZ2FtZU9iamVjdC5tQ2hpbGRyZW5baV07XHJcblxyXG4gICAgICBvYmogPSBHYW1lT2JqZWN0LmludGVyc2VjdHNXaXRoKGNoaWxkLCBwb2ludCk7XHJcbiAgICAgIGlmIChvYmogIT0gbnVsbClcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG5cclxuICAgICAgbGV0IGluc2lkZSA9IEdhbWVPYmplY3QuaW50ZXJzZWN0cyhjaGlsZCwgcG9pbnQpO1xyXG4gICAgICBpZiAoaW5zaWRlKSB7XHJcbiAgICAgICAgb2JqID0gY2hpbGQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob2JqID09PSBudWxsICYmIEdhbWVPYmplY3QuaW50ZXJzZWN0cyhnYW1lT2JqZWN0LCBwb2ludCkpXHJcbiAgICAgIHJldHVybiBnYW1lT2JqZWN0O1xyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgR2FtZU9iamVjdCB3aXRoIGdpdmVuIHRhZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIHRvIGZpbmQuXHJcbiAgICogQHJldHVybnMge0FycmF5PGJsYWNrLWVuZ2luZX5HYW1lT2JqZWN0PnxudWxsfSBBcnJheSBvZiBHYW1lT2JqZWN0IG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBmaW5kV2l0aFRhZyh0YWcpIHtcclxuICAgIGlmIChCbGFjay5lbmdpbmUubVRhZ0NhY2hlLmhhc093blByb3BlcnR5KHRhZykgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gQmxhY2suZW5naW5lLm1UYWdDYWNoZVt0YWddO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgQ29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGdhbWVPYmplY3QgR2FtZU9iamVjdCB0byBzdGFydCBzZWFyY2ggZnJvbS5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uIChuZXc6YmxhY2stZW5naW5lfkNvbXBvbmVudCl9IHR5cGUgVHlwZSBvZiBDb21wb25lbnQuXHJcbiAgICogQHJldHVybiB7QXJyYXk8YmxhY2stZW5naW5lfkNvbXBvbmVudD59IEFycmF5IG9mIENvbXBvbmVudCBvciBlbXB0eSBhcnJheS5cclxuICAgKi9cclxuICBzdGF0aWMgZmluZENvbXBvbmVudHMoZ2FtZU9iamVjdCwgdHlwZSkge1xyXG4gICAgRGVidWcuYXNzZXJ0KGdhbWVPYmplY3QgIT09IG51bGwsICdnYW1lT2JqZWN0IGNhbm5vdCBiZSBudWxsLicpO1xyXG4gICAgRGVidWcuYXNzZXJ0KHR5cGUgIT09IG51bGwsICd0eXBlIGNhbm5vdCBiZSBudWxsLicpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7QXJyYXk8Q29tcG9uZW50Pn0gKi9cclxuICAgIGxldCBsaXN0ID0gW107XHJcblxyXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbihHYW1lT2JqZWN0LCBmdW5jdGlvbihuZXc6Q29tcG9uZW50KSk6dm9pZH0gKi9cclxuICAgIGxldCBmID0gZnVuY3Rpb24gKGdhbWVPYmplY3QsIHR5cGUpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lT2JqZWN0Lm1Db21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBnYW1lT2JqZWN0Lm1Db21wb25lbnRzW2ldO1xyXG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgdHlwZSlcclxuICAgICAgICAgIGxpc3QucHVzaChjKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lT2JqZWN0Lm1DaGlsZHJlbi5sZW5ndGg7IGkrKylcclxuICAgICAgICBmKGdhbWVPYmplY3QubUNoaWxkcmVuW2ldLCB0eXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgZihnYW1lT2JqZWN0LCB0eXBlKTtcclxuXHJcbiAgICByZXR1cm4gbGlzdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJ1bnMgYWN0aW9uIGFjcm9zcyBhbGwgR2FtZU9iamVjdHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0IEdhbWVPYmplY3QgdG8gc3RhcnQgaXRlcmF0aW9uIGZyb20uXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihibGFjay1lbmdpbmV+R2FtZU9iamVjdCl9IGFjdGlvbiBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gZXZlcnkgR2FtZU9iamVjdC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JFYWNoKGdhbWVPYmplY3QsIGFjdGlvbikge1xyXG4gICAgaWYgKGdhbWVPYmplY3QgPT0gbnVsbClcclxuICAgICAgZ2FtZU9iamVjdCA9IEJsYWNrLnN0YWdlO1xyXG5cclxuICAgIGxldCByID0gYWN0aW9uKGdhbWVPYmplY3QpO1xyXG4gICAgaWYgKHIgPT09IHRydWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdhbWVPYmplY3QubUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHIgPSBHYW1lT2JqZWN0LmZvckVhY2goZ2FtZU9iamVjdC5tQ2hpbGRyZW5baV0sIGFjdGlvbik7XHJcbiAgICAgIGlmIChyID09PSB0cnVlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBGaW5kcyBvYmplY3QgYnkgaXRzIG5hbWUuIElmIG5vZGUgaXMgbm90IHBhc3NlZCB0aGUgcm9vdCB3aWxsIGJlIHRha2VuIGFzXHJcbiAgICogc3RhcnRpbmcgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgIE5hbWUgdG8gc2VhcmNoLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3Q9fSBub2RlIFN0YXJ0aW5nIEdhbWVPYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gR2FtZU9iamVjdCBvciBudWxsLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBmaW5kKG5hbWUsIG5vZGUpIHtcclxuICAgIGlmIChub2RlID09IG51bGwpXHJcbiAgICAgIG5vZGUgPSBCbGFjay5zdGFnZTtcclxuXHJcbiAgICBpZiAobm9kZS5uYW1lID09PSBuYW1lKVxyXG4gICAgICByZXR1cm4gbm9kZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubnVtQ2hpbGRyZW47IGkrKykge1xyXG4gICAgICBsZXQgciA9IEdhbWVPYmplY3QuZmluZChuYW1lLCBub2RlLmdldENoaWxkQXQoaSkpO1xyXG4gICAgICBpZiAociAhPSBudWxsKVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgb2JqZWN0IGJ5IGl0cyBpZCBwcm9wZXJ0eS4gSWYgbm9kZSBpcyBub3QgcGFzc2VkIHRoZSByb290IHdpbGwgYmUgdGFrZW4gYXNcclxuICAgKiBzdGFydGluZyBwb2ludC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAgICAgICAgIElkIHRvIHNlYXJjaC5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0PX0gbm9kZSAgU3RhcnRpbmcgR2FtZU9iamVjdCBvciBudWxsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IEdhbWVPYmplY3Qgb3IgbnVsbC5cclxuICAgKi9cclxuICBzdGF0aWMgZmluZEJ5SWQoaWQsIG5vZGUpIHtcclxuICAgIGlmIChub2RlID09IG51bGwpXHJcbiAgICAgIG5vZGUgPSBCbGFjay5zdGFnZTtcclxuXHJcbiAgICBpZiAobm9kZS5pZCA9PT0gaWQpXHJcbiAgICAgIHJldHVybiBub2RlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5udW1DaGlsZHJlbjsgaSsrKSB7XHJcbiAgICAgIGxldCByID0gR2FtZU9iamVjdC5maW5kQnlJZChpZCwgbm9kZS5nZXRDaGlsZEF0KGkpKTtcclxuICAgICAgaWYgKHIgIT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RhZ2Ugc2NhbGUgbW9kZS5cclxuICogXHJcbiAqIE1ha2Ugc3VyZSB0byB0byBoYXZlIHZpZXdwb3J0IG1ldGEgdGFnIGluIHlvdXIgSFRNTCBmaWxlLlxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cImluaXRpYWwtc2NhbGU9MSBtYXhpbXVtLXNjYWxlPTEgdXNlci1zY2FsYWJsZT0wXCIgLz5cclxuICogXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgU3RhZ2VTY2FsZU1vZGUgPSB7XHJcbiAgLyoqIFRoZSBzdGFnZSBzaXplIHdpbGwgYmUgdGhlIHNhbWUgbm8gbWF0dGVyIHdoYXQgRFBJIGlzICovXHJcbiAgTk9STUFMOiAnbm9ybWFsJyxcclxuICAvKiogVGhlIHN0YWdlIHNpemUgd2lsbCBiZSBhZmZlY3RlZCBieSBkcGkgKi9cclxuICBOT19TQ0FMRTogJ25vU2NhbGUnLFxyXG4gIC8qKiBUaGUgc3RhZ2Ugc2l6ZSB0cmllcyB0byBzdGF5IGluc2lkZSByZXF1ZXN0ZWQgc2l6ZS4gZGVmYXVsdCBpcyA5NjB4NjQwICovXHJcbiAgRklYRUQ6ICdmaXhlZCcsXHJcbiAgLyoqIFRoZSBzdGFnZSBzaXplIHdpbGwgYmUgZXF1YWwgdG8gcmVxdWVzdGVkIHNpemUsIHBvc2l0aW9uIHdpbGwgYmUgY2VudGVyZWQgKi9cclxuICBMRVRURVJCT1g6ICdsZXR0ZXJCb3gnLFxyXG4gIC8qKiBUaGUgc3RhZ2Ugc2l6ZSB3aWxsIGJlIGVxdWFsIHRvIHJlcXVlc3RlZCBzaXplLCBwb3NpdGlvbiB3aWxsIGJlIGNlbnRlcmVkLCBhbmQgY292ZXIgdGhlIHZpZXdwb3J0ICovXHJcbiAgQ09WRVI6ICdjb3ZlcidcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBrZXlib2FyZCBldmVudC5cclxuICpcclxuICogQGNhdCBpbnB1dFxyXG4gKi9cclxuY2xhc3MgS2V5SW5mbyB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgS2V5SW5mb1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBuYXRpdmVFdmVudCBOYXRpdmUgdG91Y2ggZXZlbnQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihuYXRpdmVFdmVudCkge1xyXG4gICAgdGhpcy5rZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcclxuICAgIHRoaXMuY29kZSA9IG5hdGl2ZUV2ZW50LmNvZGU7XHJcbiAgICB0aGlzLmNoYXIgPSBuYXRpdmVFdmVudC5rZXk7XHJcbiAgICB0aGlzLnNoaWZ0S2V5ID0gbmF0aXZlRXZlbnQuc2hpZnRLZXk7XHJcbiAgICB0aGlzLmFsdEtleSA9IG5hdGl2ZUV2ZW50LmFsdEtleTtcclxuICAgIHRoaXMuY3RybEtleSA9IG5hdGl2ZUV2ZW50LmN0cmxLZXk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ29udGFpbnMgc3lzdGVtIGZ1bmN0aW9ucy5cclxuICogQHN0YXRpY1xyXG4gKiBAY2F0IHN5c3RlbVxyXG4gKi9cclxuY2xhc3MgRGV2aWNlIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcnxudWxsfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGl4ZWxSYXRpb0NhY2hlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBPUyBuYW1lLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgb3MoKSB7XHJcbiAgICBsZXQgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcclxuXHJcbiAgICBpZiAoL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVzZXJBZ2VudCkpXHJcbiAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XHJcblxyXG4gICAgaWYgKC9hbmRyb2lkL2kudGVzdCh1c2VyQWdlbnQpKVxyXG4gICAgICByZXR1cm4gJ0FuZHJvaWQnO1xyXG5cclxuICAgIGlmICgvaVBhZHxpUGhvbmV8aVBvZC8udGVzdCh1c2VyQWdlbnQpLyogJiYgIXdpbmRvdy5NU1N0cmVhbSovKVxyXG4gICAgICByZXR1cm4gJ2lPUyc7XHJcblxyXG4gICAgcmV0dXJuICd1bmtub3duJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgVHJ1ZSBpZiB0b3VjaCBzY3JlZW4gaXMgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzVG91Y2goKSB7XHJcbiAgICBsZXQgaGFzRXZlbnQgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XHJcbiAgICBpZiAoaGFzRXZlbnQpXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIGlmIChuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIFRydWUgaWYgZW5naW5lIGlzIHJ1bm5pbmcgb24gbW9iaWxlIGRldmljZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzTW9iaWxlKCkge1xyXG4gICAgcmV0dXJuIC9Nb2JpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBzY3JlZW4gcGl4ZWwgcmF0aW8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHBpeGVsUmF0aW8oKSB7XHJcbiAgICBpZiAodGhpcy5tUGl4ZWxSYXRpb0NhY2hlID09PSBudWxsKVxyXG4gICAgICB0aGlzLm1QaXhlbFJhdGlvQ2FjaGUgPSB0aGlzLmdldERldmljZVBpeGVsUmF0aW8oKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tUGl4ZWxSYXRpb0NhY2hlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHdlYiBhdWRpbyBpcyBzdXBwb3J0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCB3ZWJBdWRpb1N1cHBvcnRlZCgpIHtcclxuICAgIHJldHVybiB3aW5kb3dbJ0F1ZGlvQ29udGV4dCddICE9IG51bGwgfHwgd2luZG93Wyd3ZWJraXRBdWRpb0NvbnRleHQnXSAhPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICpcclxuICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRGVzY3JpcHRpb25cclxuICAgKi9cclxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xyXG4gICAgaWYgKHdpbmRvdy5zY3JlZW4uc3lzdGVtWERQSSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cuc2NyZWVuLnN5c3RlbVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKVxyXG4gICAgICByZXR1cm4gd2luZG93LnNjcmVlbi5zeXN0ZW1YRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSTtcclxuICAgIGVsc2UgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHJcbiAgICByZXR1cm4gMTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIHJlbmRlcmFibGUgb2JqZWN0cy4gQWRkcyBgYWxwaGFgIGFuZCBgdmlzaWJsZWAgcHJvcGVydGllcyB0byBHYW1lT2JqZWN0LlxyXG4gKlxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkdhbWVPYmplY3RcclxuICovXHJcbmNsYXNzIERpc3BsYXlPYmplY3QgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BbHBoYSA9IDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+QmxlbmRNb2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQmxlbmRNb2RlID0gQmxlbmRNb2RlLkFVVE87XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2xpcFJlY3QgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlbmRlcmVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DYWNoZUFzQml0bWFwRHluYW1pYyA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlQXNCaXRtYXBEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeHxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+Q2FudmFzUmVuZGVyVGV4dHVyZXxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlQm91bmRzID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUgez9udW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db2xvciA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU25hcFRvUGl4ZWxzID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgbG9vcCwgYWxsIHJlbmRlcmVycyBhcmUgYWxyZWFkeSBjb2xsZWN0ZWQgYW5kIHRoaXMgb2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4gd2lsbCBiZVxyXG4gICAqIHJlbmRlcmVkLiBTaG91bGQgYmUgdXNlZCB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGxhc3QgYW5kIGN1cnJlbnQgc3RhdGUuIFxyXG4gICAqIFxyXG4gICAqIE5PVEU6IEFkZGluZywgcmVtb3Zpbmcgb3IgY2hhbmdpbmcgY2hpbGRyZW4gZWxlbWVudHMgaW5zaWRlIG9uUmVuZGVyIG1ldGhvZCBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxyXG4gICAqIFxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uUmVuZGVyKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZhY3RvcnkgbWV0aG9kIHJldHVybnMgY29uY3JldGUgcmVuZGVyZXIgZm9yIHRoaXMgR2FtZSBPYmplY3QuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZW5kZXJlcn1cclxuICAgKi9cclxuICBnZXRSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiBCbGFjay5kcml2ZXIuZ2V0UmVuZGVyZXIoJ0Rpc3BsYXlPYmplY3QnLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25HZXRMb2NhbEJvdW5kcyhvdXRSZWN0ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBvdXRSZWN0ID0gb3V0UmVjdCB8fCBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMubUNsaXBSZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubUNsaXBSZWN0LmNvcHlUbyhvdXRSZWN0KTtcclxuICAgICAgcmV0dXJuIG91dFJlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFJlY3Quc2V0KDAsIDAsIDAsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBnZXRCb3VuZHMoc3BhY2UgPSB1bmRlZmluZWQsIGluY2x1ZGVDaGlsZHJlbiA9IHRydWUsIG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBsZXQgbG9jYWxCb3VuZHMgPSB0aGlzLm9uR2V0TG9jYWxCb3VuZHMoKTtcclxuXHJcbiAgICBpZiAoc3BhY2UgPT0gbnVsbClcclxuICAgICAgc3BhY2UgPSB0aGlzLm1QYXJlbnQ7XHJcblxyXG4gICAgaWYgKHNwYWNlID09IHRoaXMpIDsgZWxzZSBpZiAoc3BhY2UgPT0gdGhpcy5tUGFyZW50KSB7XHJcbiAgICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4gPT09IGZhbHNlIHx8IHRoaXMubUNsaXBSZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IE1hdHJpeC5wb29sLmdldCgpO1xyXG4gICAgICAgIG1hdHJpeC5jb3B5RnJvbSh0aGlzLmxvY2FsVHJhbnNmb3JtYXRpb24pO1xyXG4gICAgICAgIG1hdHJpeC50cmFuc2Zvcm1SZWN0KGxvY2FsQm91bmRzLCBvdXRSZWN0KTtcclxuICAgICAgICBNYXRyaXgucG9vbC5yZWxlYXNlKG1hdHJpeCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaW5jbHVkZUNoaWxkcmVuID09PSB0cnVlICYmIHRoaXMubURpcnR5ICYgRGlydHlGbGFnLkJPVU5EUykge1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBNYXRyaXgucG9vbC5nZXQoKTtcclxuICAgICAgICBtYXRyaXguY29weUZyb20odGhpcy5sb2NhbFRyYW5zZm9ybWF0aW9uKTtcclxuICAgICAgICBtYXRyaXgudHJhbnNmb3JtUmVjdChsb2NhbEJvdW5kcywgb3V0UmVjdCk7XHJcbiAgICAgICAgTWF0cml4LnBvb2wucmVsZWFzZShtYXRyaXgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFJldHVybiBjYWNoZWRcclxuICAgICAgICBvdXRSZWN0LmNvcHlGcm9tKHRoaXMubUJvdW5kc0NhY2hlKTtcclxuICAgICAgICByZXR1cm4gb3V0UmVjdDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IG1hdHJpeCA9IE1hdHJpeC5wb29sLmdldCgpO1xyXG4gICAgICBtYXRyaXguY29weUZyb20odGhpcy53b3JsZFRyYW5zZm9ybWF0aW9uKTtcclxuICAgICAgbWF0cml4LnByZXBlbmQoc3BhY2Uud29ybGRUcmFuc2Zvcm1hdGlvbkludmVydGVkKTtcclxuICAgICAgbWF0cml4LnRyYW5zZm9ybVJlY3QobG9jYWxCb3VuZHMsIG91dFJlY3QpO1xyXG4gICAgICBNYXRyaXgucG9vbC5yZWxlYXNlKG1hdHJpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNwYWNlICE9PSB0aGlzKSB7XHJcbiAgICAgIGlmICh0aGlzLm1DbGlwUmVjdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIG91dFJlY3QueCArPSB0aGlzLm1QaXZvdFg7XHJcbiAgICAgICAgb3V0UmVjdC55ICs9IHRoaXMubVBpdm90WTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbG9jYWxCb3VuZHMuY29weVRvKG91dFJlY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm1DbGlwUmVjdCAhPT0gbnVsbClcclxuICAgICAgcmV0dXJuIG91dFJlY3Q7XHJcblxyXG4gICAgaWYgKGluY2x1ZGVDaGlsZHJlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICBsZXQgY2hpbGRCb3VuZHMgPSBSZWN0YW5nbGUucG9vbC5nZXQoKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaGlsZEJvdW5kcy56ZXJvKCk7XHJcblxyXG4gICAgICAgIHRoaXMubUNoaWxkcmVuW2ldLmdldEJvdW5kcyhzcGFjZSwgaW5jbHVkZUNoaWxkcmVuLCBjaGlsZEJvdW5kcyk7XHJcbiAgICAgICAgb3V0UmVjdC51bmlvbihjaGlsZEJvdW5kcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFJlY3RhbmdsZS5wb29sLnJlbGVhc2UoY2hpbGRCb3VuZHMpO1xyXG5cclxuICAgICAgaWYgKHNwYWNlID09IHRoaXMubVBhcmVudCAmJiB0aGlzLm1EaXJ0eSAmIERpcnR5RmxhZy5CT1VORFMpIHtcclxuICAgICAgICB0aGlzLm1Cb3VuZHNDYWNoZS5jb3B5RnJvbShvdXRSZWN0KTtcclxuICAgICAgICB0aGlzLm1EaXJ0eSBePSBEaXJ0eUZsYWcuQk9VTkRTO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFJlY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGhpdFRlc3QobG9jYWxQb2ludCkge1xyXG4gICAgbGV0IGMgPSAvKiogQHR5cGUge0lucHV0Q29tcG9uZW50fSovICh0aGlzLmdldENvbXBvbmVudChJbnB1dENvbXBvbmVudCkpO1xyXG4gICAgbGV0IHRvdWNoYWJsZSA9IGMgIT09IG51bGwgJiYgYy50b3VjaGFibGU7XHJcbiAgICBsZXQgaW5zaWRlTWFzayA9IHRoaXMub25IaXRUZXN0TWFzayhsb2NhbFBvaW50KTtcclxuXHJcbiAgICBpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSB8fCB0b3VjaGFibGUgPT09IGZhbHNlIHx8IGluc2lkZU1hc2sgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcclxuICAgIGxldCBudW1DaGlsZHJlbiA9IHRoaXMubUNoaWxkcmVuLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gbnVtQ2hpbGRyZW4gLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICBsZXQgY2hpbGQgPSB0aGlzLm1DaGlsZHJlbltpXTtcclxuXHJcbiAgICAgIHRhcmdldCA9IGNoaWxkLmhpdFRlc3QobG9jYWxQb2ludCk7XHJcblxyXG4gICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub25IaXRUZXN0KGxvY2FsUG9pbnQpID09PSB0cnVlKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogQGluaGVyaXREb2NcclxuICAqL1xyXG4gIG9uSGl0VGVzdE1hc2sobG9jYWxQb2ludCkge1xyXG4gICAgaWYgKHRoaXMubUNsaXBSZWN0ID09PSBudWxsKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBsZXQgdG1wVmVjdG9yID0gVmVjdG9yLnBvb2wuZ2V0KCk7XHJcbiAgICB0aGlzLndvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZC50cmFuc2Zvcm1WZWN0b3IobG9jYWxQb2ludCwgdG1wVmVjdG9yKTtcclxuXHJcbiAgICBsZXQgY29udGFpbnMgPSB0aGlzLm1DbGlwUmVjdC5jb250YWluc1hZKHRtcFZlY3Rvci54IC0gdGhpcy5tUGl2b3RYLCB0bXBWZWN0b3IueSAtIHRoaXMubVBpdm90WSk7XHJcbiAgICBWZWN0b3IucG9vbC5yZWxlYXNlKHRtcFZlY3Rvcik7XHJcblxyXG4gICAgcmV0dXJuIGNvbnRhaW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRpbnRpbmcgY29sb3Igb2YgdGhlIG9iamVjdC4gUGFzcyBgbnVsbGAgdG8gZGlzYWJsZSB0aW50aW5nLiBUaW50aW5nIGNvbG9yIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgY2hpbGRyZW5cclxuICAgKiBvYmplY3RzLiBZb3UgY2FuIG92ZXJyaWRlIHRpbnQgY29sb3IgZm9yIGNoaWxkcmVuIGJ5IHNldHRpbmcgY3VzdG9tIHZhbHVlIG9yIGBudWxsYCB0byBpbmhlcml0IGNvbG9yIGZyb20gcGFyZW50LlxyXG4gICAqIEByZXR1cm5zIHs/bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBjb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLm1Db2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7P251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBjb2xvcih2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubUNvbG9yID09PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUNvbG9yID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFJlbmRlckRpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgd2hldGhlciB0aGlzIGNvbnRhaW5lciBhbmQgYWxsIGl0J3MgY2hpbGRyZW4gc2hvdWxkIGJlIGJha2VkIGludG8gYml0bWFwLiBTZXR0aW5nIGBjYWNoZUFzQml0bWFwYCBvbnRvXHJcbiAgICogU3ByaXRlcywsIFRleHRGaWVsZCdzIG9yIGFueSBvdGhlciBpbmhlcml0ZWQgY2xhc3NlcyB3aWxsIGdpdmUgemVybyBlZmZlY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBcclxuICAgKi9cclxuICBnZXQgY2FjaGVBc0JpdG1hcCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1DYWNoZUFzQml0bWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGNhY2hlQXNCaXRtYXAodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5tQ2FjaGVBc0JpdG1hcClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUNhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMubUNhY2hlID0gbnVsbDtcclxuICAgICAgdGhpcy5tQ2FjaGVBc0JpdG1hcERpcnR5ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlID0gbnVsbDtcclxuICAgICAgdGhpcy5tQ2FjaGVCb3VuZHMgPSBudWxsO1xyXG5cclxuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9zZXRzIHdoZW5ldmVyIGNhY2hlIGFzIGJpdG1hcCBzaG91bGQgYmUgYXV0b21hdGljYWxseSByZWZyZXNoZWQuXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGNhY2hlQXNCaXRtYXBEeW5hbWljKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNhY2hlQXNCaXRtYXBEeW5hbWljO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGNhY2hlQXNCaXRtYXBEeW5hbWljKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1DYWNoZUFzQml0bWFwRHluYW1pYyA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBvYmplY3QuXHJcbiAgICogQmFrZWQgb2JqZWN0cyBtYXkgY2hhbmdlIGJlaGF2aW9yLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBhbHBoYSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1BbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGFscGhhKHZhbHVlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoIWlzTmFOKHZhbHVlKSwgJ1ZhbHVlIGNhbm5vdCBiZSBOYU4nKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQWxwaGEgPT09IE1hdGhFeC5jbGFtcCh2YWx1ZSwgMCwgMSkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1BbHBoYSA9IE1hdGhFeC5jbGFtcCh2YWx1ZSwgMCwgMSk7XHJcbiAgICB0aGlzLnNldFJlbmRlckRpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdmlzaWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1WaXNpYmxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHZpc2libGUodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1WaXNpYmxlID09PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubVZpc2libGUgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0UmVuZGVyRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBibGVuZCBtb2RlIGZvciB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkJsZW5kTW9kZX1cclxuICAgKi9cclxuICBnZXQgYmxlbmRNb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUJsZW5kTW9kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkJsZW5kTW9kZX0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBibGVuZE1vZGUodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1CbGVuZE1vZGUgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tQmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFJlbmRlckRpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgY2xpcHBpbmcgYXJlYSBmb3IgdGhlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9XHJcbiAgICovXHJcbiAgZ2V0IGNsaXBSZWN0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNsaXBSZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGNsaXBSZWN0KHZhbHVlKSB7XHJcbiAgICB0aGlzLm1DbGlwUmVjdCA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRSZW5kZXJEaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9zZXRzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IHggYW5kIHkgdmFsdWUgc2hvdWxkIGJlIHJvdW5kZWQuXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHNuYXBUb1BpeGVscygpIHtcclxuICAgIHJldHVybiB0aGlzLm1TbmFwVG9QaXhlbHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0IHNuYXBUb1BpeGVscyh2YWx1ZSkge1xyXG4gICAgdGhpcy5tU25hcFRvUGl4ZWxzID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCByZW5kZXJhYmxlIG9iamVjdHMuIEFkZHMgYGFscGhhYCBhbmQgYHZpc2libGVgIHByb3BlcnRpZXMgdG8gR2FtZU9iamVjdC5cclxuICpcclxuICogQGNhdCBkaXNwbGF5XHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5EaXNwbGF5T2JqZWN0XHJcbiAqL1xyXG5jbGFzcyBDYW1lcmEgZXh0ZW5kcyBEaXNwbGF5T2JqZWN0IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgQmxhY2suY2FtZXJhID0gdGhpcztcclxuICB9XHJcblxyXG4gIGdldCB3b3JsZFRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgbGV0IHd0ID0gc3VwZXIud29ybGRUcmFuc2Zvcm1hdGlvbi5jbG9uZSgpO1xyXG4gICAgd3QucHJlcGVuZCh0aGlzLnN0YWdlLndvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZCk7XHJcblxyXG4gICAgcmV0dXJuIHd0O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgaW5wdXQgc3lzdGVtIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBtb3VzZSwgdG91Y2ggYW5kIGtleWJvYXJkIGlucHV0IGV2ZW50cy5cclxuICogUG9pbnRlciBldmVudHMgd29ya3MgZm9yIGEgc2luZ2xlIHRhcmdldCBvbmx5LlxyXG4gKiBHbG9iYWwgSW5wdXQgbWVzc2FnZXMgaGFzIGhpZ2hlciBwcmlvcml0eS5cclxuICpcclxuICogV2hlbiBHYW1lT2JqZWN0IGdldHMgYSBgcG9pbnRlckRvd25gIG1lc3NhZ2UgaXQgZ2V0cyB0YXJnZXQgbG9ja2VkLiBPdGhlclxyXG4gKiBvYmplY3RzIHdpbGwgbm90IHJlY2VpdmUgYHBvaW50ZXJNb3ZlYCBvciBgcG9pbnRlclVwYCBtZXNzYWdlcy4gVGFyZ2V0IGxvY2tlZFxyXG4gKiBvYmplY3Qgd2lsbCByZWNlaXZlIGBwb2ludGVyVXBgIG1lc3NhZ2UgZXZlbiBpZiBwb2ludGVyIGlzIG91dHNpZGUgb2YgaXRzXHJcbiAqIGJvdW5kcy5cclxuICogXHJcbiAqIEV2ZXJ5IG9iamVjdCBpbiB0aGUgZGlzcGxheSBsaXN0IHNob3VsZCBiZSBgdG91Y2hhYmxlYCBpbiBvcmRlciB0byByZWNlaXZlIGlucHV0IG1lc3NhZ2VzLlxyXG4gKlxyXG4gKiBAY2F0IGlucHV0XHJcbiAqIEBmaXJlcyBJbnB1dCNwb2ludGVyTW92ZVxyXG4gKiBAZmlyZXMgSW5wdXQjcG9pbnRlckRvd25cclxuICogQGZpcmVzIElucHV0I3BvaW50ZXJVcFxyXG4gKiBcclxuICogQGZpcmVzIEdhbWVPYmplY3QjcG9pbnRlck1vdmVcclxuICogQGZpcmVzIEdhbWVPYmplY3QjcG9pbnRlckRvd25cclxuICogQGZpcmVzIEdhbWVPYmplY3QjcG9pbnRlclVwXHJcbiAqIFxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+U3lzdGVtXHJcbiAqL1xyXG5jbGFzcyBJbnB1dCBleHRlbmRzIFN5c3RlbSB7XHJcbiAgLyoqXHJcbiAgICogUHJpdmF0ZSBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgRGVidWcuYXNzZXJ0KHRoaXMuY29uc3RydWN0b3IuaW5zdGFuY2UgPT0gbnVsbCwgJ09ubHkgc2luZ2xlIGluc3RhbmNlIGlzIGFsbG93ZWQnKTtcclxuXHJcbiAgICBCbGFjay5pbnB1dCA9IHRoaXM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVZpZXdwb3J0UG9zaXRpb24gPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvaW50ZXJQb3NpdGlvbiA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RhZ2VQb3NpdGlvbiA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtFbGVtZW50fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Eb20gPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1FdmVudExpc3QgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1LZXlFdmVudExpc3QgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PHtuYW1lOiBTdHJpbmcsIGxpc3RlbmVyOiBGdW5jdGlvbn0+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQm91bmRMaXN0ZW5lcnMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTx7ZTogRXZlbnQsIHg6IG51bWJlciwgeTpudW1iZXJ9Pn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvaW50ZXJRdWV1ZSA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PEtleWJvYXJkRXZlbnQ+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tS2V5UXVldWUgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUHJlc3NlZEtleXMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNQb2ludGVyRG93biA9IGZhbHNlO1xyXG5cclxuICAgIC8vIE5PVEU6IHdlIG5lZWQgZ3VhcmFudGVlIHRoYXQga2V5cyBhcmUgbm90IGdvaW5nIHRvIGNoYW5nZSB0aGVpcnMgb3JkZXIgd2hlbiBpdGVyYXRpbmcuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtNYXB9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnB1dExpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRhcmdldCA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkNvbXBvbmVudH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRhcmdldENvbXBvbmVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Mb2NrZWRUYXJnZXQgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Db21wb25lbnR9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1MYXN0SW5UYXJnZXRDb21wb25lbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19pbml0aWFsaXplKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICovXHJcbiAgX19pbml0aWFsaXplKCkge1xyXG4gICAgdGhpcy5tRG9tID0gQmxhY2suZW5naW5lLnZpZXdwb3J0Lm5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgdGhpcy5fX2luaXRMaXN0ZW5lcnMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9faW5pdExpc3RlbmVycygpIHtcclxuICAgIHRoaXMubUtleUV2ZW50TGlzdCA9IG1LZXlFdmVudExpc3Q7XHJcbiAgICBsZXQgaXNNb3VzZURldmljZSA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgIHRoaXMubUV2ZW50TGlzdCA9IG1Qb2ludGVyRXZlbnRMaXN0O1xyXG4gICAgICBpc01vdXNlRGV2aWNlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEJsYWNrLmRldmljZS5pc1RvdWNoICYmIEJsYWNrLmRldmljZS5pc01vYmlsZSkge1xyXG4gICAgICB0aGlzLm1FdmVudExpc3QgPSBtVG91Y2hFdmVudExpc3Q7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5tRXZlbnRMaXN0ID0gbU1vdXNlRXZlbnRMaXN0O1xyXG4gICAgICBpc01vdXNlRGV2aWNlID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgdGhpcy5tRG9tLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5tRXZlbnRMaXN0W2ldLCBlID0+IHRoaXMuX19vblBvaW50ZXJFdmVudChlKSwgZmFsc2UpO1xyXG5cclxuICAgIGxldCBhZGRCb3VuZHNMaXN0ZW5lciA9ICh0YXJnZXQsIG5hbWUsIGFjdGlvbikgPT4ge1xyXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGUgPT4gYWN0aW9uLmNhbGwodGhpcywgZSk7XHJcblxyXG4gICAgICB0aGlzLm1Cb3VuZExpc3RlbmVycy5wdXNoKHsgbmFtZTogbmFtZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH0pO1xyXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGFkZEJvdW5kc0xpc3RlbmVyKGRvY3VtZW50LCB0aGlzLm1FdmVudExpc3RbSVhfUE9JTlRFUl9NT1ZFXSwgdGhpcy5fX29uUG9pbnRlckV2ZW50RG9jKTtcclxuICAgIGFkZEJvdW5kc0xpc3RlbmVyKGRvY3VtZW50LCB0aGlzLm1FdmVudExpc3RbSVhfUE9JTlRFUl9VUF0sIHRoaXMuX19vblBvaW50ZXJFdmVudERvYyk7XHJcblxyXG4gICAgaWYgKGlzTW91c2VEZXZpY2UgPT09IHRydWUpXHJcbiAgICAgIGFkZEJvdW5kc0xpc3RlbmVyKHdpbmRvdywgJ3doZWVsJywgdGhpcy5fX29uUG9pbnRlckV2ZW50RG9jKTtcclxuXHJcbiAgICAvLyBoYW5kbGUga2V5Ym9hcmQgbGlzdGVuZXJzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubUtleUV2ZW50TGlzdC5sZW5ndGg7IGkrKylcclxuICAgICAgYWRkQm91bmRzTGlzdGVuZXIoZG9jdW1lbnQsIHRoaXMubUtleUV2ZW50TGlzdFtpXSwgdGhpcy5fX29uS2V5RXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgX19vbktleUV2ZW50KGUpIHtcclxuICAgIGlmIChCbGFjay5lbmdpbmUuaXNQYXVzZWQgPT09IHRydWUpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB0aGlzLm1LZXlRdWV1ZS5wdXNoKGUpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19vblBvaW50ZXJFdmVudERvYyhlKSB7XHJcbiAgICBpZiAoQmxhY2suZW5naW5lLmlzUGF1c2VkID09PSB0cnVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbGV0IG92ZXIgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBJRTExIGRvZXMgbm90IGhhdmUgc3VwcG9ydCBmb3IgYHBhdGhgXHJcbiAgICBsZXQgZWxlbWVudCA9IGUudGFyZ2V0O1xyXG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcclxuICAgICAgaWYgKGVsZW1lbnQgPT09IHRoaXMubURvbSkge1xyXG4gICAgICAgIG92ZXIgPSB0cnVlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGUudHlwZSA9PT0gJ3doZWVsJykge1xyXG4gICAgICBpZiAob3ZlciA9PT0gdHJ1ZSlcclxuICAgICAgICB0aGlzLl9fcHVzaEV2ZW50KGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKG92ZXIgPT09IGZhbHNlICYmIHRoaXMubUlzUG9pbnRlckRvd24gPT09IHRydWUpXHJcbiAgICAgICAgdGhpcy5fX3B1c2hFdmVudChlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBfX29uUG9pbnRlckV2ZW50KGUpIHtcclxuICAgIGlmIChCbGFjay5lbmdpbmUuaXNQYXVzZWQgPT09IHRydWUpXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgdGhpcy5fX3B1c2hFdmVudChlKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fcHVzaEV2ZW50KGUpIHtcclxuICAgIGxldCAvKiogQHR5cGUge1ZlY3RvcnxudWxsfSAqLyBwID0gbnVsbDtcclxuICAgIGlmIChlLnR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMClcclxuICAgICAgcCA9IHRoaXMuX19nZXRUb3VjaFBvcyh0aGlzLm1Eb20sIC8qKiBAdHlwZSB7VG91Y2hFdmVudH0gKi8oZSkpO1xyXG4gICAgZWxzZVxyXG4gICAgICBwID0gdGhpcy5fX2dldFBvaW50ZXJQb3ModGhpcy5tRG9tLCBlKTtcclxuXHJcbiAgICB0aGlzLm1Qb2ludGVyUXVldWUucHVzaCh7IGU6IGUsIHg6IHAueCwgeTogcC55IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjYW52YXNcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBfX2dldFBvaW50ZXJQb3MoY2FudmFzLCBldnQpIHtcclxuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGNvbnN0IHJvdGF0aW9uID0gQmxhY2suZW5naW5lLnZpZXdwb3J0LnJvdGF0aW9uO1xyXG5cclxuICAgIGxldCBzY2FsZVggPSAocm90YXRpb24gPT09IDAgPyBjYW52YXMuY2xpZW50V2lkdGggOiBjYW52YXMuY2xpZW50SGVpZ2h0KSAvIHJlY3Qud2lkdGg7XHJcbiAgICBsZXQgc2NhbGVZID0gKHJvdGF0aW9uID09PSAwID8gY2FudmFzLmNsaWVudEhlaWdodCA6IGNhbnZhcy5jbGllbnRXaWR0aCkgLyByZWN0LmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcigoZXZ0LmNsaWVudFggLSByZWN0LmxlZnQpICogc2NhbGVYLCAoZXZ0LmNsaWVudFkgLSByZWN0LnRvcCkgKiBzY2FsZVkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjYW52YXNcclxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dFxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAqL1xyXG4gIF9fZ2V0VG91Y2hQb3MoY2FudmFzLCBldnQpIHtcclxuICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7VG91Y2h9ICovXHJcbiAgICBsZXQgdG91Y2ggPSBldnQuY2hhbmdlZFRvdWNoZXNbMF07IC8vIGlvcz8gd2hhdCBhYm91dCBhbmRyb2lkP1xyXG4gICAgbGV0IHggPSB0b3VjaC5jbGllbnRYO1xyXG4gICAgbGV0IHkgPSB0b3VjaC5jbGllbnRZO1xyXG5cclxuICAgIGNvbnN0IHJvdGF0aW9uID0gQmxhY2suZW5naW5lLnZpZXdwb3J0LnJvdGF0aW9uO1xyXG4gICAgbGV0IHNjYWxlWCA9IChyb3RhdGlvbiA9PT0gMCA/IGNhbnZhcy5jbGllbnRXaWR0aCA6IGNhbnZhcy5jbGllbnRIZWlnaHQpIC8gcmVjdC53aWR0aDtcclxuICAgIGxldCBzY2FsZVkgPSAocm90YXRpb24gPT09IDAgPyBjYW52YXMuY2xpZW50SGVpZ2h0IDogY2FudmFzLmNsaWVudFdpZHRoKSAvIHJlY3QuaGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yKCh4IC0gcmVjdC5sZWZ0KSAqIHNjYWxlWCwgKHkgLSByZWN0LnRvcCkgKiBzY2FsZVkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvblVwZGF0ZSgpIHtcclxuICAgIC8vIG9tZywgd2hvIGdhdmUgeW91IGtleWJvYXJkP1xyXG4gICAgdGhpcy5fX3VwZGF0ZUtleWJvYXJkKCk7XHJcblxyXG4gICAgY29uc3Qgc2l6ZSA9IEJsYWNrLmVuZ2luZS52aWV3cG9ydC5zaXplO1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSBCbGFjay5lbmdpbmUudmlld3BvcnQucm90YXRpb247XHJcblxyXG4gICAgbGV0IHN0YWdlID0gQmxhY2suc3RhZ2U7XHJcblxyXG4gICAgd2hpbGUgKHRoaXMubVBvaW50ZXJRdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IG5hdGl2ZUV2ZW50ID0gdGhpcy5tUG9pbnRlclF1ZXVlLnNoaWZ0KCk7XHJcblxyXG4gICAgICBjb25zdCB4ID0gbmF0aXZlRXZlbnQueDtcclxuICAgICAgY29uc3QgeSA9IG5hdGl2ZUV2ZW50Lnk7XHJcblxyXG4gICAgICBpZiAocm90YXRpb24gPT09IDEpIHtcclxuICAgICAgICBuYXRpdmVFdmVudC54ID0geTtcclxuICAgICAgICBuYXRpdmVFdmVudC55ID0gc2l6ZS5oZWlnaHQgLSB4O1xyXG4gICAgICB9IGVsc2UgaWYgKHJvdGF0aW9uID09PSAtMSkge1xyXG4gICAgICAgIG5hdGl2ZUV2ZW50LnggPSBzaXplLndpZHRoIC0geTtcclxuICAgICAgICBuYXRpdmVFdmVudC55ID0geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdXBkYXRlIHRvIHRoZSBsYXRlc3QgcG9zaXRpb25cclxuICAgICAgdGhpcy5tUG9pbnRlclBvc2l0aW9uLnggPSBuYXRpdmVFdmVudC54O1xyXG4gICAgICB0aGlzLm1Qb2ludGVyUG9zaXRpb24ueSA9IG5hdGl2ZUV2ZW50Lnk7XHJcblxyXG4gICAgICB0aGlzLm1WaWV3cG9ydFBvc2l0aW9uLmNvcHlGcm9tKHRoaXMubVBvaW50ZXJQb3NpdGlvbik7XHJcblxyXG4gICAgICBpZiAoQmxhY2suY2FtZXJhICE9PSBudWxsKVxyXG4gICAgICAgIEJsYWNrLmNhbWVyYS53b3JsZFRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybVZlY3Rvcih0aGlzLm1Qb2ludGVyUG9zaXRpb24sIHRoaXMubVBvaW50ZXJQb3NpdGlvbik7XHJcblxyXG4gICAgICB0aGlzLm1TdGFnZVBvc2l0aW9uLmNvcHlGcm9tKHRoaXMubVBvaW50ZXJQb3NpdGlvbik7XHJcblxyXG4gICAgICBsZXQgaW52ID0gc3RhZ2Uud29ybGRUcmFuc2Zvcm1hdGlvbkludmVydGVkO1xyXG4gICAgICBpbnYudHJhbnNmb3JtVmVjdG9yKHRoaXMubVN0YWdlUG9zaXRpb24sIHRoaXMubVN0YWdlUG9zaXRpb24pO1xyXG5cclxuICAgICAgbGV0IGV2ZW50VHlwZSA9IG1JbnB1dEV2ZW50c0xvb2t1cFt0aGlzLm1FdmVudExpc3QuaW5kZXhPZihuYXRpdmVFdmVudC5lLnR5cGUpXTtcclxuXHJcbiAgICAgIHRoaXMuX19maW5kVGFyZ2V0KHRoaXMubVBvaW50ZXJQb3NpdGlvbik7XHJcbiAgICAgIHRoaXMuX19wcm9jZXNzTmF0aXZlRXZlbnQobmF0aXZlRXZlbnQsIHRoaXMubVBvaW50ZXJQb3NpdGlvbiwgZXZlbnRUeXBlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9zXHJcbiAgICovXHJcbiAgX19maW5kVGFyZ2V0KHBvcykge1xyXG4gICAgbGV0IG9iaiA9IEJsYWNrLnN0YWdlLmhpdFRlc3QocG9zKTtcclxuXHJcbiAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubVRhcmdldCA9IG51bGw7XHJcbiAgICAgIHRoaXMubVRhcmdldENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1UYXJnZXQgPSBvYmo7XHJcbiAgICB0aGlzLm1UYXJnZXRDb21wb25lbnQgPSBvYmouZ2V0Q29tcG9uZW50KElucHV0Q29tcG9uZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVFdmVudFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9zXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcclxuICAgKi9cclxuICBfX3Byb2Nlc3NOYXRpdmVFdmVudChuYXRpdmVFdmVudCwgcG9zLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gSW5wdXQuUE9JTlRFUl9ET1dOKSB7XHJcbiAgICAgIHRoaXMubUlzUG9pbnRlckRvd24gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gSW5wdXQuUE9JTlRFUl9VUCkge1xyXG4gICAgICB0aGlzLm1Jc1BvaW50ZXJEb3duID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRlbHRhID0gMDtcclxuICAgIGlmICh0eXBlID09PSBJbnB1dC5XSEVFTClcclxuICAgICAgZGVsdGEgPSBuYXRpdmVFdmVudC5lLmRlbHRhWSA+IDAgPyAxIDogLTE7XHJcblxyXG4gICAgY29uc3QgaW5mbyA9IG5ldyBQb2ludGVySW5mbyh0aGlzLm1UYXJnZXQsIHBvcy54LCBwb3MueSwgbmF0aXZlRXZlbnQuZS5idXR0b24sIGRlbHRhKTtcclxuICAgIHRoaXMucG9zdCh0eXBlLCBpbmZvKTtcclxuXHJcbiAgICBpZiAodGhpcy5tVGFyZ2V0ID09PSBudWxsICYmIHRoaXMubUxvY2tlZFRhcmdldCA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0eXBlID09PSBJbnB1dC5QT0lOVEVSX0RPV04pIHtcclxuICAgICAgdGhpcy5tTG9ja2VkVGFyZ2V0ID0gdGhpcy5tVGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gSW5wdXQuUE9JTlRFUl9VUCAmJiB0aGlzLm1Mb2NrZWRUYXJnZXQgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5tTG9ja2VkVGFyZ2V0LnBvc3QoJ35wb2ludGVyVXAnLCBpbmZvKTtcclxuICAgICAgdGhpcy5tTG9ja2VkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzYW1lVGFyZ2V0ID0gdGhpcy5tVGFyZ2V0ID09PSB0aGlzLm1Mb2NrZWRUYXJnZXQ7XHJcblxyXG4gICAgaWYgKHRoaXMubUxvY2tlZFRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICBpZiAodGhpcy5tVGFyZ2V0ICE9PSBudWxsKVxyXG4gICAgICAgIHRoaXMubVRhcmdldC5wb3N0KCd+JyArIHR5cGUsIGluZm8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHNhbWVUYXJnZXQgPT09IHRydWUpXHJcbiAgICAgICAgdGhpcy5tTG9ja2VkVGFyZ2V0LnBvc3QoJ34nICsgdHlwZSwgaW5mbyk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLm1Mb2NrZWRUYXJnZXQubVBhcmVudCAhPT0gbnVsbCAmJiB0aGlzLm1UYXJnZXQgIT09IG51bGwpXHJcbiAgICAgICAgICB0aGlzLm1Mb2NrZWRUYXJnZXQubVBhcmVudC5wb3N0KCd+JyArIHR5cGUsIGluZm8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX3VwZGF0ZUtleWJvYXJkKCkge1xyXG4gICAgd2hpbGUgKHRoaXMubUtleVF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgbGV0IG5hdGl2ZUV2ZW50ID0gdGhpcy5tS2V5UXVldWUuc2hpZnQoKTtcclxuXHJcbiAgICAgIGxldCBpeCA9IHRoaXMubUtleUV2ZW50TGlzdC5pbmRleE9mKG5hdGl2ZUV2ZW50LnR5cGUpO1xyXG4gICAgICBsZXQgcEl4ID0gdGhpcy5tUHJlc3NlZEtleXMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKTtcclxuICAgICAgbGV0IGZuTmFtZSA9IG1LZXlFdmVudHNMb29rdXBbaXhdO1xyXG5cclxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ2tleVVwJyAmJiBwSXggIT09IC0xKVxyXG4gICAgICAgIHRoaXMubVByZXNzZWRLZXlzLnNwbGljZShwSXgsIDEpO1xyXG5cclxuICAgICAgZWxzZSBpZiAoZm5OYW1lID09PSAna2V5RG93bicgJiYgcEl4ID09PSAtMSkge1xyXG4gICAgICAgIHRoaXMubVByZXNzZWRLZXlzLnB1c2gobmF0aXZlRXZlbnQua2V5Q29kZSk7XHJcbiAgICAgICAgZm5OYW1lID0gJ2tleVByZXNzJztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5wb3N0KGZuTmFtZSwgbmV3IEtleUluZm8obmF0aXZlRXZlbnQpLCBuYXRpdmVFdmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xyXG5cclxuICAgIHdoaWxlICh0aGlzLm1Cb3VuZExpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGxldCBrZXlWYWx1ZSA9IHRoaXMubUJvdW5kTGlzdGVuZXJzLnBvcCgpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGtleVZhbHVlLm5hbWUsIGtleVZhbHVlLmxpc3RlbmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBCbGFjay5pbnB1dCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgaWYgbW91c2Ugb3IgdG91Y2ggaW4gZG93biBhdCB0aGlzIG1vbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc1BvaW50ZXJEb3duKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUlzUG9pbnRlckRvd247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG1vdXNlIG9yIHRvdWNoIHBvaW50ZXIgeC1jb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBwb2ludGVyWCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1Qb2ludGVyUG9zaXRpb24ueDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbW91c2Ugb3IgdG91Y2ggcG9pbnRlciB4LWNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHBvaW50ZXJZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBvaW50ZXJQb3NpdGlvbi55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBtb3VzZSBvciB0b3VjaCBwb2ludGVyIHgtY29tcG9uZW50IHJlbGF0aXZlIHRvIHN0YWdlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgc3RhZ2VYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YWdlUG9zaXRpb24ueDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbW91c2Ugb3IgdG91Y2ggcG9pbnRlciB4LWNvbXBvbmVudCAgcmVsYXRpdmUgdG8gc3RhZ2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBzdGFnZVkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU3RhZ2VQb3NpdGlvbi55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBtb3VzZSBvciB0b3VjaCBwb2ludGVyIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICovXHJcbiAgZ2V0IHZpZXdwb3J0UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVmlld3BvcnRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbW91c2Ugb3IgdG91Y2ggcG9pbnRlciBwb3NpdGlvbiBpbmNsdWRpbmcgYWN0aXZlIGNhbWVyYSB0cmFuc2Zvcm1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAqL1xyXG4gIGdldCBwb2ludGVyUG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUG9pbnRlclBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBwb2ludGVyIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgKi9cclxuICBnZXQgc3RhZ2VQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1TdGFnZVBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBsaXN0IG9mIHByZXNzZWQga2V5cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fVxyXG4gICAqL1xyXG4gIGdldCBwcmVzc2VkS2V5cygpIHtcclxuICAgIHJldHVybiB0aGlzLm1QcmVzc2VkS2V5cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQGNvbnN0XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBQT0lOVEVSX0RPV04oKSB7IHJldHVybiAncG9pbnRlckRvd24nOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQGNvbnN0XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBQT0lOVEVSX01PVkUoKSB7IHJldHVybiAncG9pbnRlck1vdmUnOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQGNvbnN0XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBQT0lOVEVSX1VQKCkgeyByZXR1cm4gJ3BvaW50ZXJVcCc7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKiBAY29uc3RcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IFdIRUVMKCkgeyByZXR1cm4gJ3doZWVsJzsgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxuY29uc3QgSVhfUE9JTlRFUl9NT1ZFID0gMDtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICovXHJcbmNvbnN0IElYX1BPSU5URVJfVVAgPSAyO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxyXG4gKiBAY29uc3RcclxuICovXHJcbmNvbnN0IG1LZXlFdmVudExpc3QgPSBbJ2tleWRvd24nLCAna2V5dXAnXTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG5jb25zdCBtS2V5RXZlbnRzTG9va3VwID0gWydrZXlEb3duJywgJ2tleVVwJywgJ2tleVByZXNzJ107XHJcblxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogQHR5cGUge0FycmF5PHN0cmluZz59XHJcbiAqIEBjb25zdFxyXG4gKi9cclxuY29uc3QgbUlucHV0RXZlbnRzTG9va3VwID0gWydwb2ludGVyTW92ZScsICdwb2ludGVyRG93bicsICdwb2ludGVyVXAnLCAncG9pbnRlckluJywgJ3BvaW50ZXJPdXQnLCAnd2hlZWwnXTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG5jb25zdCBtUG9pbnRlckV2ZW50TGlzdCA9IFsncG9pbnRlcm1vdmUnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJlbnRlcicsICdwb2ludGVybGVhdmUnLCAnd2hlZWwnXTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG5jb25zdCBtTW91c2VFdmVudExpc3QgPSBbJ21vdXNlbW92ZScsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnLCAnd2hlZWwnXTtcclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG5jb25zdCBtVG91Y2hFdmVudExpc3QgPSBbJ3RvdWNobW92ZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNoZW50ZXInLCAndG91Y2hsZWF2ZSddO1xyXG5cclxuLyoqXHJcbiAqIFBvc3RzIHdoZW4gbW91c2UgZG93biBvciB0b3VjaCBkb3duIGV2ZW50IGhhcHBlbmVkLlxyXG4gKiBAZXZlbnQgSW5wdXQjcG9pbnRlckRvd25cclxuICovXHJcblxyXG4vKipcclxuICogUG9zdHMgd2hlbiBtb3VzZSB1cCBvciB0b3VjaCB1cCBldmVudCBoYXBwZW5lZC5cclxuICogQGV2ZW50IElucHV0I3BvaW50ZXJVcFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBQb3N0cyB3aGVuIG1vdXNlIG1vdmUgb3IgdG91Y2ggbW92ZSBldmVudCBoYXBwZW5lZC5cclxuICogQGV2ZW50IElucHV0I3BvaW50ZXJNb3ZlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiogUG9zdHMgd2hlbiBtb3VzZSBkb3duIG9yIHRvdWNoIGRvd24gZXZlbnQgaGFwcGVuZWQuXHJcbiogQGV2ZW50IEdhbWVPYmplY3QjcG9pbnRlckRvd25cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBQb3N0cyB3aGVuIG1vdXNlIHVwIG9yIHRvdWNoIHVwIGV2ZW50IGhhcHBlbmVkLlxyXG4gKiBAZXZlbnQgR2FtZU9iamVjdCNwb2ludGVyVXBcclxuICovXHJcblxyXG4vKipcclxuICogUG9zdHMgd2hlbiBtb3VzZSBtb3ZlIG9yIHRvdWNoIG1vdmUgZXZlbnQgaGFwcGVuZWQuXHJcbiAqIEBldmVudCBHYW1lT2JqZWN0I3BvaW50ZXJNb3ZlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFN0b3JlcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHBvaW50ZXIgZXZlbnRzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBjYXQgaW5wdXRcclxuICovXHJcbmNsYXNzIFBvaW50ZXJJbmZvIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBQb2ludGVySW5mbyBpbnN0YW5jZS4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gYWN0aXZlT2JqZWN0IGBHYW1lT2JqZWN0YCB0aGUgY3Vyc29yIGlzIGFib3ZlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHgtY29vcmRpbmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IHktY29vcmRpbmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidXR0b24gYWN0aXZlIHByZXNzZWQgYnV0dG9uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoYWN0aXZlT2JqZWN0LCB4LCB5LCBidXR0b24sIGRlbHRhID0gMCkge1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQWN0aXZlT2JqZWN0ID0gYWN0aXZlT2JqZWN0O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVggPSB4O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVkgPSB5O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJ1dHRvbiA9IGJ1dHRvbjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EZWx0YSA9IGRlbHRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cnVucyBub3JtYWxpemVkIHdoZWVsIGRlbHRhIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGRlbHRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlbHRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cnVucyBjdXJyZW50IHByZXNzZWQgYnV0dG9uLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGJ1dHRvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1CdXR0b247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgdW5kZXIgY3Vyc29yIHJpZ2h0IG5vdy5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH1cclxuICAgKi9cclxuICBnZXQgYWN0aXZlT2JqZWN0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUFjdGl2ZU9iamVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFgtY29vcmRpbmF0ZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tWDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFktY29vcmRpbmF0ZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tWTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgcm9vdCBjb250YWluZXIgZm9yIGFsbCByZW5kZXJhYmxlIG9iamVjdHNcclxuICpcclxuICogQGNhdCBkaXNwbGF5XHJcbiAqIEBmaXJlcyBTdGFnZSNyZXNpemVcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkdhbWVPYmplY3RcclxuICovXHJcbmNsYXNzIFN0YWdlIGV4dGVuZHMgR2FtZU9iamVjdCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU5hbWUgPSAnc3RhZ2UnO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5TdGFnZVNjYWxlTW9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVNjYWxlTW9kZSA9IFN0YWdlU2NhbGVNb2RlLk5PUk1BTDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1XaWR0aCA9IDk2MDtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUhlaWdodCA9IDY0MDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdGFnZVdpZHRoID0gMDtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YWdlSGVpZ2h0ID0gMDtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YWdlU2NhbGVGYWN0b3IgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlV2lkdGggPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlSGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EUFIgPSBCbGFjay5kZXZpY2UuZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xyXG5cclxuICAgIHRoaXMubUFkZGVkID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBGYWtlIFxyXG4gICAgaWYgKEJsYWNrLmVuZ2luZS5oYXNTeXN0ZW0oSW5wdXQpKXtcclxuICAgICAgbGV0IGMgPSBuZXcgSW5wdXRDb21wb25lbnQoKTtcclxuICAgICAgYy5tQWRkZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLmFkZENvbXBvbmVudChjKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgc3RhZ2Ugc2l6ZSBieSBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIE5ldyBzdGFnZSB3aWR0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IE5ldyBzdGFnZSBoZWlnaHQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB0aGlzLm1XaWR0aCA9IHdpZHRoO1xyXG4gICAgdGhpcy5tSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIHRoaXMuX19yZWZyZXNoKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uVXBkYXRlKCkge1xyXG4gICAgbGV0IHNpemUgPSBCbGFjay5lbmdpbmUudmlld3BvcnQuc2l6ZTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ2FjaGVXaWR0aCAhPT0gc2l6ZS53aWR0aCB8fCB0aGlzLm1DYWNoZUhlaWdodCAhPT0gc2l6ZS5oZWlnaHQpIHtcclxuICAgICAgdGhpcy5tQ2FjaGVXaWR0aCA9IHNpemUud2lkdGg7XHJcbiAgICAgIHRoaXMubUNhY2hlSGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICB0aGlzLl9fcmVmcmVzaCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVmcmVzaGVzIHN0YWdlIHNpemUuIENhbGwgdGhpcyBtZXRob2Qgb25seSBpZiB5b3UgYXJlIGNoYW5naW5nIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgbWFudWFsbHkuIFxyXG4gICAqL1xyXG4gIHJlZnJlc2goKSB7XHJcbiAgICB0aGlzLl9fcmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19yZWZyZXNoKCkge1xyXG4gICAgY29uc3Qgc2l6ZSA9IEJsYWNrLmVuZ2luZS52aWV3cG9ydC5zaXplO1xyXG4gICAgY29uc3Qgd2luZG93V2lkdGggPSBzaXplLndpZHRoO1xyXG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgaWYgKHRoaXMubVNjYWxlTW9kZSA9PT0gU3RhZ2VTY2FsZU1vZGUuRklYRUQpIHtcclxuICAgICAgY29uc3QgbXcgPSB3aW5kb3dXaWR0aCAqIHRoaXMubUhlaWdodCAvIHdpbmRvd0hlaWdodDtcclxuICAgICAgY29uc3QgbWggPSB3aW5kb3dIZWlnaHQgKiB0aGlzLm1XaWR0aCAvIHdpbmRvd1dpZHRoO1xyXG4gICAgICBjb25zdCBzYyA9IE1hdGgubWF4KG13IC8gd2luZG93V2lkdGgsIG1oIC8gd2luZG93SGVpZ2h0KTtcclxuICAgICAgY29uc3Qgd2lkdGggPSB3aW5kb3dXaWR0aCAqIHNjO1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3dIZWlnaHQgKiBzYztcclxuXHJcbiAgICAgIHRoaXMubVN0YWdlV2lkdGggPSB3aWR0aDtcclxuICAgICAgdGhpcy5tU3RhZ2VIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICB0aGlzLm1TY2FsZVggPSB0aGlzLm1TY2FsZVkgPSB0aGlzLm1TdGFnZVNjYWxlRmFjdG9yID0gTWF0aC5taW4od2luZG93V2lkdGggLyB3aWR0aCwgd2luZG93SGVpZ2h0IC8gaGVpZ2h0KTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tU2NhbGVNb2RlID09PSBTdGFnZVNjYWxlTW9kZS5MRVRURVJCT1ggfHwgdGhpcy5tU2NhbGVNb2RlID09PSBTdGFnZVNjYWxlTW9kZS5DT1ZFUikge1xyXG4gICAgICBjb25zdCBzYyA9IHRoaXMubVNjYWxlTW9kZSA9PT0gU3RhZ2VTY2FsZU1vZGUuQ09WRVIgP1xyXG4gICAgICAgIE1hdGgubWF4KHdpbmRvd1dpZHRoIC8gdGhpcy5tV2lkdGgsIHdpbmRvd0hlaWdodCAvIHRoaXMubUhlaWdodCkgOlxyXG4gICAgICAgIE1hdGgubWluKHdpbmRvd1dpZHRoIC8gdGhpcy5tV2lkdGgsIHdpbmRvd0hlaWdodCAvIHRoaXMubUhlaWdodCk7XHJcblxyXG4gICAgICB0aGlzLm1YID0gKHdpbmRvd1dpZHRoIC0gdGhpcy5tV2lkdGggKiBzYykgLyAyO1xyXG4gICAgICB0aGlzLm1ZID0gKHdpbmRvd0hlaWdodCAtIHRoaXMubUhlaWdodCAqIHNjKSAvIDI7XHJcblxyXG4gICAgICB0aGlzLm1TdGFnZVdpZHRoID0gdGhpcy5tV2lkdGg7XHJcbiAgICAgIHRoaXMubVN0YWdlSGVpZ2h0ID0gdGhpcy5tSGVpZ2h0O1xyXG5cclxuICAgICAgdGhpcy5tU2NhbGVYID0gdGhpcy5tU2NhbGVZID0gdGhpcy5tU3RhZ2VTY2FsZUZhY3RvciA9IHNjO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLm1TY2FsZU1vZGUgPT09IFN0YWdlU2NhbGVNb2RlLk5PUk1BTCkge1xyXG4gICAgICB0aGlzLm1TdGFnZVdpZHRoID0gd2luZG93V2lkdGg7XHJcbiAgICAgIHRoaXMubVN0YWdlSGVpZ2h0ID0gd2luZG93SGVpZ2h0O1xyXG4gICAgICB0aGlzLm1TY2FsZVggPSB0aGlzLm1TY2FsZVkgPSB0aGlzLm1TdGFnZVNjYWxlRmFjdG9yID0gMTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tU2NhbGVNb2RlID09PSBTdGFnZVNjYWxlTW9kZS5OT19TQ0FMRSkge1xyXG4gICAgICB0aGlzLm1TdGFnZVdpZHRoID0gKHdpbmRvd1dpZHRoICogdGhpcy5tRFBSKTtcclxuICAgICAgdGhpcy5tU3RhZ2VIZWlnaHQgPSAod2luZG93SGVpZ2h0ICogdGhpcy5tRFBSKTtcclxuXHJcbiAgICAgIHRoaXMubVNjYWxlWCA9IHRoaXMubVNjYWxlWSA9IHRoaXMubVN0YWdlU2NhbGVGYWN0b3IgPSAxIC8gdGhpcy5tRFBSO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgRGVidWcuZXJyb3IoJ05vdCBzdXBwb3J0ZWQgc3RhZ2Ugc2NhbGUgbW9kZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1TdGFnZVdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLm1TdGFnZVdpZHRoKTtcclxuICAgIHRoaXMubVN0YWdlSGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLm1TdGFnZUhlaWdodCk7XHJcbiAgICB0aGlzLm1YID0gTWF0aC5yb3VuZCh0aGlzLm1YKTtcclxuICAgIHRoaXMubVkgPSBNYXRoLnJvdW5kKHRoaXMubVkpO1xyXG5cclxuICAgIC8vIFRPRE86IGkgZG9uJ3QgbGlrZSB0aGlzIGxpbmVcclxuICAgIC8vIFRPRE86IG1lIG5laXRoZXJcclxuICAgIC8vIFRPRE86IGJ1dCBpdHMgc2V0dGluZyBSZW5kZXJlci5fX2RpcnR5IHdoaWNoIGlzIGdvb2RcclxuICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBwcmlvcml0eSBtZXNzYWdlP1xyXG4gICAgQmxhY2suZHJpdmVyLl9fb25SZXNpemUobnVsbCwgbnVsbCk7XHJcblxyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG5cclxuICAgIHRoaXMubUxvY2FsVHJhbnNmb3JtLnNldCh0aGlzLm1TY2FsZVgsIDAsIDAsIHRoaXMubVNjYWxlWSwgdGhpcy5tWCwgdGhpcy5tWSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0cyBldmVyeSB0aW1lIHN0YWdlIHNpemUgaXMgY2hhbmdlZC5cclxuICAgICAqIEBldmVudCBTdGFnZSNyZXNpemVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3N0KE1lc3NhZ2UuUkVTSVpFKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBzdGFnZSBzY2FsZSBtb2RlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflN0YWdlU2NhbGVNb2RlfVxyXG4gICAqL1xyXG4gIGdldCBzY2FsZU1vZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU2NhbGVNb2RlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+U3RhZ2VTY2FsZU1vZGV9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNjYWxlTW9kZSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tU2NhbGVNb2RlID0gdmFsdWU7XHJcbiAgICB0aGlzLl9fcmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhZ2Ugc2NhbGUgZmFjdG9yLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNjYWxlRmFjdG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YWdlU2NhbGVGYWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBzdGFnZSB3aWR0aCBtdWx0aXBsaWVkIGJ5IGRldmljZSBwaXhlbCByYXRpbyBhbmQgc3RhZ2Ugc2NhbGUgZmFjdG9yLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJlbmRlcldpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YWdlV2lkdGggKiB0aGlzLm1EUFIgKiB0aGlzLm1TdGFnZVNjYWxlRmFjdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgc3RhZ2UgaGVpZ2h0IG11bHRpcGxpZWQgYnkgZGV2aWNlIHBpeGVsIHJhdGlvIGFuZCBzdGFnZSBzY2FsZSBmYWN0b3IuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcmVuZGVySGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YWdlSGVpZ2h0ICogdGhpcy5tRFBSICogdGhpcy5tU3RhZ2VTY2FsZUZhY3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgc3RhZ2UgY2VudGVyIGNvb3JkaW5hdGUgYWxvbmcgWC1heGlzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGNlbnRlclgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU3RhZ2VXaWR0aCAqIDAuNTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgc3RhZ2UgY2VudGVyIGNvb3JkaW5hdGUgYWxvbmcgWS1heGlzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGNlbnRlclkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU3RhZ2VIZWlnaHQgKiAwLjU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGdldEJvdW5kcyhzcGFjZSA9IHVuZGVmaW5lZCwgaW5jbHVkZUNoaWxkcmVuID0gdHJ1ZSwgb3V0UmVjdCA9IHVuZGVmaW5lZCkge1xyXG4gICAgb3V0UmVjdCA9IG91dFJlY3QgfHwgbmV3IFJlY3RhbmdsZSgpO1xyXG4gICAgcmV0dXJuIG91dFJlY3Quc2V0KC10aGlzLm1YIC8gdGhpcy5tU3RhZ2VTY2FsZUZhY3RvciwgLXRoaXMubVkgLyB0aGlzLm1TdGFnZVNjYWxlRmFjdG9yLCB0aGlzLm1TdGFnZVdpZHRoICsgMiAqIHRoaXMubVggLyB0aGlzLm1TdGFnZVNjYWxlRmFjdG9yLCB0aGlzLm1TdGFnZUhlaWdodCArIDIgKiB0aGlzLm1ZIC8gdGhpcy5tU3RhZ2VTY2FsZUZhY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cclxuICBvbkdldExvY2FsQm91bmRzKG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuICAgIHJldHVybiBvdXRSZWN0LnNldCgwLCAwLCB0aGlzLm1TdGFnZVdpZHRoLCB0aGlzLm1TdGFnZUhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGBNYXRyaXhgXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+TWF0cml4fVxyXG4gICAqL1xyXG4gIGdldCBsb2NhbFRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUxvY2FsVHJhbnNmb3JtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWF0cml4fSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGxvY2FsVHJhbnNmb3JtYXRpb24odmFsdWUpIHtcclxuICAgIERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTtcclxuICB9XHJcblxyXG4gIHJlbW92ZUZyb21QYXJlbnQoKSB7IERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTsgfVxyXG5cclxuICBzZXQgc2NhbGVYKHZhbHVlKSB7IERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTsgfVxyXG4gIGdldCBzY2FsZVgoKSB7IHJldHVybiAxOyB9XHJcblxyXG4gIHNldCBzY2FsZVkodmFsdWUpIHsgRGVidWcuZXJyb3IoJ05vdCBhbGxvd2VkLicpOyB9XHJcbiAgZ2V0IHNjYWxlWSgpIHsgcmV0dXJuIDE7IH1cclxuXHJcbiAgc2V0IHBpdm90T2Zmc2V0WCh2YWx1ZSkgeyBEZWJ1Zy5lcnJvcignTm90IGFsbG93ZWQuJyk7IH1cclxuICBnZXQgcGl2b3RPZmZzZXRYKCkgeyByZXR1cm4gMDsgfVxyXG5cclxuICBzZXQgcGl2b3RPZmZzZXRZKHZhbHVlKSB7IERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTsgfVxyXG4gIGdldCBwaXZvdE9mZnNldFkoKSB7IHJldHVybiAwOyB9XHJcblxyXG4gIHNldCBhbmNob3JYKHZhbHVlKSB7IERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTsgfVxyXG4gIGdldCBhbmNob3JYKCkgeyByZXR1cm4gMDsgfVxyXG5cclxuICBzZXQgYW5jaG9yWSh2YWx1ZSkgeyBEZWJ1Zy5lcnJvcignTm90IGFsbG93ZWQuJyk7IH1cclxuICBnZXQgYW5jaG9yWSgpIHsgcmV0dXJuIDA7IH1cclxuXHJcbiAgc2V0IHgodmFsdWUpIHsgRGVidWcuZXJyb3IoJ05vdCBhbGxvd2VkLicpOyB9XHJcbiAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLm1YIC8gdGhpcy5tU3RhZ2VTY2FsZUZhY3RvcjsgfSAvLyBHRyBFUzZcclxuXHJcbiAgc2V0IHkodmFsdWUpIHsgRGVidWcuZXJyb3IoJ05vdCBhbGxvd2VkLicpOyB9XHJcbiAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLm1ZIC8gdGhpcy5tU3RhZ2VTY2FsZUZhY3RvciB9IC8vIEdHIEVTNlxyXG5cclxuICBzZXQgcm90YXRpb24odmFsdWUpIHsgRGVidWcuZXJyb3IoJ05vdCBhbGxvd2VkLicpOyB9XHJcbiAgZ2V0IHJvdGF0aW9uKCkgeyByZXR1cm4gMDsgfSAvLyBHRyBFUzZcclxuXHJcbiAgc2V0IHdpZHRoKHZhbHVlKSB7IERlYnVnLmVycm9yKCdOb3QgYWxsb3dlZC4nKTsgfVxyXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMubVN0YWdlV2lkdGg7IH1cclxuXHJcbiAgc2V0IGhlaWdodCh2YWx1ZSkgeyBEZWJ1Zy5lcnJvcignTm90IGFsbG93ZWQuJyk7IH1cclxuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5tU3RhZ2VIZWlnaHQ7IH1cclxuXHJcbiAgc2V0IG5hbWUodmFsdWUpIHsgRGVidWcuZXJyb3IoJ05vdCBhbGxvd2VkLicpOyB9XHJcbiAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLm1OYW1lIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbGxpZGVyIHdpdGggcmVjdGFuZ2xlIHNoYXBlLlxyXG4gKlxyXG4gKiBAY2F0IGNvbGxpZGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+Q29sbGlkZXJcclxuICovXHJcbmNsYXNzIEJveENvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgQm94Q29sbGlkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgIFgtY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgIFktY29vcmRpbmF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggIFJlY3RhbmdsZSB3aWR0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFJlY3RhbmdsZSBoZWlnaHQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBjb25zdCBub3JtYWxzID0gW107XHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgIG5vcm1hbHMucHVzaChuZXcgVmVjdG9yKCkpO1xyXG4gICAgICB2ZXJ0aWNlcy5wdXNoKG5ldyBWZWN0b3IoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhbCB0byBnYW1lT2JqZWN0LiBcclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmVjdCA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHRvIHJpZ2lkIGJvZHkgbm9ybWFscy4gXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5WZWN0b3I+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ob3JtYWxzID0gbm9ybWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHRvIHJpZ2lkIGJvZHkgdmVydGljZXMuIFxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+VmVjdG9yPn0gKi9cclxuICAgIHRoaXMubVZlcnRpY2VzID0gdmVydGljZXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhbCB0byByaWdpZCBib2R5IG1pbiB4IGFuZCB5IHZlcnRleC4gXHJcbiAgICAgKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9ICovXHJcbiAgICB0aGlzLm1Mb2NhbE1pbiA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHRvIHJpZ2lkIGJvZHkgbWF4IHggYW5kIHkgdmVydGV4IFxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Mb2NhbE1heCA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvY2FsIHRvIHJpZ2lkIGJvZHkgY2VudGVyICBcclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTG9jYWxDZW50ZXIgPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgdGhpcy5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgY29sbGlkZXIgd2l0aCBhIG5ldyBnaXZlbiB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICBYLWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICBZLWNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBSZWN0YW5nbGUgd2lkdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBSZWN0YW5nbGUgaGVpZ2h0LlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+Qm94Q29sbGlkZXJ9XHJcbiAgICovXHJcbiAgc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHRoaXMubVJlY3Quc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgdGhpcy5tQ2hhbmdlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgcmVmcmVzaCh0cmFuc2Zvcm0sIHBvc2l0aW9uKSB7XHJcbiAgICBjb25zdCBsb2NhbE1pbiA9IHRoaXMubUxvY2FsTWluO1xyXG4gICAgY29uc3QgbG9jYWxNYXggPSB0aGlzLm1Mb2NhbE1heDtcclxuICAgIGNvbnN0IG1pbiA9IHRoaXMubU1pbjtcclxuICAgIGNvbnN0IG1heCA9IHRoaXMubU1heDtcclxuICAgIGNvbnN0IGxvY2FsQ2VudGVyID0gdGhpcy5tTG9jYWxDZW50ZXI7XHJcbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLm1DZW50ZXI7XHJcblxyXG4gICAgaWYgKHRoaXMubUNoYW5nZWQpIHtcclxuICAgICAgY29uc3QgdmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAgICAgY29uc3Qgbm9ybWFscyA9IHRoaXMubU5vcm1hbHM7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLm1SZWN0O1xyXG4gICAgICBjb25zdCB2ZWMgPSBWZWN0b3IucG9vbC5nZXQoKTtcclxuXHJcbiAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1WZWN0b3IodmVjLnNldCgwLCAtMSksIG5vcm1hbHNbMF0pO1xyXG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtVmVjdG9yKHZlYy5zZXQoMSwgMCksIG5vcm1hbHNbMV0pO1xyXG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtVmVjdG9yKHZlYy5zZXQoMCwgMSksIG5vcm1hbHNbMl0pO1xyXG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtVmVjdG9yKHZlYy5zZXQoLTEsIDApLCBub3JtYWxzWzNdKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgbm9ybWFsc1tpXS5ub3JtYWxpemUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVZlY3Rvcih2ZWMuc2V0KHJlY3QueCwgcmVjdC55KSwgdmVydGljZXNbMF0pO1xyXG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtVmVjdG9yKHZlYy5zZXQocmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55KSwgdmVydGljZXNbMV0pO1xyXG4gICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtVmVjdG9yKHZlYy5zZXQocmVjdC54ICsgcmVjdC53aWR0aCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpLCB2ZXJ0aWNlc1syXSk7XHJcbiAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1WZWN0b3IodmVjLnNldChyZWN0LngsIHJlY3QueSArIHJlY3QuaGVpZ2h0KSwgdmVydGljZXNbM10pO1xyXG5cclxuICAgICAgbG9jYWxDZW50ZXIuc2V0KCh2ZXJ0aWNlc1swXS54ICsgdmVydGljZXNbMl0ueCkgLyAyLCAodmVydGljZXNbMF0ueSArIHZlcnRpY2VzWzJdLnkpIC8gMik7XHJcbiAgICAgIGxvY2FsTWluLnggPSBNYXRoLm1pbih2ZXJ0aWNlc1swXS54LCB2ZXJ0aWNlc1sxXS54LCB2ZXJ0aWNlc1syXS54LCB2ZXJ0aWNlc1szXS54KTtcclxuICAgICAgbG9jYWxNaW4ueSA9IE1hdGgubWluKHZlcnRpY2VzWzBdLnksIHZlcnRpY2VzWzFdLnksIHZlcnRpY2VzWzJdLnksIHZlcnRpY2VzWzNdLnkpO1xyXG4gICAgICBsb2NhbE1heC54ID0gTWF0aC5tYXgodmVydGljZXNbMF0ueCwgdmVydGljZXNbMV0ueCwgdmVydGljZXNbMl0ueCwgdmVydGljZXNbM10ueCk7XHJcbiAgICAgIGxvY2FsTWF4LnkgPSBNYXRoLm1heCh2ZXJ0aWNlc1swXS55LCB2ZXJ0aWNlc1sxXS55LCB2ZXJ0aWNlc1syXS55LCB2ZXJ0aWNlc1szXS55KTtcclxuXHJcbiAgICAgIFZlY3Rvci5wb29sLnJlbGVhc2UodmVjKTtcclxuICAgIH1cclxuXHJcbiAgICBtaW4ueCA9IGxvY2FsTWluLnggKyBwb3NpdGlvbi54O1xyXG4gICAgbWluLnkgPSBsb2NhbE1pbi55ICsgcG9zaXRpb24ueTtcclxuICAgIG1heC54ID0gbG9jYWxNYXgueCArIHBvc2l0aW9uLng7XHJcbiAgICBtYXgueSA9IGxvY2FsTWF4LnkgKyBwb3NpdGlvbi55O1xyXG5cclxuICAgIGNlbnRlci54ID0gbG9jYWxDZW50ZXIueCArIHBvc2l0aW9uLng7XHJcbiAgICBjZW50ZXIueSA9IGxvY2FsQ2VudGVyLnkgKyBwb3NpdGlvbi55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGdpdmVuIGdsb2JhbCBjb29yZGluYXRlcyBhcmUgbG9jYXRlZCB3aXRoaW4gY29sbGlkZXIncyBhcmVhLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9pbnQgR2xvYmFsIGNvb3JkaW5hdGVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUmVjdC5jb250YWluc1hZKHBvaW50LngsIHBvaW50LnkpO1xyXG4gIH1cclxuXHJcbiAgLy8gLyoqXHJcbiAgLy8gICogRHJhdyB0aGlzXHJcbiAgLy8gICpcclxuICAvLyAgKiBAcHVibGljXHJcbiAgLy8gICogQHBhcmFtIHtHcmFwaGljc30gZ3JhcGhpY3MgICBEcmF3aW5nIHBsYWNlXHJcbiAgLy8gICogQHBhcmFtIHtWZWN0b3J9IGJvZHlQb3NpdGlvbiBUaGlzIHBhcmVudCBnbG9iYWwgcG9zaXRpb25cclxuICAvLyAgKlxyXG4gIC8vICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgLy8gICovXHJcbiAgLy8gZGVidWcoZ3JhcGhpY3MsIGJvZHlQb3NpdGlvbikge1xyXG4gIC8vICAgY29uc3QgdmVydGljZXMgPSB0aGlzLm1WZXJ0aWNlcztcclxuICAvL1xyXG4gIC8vICAgZ3JhcGhpY3MuYmVnaW5QYXRoKCk7XHJcbiAgLy8gICBncmFwaGljcy5tb3ZlVG8oYm9keVBvc2l0aW9uLnggKyB2ZXJ0aWNlc1swXS54LCBib2R5UG9zaXRpb24ueSArIHZlcnRpY2VzWzBdLnkpO1xyXG4gIC8vICAgZ3JhcGhpY3MubGluZVRvKGJvZHlQb3NpdGlvbi54ICsgdmVydGljZXNbMV0ueCwgYm9keVBvc2l0aW9uLnkgKyB2ZXJ0aWNlc1sxXS55KTtcclxuICAvLyAgIGdyYXBoaWNzLmxpbmVUbyhib2R5UG9zaXRpb24ueCArIHZlcnRpY2VzWzJdLngsIGJvZHlQb3NpdGlvbi55ICsgdmVydGljZXNbMl0ueSk7XHJcbiAgLy8gICBncmFwaGljcy5saW5lVG8oYm9keVBvc2l0aW9uLnggKyB2ZXJ0aWNlc1szXS54LCBib2R5UG9zaXRpb24ueSArIHZlcnRpY2VzWzNdLnkpO1xyXG4gIC8vICAgZ3JhcGhpY3MubGluZVRvKGJvZHlQb3NpdGlvbi54ICsgdmVydGljZXNbMF0ueCwgYm9keVBvc2l0aW9uLnkgKyB2ZXJ0aWNlc1swXS55KTtcclxuICAvLyAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gIC8vIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbGxpZGVyIHdpdGggY2lyY2xlIHNoYXBlLlxyXG4gKlxyXG4gKiBAY2F0IGNvbGxpZGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+Q29sbGlkZXJcclxuICovXHJcbmNsYXNzIENpcmNsZUNvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIENpcmNsZUNvbGxpZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICBDZW50ZXIgY29vcmRpbmF0ZSB3aXRoaW4gWC1heGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgQ2VudGVyIGNvb3JkaW5hdGUgd2l0aGluIFktYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHgsIHksIHJhZGl1cykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+Q2lyY2xlfSAqL1xyXG4gICAgdGhpcy5tQ2lyY2xlID0gbmV3IENpcmNsZSh4LCB5LCByYWRpdXMpOyAgLy8gbG9jYWwgdG8gc3ByaXRlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhbCB0byByaWdpZCBib2R5IGNlbnRlci5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvY2FsQ2VudGVyID0gbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9jYWwgdG8gcmlnaWQgYm9keSBtaW4geCBhbmQgeSB2ZXJ0ZXguXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfSAqL1xyXG4gICAgdGhpcy5tTG9jYWxNaW4gPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhbCB0byByaWdpZCBib2R5IG1heCB4IGFuZCB5IHZlcnRleCBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvY2FsTWF4ID0gbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2xvYmFsIGluIHN0YWdlIGNvb3JkaW5hdGVzIHJhZGl1cyBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmFkaXVzID0gMDtcclxuXHJcbiAgICB0aGlzLnNldCh4LCB5LCByYWRpdXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGlzIGNvbGxpZGVyIHdpdGggYSBuZXcgZ2l2ZW4gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgQ2VudGVyIGNvb3JkaW5hdGUgd2l0aGluIFgtYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgIENlbnRlciBjb29yZGluYXRlIHdpdGhpbiBZLWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkNpcmNsZUNvbGxpZGVyfVxyXG4gICAqL1xyXG4gIHNldCh4LCB5LCByYWRpdXMpIHtcclxuICAgIHRoaXMubUNpcmNsZS5zZXQoeCwgeSwgcmFkaXVzKTtcclxuICAgIHRoaXMubUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHJlZnJlc2godHJhbnNmb3JtLCBwb3NpdGlvbikge1xyXG4gICAgY29uc3QgbG9jYWxNaW4gPSB0aGlzLm1Mb2NhbE1pbjtcclxuICAgIGNvbnN0IGxvY2FsTWF4ID0gdGhpcy5tTG9jYWxNYXg7XHJcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1NaW47XHJcbiAgICBjb25zdCBtYXggPSB0aGlzLm1NYXg7XHJcbiAgICBjb25zdCBsb2NhbENlbnRlciA9IHRoaXMubUxvY2FsQ2VudGVyO1xyXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5tQ2VudGVyO1xyXG5cclxuICAgIGlmICh0aGlzLm1DaGFuZ2VkKSB7XHJcbiAgICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMubUNpcmNsZTtcclxuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnNxcnQodHJhbnNmb3JtLmRhdGFbMF0gKiB0cmFuc2Zvcm0uZGF0YVswXSArIHRyYW5zZm9ybS5kYXRhWzFdICogdHJhbnNmb3JtLmRhdGFbMV0pO1xyXG4gICAgICBjb25zdCByYWRpdXMgPSBjaXJjbGUuciAqIHNjYWxlO1xyXG5cclxuICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVhZKGNpcmNsZS54LCBjaXJjbGUueSwgbG9jYWxDZW50ZXIpO1xyXG4gICAgICB0aGlzLm1SYWRpdXMgPSByYWRpdXM7XHJcblxyXG4gICAgICBsb2NhbE1pbi54ID0gbG9jYWxDZW50ZXIueCAtIHJhZGl1cztcclxuICAgICAgbG9jYWxNaW4ueSA9IGxvY2FsQ2VudGVyLnkgLSByYWRpdXM7XHJcbiAgICAgIGxvY2FsTWF4LnggPSBsb2NhbENlbnRlci54ICsgcmFkaXVzO1xyXG4gICAgICBsb2NhbE1heC55ID0gbG9jYWxDZW50ZXIueSArIHJhZGl1cztcclxuICAgIH1cclxuXHJcbiAgICBtaW4ueCA9IGxvY2FsTWluLnggKyBwb3NpdGlvbi54O1xyXG4gICAgbWluLnkgPSBsb2NhbE1pbi55ICsgcG9zaXRpb24ueTtcclxuICAgIG1heC54ID0gbG9jYWxNYXgueCArIHBvc2l0aW9uLng7XHJcbiAgICBtYXgueSA9IGxvY2FsTWF4LnkgKyBwb3NpdGlvbi55O1xyXG5cclxuICAgIGNlbnRlci54ID0gbG9jYWxDZW50ZXIueCArIHBvc2l0aW9uLng7XHJcbiAgICBjZW50ZXIueSA9IGxvY2FsQ2VudGVyLnkgKyBwb3NpdGlvbi55O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGdpdmVuIGdsb2JhbCBjb29yZGluYXRlcyBhcmUgbG9jYXRlZCB3aXRoaW4gY29sbGlkZXIncyBhcmVhLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcn0gcG9pbnQgR2xvYmFsIGNvb3JkaW5hdGVzLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgIGlmICh0aGlzLmdhbWVPYmplY3QgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMubUNpcmNsZTtcclxuICAgIGNvbnN0IHZlYyA9IFZlY3Rvci5wb29sLmdldCgpO1xyXG4gICAgY29uc3QgZGlzdGFuY2UgPSB2ZWMuc2V0KGNpcmNsZS54LCBjaXJjbGUueSkuZGlzdGFuY2UocG9pbnQpO1xyXG4gICAgVmVjdG9yLnBvb2wucmVsZWFzZSh2ZWMpO1xyXG5cclxuICAgIHJldHVybiBkaXN0YW5jZSA8PSBjaXJjbGUucjtcclxuICB9XHJcblxyXG4gIC8vIC8qKlxyXG4gIC8vICAqIERyYXcgdGhpc1xyXG4gIC8vICAqXHJcbiAgLy8gICogQHB1YmxpY1xyXG4gIC8vICAqIEBwYXJhbSB7R3JhcGhpY3N9IGdyYXBoaWNzIERyYXdpbmcgcGxhY2VcclxuICAvLyAgKi9cclxuICAvLyBkZWJ1ZyhncmFwaGljcykge1xyXG4gIC8vICAgZ3JhcGhpY3MuYmVnaW5QYXRoKCk7XHJcbiAgLy8gICBncmFwaGljcy5jaXJjbGUodGhpcy5tQ2VudGVyLngsIHRoaXMubUNlbnRlci55LCB0aGlzLm1SYWRpdXMpO1xyXG4gIC8vICAgZ3JhcGhpY3Muc3Ryb2tlKCk7XHJcbiAgLy8gfVxyXG59XHJcblxyXG4vKipcclxuICogQSB0ZXh0dXJlIGFsbG93aW5nIGdhbWUgb2JqZWN0cyB0byBiZSByZW5kZXJlZCBvbnRvIGl0LlxyXG4gKlxyXG4gKiBAY2F0IHRleHR1cmVzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5UZXh0dXJlXHJcbiAqL1xyXG5jbGFzcyBDYW52YXNSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ2FudmFzUmVuZGVyVGV4dHVyZSBpbnN0YW5jZSB3aXRoIGdpdmVuIHNpemUgYW5kIHNjYWxlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHRleHR1cmUgaW4gc3RhZ2Ugc3BhY2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlIGluIHN0YWdlIHNwYWNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAgVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgaW50ZXJuYWwgdGV4dHVyZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHNjYWxlKSB7XHJcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0Q2FudmFzKHdpZHRoICogc2NhbGUsIGhlaWdodCAqIHNjYWxlKTtcclxuXHJcbiAgICBzdXBlcihyZW5kZXJUYXJnZXQubmF0aXZlKTtcclxuICAgIHRoaXMuc2V0KHJlbmRlclRhcmdldC5uYXRpdmUsIG51bGwsIG51bGwsIDEgLyBzY2FsZSk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgaW5zdGFuY2Ugd2l0aCBnaXZlbiBzaXplIGFuZCBzY2FsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgVGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlIGluIHN0YWdlIHNwYWNlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZSBpbiBzdGFnZSBzcGFjZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgIFRoZSBzY2FsZSBmYWN0b3Igb2YgdGhlIGludGVybmFsIHRleHR1cmVcclxuICAgKi9cclxuICByZXNpemUod2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcclxuICAgIHRoaXMucmVuZGVyVGFyZ2V0LnJlc2l6ZSh3aWR0aCAqIHNjYWxlLCBoZWlnaHQgKiBzY2FsZSk7XHJcbiAgICB0aGlzLnNldCh0aGlzLnJlbmRlclRhcmdldC5uYXRpdmUsIG51bGwsIG51bGwsIDEgLyBzY2FsZSk7XHJcbiAgfVxyXG5cclxuICBfX2R1bXBUb0RvY3VtZW50KCkge1xyXG4gICAgbGV0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgIGltZy5zdHlsZS50b3AgPSAnMHB4JztcclxuICAgIGltZy5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICBpbWcuc3R5bGUuYmFja2dyb3VuZCA9ICcjMzMzJztcclxuICAgIGltZy5zdHlsZS53aWR0aCA9ICcyNTZweCc7XHJcbiAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xyXG4gICAgLy9pbWcuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBjcmltc29uJztcclxuICAgIGltZy5zcmMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyh0aGlzLm1OYXRpdmUpLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSB0ZXh0dXJlIGF0bGFzLlxyXG4gKlxyXG4gKiBAY2F0IHRleHR1cmVzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5UZXh0dXJlXHJcbiAqL1xyXG5jbGFzcyBBdGxhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcclxuICBjb25zdHJ1Y3RvcihuYXRpdmVFbGVtZW50LCBqc29uT2JqZWN0LCBzY2FsZSA9IDEpIHtcclxuICAgIHN1cGVyKG5hdGl2ZUVsZW1lbnQsIG51bGwsIG51bGwsIHNjYWxlKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYmxhY2stZW5naW5lflRleHR1cmU+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3ViVGV4dHVyZXMgPSB7fTtcclxuXHJcbiAgICB0aGlzLl9fcGFyc2VBdGxhc0RhdGEoanNvbk9iamVjdCwgc2NhbGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHt7bWV0YTogKiwgZnJhbWVzOiBPYmplY3R9fSBvXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3BhcnNlQXRsYXNEYXRhKG8sIHNjYWxlKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gby5mcmFtZXMpIHtcclxuICAgICAgY29uc3QgZGF0YSA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKG8uZnJhbWVzW2tleV0pO1xyXG4gICAgICBjb25zdCByZWdpb24gPSBuZXcgUmVjdGFuZ2xlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10pO1xyXG4gICAgICBjb25zdCB1bnRyaW1tZWRSZWN0ID0gbmV3IFJlY3RhbmdsZShkYXRhWzRdLCBkYXRhWzVdLCBkYXRhWzZdLCBkYXRhWzddKTtcclxuXHJcbiAgICAgIGxldCByZWdpc3RyYXRpb25Qb2ludCA9IG51bGw7XHJcbiAgICAgIGxldCBzbGljZTlib3JkZXJzID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gOCArIDIpIHtcclxuICAgICAgICAvLyB3ZSBnb3QgcGl2b3RzXHJcbiAgICAgICAgcmVnaXN0cmF0aW9uUG9pbnQgPSBuZXcgVmVjdG9yKGRhdGFbOF0sIGRhdGFbOV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSA4ICsgNCkge1xyXG4gICAgICAgIC8vIHdlIGdvdCA5IHNsaWNlIGJ1dCBubyBwaXZvdHNcclxuICAgICAgICBzbGljZTlib3JkZXJzID0gbmV3IFJlY3RhbmdsZShkYXRhWzhdLCBkYXRhWzldLCBkYXRhWzEwXSwgZGF0YVsxMV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSA4ICsgNikge1xyXG4gICAgICAgIC8vIHdlIGdvdCBib3RoIHBpdm90cyBhbmQgOSBzbGljZVxyXG4gICAgICAgIHJlZ2lzdHJhdGlvblBvaW50ID0gbmV3IFZlY3RvcihkYXRhWzhdLCBkYXRhWzldKTtcclxuICAgICAgICBzbGljZTlib3JkZXJzID0gbmV3IFJlY3RhbmdsZShkYXRhWzEwXSwgZGF0YVsxMV0sIGRhdGFbMTJdLCBkYXRhWzEzXSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRoaXMubVN1YlRleHR1cmVzW2tleV0gPSBuZXcgVGV4dHVyZSh0aGlzLm5hdGl2ZSwgcmVnaW9uLCB1bnRyaW1tZWRSZWN0LCBzY2FsZSwgcmVnaXN0cmF0aW9uUG9pbnQsIHNsaWNlOWJvcmRlcnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgdGV4dHVyZSBieSBhIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGV4dHVyZSB0byBmaW5kLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfSBUaGUgVGV4dHVyZSBvciBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAgKi9cclxuICBnZXRUZXh0dXJlKG5hbWUpIHtcclxuICAgIC8qKiBAdHlwZSB7VGV4dHVyZX0gKi9cclxuICAgIGxldCB0ID0gdGhpcy5tU3ViVGV4dHVyZXNbbmFtZV07XHJcbiAgICBEZWJ1Zy5hc3NlcnRXYXJuKHQgIT09IHVuZGVmaW5lZCwgYFRleHR1cmUgJyR7bmFtZX0nIHdhcyBub3QgZm91bmRgKTtcclxuXHJcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtUZXh0dXJlfSAqLyAodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFycmF5IG9mIFRleHR1cmUgYnkgZ2l2ZW4gbmFtZSBvciB3aWxkY2FyZCBtYXNrLlxyXG4gICAqIElmIGBuYW1lTWFza2AgaXMgbnVsbCB0aGVuIGFsbCB0ZXh0dXJlcyB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAqIFRoaXMgbWV0aG9kIHNvcnRzIGFsbCByZXN1bHRpbmcgdGV4dHVyZXMgdXNpbmcgbmV1dHJhbCBzb3J0IGFsZ29yaXRoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW25hbWVNYXNrPW51bGxdIFRoZSBtYXNrIHRvIGZpbHRlciBieS5cclxuICAgKiBAcGFyYW0ge0FycmF5PGJsYWNrLWVuZ2luZX5UZXh0dXJlPnxudWxsfSAgICAgICAgIG91dFRleHR1cmVzIElmIHBhc3NlZCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHJlc3VsdCBvYmplY3QuXHJcbiAgICogQHJldHVybiB7QXJyYXk8YmxhY2stZW5naW5lflRleHR1cmU+fSAgICAgICAgICAgICBUaGUgbGlzdCBvZiBmb3VuZCB0ZXh0dXJlcy5cclxuICAgKi9cclxuICBnZXRUZXh0dXJlcyhuYW1lTWFzayA9IG51bGwsIG91dFRleHR1cmVzID0gbnVsbCkge1xyXG4gICAgbGV0IG91dCA9IG91dFRleHR1cmVzIHx8IFtdO1xyXG4gICAgaWYgKG5hbWVNYXNrID09PSBudWxsKSB7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLm1TdWJUZXh0dXJlcylcclxuICAgICAgICBvdXQucHVzaCh0aGlzLm1TdWJUZXh0dXJlc1trZXldKTtcclxuXHJcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PFRleHR1cmU+fSAqLyAob3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbmFtZXMgPSBbXTtcclxuXHJcbiAgICAvLyBUT0RPOiBtYWtlIGhlbHBlciB3aWxkIGZ1bmN0aW9uXHJcbiAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZU1hc2suc3BsaXQoXCIqXCIpLmpvaW4oXCIuKlwiKSArIFwiJFwiKTtcclxuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLm1TdWJUZXh0dXJlcylcclxuICAgICAgaWYgKHJlLnRlc3Qoa2V5KSlcclxuICAgICAgICBuYW1lcy5wdXNoKGtleSk7XHJcblxyXG4gICAgLy9uYW1lcy5zb3J0KEF0bGFzVGV4dHVyZS5fX25hdHVyYWxDb21wYXJlcik7XHJcbiAgICBBdGxhc1RleHR1cmUubmF0dXJhbFNvcnQobmFtZXMpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgIG91dC5wdXNoKHRoaXMubVN1YlRleHR1cmVzW25hbWVzW2ldXSk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgZGljdGlvbmFyeSBvZiBzdWIgdGV4dHVyZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbGlzdCBvZiBzdWIgdGV4dHVyZXMuXHJcbiAgICovXHJcbiAgZ2V0IHN1YlRleHR1cmVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN1YlRleHR1cmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydHMgc2V0IG9mIGRhdGEgaW4gbmF0dXJhbCBvcmRlclxyXG4gICAqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YXNldFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtmaWVsZD1udWxsXVxyXG4gICAqL1xyXG4gIHN0YXRpYyBuYXR1cmFsU29ydChkYXRhc2V0LCBmaWVsZCA9IG51bGwpIHtcclxuICAgIGRhdGFzZXQuc29ydChBdGxhc1RleHR1cmUuX19uYXR1cmFsQ29tcGFyZXIoZmllbGQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZpZWxkXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBYnNcclxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oPywgPyk6bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBfX25hdHVyYWxDb21wYXJlcihmaWVsZCA9IG51bGwsIHVzZUFicyA9IHRydWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBjb25zdCBOVU1CRVJfR1JPVVBTID0gLygtP1xcZCpcXC4/XFxkKykvZztcclxuICAgICAgbGV0IGFhID0gU3RyaW5nKGZpZWxkID09IG51bGwgPyBhIDogYVtmaWVsZF0pLnNwbGl0KE5VTUJFUl9HUk9VUFMpO1xyXG4gICAgICBsZXQgYmIgPSBTdHJpbmcoZmllbGQgPT0gbnVsbCA/IGIgOiBiW2ZpZWxkXSkuc3BsaXQoTlVNQkVSX0dST1VQUyk7XHJcbiAgICAgIGxldCBtaW4gPSBNYXRoLm1pbihhYS5sZW5ndGgsIGJiLmxlbmd0aCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHVzZUFicykge1xyXG4gICAgICAgICAgeCA9IE1hdGguYWJzKHBhcnNlRmxvYXQoYWFbaV0pKSB8fCBhYVtpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgeSA9IE1hdGguYWJzKHBhcnNlRmxvYXQoYmJbaV0pKSB8fCBiYltpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4ID0gcGFyc2VGbG9hdChhYVtpXSkgfHwgYWFbaV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgIHkgPSBwYXJzZUZsb2F0KGJiW2ldKSB8fCBiYltpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHggPCB5KVxyXG4gICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGVsc2UgaWYgKHggPiB5KVxyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFzc2V0IHR5cGUgZW51bS5cclxuICogQGNhdCBhc3NldHNcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IEFzc2V0VHlwZSA9IHtcclxuICBURVhUVVJFICAgICAgICAgICAgICA6ICd0ZXh0dXJlJyxcclxuICBURVhUVVJFX0FUTEFTICAgICAgICA6ICd0ZXh0dXJlQXRsYXMnLFxyXG4gIFZFQ1RPUl9URVhUVVJFICAgICAgIDogJ3ZlY3RvclRleHR1cmUnLFxyXG4gIFZFQ1RPUl9URVhUVVJFX0FUTEFTIDogJ3ZlY3RvclRleHR1cmVBdGxhcycsXHJcbiAgRk9OVCAgICAgICAgICAgICAgICAgOiAnZm9udCcsXHJcbiAgQklUTUFQX0ZPTlQgICAgICAgICAgOiAnYml0bWFwRm9udCcsXHJcbiAgWE1MICAgICAgICAgICAgICAgICAgOiAneG1sJyxcclxuICBKU09OICAgICAgICAgICAgICAgICA6ICdqc29uJyxcclxuICBWRUNUT1JfR1JBUEhJQ1MgICAgICA6ICd2ZWN0b3JHcmFwaGljcycsXHJcbiAgU09VTkQgICAgICAgICAgICAgICAgOiAnc291bmQnLFxyXG4gIFNPVU5EX0FUTEFTICAgICAgICAgIDogJ3NvdW5kQXRsYXMnXHJcbn07XHJcblxyXG4vKipcclxuICogTG9hZGVyIHR5cGUgZW51bS5cclxuICogQGNhdCBhc3NldHNcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IExvYWRlclR5cGUgPSB7XHJcbiAgRk9OVF9GQUNFIDogJ2ZvbnRGYWNlJyxcclxuICBJTUFHRSAgICAgOiAnaW1hZ2UnLFxyXG4gIFhIUiAgICAgICA6ICd4aHInXHJcbn07XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgbG9hZGVycy5cclxuICpcclxuICogQGNhdCBhc3NldHMubG9hZGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TWVzc2FnZURpc3BhdGNoZXJcclxuICovXHJcbmNsYXNzIEFzc2V0TG9hZGVyIGV4dGVuZHMgTWVzc2FnZURpc3BhdGNoZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEFzc2V0TG9hZGVyIGluc3RhbmNlLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih1cmwpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1VcmwgPSB1cmw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHsqfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EYXRhID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNMb2FkZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1OdW1Pd25lcnMgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBvdmVycmlkZGVuIGxvYWRzIGRhdGEuIFNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cclxuICBsb2FkKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gb3ZlcnJpZGRlbiBhYm9ydHMgbG9hZGluZyBwcm9jZXNzLiBTaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBhYm9ydCgpIHtcclxuICAgIC8vIG1vcmUgdGhhbiBvbmUgb3duZXIgbWVhbnMgdGhpcyBsb2FkZXIgd2FzIHVzZWQgYnkgdHdvIGFzc2V0cywgZWcgdHdvIGFzc2V0cyBoYXMgc2FtZSB1cmwuXHJcbiAgICBpZiAodGhpcy5tTnVtT3duZXJzID4gMSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMub25BYm9ydCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIG9uQWJvcnQoKSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIG9uTG9hZCgpIHtcclxuICAgIHRoaXMubUlzTG9hZGVkID0gdHJ1ZTtcclxuICAgIHRoaXMucG9zdChNZXNzYWdlLkNPTVBMRVRFKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBvbkVycm9yKCkge1xyXG4gICAgdGhpcy5tSXNMb2FkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMucG9zdChNZXNzYWdlLkVSUk9SKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbmF0aXZlIGxvYWRlZCBkYXRhIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsb2FkZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfVxyXG4gICAqL1xyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgdXJsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVVybDtcclxuICB9XHJcbn1cclxuXHJcbnZhciBhbHRlcm5hdGl2ZVVybCA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQUlBQUFDUWQxUGVBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUE1SlJFRlVlTnBpWW1CZ0FBZ3dBQUFNQUFNamNtTmNBQUFBQUVsRlRrU3VRbUNDJztcclxuXHJcbi8qKlxyXG4gKiBSZXNwb25zaWJsZSBmb3IgbG9hZGluZyBpbWFnZXMuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzLmxvYWRlcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkFzc2V0TG9hZGVyXHJcbiAqL1xyXG5jbGFzcyBJbWFnZUFzc2V0TG9hZGVyIGV4dGVuZHMgQXNzZXRMb2FkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEltYWdlQXNzZXRMb2FkZXIgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih1cmwpIHtcclxuICAgIHN1cGVyKHVybCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7SW1hZ2V9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgIHRoaXMubUltYWdlRWxlbWVudC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBsb2FkKCkge1xyXG4gICAgdGhpcy5tRGF0YSA9IHRoaXMubUltYWdlRWxlbWVudDtcclxuICAgIFxyXG4gICAgdGhpcy5tSW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHRoaXMub25Mb2FkKCk7XHJcbiAgICB0aGlzLm1JbWFnZUVsZW1lbnQub25lcnJvciA9ICgpID0+IHRoaXMub25FcnJvcigpO1xyXG4gICAgdGhpcy5tSW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMubVVybDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BYm9ydCgpIHtcclxuICAgIHRoaXMubUltYWdlRWxlbWVudC5vbmxvYWQgPSB0aGlzLm1JbWFnZUVsZW1lbnQub25hYm9ydCA9IHRoaXMubUltYWdlRWxlbWVudC5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgdGhpcy5tSW1hZ2VFbGVtZW50LnNyYyA9IGFsdGVybmF0aXZlVXJsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFhIUkFzc2V0TG9hZGVyIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGRhdGEgdmlhIFhNTEh0dHBSZXF1ZXN0LlxyXG4gKlxyXG4gKiBAY2F0IGFzc2V0cy5sb2FkZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldExvYWRlclxyXG4gKi9cclxuY2xhc3MgWEhSQXNzZXRMb2FkZXIgZXh0ZW5kcyBBc3NldExvYWRlciB7XHJcbiAgY29uc3RydWN0b3IodXJsKSB7XHJcbiAgICBzdXBlcih1cmwpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3R9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pbWVUeXBlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9ICcnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBsb2FkKCkge1xyXG4gICAgdGhpcy5tUmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLm1VcmwsIHRydWUpO1xyXG5cclxuICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSAhPSAnJylcclxuICAgICAgdGhpcy5tUmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuXHJcbiAgICBpZiAodGhpcy5tUmVxdWVzdC5vdmVycmlkZU1pbWVUeXBlICE9IHVuZGVmaW5lZCAmJiB0aGlzLm1pbWVUeXBlKVxyXG4gICAgICB0aGlzLm1SZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUodGhpcy5taW1lVHlwZSk7XHJcblxyXG4gICAgdGhpcy5tUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLm1SZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICBpZiAoKHRoaXMubVJlcXVlc3Quc3RhdHVzID09PSAyMDApIHx8ICgodGhpcy5tUmVxdWVzdC5zdGF0dXMgPT09IDApICYmIHRoaXMubVJlcXVlc3QucmVzcG9uc2VUZXh0KSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKVxyXG4gICAgICAgICAgICB0aGlzLm1EYXRhID0gdGhpcy5tUmVxdWVzdC5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMubURhdGEgPSB0aGlzLm1SZXF1ZXN0LnJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgIHRoaXMub25Mb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMub25FcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMubVJlcXVlc3Quc2VuZChudWxsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BYm9ydCgpIHtcclxuICAgIHRoaXMubVJlcXVlc3QuYWJvcnQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNwb25zaWJsZSBmb3IgbG9hZGluZyBsb2NhbCBvciBHb29nbGUgZm9udHMuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzLmxvYWRlcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkFzc2V0TG9hZGVyXHJcbiAqL1xyXG5jbGFzcyBGb250RmFjZUFzc2V0TG9hZGVyIGV4dGVuZHMgQXNzZXRMb2FkZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEZvbnRGYWNlQXNzZXRMb2FkZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgVGhlIGN1c3RvbSBuYW1lIG9mIHRoZSBmb250XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgIFRoZSBwYXRoIHRvIHRoZSBmb250XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvY2FsIFBhc3MgYHRydWVgIGlmIGZvbnQgaXMgbG9jYWwgb3RoZXJ3aXNlIEdvb2dsZSBGb250cyBzZXJ2aWNlIGlzIHVzZWQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgdXJsLCBpc0xvY2FsKSB7XHJcbiAgICBzdXBlcih1cmwpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRlc3RpbmdGb250TmFtZSA9ICdDb3VyaWVyIE5ldyc7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzTG9jYWwgPSBpc0xvY2FsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRlc3RpbmdTdHJpbmcgPSAnfiBHSEJEVE4sLiMkTWxjayc7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2hlY2tEZWxheSA9IDUwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGVzdGluZ0VsZW1lbnQgPSB0aGlzLl9fZ2V0VGVzdGluZ0VsZW1lbnQoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+Rm9udE1ldHJpY3N8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWV0cmljcyA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7RWxlbWVudH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvYWRlckVsZW1lbnQgPSB0aGlzLl9fZ2V0TG9hZGVyRWxlbWVudCh0aGlzLm1Jc0xvY2FsKTtcclxuICAgIHRoaXMubVRlc3RpbmdFbGVtZW50LnN0eWxlLmZvbnRGYW1pbHkgPSB0aGlzLm1UZXN0aW5nRm9udE5hbWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRGVmYXVsdEZvbnRXaWR0aCA9IHRoaXMubVRlc3RpbmdFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgdGhpcy5tVGVzdGluZ0VsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9IG5hbWUgKyAnLCcgKyB0aGlzLm1UZXN0aW5nRm9udE5hbWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGltZW91dEhhbmRsZSA9IC0xO1xyXG4gIH1cclxuXHJcbiAgbG9hZCgpIHtcclxuICAgIGlmICh0aGlzLm1Jc0xvY2FsKVxyXG4gICAgICB0aGlzLm1Mb2FkZXJFbGVtZW50LmlubmVySFRNTCArPSAoYFxcbiBAZm9udC1mYWNlIHtmb250LWZhbWlseTogJHt0aGlzLm1OYW1lfTsgc3JjOiB1cmwoJHt0aGlzLm1Vcmx9KTt9YCk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMubUxvYWRlckVsZW1lbnQuaHJlZiA9IHRoaXMubVVybDtcclxuXHJcbiAgICB0aGlzLl9fY2hlY2tMb2FkaW5nU3RhdHVzKCk7XHJcbiAgfVxyXG5cclxuICBvbkFib3J0KCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubVRpbWVvdXRIYW5kbGUpO1xyXG4gICAgdGhpcy5tVGVzdGluZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1UZXN0aW5nRWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9fZ2V0TG9hZGVyRWxlbWVudChsb2NhbCkge1xyXG4gICAgbGV0IGxvYWRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGxvY2FsID8gJ3N0eWxlJyA6ICdsaW5rJyk7XHJcbiAgICBsb2FkZXJFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgbG9hZGVyRWxlbWVudC5tZWRpYSA9ICdhbGwnO1xyXG4gICAgbG9hZGVyRWxlbWVudC5yZWwgPSAnc3R5bGVzaGVldCc7XHJcbiAgICBsb2FkZXJFbGVtZW50Lm9uZXJyb3IgPSAoKSA9PiB7IHRoaXMub25FcnJvcigpOyB9O1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsb2FkZXJFbGVtZW50KTtcclxuICAgIHJldHVybiBsb2FkZXJFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgX19nZXRUZXN0aW5nRWxlbWVudCgpIHtcclxuICAgIGxldCB0ZXN0aW5nRWxlbWVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9Ki8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XHJcbiAgICB0ZXN0aW5nRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB0ZXN0aW5nRWxlbWVudC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XHJcbiAgICB0ZXN0aW5nRWxlbWVudC5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xyXG4gICAgdGVzdGluZ0VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG4gICAgdGVzdGluZ0VsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMjUwcHgnO1xyXG4gICAgdGVzdGluZ0VsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5tVGVzdGluZ1N0cmluZztcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdGluZ0VsZW1lbnQpO1xyXG5cclxuICAgIHJldHVybiB0ZXN0aW5nRWxlbWVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX2NoZWNrTG9hZGluZ1N0YXR1cygpIHtcclxuICAgIGlmICh0aGlzLm1EZWZhdWx0Rm9udFdpZHRoID09PSB0aGlzLm1UZXN0aW5nRWxlbWVudC5vZmZzZXRXaWR0aCkge1xyXG4gICAgICB0aGlzLm1UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLl9fY2hlY2tMb2FkaW5nU3RhdHVzLmJpbmQodGhpcyksIHRoaXMubUNoZWNrRGVsYXkpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tZXRyaWNzID0gRm9udE1ldHJpY3MuZ2V0KHRoaXMubU5hbWUpO1xyXG4gICAgdGhpcy5tVGVzdGluZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1UZXN0aW5nRWxlbWVudCk7XHJcblxyXG4gICAgdGhpcy5vbkxvYWQoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIGFic3RyYWN0IGNsYXNzIGZvciBjdXN0b20gYXNzZXRzLiBGb3IgZXhhbXBsZSBBc3NldCBjYW4gYmUgdXNlZCB0byBsb2FkIHZpZGVvIG9yIG90aGVyIGRhdGEgZmlsZXMuXHJcbiAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGV4dGVybmFsIGFzc2V0cy5cclxuICpcclxuICogQGZpcmVzIEFzc2V0I2Vycm9yXHJcbiAqIEBmaXJlcyBBc3NldCNjb21wbGV0ZVxyXG4gKiBcclxuICogQGNhdCBhc3NldHNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1lc3NhZ2VEaXNwYXRjaGVyXHJcbiAqL1xyXG5jbGFzcyBBc3NldCBleHRlbmRzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBBc3NldCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSBOYW1lIG9mIGFzc2V0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hbWUpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UeXBlID0gdHlwZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EYXRhID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5Bc3NldExvYWRlcj59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Mb2FkZXJzID0gW107XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTnVtTG9hZGVkID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNSZWFkeSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5NZXNzYWdlQmluZGluZz59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1CaW5kaW5ncyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBnaXZlbiBsb2FkZXIgdG8gdGhlIGxpc3QuIExvYWRlciBjYW5ub3QgYmUgYWRkZWQgdG8gbXVsdGlwbHkgQXNzZXRzLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkFzc2V0TG9hZGVyfSBsb2FkZXIgTG9hZGVyIHRvIGFkZC5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkFzc2V0TG9hZGVyfVxyXG4gICAqL1xyXG4gIGFkZExvYWRlcihsb2FkZXIpIHtcclxuICAgIHRoaXMubUxvYWRlcnMucHVzaChsb2FkZXIpO1xyXG5cclxuICAgIGxvYWRlci5tTnVtT3duZXJzKys7XHJcblxyXG4gICAgdGhpcy5tQmluZGluZ3MucHVzaChsb2FkZXIub24oTWVzc2FnZS5DT01QTEVURSwgdGhpcy5fX29uTG9hZGVyQ29tcGxldGUsIHRoaXMpKTtcclxuICAgIHRoaXMubUJpbmRpbmdzLnB1c2gobG9hZGVyLm9uKE1lc3NhZ2UuRVJST1IsIHRoaXMuX19vbkxvYWRlckVycm9yLCB0aGlzKSk7XHJcblxyXG4gICAgcmV0dXJuIGxvYWRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIEFzc2V0TWFuYWdlciBpcyBhYm91dCB0byByZXF1ZXN0IGxvYWRlcnMgZm9yIHRoaXMgYXNzZXQuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TG9hZGVyRmFjdG9yeX0gZmFjdG9yeSBcclxuICAgKi9cclxuICBvbkxvYWRlclJlcXVlc3RlZChmYWN0b3J5KSB7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG0gXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19vbkxvYWRlckNvbXBsZXRlKG0pIHtcclxuICAgIHRoaXMubU51bUxvYWRlZCsrO1xyXG5cclxuICAgIGlmICh0aGlzLm1OdW1Mb2FkZWQgPT09IHRoaXMubUxvYWRlcnMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMubUJpbmRpbmdzLmZvckVhY2goeCA9PiB4Lm9mZigpKTtcclxuXHJcbiAgICAgIHRoaXMub25BbGxMb2FkZWQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWVzc2FnZX0gbSBcclxuICAgKi9cclxuICBfX29uTG9hZGVyRXJyb3IobSkge1xyXG4gICAgdGhpcy5hYm9ydCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zdGVkIHdoZW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxvYWRpbmcgdGhpcyBhc3NldC4gXHJcbiAgICAgKiBAZXZlbnQgQXNzZXQjZXJyb3JcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3N0KE1lc3NhZ2UuRVJST1IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIG9uQWxsTG9hZGVkKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFib3J0cyBsb2FkaW5nIG9mIHRoaXMgYXNzZXQuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xyXG4gIGFib3J0KCkge1xyXG4gICAgdGhpcy5tTnVtTG9hZGVkID0gMDtcclxuXHJcbiAgICB0aGlzLm1CaW5kaW5ncy5mb3JFYWNoKHggPT4geC5vZmYoKSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1Mb2FkZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubUxvYWRlcnNbaV07XHJcbiAgICAgIGxvYWRlci5hYm9ydCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvdGVjdGVkIG1ldGhvZCB1c2VkIHRvIG5vdGlmeSBBc3NldE1hbmFnZXIgYWJvdXQgY29tcGxldGlvbiBvZiBsb2FkaW5nIHRoaXMgYXNzZXQuXHJcbiAgICogXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gZGF0YVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlYWR5KGRhdGEpIHtcclxuICAgIHRoaXMubURhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5tSXNSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0ZWQgd2hlbiBhc3NldCBmaW5pc2hlZCBsb2FkaW5nLlxyXG4gICAgICogQGV2ZW50IEFzc2V0I2NvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zdChNZXNzYWdlLkNPTVBMRVRFKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhpcyBhc3NldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1UeXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGlzIGFzc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBuYW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubU5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGxvYWRlZCBkYXRhIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBhc3NldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4geyp9XHJcbiAgICovXHJcbiAgZ2V0IGRhdGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgYXNzZXQgaXMgbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNSZWFkeSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1Jc1JlYWR5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhcnJheSBvZiBsb2FkZXJzLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxibGFjay1lbmdpbmV+QXNzZXRMb2FkZXI+fVxyXG4gICAqL1xyXG4gIGdldCBsb2FkZXJzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUxvYWRlcnM7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2luZ2xlIFRleHR1cmUgZmlsZSBhc3NldCBjbGFzcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBpbWFnZXMgZmlsZSBhbmRcclxuICogY29udmVydGluZyB0aGVtIGludG8gVGV4dHVyZXMuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldFxyXG4gKi9cclxuY2xhc3MgVGV4dHVyZUFzc2V0IGV4dGVuZHMgQXNzZXQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgVGV4dHVyZUFzc2V0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXNzZXQgbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBVUkwgdG8gbG9hZCBpbWFnZSBmcm9tLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHVybCkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLlRFWFRVUkUsIG5hbWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVVybCA9IHVybDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubVNjYWxlID0gMSAvIFRleHR1cmUuZ2V0U2NhbGVGYWN0b3JGcm9tTmFtZSh1cmwpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5JbWFnZUFzc2V0TG9hZGVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbWFnZUxvYWRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uTG9hZGVyUmVxdWVzdGVkKGZhY3RvcnkpIHtcclxuICAgIHRoaXMubUltYWdlTG9hZGVyID0gZmFjdG9yeS5nZXQoTG9hZGVyVHlwZS5JTUFHRSwgdGhpcy5tVXJsKTtcclxuICAgIHRoaXMuYWRkTG9hZGVyKHRoaXMubUltYWdlTG9hZGVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBzdXBlci5yZWFkeShuZXcgVGV4dHVyZSh0aGlzLm1JbWFnZUxvYWRlci5kYXRhLCBudWxsLCBudWxsLCB0aGlzLm1TY2FsZSkpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbmdsZSBKU09OIGZpbGUgYXNzZXQgY2xhc3MgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcganNvbiBmaWxlLlxyXG4gKlxyXG4gKiBAY2F0IGFzc2V0c1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+QXNzZXRcclxuICovXHJcbmNsYXNzIEpTT05Bc3NldCBleHRlbmRzIEFzc2V0IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBKU09OQXNzZXQgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBVUkwgdG8gdGhlIGpzb24gZmlsZS5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHVybCkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLkpTT04sIG5hbWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVVybCA9IHVybDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+WEhSQXNzZXRMb2FkZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVhIUiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uTG9hZGVyUmVxdWVzdGVkKGZhY3RvcnkpIHtcclxuICAgIHRoaXMubVhIUiA9IGZhY3RvcnkuZ2V0KExvYWRlclR5cGUuWEhSLCB0aGlzLm1VcmwpO1xyXG4gICAgdGhpcy5tWEhSLm1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgdGhpcy5tWEhSLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcclxuICAgIHRoaXMuYWRkTG9hZGVyKHRoaXMubVhIUik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQWxsTG9hZGVkKCkge1xyXG4gICAgc3VwZXIucmVhZHkoLyoqIEB0eXBlIHshT2JqZWN0fSovKHRoaXMubVhIUi5kYXRhKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2luZ2xlIEpTT04gZmlsZSBhc3NldCBjbGFzcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBqc29uIGZpbGUuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldFxyXG4gKi9cclxuY2xhc3MgWE1MQXNzZXQgZXh0ZW5kcyBBc3NldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgSlNPTkFzc2V0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgYXNzZXQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgVVJMIHRvIHRoZSBqc29uIGZpbGUuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihuYW1lLCB1cmwpIHtcclxuICAgIHN1cGVyKEFzc2V0VHlwZS5YTUwsIG5hbWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVVybCA9IHVybDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+WEhSQXNzZXRMb2FkZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVhIUiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uTG9hZGVyUmVxdWVzdGVkKGZhY3RvcnkpIHtcclxuICAgIHRoaXMubVhIUiA9IGZhY3RvcnkuZ2V0KExvYWRlclR5cGUuWEhSLCB0aGlzLm1VcmwpO1xyXG4gICAgdGhpcy5tWEhSLm1pbWVUeXBlID0gJ3RleHQveG1sJztcclxuICAgIHRoaXMuYWRkTG9hZGVyKHRoaXMubVhIUik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQWxsTG9hZGVkKCkge1xyXG4gICAgc3VwZXIucmVhZHkobmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygvKiogQHR5cGUge3N0cmluZ30gKi8odGhpcy5tWEhSLmRhdGEpLCAndGV4dC94bWwnKSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRm9udCBmaWxlIGFzc2V0IGNsYXNzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGxvY2FsIGZvbnQgZmlsZXMuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgY2xhc3MgbmVlZCBhIGJvZHkgdG8gd29yayBwcm9wZXJseS5cclxuICpcclxuICogQGNhdCBhc3NldHNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkFzc2V0XHJcbiAqL1xyXG5jbGFzcyBGb250QXNzZXQgZXh0ZW5kcyBBc3NldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgRm9udEFzc2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgIFRoZSBjdXN0b20gbmFtZSBvZiB0aGUgZm9udFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICBUaGUgcGF0aCB0byB0aGUgZm9udFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb2NhbCBQYXNzIGB0cnVlYCBpZiBmb250IGlzIGxvY2FsIG90aGVyd2lzZSBHb29nbGUgRm9udHMgc2VydmljZSBpcyB1c2VkLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHVybCwgaXNMb2NhbCkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLkZPTlQsIG5hbWUpO1xyXG5cclxuICAgIGlmIChpc0xvY2FsID09PSBmYWxzZSlcclxuICAgICAgdXJsID0gJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT0nICsgbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnKycpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVVybCA9IHVybDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNMb2NhbCA9IGlzTG9jYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uTG9hZGVyUmVxdWVzdGVkKGZhY3RvcnkpIHtcclxuICAgIC8vIFdlIGFyZSBub3QgZG9pbmcgYWN0dWFsIGxvYWRpbmcgc2luY2UgbG9hZGluZyBpcyBoYW5kbGVkIGJ5IGJyb3dzZXIuIEp1c3QgZmFrZSBpdC5cclxuICAgIGNvbnN0IGxvYWRlciA9IGZhY3RvcnkuZ2V0KExvYWRlclR5cGUuRk9OVF9GQUNFLCB0aGlzLm1OYW1lLCB0aGlzLm1VcmwsIHRoaXMubUlzTG9jYWwpO1xyXG4gICAgdGhpcy5hZGRMb2FkZXIobG9hZGVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBzdXBlci5yZWFkeSgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRleHR1cmUgQXRsYXMgYXNzZXQgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgSW1hZ2UgZmlsZSBhbmQgY29ycmVzcG9uZGluZyBKc29uXHJcbiAqIGZpbGUuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldFxyXG4gKi9cclxuY2xhc3MgQXRsYXNUZXh0dXJlQXNzZXQgZXh0ZW5kcyBBc3NldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQXRsYXNUZXh0dXJlQXNzZXQgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgTmFtZSBvZiB0aGUgYXNzZXQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdlVXJsIEltYWdlIFVSTC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVybCAgSnNvbiBVUkwuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgaW1hZ2VVcmwsIGRhdGFVcmwpIHtcclxuICAgIHN1cGVyKEFzc2V0VHlwZS5URVhUVVJFX0FUTEFTLCBuYW1lKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbWFnZVVybCA9IGltYWdlVXJsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubURhdGFVcmwgPSBkYXRhVXJsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVNjYWxlID0gMSAvIFRleHR1cmUuZ2V0U2NhbGVGYWN0b3JGcm9tTmFtZShpbWFnZVVybCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkltYWdlQXNzZXRMb2FkZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUltYWdlTG9hZGVyID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtYSFJBc3NldExvYWRlcnxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tWEhSID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25Mb2FkZXJSZXF1ZXN0ZWQoZmFjdG9yeSkge1xyXG4gICAgdGhpcy5tSW1hZ2VMb2FkZXIgPSBmYWN0b3J5LmdldChMb2FkZXJUeXBlLklNQUdFLCB0aGlzLm1JbWFnZVVybCk7XHJcbiAgICB0aGlzLmFkZExvYWRlcih0aGlzLm1JbWFnZUxvYWRlcik7XHJcblxyXG4gICAgdGhpcy5tWEhSID0gZmFjdG9yeS5nZXQoTG9hZGVyVHlwZS5YSFIsIHRoaXMubURhdGFVcmwpO1xyXG4gICAgdGhpcy5tWEhSLm1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgdGhpcy5tWEhSLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcclxuICAgIHRoaXMuYWRkTG9hZGVyKHRoaXMubVhIUik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQWxsTG9hZGVkKCkge1xyXG4gICAgc3VwZXIucmVhZHkobmV3IEF0bGFzVGV4dHVyZSh0aGlzLm1JbWFnZUxvYWRlci5kYXRhLCB0aGlzLm1YSFIuZGF0YSwgdGhpcy5tU2NhbGUpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaXRtYXAgRm9udCBBc3NldCByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBmb250IGltYWdlIGZpbGUgYW5kIGNvcnJlc3BvbmRpbmcgeG1sIGZpbGUuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldFxyXG4gKi9cclxuY2xhc3MgQml0bWFwRm9udEFzc2V0IGV4dGVuZHMgQXNzZXQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEF0bGFzVGV4dHVyZUFzc2V0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgIE5hbWUgb2YgdGhlIGFzc2V0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCBJbWFnZSBVUkwuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHhtbFVybCAgIFhNTCBVUkwuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgaW1hZ2VVcmwsIHhtbFVybCkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLkJJVE1BUF9GT05ULCBuYW1lKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbWFnZVVybCA9IGltYWdlVXJsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVhtbFVybCA9IHhtbFVybDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubVNjYWxlID0gMSAvIFRleHR1cmUuZ2V0U2NhbGVGYWN0b3JGcm9tTmFtZShpbWFnZVVybCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkltYWdlQXNzZXRMb2FkZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tSW1hZ2VMb2FkZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge1hIUkFzc2V0TG9hZGVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1YSFIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkxvYWRlclJlcXVlc3RlZChmYWN0b3J5KSB7XHJcbiAgICB0aGlzLm1JbWFnZUxvYWRlciA9IGZhY3RvcnkuZ2V0KExvYWRlclR5cGUuSU1BR0UsIHRoaXMubUltYWdlVXJsKTtcclxuICAgIHRoaXMuYWRkTG9hZGVyKHRoaXMubUltYWdlTG9hZGVyKTtcclxuXHJcbiAgICB0aGlzLm1YSFIgPSBmYWN0b3J5LmdldChMb2FkZXJUeXBlLlhIUiwgdGhpcy5tWG1sVXJsKTtcclxuICAgIHRoaXMubVhIUi5taW1lVHlwZSA9ICd0ZXh0L3htbCc7XHJcbiAgICB0aGlzLmFkZExvYWRlcih0aGlzLm1YSFIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkFsbExvYWRlZCgpIHtcclxuICAgIGxldCB4bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyh0aGlzLm1YSFIuZGF0YSksICd0ZXh0L3htbCcpO1xyXG4gICAgbGV0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLm1JbWFnZUxvYWRlci5kYXRhLCBudWxsLCBudWxsLCB0aGlzLm1TY2FsZSk7XHJcblxyXG4gICAgc3VwZXIucmVhZHkoQml0bWFwRm9udEFzc2V0LnBhcnNlKHhtbCwgdGV4dHVyZSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSB4bWxcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfSB0ZXh0dXJlXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5CaXRtYXBGb250RGF0YX1cclxuICAgKi9cclxuICBzdGF0aWMgcGFyc2UoeG1sLCB0ZXh0dXJlKSB7XHJcbiAgICBsZXQgZGF0YSA9IG5ldyBCaXRtYXBGb250RGF0YSgpO1xyXG4gICAgZGF0YS50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgIGRhdGEueG1sID0geG1sO1xyXG5cclxuICAgIGxldCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF07XHJcbiAgICBsZXQgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcclxuXHJcbiAgICBkYXRhLm5hbWUgPSBpbmZvLmdldEF0dHJpYnV0ZSgnZmFjZScpO1xyXG4gICAgZGF0YS5zaXplID0gcGFyc2VJbnQoaW5mby5nZXRBdHRyaWJ1dGUoJ3NpemUnKSwgMTApO1xyXG4gICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZSgnbGluZUhlaWdodCcpLCAxMCk7XHJcbiAgICBkYXRhLmJhc2VsaW5lID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZSgnYmFzZScpLCAxMCk7XHJcbiAgICBkYXRhLmNoYXJzID0ge307XHJcblxyXG4gICAgbGV0IGxldHRlcnMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NoYXInKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGxldHRlciA9IGxldHRlcnNbaV07XHJcbiAgICAgIGxldCBjaGFyQ29kZSA9IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ2lkJyksIDEwKTtcclxuICAgICAgbGV0IHggPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd4JyksIDEwKSArIHRleHR1cmUucmVnaW9uLng7XHJcbiAgICAgIGxldCB5ID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneScpLCAxMCkgKyB0ZXh0dXJlLnJlZ2lvbi55O1xyXG4gICAgICBsZXQgdyA9IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKTtcclxuICAgICAgbGV0IGggPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApO1xyXG4gICAgICBsZXQgeG8gPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd4b2Zmc2V0JyksIDEwKTtcclxuICAgICAgbGV0IHlvID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCk7XHJcbiAgICAgIGxldCB4YSA9IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3hhZHZhbmNlJyksIDEwKTtcclxuICAgICAgbGV0IHRleHR1cmVSZWN0ID0gbmV3IFJlY3RhbmdsZSh4LCB5LCB3LCBoKTtcclxuXHJcbiAgICAgIGxldCBjaGFyRGF0YSA9IG5ldyBCaXRtYXBGb250Q2hhckRhdGEoKTtcclxuICAgICAgY2hhckRhdGEudGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRleHR1cmUubmF0aXZlLCB0ZXh0dXJlUmVjdCk7XHJcbiAgICAgIGNoYXJEYXRhLnhPZmZzZXQgPSB4bztcclxuICAgICAgY2hhckRhdGEueU9mZnNldCA9IHlvO1xyXG4gICAgICBjaGFyRGF0YS53aWR0aCA9IHc7XHJcbiAgICAgIGNoYXJEYXRhLmhlaWdodCA9IGg7XHJcbiAgICAgIGNoYXJEYXRhLnhBZHZhbmNlID0geGE7XHJcblxyXG4gICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9IGNoYXJEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBrZXJuaW5ncyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgna2VybmluZycpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGtlcm5pbmcgPSBrZXJuaW5nc1tpXTtcclxuICAgICAgbGV0IGZpcnN0ID0gcGFyc2VJbnQoa2VybmluZy5nZXRBdHRyaWJ1dGUoJ2ZpcnN0JyksIDEwKTtcclxuICAgICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KGtlcm5pbmcuZ2V0QXR0cmlidXRlKCdzZWNvbmQnKSwgMTApO1xyXG4gICAgICBsZXQgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZy5nZXRBdHRyaWJ1dGUoJ2Ftb3VudCcpLCAxMCk7XHJcblxyXG4gICAgICBpZiAoZGF0YS5jaGFyc1tzZWNvbmRdKVxyXG4gICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIEJpdG1hcEZvbnREYXRhIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBAdHlwZSB7VGV4dHVyZX0gKi9cclxuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cclxuICAgIHRoaXMueG1sID0gbnVsbDtcclxuXHJcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgIHRoaXMubmFtZSA9ICcnO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5zaXplID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubGluZUhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgQml0bWFwRm9udENoYXJEYXRhPn0gKi9cclxuICAgIHRoaXMuY2hhcnMgPSB7fTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMuYmFzZWxpbmUgPSAwO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgQml0bWFwRm9udENoYXJEYXRhIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBAdHlwZSB7VGV4dHVyZX0gKi9cclxuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnhPZmZzZXQgPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMud2lkdGggPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy54QWR2YW5jZSA9IDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgbnVtYmVyPn0gKi9cclxuICAgIHRoaXMua2VybmluZyA9IHt9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNvdW5kIHN0YXRlcy5cclxuICogQGlnbm9yZVxyXG4gKiBAY29uc3RhbnRcclxuICogQGNhdCBhdWRpb1xyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgU291bmRTdGF0ZSA9IHtcclxuICBORVdCT1JOOiAnbmV3Ym9ybicsXHJcbiAgUExBWUlORzogJ3BsYXlpbmcnLFxyXG4gIFBBVVNFRDogJ3BhdXNlZCcsXHJcbiAgU1RPUFBFRDogJ3N0b3BwZWQnLFxyXG4gIENPTVBMRVRFRDogJ2NvbXBsZXRlZCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc291bmQgZWZmZWN0IGludGVyZmFjZS4gSW1wbGVtZW50YXRpb25zIGNhbiBiZSBhdHRhY2hlZCB0byBzb3VuZCBjaGFubmVsLlxyXG4gKiBcclxuICogQGNhdCBhdWRpb1xyXG4gKi9cclxuY2xhc3MgU291bmRFZmZlY3Qge1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBTb3VuZEVmZmVjdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9Ob2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSW5wdXROb2RlID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0F1ZGlvTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU91dHB1dE5vZGUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEByZXR1cm4ge0F1ZGlvTm9kZX1cclxuICAgKi9cclxuICBnZXQgX2lucHV0Tm9kZSgpIHtcclxuICAgIERlYnVnLmFzc2VydCh0aGlzLm1JbnB1dE5vZGUgIT0gbnVsbCwgJ0lucHV0IG5vZGUgbXVzdCBiZSBzcGVjaWZpZWQgaW4gZGVzY2VuZGFudCBjbGFzcycpO1xyXG4gICAgcmV0dXJuIHRoaXMubUlucHV0Tm9kZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcmV0dXJuIHtBdWRpb05vZGV9XHJcbiAgICovXHJcbiAgZ2V0IF9vdXRwdXROb2RlKCkge1xyXG4gICAgRGVidWcuYXNzZXJ0KHRoaXMubU91dHB1dE5vZGUgIT0gbnVsbCwgJ091dHB1dCBub2RlIG11c3QgYmUgc3BlY2lmaWVkIGluIGRlc2NlbmRhbnQgY2xhc3MnKTtcclxuICAgIHJldHVybiB0aGlzLm1PdXRwdXROb2RlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB0byBkaXN0cmlidXRlIHNvdW5kIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQgY2hhbm5lbC5cclxuICogXHJcbiAqIEBjYXQgYXVkaW8uZWZmZWN0c1xyXG4gKiBAZXh0ZW5kcyB7YmxhY2stZW5naW5lflNvdW5kRWZmZWN0fVxyXG4gKi9cclxuY2xhc3MgU3RlcmVvUGFubmVyIGV4dGVuZHMgU291bmRFZmZlY3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFN0ZXJlb1Bhbi5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7R2Fpbk5vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1HYWluTCA9IEJsYWNrLmF1ZGlvLl9uZXdHYWluTm9kZSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0dhaW5Ob2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tR2FpblIgPSBCbGFjay5hdWRpby5fbmV3R2Fpbk5vZGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtDaGFubmVsU3BsaXR0ZXJOb2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3BsaXR0ZXIgPSBCbGFjay5hdWRpby5jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcclxuICAgIFxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Q2hhbm5lbE1lcmdlck5vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1NZXJnZXIgPSBCbGFjay5hdWRpby5jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XHJcblxyXG4gICAgdGhpcy5tU3BsaXR0ZXIuY29ubmVjdCh0aGlzLm1HYWluTCwgMCk7XHJcbiAgICB0aGlzLm1TcGxpdHRlci5jb25uZWN0KHRoaXMubUdhaW5SLCAxKTtcclxuICAgIHRoaXMubUdhaW5MLmNvbm5lY3QodGhpcy5tTWVyZ2VyLCAwLCAwKTtcclxuICAgIHRoaXMubUdhaW5SLmNvbm5lY3QodGhpcy5tTWVyZ2VyLCAwLCAxKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1WYWx1ZSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnB1dE5vZGUgPSB0aGlzLm1TcGxpdHRlcjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0F1ZGlvTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU91dHB1dE5vZGUgPSB0aGlzLm1NZXJnZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHBhbih2YWx1ZSkge1xyXG4gICAgdGhpcy5tVmFsdWUgPSBNYXRoRXguY2xhbXAodmFsdWUsIC0xLCAxKTtcclxuICAgIHRoaXMubUdhaW5MLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSAtIE1hdGhFeC5jbGFtcCh0aGlzLm1WYWx1ZSwgMCwgMSksIDApO1xyXG4gICAgdGhpcy5tR2FpblIuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxICsgTWF0aEV4LmNsYW1wKHRoaXMubVZhbHVlLCAtMSwgMCksIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIHN0ZXJlbyBwYW5uaW5nIHZhbHVlXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHBhbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1WYWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5sZXQgSUQkMiA9IDA7XHJcblxyXG4vKipcclxuICogVGhlIHNvdW5kXHJcbiAqIFxyXG4gKiBAY2F0IGF1ZGlvXHJcbiAqIEBleHRlbmRzIHtibGFjay1lbmdpbmV+TWVzc2FnZURpc3BhdGNoZXJ9XHJcbiAqL1xyXG5jbGFzcyBTb3VuZEluc3RhbmNlIGV4dGVuZHMgTWVzc2FnZURpc3BhdGNoZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Tb3VuZENsaXB9IHNvdW5kIGBTb3VuZENsaXBgIGluc3RhbmNlIHRha2VuIGZyb20gYEFzc2V0TWFuYWdlcmAuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc291bmQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSWQgPSArK0lEJDI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflNvdW5kQ2xpcH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVNvdW5kID0gc291bmQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflNvdW5kU3RhdGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdGF0ZSA9IFNvdW5kU3RhdGUuTkVXQk9STjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DaGFubmVsID0gJ21hc3Rlcic7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVm9sdW1lID0gMTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTG9vcCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YXJ0VGltZSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGF1c2VQb3NpdGlvbiA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RvcFBvc2l0aW9uID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TcmMgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0dhaW5Ob2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tR2Fpbk5vZGUgPSBCbGFjay5hdWRpby5fbmV3R2Fpbk5vZGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFRoZSBub2RlIHRvIGNvbm5lY3QgYXVkaW8gc291cmNlIFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaXJzdE5vZGUgPSB0aGlzLm1HYWluTm9kZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFRoZSBub2RlIHRoZSBzb3VyY2UgaXMgY29ubmVjdGVkIHRvIFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QbGF5Tm9kZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7UGFubmVyTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVNwYXRpYWxQYW5uZXIgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge1N0ZXJlb1Bhbm5lcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0ZXJlb1Bhbm5lciA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QW5hbHlzZXJOb2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQW5hbHlzZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlcyBzcGF0aWFsIGVmZmVjdCBpZiBub3QgZW5hYmxlZCBwcmV2aW91c2x5LlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7UGFubmVyTm9kZX1cclxuICAgKi9cclxuICBlbmFibGVTcGFjZVBhbigpIHtcclxuICAgIGlmICh0aGlzLm1TcGF0aWFsUGFubmVyID09IG51bGwpIHtcclxuICAgICAgdGhpcy5tU3BhdGlhbFBhbm5lciA9IEJsYWNrLmF1ZGlvLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XHJcbiAgICAgIGlmICh0aGlzLm1GaXJzdE5vZGUpIHtcclxuICAgICAgICB0aGlzLm1TcGF0aWFsUGFubmVyLmNvbm5lY3QodGhpcy5tRmlyc3ROb2RlKTtcclxuICAgICAgICB0aGlzLm1GaXJzdE5vZGUgPSB0aGlzLm1TcGF0aWFsUGFubmVyO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX19yZWNvbm5lY3RTb3VyY2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm1TcGF0aWFsUGFubmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlcyBzdGVyZW8gcGFubmluZyBlZmZlY3QgaWYgbm90IGVuYWJsZWQgcHJldmlvdXNseS5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge1N0ZXJlb1Bhbm5lcn1cclxuICAgKi9cclxuICBlbmFibGVTdGVyZW9QYW4oKSB7XHJcbiAgICBpZiAodGhpcy5tU3RlcmVvUGFubmVyID09IG51bGwpIHtcclxuICAgICAgdGhpcy5tU3RlcmVvUGFubmVyID0gbmV3IFN0ZXJlb1Bhbm5lcigpO1xyXG4gICAgICBpZiAodGhpcy5tRmlyc3ROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5tU3RlcmVvUGFubmVyLl9vdXRwdXROb2RlLmNvbm5lY3QodGhpcy5tRmlyc3ROb2RlKTtcclxuICAgICAgICB0aGlzLm1GaXJzdE5vZGUgPSB0aGlzLm1TdGVyZW9QYW5uZXIuX2lucHV0Tm9kZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9fcmVjb25uZWN0U291cmNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tU3RlcmVvUGFubmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlcyBhbmFseXNlciBub2RlIGlmIG5vdCBlbmFibGVkIHByZXZpb3VzbHkuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtBbmFseXNlck5vZGV9XHJcbiAgICovXHJcbiAgZW5hYmxlQW5hbHlzZXIoKSB7XHJcbiAgICBpZiAodGhpcy5tQW5hbHlzZXIgPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLm1BbmFseXNlciA9IEJsYWNrLmF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcclxuICAgICAgaWYgKHRoaXMubUZpcnN0Tm9kZSkge1xyXG4gICAgICAgIHRoaXMubUFuYWx5c2VyLmNvbm5lY3QodGhpcy5tRmlyc3ROb2RlKTtcclxuICAgICAgICB0aGlzLm1GaXJzdE5vZGUgPSB0aGlzLm1BbmFseXNlcjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9fcmVjb25uZWN0U291cmNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5tQW5hbHlzZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX3JlY29ubmVjdFNvdXJjZSgpIHtcclxuICAgIGlmICh0aGlzLm1TcmMgIT0gbnVsbCAmJiB0aGlzLm1QbGF5Tm9kZSAhPSBudWxsICYmIHRoaXMubUZpcnN0Tm9kZSAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMubVNyYy5kaXNjb25uZWN0KHRoaXMubVBsYXlOb2RlKTtcclxuICAgICAgdGhpcy5tU3JjLmNvbm5lY3QodGhpcy5tRmlyc3ROb2RlKTtcclxuICAgICAgdGhpcy5tUGxheU5vZGUgPSB0aGlzLm1GaXJzdE5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Tb3VuZEluc3RhbmNlfVxyXG4gICAqL1xyXG4gIF9wbGF5KCkge1xyXG4gICAgaWYgKHRoaXMubVN0YXRlID09PSBTb3VuZFN0YXRlLlBMQVlJTkcpXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHRoaXMubVN0YXRlID0gU291bmRTdGF0ZS5QTEFZSU5HO1xyXG5cclxuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMubVNvdW5kLmlzU3ViQ2xpcCAmJiAhdGhpcy5tTG9vcCA/IHRoaXMubVNvdW5kLmR1cmF0aW9uIC0gdGhpcy5tUGF1c2VQb3NpdGlvbiA6IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubUdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5tVm9sdW1lLCAwKTtcclxuXHJcbiAgICBsZXQgc3JjID0gQmxhY2suYXVkaW8uY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgIHNyYy5idWZmZXIgPSB0aGlzLm1Tb3VuZC5uYXRpdmU7XHJcbiAgICBzcmMubG9vcCA9IHRoaXMubUxvb3A7XHJcbiAgICBzcmMub25lbmRlZCA9ICgpID0+IHRoaXMuX19vbkNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLm1GaXJzdE5vZGUgJiYgc3JjLmNvbm5lY3QodGhpcy5tRmlyc3ROb2RlKTtcclxuICAgIHRoaXMubVBsYXlOb2RlID0gdGhpcy5tRmlyc3ROb2RlO1xyXG4gICAgdGhpcy5tU3RhcnRUaW1lID0gQmxhY2suYXVkaW8uY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMubVBhdXNlUG9zaXRpb247XHJcblxyXG4gICAgaWYgKHRoaXMubUxvb3AgJiYgdGhpcy5tU291bmQuaXNTdWJDbGlwKSB7XHJcbiAgICAgIHNyYy5sb29wU3RhcnQgPSB0aGlzLm1Tb3VuZC5vZmZzZXQ7XHJcbiAgICAgIHNyYy5sb29wRW5kID0gdGhpcy5tU291bmQub2Zmc2V0ICsgdGhpcy5tU291bmQuZHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgc3JjLnN0YXJ0KEJsYWNrLmF1ZGlvLmNvbnRleHQuY3VycmVudFRpbWUsIHRoaXMubVNvdW5kLm9mZnNldCArIHRoaXMubVBhdXNlUG9zaXRpb24sIGR1cmF0aW9uKTtcclxuICAgIEJsYWNrLmF1ZGlvLl9yZXNvbHZlQ2hhbm5lbCh0aGlzKTtcclxuICAgIHRoaXMubVNyYyA9IHNyYztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIHBsYXlpbmcuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW2R1cmF0aW9uPTBdIFRpbWUgb2Zmc2V0IGluIHNlY29uZHMgc3BlY2lmeWluZyB3aGVuIHRoZSBzb3VuZCB3aWxsIGNvbXBsZXRlbHkgc3RvcC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzdG9wKGR1cmF0aW9uID0gMCkge1xyXG4gICAgaWYgKHRoaXMubVN0YXRlID09PSBTb3VuZFN0YXRlLlBMQVlJTkcpIHtcclxuICAgICAgdGhpcy5tU3RvcFBvc2l0aW9uID0gdGhpcy5jdXJyZW50UG9zaXRpb247XHJcblxyXG4gICAgICB0aGlzLm1HYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcclxuICAgICAgdGhpcy5tU3JjLnN0b3AoQmxhY2suYXVkaW8uY29udGV4dC5jdXJyZW50VGltZSArIGR1cmF0aW9uKTtcclxuXHJcbiAgICAgIHRoaXMubVN0YXRlID0gU291bmRTdGF0ZS5TVE9QUEVEO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIGN1cnJlbnQgc291bmQuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgaWYgKHRoaXMubVN0YXRlID09PSBTb3VuZFN0YXRlLlBMQVlJTkcpIHtcclxuICAgICAgdGhpcy5tUGF1c2VQb3NpdGlvbiA9IHRoaXMuY3VycmVudFBvc2l0aW9uO1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMubVN0YXRlID0gU291bmRTdGF0ZS5QQVVTRUQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWVzIGN1cnJlbnQgc291bmQsIGlmIGl0IGhhcyBiZWVuIHBhdXNlZC5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgcmVzdW1lKCkge1xyXG4gICAgaWYgKHRoaXMubVN0YXRlID09PSBTb3VuZFN0YXRlLlBBVVNFRClcclxuICAgICAgdGhpcy5fcGxheSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hhbmdlcyB0aGUgdm9sdW1lIG9mIHNvdW5kIGluIGdpdmVuIHRpbWUuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gICAgICAgICAgICBJbml0aWFsIHZvbHVtZSBsZXZlbC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdG8gICAgICAgICAgICAgIFRhcmdldCB2b2x1bWUgbGV2ZWwuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbZHVyYXRpb249MF0gICBJbiBzZWNvbmRzLiBJZiAnMCcgY2hhbmdlcyB0aGUgdm9sdW1lIGluc3RhbnRseS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9J2xpbmVhciddIFBvc3NpYmxlIHR5cGVzOiAnbGluZWFyJywgJ2V4cCcuXHJcbiAgICovXHJcbiAgZmFkZShmcm9tLCB0bywgZHVyYXRpb24gPSAwLCB0eXBlID0gJ2xpbmVhcicpIHtcclxuICAgIGlmIChkdXJhdGlvbiA8PSAwKSB7XHJcbiAgICAgIHRoaXMubUdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodG8sIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tR2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShmcm9tLCAwKTtcclxuICAgICAgaWYgKHR5cGUgPT09ICdleHAnKVxyXG4gICAgICAgIHRoaXMubUdhaW5Ob2RlLmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShNYXRoLm1heCh0bywgMC4wMSksIEJsYWNrLmF1ZGlvLmNvbnRleHQuY3VycmVudFRpbWUgKyBkdXJhdGlvbik7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLm1HYWluTm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRvLCBCbGFjay5hdWRpby5jb250ZXh0LmN1cnJlbnRUaW1lICsgZHVyYXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19vbkNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5tU3JjID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5tU3RhdGUgIT09IFNvdW5kU3RhdGUuUEFVU0VEKSB7XHJcbiAgICAgIHRoaXMubVN0YXJ0VGltZSA9IDA7XHJcbiAgICAgIHRoaXMubVN0YXRlID0gU291bmRTdGF0ZS5DT01QTEVURUQ7XHJcbiAgICAgIHRoaXMucG9zdChNZXNzYWdlLkNPTVBMRVRFKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgY3VycmVudCBwb3NpdGlvbiBvZiBzb3VuZCBpbiBzZWNvbmRzLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMubVN0YXRlKSB7XHJcbiAgICAgIGNhc2UgU291bmRTdGF0ZS5QTEFZSU5HOlxyXG4gICAgICAgIHJldHVybiAoQmxhY2suYXVkaW8uY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMubVN0YXJ0VGltZSkgJSAodGhpcy5tU291bmQuZHVyYXRpb24gKyAwLjAxKTtcclxuICAgICAgY2FzZSBTb3VuZFN0YXRlLlBBVVNFRDpcclxuICAgICAgICByZXR1cm4gdGhpcy5tUGF1c2VQb3NpdGlvbjtcclxuICAgICAgY2FzZSBTb3VuZFN0YXRlLkNPTVBMRVRFRDpcclxuICAgICAgICByZXR1cm4gdGhpcy5tU291bmQuZHVyYXRpb247XHJcbiAgICAgIGNhc2UgU291bmRTdGF0ZS5TVE9QUEVEOlxyXG4gICAgICAgIHJldHVybiB0aGlzLm1TdG9wUG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtBdWRpb05vZGV9XHJcbiAgICovXHJcbiAgZ2V0IF9vdXRwdXROb2RlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUdhaW5Ob2RlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIGN1cnJlbnQgY2hhbm5lbCB0byBwbGF5IGJ5IG5hbWUuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGNoYW5uZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQ2hhbm5lbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgY2hhbm5lbCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubUNoYW5uZWwgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLm1DaGFubmVsID0gdmFsdWU7XHJcbiAgICBpZiAodGhpcy5tU3RhdGUgPT09IFNvdW5kU3RhdGUuUExBWUlORykge1xyXG4gICAgICBCbGFjay5hdWRpby5fcmVzb2x2ZUNoYW5uZWwodGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgc291bmQgdm9sdW1lLiBSYW5naW5nIGZyb20gMCB0byAxLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB2b2x1bWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVm9sdW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgIHRoaXMubVZvbHVtZSA9IHZhbHVlO1xyXG4gICAgdGhpcy5tR2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLm1Wb2x1bWUsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIHNvdW5kIHdpbGwgYmUgbG9vcGVkLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgbG9vcCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1Mb29wO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgbG9vcCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tTG9vcCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHBhbiBzdGVyZW8gZWZmZWN0LiBSYW5naW5nIGZyb20gLTEgKGxlZnQpIHRvIDEgKHJpZ2h0KS5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgcGFuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0ZXJlb1Bhbm5lci5wYW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHBhbih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSAwICYmIHRoaXMubVN0ZXJlb1Bhbm5lciA9PSBudWxsKVxyXG4gICAgICB0aGlzLmVuYWJsZVN0ZXJlb1BhbigpO1xyXG5cclxuICAgIGlmICh0aGlzLm1TdGVyZW9QYW5uZXIpXHJcbiAgICAgIHRoaXMubVN0ZXJlb1Bhbm5lci5wYW4gPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBzb3VuZCBpcyBwbGF5aW5nLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNQbGF5aW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YXRlID09PSBTb3VuZFN0YXRlLlBMQVlJTkc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRvdGFsIGR1cmF0aW9uIG9mIHNvdW5kIGNsaXAuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGR1cmF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNvdW5kLmR1cmF0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNvdW5kIGNoYW5uZWxcclxuICogXHJcbiAqIEBjYXQgYXVkaW9cclxuICovXHJcbmNsYXNzIFNvdW5kQ2hhbm5lbCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBTb3VuZENoYW5uZWwgd2l0aCBzcGVjaWZpYyBuYW1lXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSkge1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUgeyFHYWluTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUdhaW4gPSBCbGFjay5hdWRpby5fbmV3R2Fpbk5vZGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+U291bmRJbnN0YW5jZT59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Tb3VuZHMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+U291bmRFZmZlY3Q+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRWZmZWN0cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIHRoZSBzb3VuZCB0byBiZSBwbGF5ZWQgb24gdGhpcyBjaGFubmVsXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V9IHNvdW5kSW5zdGFuY2UgQ29uY3JldGUgU291bmRJbnN0YW5jZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBhdHRhY2hTb3VuZChzb3VuZEluc3RhbmNlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoc291bmRJbnN0YW5jZSAhPSBudWxsLCAnU291bmQgY2Fubm90IGJlIG51bGwnKTtcclxuXHJcbiAgICBzb3VuZEluc3RhbmNlLl9vdXRwdXROb2RlLmNvbm5lY3QodGhpcy5faW5wdXROb2RlKTtcclxuICAgIHRoaXMubVNvdW5kcy5wdXNoKHNvdW5kSW5zdGFuY2UpO1xyXG5cclxuICAgIHNvdW5kSW5zdGFuY2Uub24oTWVzc2FnZS5DT01QTEVURSwgKCkgPT4ge1xyXG4gICAgICB0aGlzLm1Tb3VuZHMuc3BsaWNlKHRoaXMubVNvdW5kcy5pbmRleE9mKHNvdW5kSW5zdGFuY2UpLCAxKTtcclxuICAgICAgc291bmRJbnN0YW5jZS5fb3V0cHV0Tm9kZS5kaXNjb25uZWN0KDApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGdpdmVuIHNvdW5kIGluc3RhbmNlIGZyb20gdGhpcyBjaGFubmVsXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V9IHNvdW5kSW5zdGFuY2UgQ29uY3JldGUgU291bmRJbnN0YW5jZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBkZXRhY2hTb3VuZChzb3VuZEluc3RhbmNlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoc291bmRJbnN0YW5jZSAhPSBudWxsLCAnU291bmQgY2Fubm90IGJlIG51bGwnKTtcclxuXHJcbiAgICBsZXQgaXggPSB0aGlzLm1Tb3VuZHMuaW5kZXhPZihzb3VuZEluc3RhbmNlKTtcclxuICAgIGlmIChpeCA+IC0xKSB7XHJcbiAgICAgIHRoaXMubVNvdW5kcy5zcGxpY2UoaXgsIDEpO1xyXG4gICAgICBzb3VuZEluc3RhbmNlLl9vdXRwdXROb2RlLmRpc2Nvbm5lY3QoMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBhbGwgc291bmRzIG9uIHRoaXMgY2hhbm5lbFxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzdG9wQWxsKCkge1xyXG4gICAgZm9yIChsZXQgc25kID0gdGhpcy5tU291bmRzWzBdOyB0aGlzLm1Tb3VuZHMubGVuZ3RoOyBzbmQgPSB0aGlzLm1Tb3VuZHMuc2hpZnQoKSkge1xyXG4gICAgICBzbmQuc3RvcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIGFsbCBzb3VuZHMgb24gdGhpcyBjaGFubmVsLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBwYXVzZUFsbCgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tU291bmRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1Tb3VuZHNbaV0ucGF1c2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZXMgYWxsIHBhdXNlZCBzb3VuZHMgb24gdGhpcyBjaGFubmVsLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICByZXN1bWVBbGwoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubVNvdW5kcy5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy5tU291bmRzW2ldLnJlc3VtZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzb3VuZCBlZmZlY3QgdG8gdGhpcyBjaGFubmVsXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflNvdW5kRWZmZWN0fSBlZmZlY3QgU291bmRFZmZlY3QgaW5zdGFuY2UuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Tb3VuZEVmZmVjdH1cclxuICAgKi9cclxuICBhZGRFZmZlY3QoZWZmZWN0KSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoZWZmZWN0ICE9IG51bGwsICdFZmZlY3QgY2Fubm90IGJlIG51bGwnKTtcclxuXHJcbiAgICBlZmZlY3QuX291dHB1dE5vZGUuY29ubmVjdCh0aGlzLl9pbnB1dE5vZGUpO1xyXG4gICAgdGhpcy5tRWZmZWN0cy51bnNoaWZ0KGVmZmVjdCk7XHJcbiAgICB0aGlzLl9fcmVjb25uZWN0U291bmRzKCk7XHJcbiAgICByZXR1cm4gZWZmZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzb3VuZCBlZmZlY3QgZnJvbSB0aGlzIGNoYW5uZWxcclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+U291bmRFZmZlY3R9IGVmZmVjdCBTb3VuZEVmZmVjdCBpbnN0YW5jZS5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kRWZmZWN0fVxyXG4gICAqL1xyXG4gIHJlbW92ZUVmZmVjdChlZmZlY3QpIHtcclxuICAgIERlYnVnLmFzc2VydChlZmZlY3QgIT0gbnVsbCwgJ0VmZmVjdCBjYW5ub3QgYmUgbnVsbCcpO1xyXG5cclxuICAgIGVmZmVjdC5fb3V0cHV0Tm9kZS5kaXNjb25uZWN0KDApO1xyXG4gICAgdGhpcy5tRWZmZWN0cy5zcGxpY2UodGhpcy5tRWZmZWN0cy5pbmRleE9mKGVmZmVjdCksIDEpO1xyXG4gICAgdGhpcy5fX3JlY29ubmVjdFNvdW5kcygpO1xyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYWxsIHNvdW5kIGVmZmVjdCBmcm9tIHRoaXMgY2hhbm5lbFxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICByZW1vdmVBbGxFZmZlY3RzKCkge1xyXG4gICAgZm9yICg7IHRoaXMubUVmZmVjdHMubGVuZ3RoOyB0aGlzLm1FZmZlY3RzLnNoaWZ0KCkpIHtcclxuICAgICAgdGhpcy5tRWZmZWN0c1swXS5fb3V0cHV0Tm9kZS5kaXNjb25uZWN0KDApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fX3JlY29ubmVjdFNvdW5kcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19yZWNvbm5lY3RTb3VuZHMoKSB7XHJcbiAgICB0aGlzLm1Tb3VuZHMuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgeC5fb3V0cHV0Tm9kZS5kaXNjb25uZWN0KDApO1xyXG4gICAgICB4Ll9vdXRwdXROb2RlLmNvbm5lY3QodGhpcy5faW5wdXROb2RlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgIHRoaXMubUdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIHZvbHVtZSBmb3IgdGhpcyBjaGFubmVsXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1HYWluLmdhaW4udmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMgeyFBdWRpb05vZGV9XHJcbiAgICovXHJcbiAgZ2V0IF9pbnB1dE5vZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRWZmZWN0cy5sZW5ndGggPyAvKiogQHR5cGUgeyFBdWRpb05vZGV9ICovICh0aGlzLm1FZmZlY3RzWzBdLl9pbnB1dE5vZGUpIDogdGhpcy5tR2FpbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7IUF1ZGlvTm9kZX1cclxuICAgKi9cclxuICBnZXQgX291dHB1dE5vZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tR2FpbjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGF1ZGlvIHN1cHBvcnQuXHJcbiAqIFxyXG4gKiBAY2F0IGF1ZGlvXHJcbiAqIEBleHRlbmRzIHtibGFjay1lbmdpbmV+U3lzdGVtfVxyXG4gKi9cclxuY2xhc3MgTWFzdGVyQXVkaW8gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gIC8qKlxyXG4gICAqIFNpbmdsZXRvblxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBCbGFjay5hdWRpbyA9IHRoaXM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9Db250ZXh0fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db250ZXh0ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+U291bmRMaXN0ZW5lcnxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ3VycmVudExpc3RlbmVyID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBibGFjay1lbmdpbmV+U291bmRDaGFubmVsPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNoYW5uZWxzID0ge307XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflNvdW5kQ2hhbm5lbHxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTWFzdGVyQ2hhbm5lbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzUGVuZGluZ1Jlc3VtZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBlbmRpbmdSZXN1bWUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVJlc3VtZVRpbWVvdXQgPSAwLjE7XHJcblxyXG4gICAgdGhpcy5fX2luaXRpYWxpemUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25QYXVzZSgpIHtcclxuICAgIGlmICh0aGlzLm1Db250ZXh0ID09PSBudWxsKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMubUNvbnRleHQuc3RhdGUgPT09ICdydW5uaW5nJylcclxuICAgICAgdGhpcy5tQ29udGV4dC5zdXNwZW5kKCk7XHJcblxyXG4gICAgdGhpcy5tSXNQZW5kaW5nUmVzdW1lID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uUmVzdW1lKCkge1xyXG4gICAgdGhpcy5tUGVuZGluZ1Jlc3VtZSA9IHRoaXMubVJlc3VtZVRpbWVvdXQ7XHJcbiAgICB0aGlzLm1Jc1BlbmRpbmdSZXN1bWUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgb25VcGRhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5tSXNQZW5kaW5nUmVzdW1lKVxyXG4gICAgICB0aGlzLm1QZW5kaW5nUmVzdW1lIC09IEJsYWNrLnRpbWUuZGVsdGE7XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZiAodGhpcy5tUGVuZGluZ1Jlc3VtZSA8PSAwKSB7XHJcbiAgICAgIGlmICh0aGlzLm1Db250ZXh0ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJyB8fCB0aGlzLm1Db250ZXh0LnN0YXRlID09PSAnaW50ZXJydXB0ZWQnKSB7XHJcbiAgICAgICAgdGhpcy5tQ29udGV4dC5yZXN1bWUoKTtcclxuICAgICAgICB0aGlzLm1Jc1BlbmRpbmdSZXN1bWUgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqL1xyXG4gIF9faW5pdGlhbGl6ZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMubUNvbnRleHQgPSBuZXcgKHdpbmRvd1snQXVkaW9Db250ZXh0J10gfHwgd2luZG93Wyd3ZWJraXRBdWRpb0NvbnRleHQnXSkoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGlmICh0aGlzLm1Db250ZXh0ID09IG51bGwpIHtcclxuICAgICAgICBEZWJ1Zy53YXJuKCdubyBhdWRpbyBzdXBwb3J0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX3VubG9jaygpO1xyXG5cclxuICAgIHRoaXMubU1hc3RlckNoYW5uZWwgPSBuZXcgU291bmRDaGFubmVsKCdtYXN0ZXInKTtcclxuXHJcbiAgICB0aGlzLm1NYXN0ZXJDaGFubmVsLl9vdXRwdXROb2RlLmNvbm5lY3QodGhpcy5tQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICB0aGlzLm1DaGFubmVsc1snbWFzdGVyJ10gPSB0aGlzLm1NYXN0ZXJDaGFubmVsO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ29udGV4dCAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnN0b3BBbGwoKTtcclxuICAgICAgdGhpcy5tQ29udGV4dC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubUlzUGVuZGluZ1Jlc3VtZSA9IGZhbHNlO1xyXG5cclxuICAgIEJsYWNrLmF1ZGlvID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX191bmxvY2soKSB7XHJcbiAgICBsZXQgZiA9ICgpID0+IHtcclxuICAgICAgbGV0IGJ1ZmZlciA9IHRoaXMubUNvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcclxuICAgICAgbGV0IHVubG9ja1NvdXJjZSA9IHRoaXMubUNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgIHVubG9ja1NvdXJjZS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgIHVubG9ja1NvdXJjZS5jb25uZWN0KHRoaXMubUNvbnRleHQuZGVzdGluYXRpb24pO1xyXG5cclxuICAgICAgaWYgKHVubG9ja1NvdXJjZS5zdGFydCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHVubG9ja1NvdXJjZS5ub3RlT24oMCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB1bmxvY2tTb3VyY2Uuc3RhcnQoMCk7XHJcblxyXG4gICAgICBpZiAodW5sb2NrU291cmNlLmNvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKVxyXG4gICAgICAgIHVubG9ja1NvdXJjZS5jb250ZXh0LnJlc3VtZSgpO1xyXG5cclxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGYpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZik7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBvciByZXR1cm5zIHRoZSBjaGFubmVsIHdpdGggc3BlY2lmaWMgbmFtZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBjaGFubmVsIHRvIGNyZWF0ZS5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kQ2hhbm5lbH1cclxuICAgKi9cclxuICBjcmVhdGVDaGFubmVsKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLm1DaGFubmVsc1tuYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgIGxldCBjaCA9IG5ldyBTb3VuZENoYW5uZWwobmFtZSk7XHJcbiAgICAgIGNoLl9vdXRwdXROb2RlLmNvbm5lY3QodGhpcy5tTWFzdGVyQ2hhbm5lbC5faW5wdXROb2RlKTtcclxuICAgICAgdGhpcy5tQ2hhbm5lbHNbbmFtZV0gPSBjaDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQ2hhbm5lbHNbbmFtZV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBjaGFubmVsIHdpdGggc3BlY2lmaWMgbmFtZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBjaGFubmVsIHRvIGdldC5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kQ2hhbm5lbHxudWxsfVxyXG4gICAqL1xyXG4gIGdldENoYW5uZWwobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNoYW5uZWxzW25hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V9IHNuZCBcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kQ2hhbm5lbH1cclxuICAgKi9cclxuICBfcmVzb2x2ZUNoYW5uZWwoc25kKSB7XHJcbiAgICBmb3IgKGxldCBjaE5hbWUgaW4gdGhpcy5tQ2hhbm5lbHMpXHJcbiAgICAgIHRoaXMubUNoYW5uZWxzW2NoTmFtZV0uZGV0YWNoU291bmQoc25kKTtcclxuXHJcbiAgICBsZXQgY2hOYW1lID0gc25kLmNoYW5uZWwgPT0gJycgPyAnbWFzdGVyJyA6IHNuZC5jaGFubmVsO1xyXG4gICAgbGV0IGNoID0gdGhpcy5tQ2hhbm5lbHNbY2hOYW1lXTtcclxuICAgIGNoLmF0dGFjaFNvdW5kKHNuZCk7XHJcblxyXG4gICAgcmV0dXJuIGNoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheXMgc291bmQgb24gc3BlY2lmaWMgY2hhbm5lbC5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8YmxhY2stZW5naW5lflNvdW5kQXRsYXNDbGlwfSBuYW1lT3JTb3VuZCBUaGUgbmFtZSBvZiBzb3VuZCBvciB0aGUgaW5zdGFuY2Ugb2YgU291bmRJbnN0YW5jZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IFtjaGFubmVsPSdtYXN0ZXInXSAgICAgICBUaGUgbmFtZSBvZiBjaGFubmVsIHRvIHBsYXkgb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbdm9sdW1lPTFdICAgICAgICAgICAgICAgVm9sdW1lIGxldmVsLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtsb29wPWZhbHNlXSAgICAgICAgICAgIERlZmluZXMgaWYgc291bmQgd2lsbCBsb29wLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW3Bhbj0wXSAgICAgICAgICAgICAgICAgIFRoZSBwYW5uaW5nIG9mIHRoZSBzb3VuZCwgcmFuZ2luZyBmcm9tIC0xIChsZWZ0KSB0byAxIChyaWdodCkuXHJcbiAgICogQHJldHVybnMge1NvdW5kSW5zdGFuY2V9ICAgICAgICAgICAgICAgICAgTmV3IHNvdW5kIGluc3RhbmNlIHRvIGJlIHBsYXllZC5cclxuICAgKi9cclxuICBwbGF5KG5hbWVPclNvdW5kLCBjaGFubmVsID0gJ21hc3RlcicsIHZvbHVtZSA9IDEsIGxvb3AgPSBmYWxzZSwgcGFuID0gMCkge1xyXG4gICAgRGVidWcuYXNzZXJ0KG5hbWVPclNvdW5kICE9IG51bGwsIGBQYXJhbSAnbmFtZU9yU291bmQnIGNhbm5vdCBiZSBudWxsLmApO1xyXG5cclxuICAgIGxldCBzb3VuZCA9IG51bGw7XHJcbiAgICBpZiAobmFtZU9yU291bmQuY29uc3RydWN0b3IgPT09IFN0cmluZylcclxuICAgICAgc291bmQgPSAoQmxhY2suYXNzZXRzLmdldFNvdW5kKCAvKiogQHR5cGUge3N0cmluZ30gKi8obmFtZU9yU291bmQpKSk7XHJcblxyXG4gICAgcmV0dXJuIHNvdW5kLnBsYXkoY2hhbm5lbCwgdm9sdW1lLCBsb29wLCBwYW4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcHMgYWxsIHNvdW5kIG9uIHNwZWNpZmljIGNoYW5uZWwuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNoYW5uZWxOYW1lIFRoZSBuYW1lIG9mIGNoYW5uZWwgdG8gc3RvcCBzb3VuZHMgb24uIElmIGVtcHR5LCBzdG9wcyBzb3VuZHMgb24gYWxsIGNoYW5uZWxzLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfSBcclxuICAgKi9cclxuICBzdG9wQWxsKGNoYW5uZWxOYW1lID0gbnVsbCkge1xyXG4gICAgaWYgKGNoYW5uZWxOYW1lID09PSBudWxsKVxyXG4gICAgICBmb3IgKGxldCBjaE5hbWUgaW4gdGhpcy5tQ2hhbm5lbHMpXHJcbiAgICAgICAgdGhpcy5tQ2hhbm5lbHNbY2hOYW1lXS5zdG9wQWxsKCk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMuZ2V0Q2hhbm5lbChjaGFubmVsTmFtZSkuc3RvcEFsbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIGFsbCB0aGUgc291bmRzIG9uIHNwZWNpZmljIGNoYW5uZWwuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNoYW5uZWxOYW1lIFRoZSBuYW1lIG9mIGNoYW5uZWwgdG8gcGF1c2Ugc291bmRzIG9uLiBJZiBlbXB0eSwgcGF1c2VzIGFsbCB0aGUgc291bmRzIG9uIGFsbCBjaGFubmVscy5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBwYXVzZUFsbChjaGFubmVsTmFtZSA9IG51bGwpIHtcclxuICAgIGlmIChjaGFubmVsTmFtZSA9PT0gbnVsbClcclxuICAgICAgZm9yIChsZXQgY2hOYW1lIGluIHRoaXMubUNoYW5uZWxzKVxyXG4gICAgICAgIHRoaXMubUNoYW5uZWxzW2NoTmFtZV0ucGF1c2VBbGwoKTtcclxuICAgIGVsc2VcclxuICAgICAgdGhpcy5nZXRDaGFubmVsKGNoYW5uZWxOYW1lKS5wYXVzZUFsbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lcyBhbGwgdGhlIHNvdW5kcyBvbiBzcGVjaWZpYyBjaGFubmVsLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjaGFubmVsTmFtZSBUaGUgbmFtZSBvZiBjaGFubmVsIHRvIHJlc3VtZSBzb3VuZHMgb24uIElmIGVtcHR5LCByZXN1bWVzIGFsbCB0aGUgc291bmRzIG9uIGFsbCBjaGFubmVscy5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICByZXN1bWVBbGwoY2hhbm5lbE5hbWUgPSBudWxsKSB7XHJcbiAgICBpZiAoY2hhbm5lbE5hbWUgPT09IG51bGwpXHJcbiAgICAgIGZvciAobGV0IGNoTmFtZSBpbiB0aGlzLm1DaGFubmVscylcclxuICAgICAgICB0aGlzLm1DaGFubmVsc1tjaE5hbWVdLnJlc3VtZUFsbCgpO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLmdldENoYW5uZWwoY2hhbm5lbE5hbWUpLnJlc3VtZUFsbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IG1hc3RlclZvbHVtZSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tTWFzdGVyQ2hhbm5lbC52b2x1bWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB2b2x1bWUgb24gbWFzdGVyIGNoYW5uZWwuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG1hc3RlclZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXN0ZXJDaGFubmVsLnZvbHVtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIG9ubHkgaW5zdGFuY2Ugb2YgbmF0aXZlIEF1ZGlvQ29udGV4dC5cclxuICAgKiBcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7QXVkaW9Db250ZXh0fVxyXG4gICAqL1xyXG4gIGdldCBjb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBtYXN0ZXIgY2hhbm5lbC5cclxuICAgKiBcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kQ2hhbm5lbH1cclxuICAgKi9cclxuICBnZXQgbWFzdGVyQ2hhbm5lbCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXN0ZXJDaGFubmVsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+U291bmRMaXN0ZW5lcn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgY3VycmVudExpc3RlbmVyKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1DdXJyZW50TGlzdGVuZXIgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBjdXJyZW50IGxpc3RlbmVyIGZvciBzcGF0aWFsIHNvdW5kIGVmZmVjdHMuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+U291bmRMaXN0ZW5lcn1cclxuICAgKi9cclxuICBnZXQgY3VycmVudExpc3RlbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUN1cnJlbnRMaXN0ZW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBjdXJyZW50IHRpbWVvdXQgd2hlbiByZXN1bWluZyBhdWRpbyBjb250ZXh0IGZyb20gc2xlZXAuXHJcbiAgICogUmVjb21tZW5kZWQgdmFsdWUgaXMgMTAwbXMgZm9yIGlPUyBkZXZpY2VzIHJ1bm5pbmcgaW4gU2FmYXJpLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZXN1bWVUaW1lb3V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVJlc3VtZVRpbWVvdXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHJlc3VtZVRpbWVvdXQodmFsdWUpIHtcclxuICAgIHRoaXMubVJlc3VtZVRpbWVvdXQgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyBjdXJyZW50IGxpc3RlbmVyIHRvIGRlZmF1bHQgQXVkaW9Db250ZXh0IGxpc3RlbmVyLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBsb29zZUxpc3RlbmVyKCkge1xyXG4gICAgdGhpcy5tQ29udGV4dC5saXN0ZW5lci5zZXRQb3NpdGlvbigwLCAwLCAxKTtcclxuICAgIHRoaXMubUN1cnJlbnRMaXN0ZW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybnMgeyFHYWluTm9kZX1cclxuICAgKi9cclxuICBfbmV3R2Fpbk5vZGUoKSB7XHJcbiAgICBpZiAodGhpcy5tQ29udGV4dC5jcmVhdGVHYWluID09PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiB0aGlzLm1Db250ZXh0LmNyZWF0ZUdhaW5Ob2RlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMubUNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBjbGFzcyB3aGljaCBzdG9yZXMgYXVkaW8gYnVmZmVyIGFuZCBpdHMgYWxsIHNvdW5kcyBkYXRhLlxyXG4gKiBcclxuICogQGNhdCBhdWRpb1xyXG4gKi9cclxuY2xhc3MgU291bmRDbGlwIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBTb3VuZENsaXAuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gbmF0aXZlQnVmZmVyICAgICBEZWNvZGVkIGF1ZGlvIGJ1ZmZlci5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtvZmZzZXQ9MF0gICAgICAgICAgIERldGVybWluZXMgYXQgd2hpY2ggcG9zaXRpb24gb2YgYnVmZmVyIHRoZSBzb3VuZCB3aWxsIGJlIHBsYXllZC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkdXJhdGlvbj11bmRlZmluZWRdIElmIHVuZGVmaW5lZCwgZ2V0cyBkdXJhdGlvbiB2YWx1ZSBmcm9tIG5hdGl2ZSBhdWRpbyBidWZmZXIuXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gW2lzU3ViQ2xpcD1mYWxzZV0gICBTcGVjaWZpZXMgd2hldGhlciB0aGlzIHNvdW5kIGNsaXAgaXMgcGFydCBvZiBhIHNvdW5kIGF0bGFzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hdGl2ZUJ1ZmZlciwgb2Zmc2V0ID0gMCwgZHVyYXRpb24gPSBOYU4sIGlzU3ViQ2xpcCA9IGZhbHNlKSB7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1OYXRpdmVCdWZmZXIgPSBuYXRpdmVCdWZmZXI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RhcnRPZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRHVyYXRpb24gPSBkdXJhdGlvbiB8fCBuYXRpdmVCdWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzU3ViQ2xpcCA9IGlzU3ViQ2xpcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgc291bmQgaW5zdGFuY2UgYW5kIHN0YXJ0cyB0byBwbGF5IG9uIHNwZWNpZmljIGNoYW5uZWxcclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBbY2hhbm5lbD0nbWFzdGVyJ10gVGhlIG5hbWUgb2YgY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFt2b2x1bWU9MV0gICAgICAgICBUaGUgdm9sdW1lIGxldmVsLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtsb29wPWZhbHNlXSAgICAgIFNwZWNpZmllcyBpZiBzb3VuZCB3aWxsIHJlcGVhdCBpbmZpbml0ZSB0aW1lcy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtwYW49MF0gICAgICAgICAgICBUaGUgcGFubmluZyB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7U291bmRJbnN0YW5jZX0gICAgICAgICAgICBOZXcgc291bmQgaW5zdGFuY2UgdG8gYmUgcGxheWVkLlxyXG4gICAqL1xyXG4gIHBsYXkoY2hhbm5lbCA9ICdtYXN0ZXInLCB2b2x1bWUgPSAxLCBsb29wID0gZmFsc2UsIHBhbiA9IDApIHtcclxuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBTb3VuZEluc3RhbmNlKHRoaXMpO1xyXG4gICAgaW5zdGFuY2UuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICBpbnN0YW5jZS52b2x1bWUgPSB2b2x1bWU7XHJcbiAgICBpbnN0YW5jZS5sb29wID0gbG9vcDtcclxuICAgIGluc3RhbmNlLnBhbiA9IHBhbjtcclxuICAgIHJldHVybiBpbnN0YW5jZS5fcGxheSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBibG9ja3MgZmlsbGVkIHdpdGggYXZlcmFnZSBhbXBsaXR1ZGUgZ2F0aGVyZWQgaW4gY2VydGFpbiBpbnRlcnZhbFxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tOdW0gTnVtYmVyIG9mIGJsb2NrcyB0byBkaXZpZGUgZGF0YSB0b1xyXG4gICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9XHJcbiAgICovXHJcbiAgY29sbGVjdFdhdmVEYXRhKGJsb2NrTnVtKSB7XHJcbiAgICBsZXQgY2hhbm5lbHMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tTmF0aXZlQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7IGkrKylcclxuICAgICAgY2hhbm5lbHNbaV0gPSB0aGlzLm1OYXRpdmVCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSk7XHJcblxyXG4gICAgY29uc3QgcGxheVBlcmNlbnQgPSB0aGlzLm1EdXJhdGlvbiAvIHRoaXMubU5hdGl2ZUJ1ZmZlci5kdXJhdGlvbjtcclxuICAgIGNvbnN0IHN0YXJ0UGVyY2VudCA9IHRoaXMubVN0YXJ0T2Zmc2V0IC8gdGhpcy5tTmF0aXZlQnVmZmVyLmR1cmF0aW9uO1xyXG4gICAgY29uc3Qgc3RhcnRQb3MgPSB+fihjaGFubmVsc1swXS5sZW5ndGggKiBzdGFydFBlcmNlbnQpO1xyXG4gICAgY29uc3QgZW5kUG9zID0gc3RhcnRQb3MgKyB+fihjaGFubmVsc1swXS5sZW5ndGggKiBwbGF5UGVyY2VudCk7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJsb2NrTnVtKTtcclxuICAgIGNvbnN0IGJsb2NrV2lkdGggPSB+fihjaGFubmVsc1swXS5sZW5ndGggKiBwbGF5UGVyY2VudCAvIGJsb2NrTnVtKTtcclxuICAgIGxldCBkYXRhQmxvY2sgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRQb3MsIGMgPSAwOyBpIDwgZW5kUG9zIDsgaSsrKSB7XHJcbiAgICAgIGRhdGFCbG9jay5wdXNoKHRoaXMuX19hdmVyYWdlUGVhayhjaGFubmVscywgaSkpO1xyXG5cclxuICAgICAgaWYgKGRhdGFCbG9jay5sZW5ndGggPj0gYmxvY2tXaWR0aCkge1xyXG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heCguLi5kYXRhQmxvY2spO1xyXG4gICAgICAgIGxldCBtaW4gPSBNYXRoLm1pbiguLi5kYXRhQmxvY2spO1xyXG4gICAgICAgIHZhbHVlc1tjKytdID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgIGRhdGFCbG9jayA9IFtdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXk8RmxvYXQzMkFycmF5Pn0gY2hhbm5lbHMgXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGl4IFxyXG4gICAqL1xyXG4gIF9fYXZlcmFnZVBlYWsoY2hhbm5lbHMsIGl4KSB7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGNoYW5uZWxzLmZvckVhY2goY2ggPT4gc3VtICs9IE1hdGguYWJzKGNoW2l4XSkpO1xyXG4gICAgcmV0dXJuIHN1bSAvIGNoYW5uZWxzLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRlY29kZWQgYXVkaW8gYnVmZmVyLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7QXVkaW9CdWZmZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG5hdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1OYXRpdmVCdWZmZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBpbiBzZWNvbmRzLCB3aGVyZSB0aGUgc291bmQgc2hvdWxkIHN0YXJ0IHRvIHBsYXkuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG9mZnNldCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1TdGFydE9mZnNldDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgc291bmQgY2xpcCBkdXJhdGlvbi5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRHVyYXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBzb3VuZCBjbGlwIGlzIGEgcGFydCBvZiBzb3VuZCBhdGxhcyBjbGlwLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNTdWJDbGlwKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUlzU3ViQ2xpcDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3VuZCBmaWxlIGFzc2V0IGNsYXNzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGF1ZGlvIGZpbGVzLlxyXG4gKlxyXG4gKiBAY2F0IGFzc2V0c1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+QXNzZXRcclxuICovXHJcbmNsYXNzIFNvdW5kQXNzZXQgZXh0ZW5kcyBBc3NldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBTb3VuZEFzc2V0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU291bmQgbmFtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBVUkwgdG8gbG9hZCBhdWRpbyBmcm9tLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHVybCkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLlNPVU5ELCBuYW1lKTtcclxuXHJcbiAgICBpZiAoQmxhY2suZGV2aWNlLndlYkF1ZGlvU3VwcG9ydGVkID09PSBmYWxzZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmIChCbGFjay5lbmdpbmUuaGFzU3lzdGVtKE1hc3RlckF1ZGlvKSA9PT0gZmFsc2UpIHtcclxuICAgICAgRGVidWcud2FybignW1NvdW5kQXNzZXRdIExvYWRpbmcgc291bmQgZmlsZXMgd2l0aG91dCBNYXN0ZXJBdWRpbyBzeXN0ZW0uJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1VcmwgPSB1cmw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflhIUkFzc2V0TG9hZGVyfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1YSFIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkxvYWRlclJlcXVlc3RlZChmYWN0b3J5KSB7XHJcbiAgICB0aGlzLm1YSFIgPSBmYWN0b3J5LmdldChMb2FkZXJUeXBlLlhIUiwgdGhpcy5tVXJsKTtcclxuICAgIHRoaXMubVhIUi5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgdGhpcy5hZGRMb2FkZXIodGhpcy5tWEhSKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBsZXQgdW5kZWNvZGVkQXVkaW8gPSAvKiogQHR5cGUgeyFBcnJheUJ1ZmZlcn0gKi8gKHRoaXMubVhIUi5kYXRhKTtcclxuICAgIEJsYWNrLmF1ZGlvLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHVuZGVjb2RlZEF1ZGlvLCAoYnVmZmVyKSA9PiB7XHJcbiAgICAgIHN1cGVyLnJlYWR5KG5ldyBTb3VuZENsaXAoYnVmZmVyKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgY2xhc3Mgd2hpY2ggc3RvcmVzIGF1ZGlvIGJ1ZmZlciBvZiBzb3VuZCBhdGxhcyBhbmQgaW5mb3JtYXRpb24gYWJvdXQgc3ViIHNvdW5kIGNsaXBzLlxyXG4gKiBcclxuICogQGNhdCBhdWRpb1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+U291bmRDbGlwXHJcbiAqL1xyXG5jbGFzcyBTb3VuZEF0bGFzQ2xpcCBleHRlbmRzIFNvdW5kQ2xpcCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgU291bmRBdGxhcy5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBuYXRpdmVCdWZmZXIgRGVjb2RlZCBhdWRpbyBidWZmZXIuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGpzb25PYmplY3QgICAgICAgIERhdGEgcmVwcmVzZW50aW5nIHN1YiBzb3VuZHMgbmFtZSwgZHVyYXRpb24gYW5kIG9mZnNldC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihuYXRpdmVCdWZmZXIsIGpzb25PYmplY3QpIHtcclxuICAgIHN1cGVyKG5hdGl2ZUJ1ZmZlcik7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYmxhY2stZW5naW5lflNvdW5kQ2xpcD59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DbGlwcyA9IHt9O1xyXG4gICAgXHJcbiAgICBpZiAoanNvbk9iamVjdCAhPT0gbnVsbClcclxuICAgICAgZm9yIChsZXQga2V5IGluIGpzb25PYmplY3RbJ3NvdW5kcyddKVxyXG4gICAgICAgIHRoaXMuYWRkU3ViU291bmQoa2V5LCBqc29uT2JqZWN0Wydzb3VuZHMnXVtrZXldWzBdLCBqc29uT2JqZWN0Wydzb3VuZHMnXVtrZXldWzFdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIER5bmFtaWNhbGx5IHNldHMgbmV3IHN1YiBzb3VuZCBpbmZvIGJ5cGFzc2luZyBqc29uLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIHN1YiBzb3VuZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0ICAgVGhlIG9mZnNldCBpcyBzZWNvbmRzLCB3aGVyZSBzdWIgc291bmQgd2lsbCBiZSBzdGFydCBwbGF5aW5nIGZyb20uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiBzdWIgc291bmQuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Tb3VuZENsaXB9ICAgICBOZXcgaW5zdGFuY2Ugb2YgU291bmRDbGlwLlxyXG4gICAqL1xyXG4gIGFkZFN1YlNvdW5kKG5hbWUsIG9mZnNldCA9IDAsIGR1cmF0aW9uID0gTmFOKSB7XHJcbiAgICB0aGlzLm1DbGlwc1tuYW1lXSA9IG5ldyBTb3VuZENsaXAodGhpcy5uYXRpdmUsIG9mZnNldCwgZHVyYXRpb24sIHRydWUpO1xyXG4gICAgcmV0dXJuIHRoaXMubUNsaXBzW25hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBwcmV2aW91c2x5IGFkZGVkIHN1YiBzb3VuZCBpbmZvLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ViIHNvdW5kLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlbW92ZVN1YlNvdW5kKG5hbWUpIHtcclxuICAgIGRlbGV0ZSB0aGlzLm1DbGlwc1tuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpcmVjdGx5IHBsYXlzIHN1YiBzb3VuZCBieSBnaXZlbiBuYW1lIG9uIHNwZWNpZmljIGNoYW5uZWwuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBzdWIgc291bmQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBbY2hhbm5lbD0nbWFzdGVyJ10gVGhlIG5hbWUgb2YgY2hhbm5lbC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFt2b2x1bWU9MV0gICAgICAgICBUaGUgdm9sdW1lIGxldmVsLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtsb29wPWZhbHNlXSAgICAgIFNwZWNpZmllcyBpZiBzb3VuZCB3aWxsIHJlcGVhdCBpbmZpbml0ZSB0aW1lcy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtwYW49MF0gICAgICAgICAgICBUaGUgcGFubmluZyB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V8bnVsbH0gICAgICAgTmV3IHNvdW5kIGluc3RhbmNlIHRvIGJlIHBsYXllZC5cclxuICAgKi9cclxuICBwbGF5U3ViU291bmQobmFtZSwgY2hhbm5lbCA9ICdtYXN0ZXInLCB2b2x1bWUgPSAxLCBsb29wID0gZmFsc2UsIHBhbiA9IDApIHtcclxuICAgIGxldCBjbGlwID0gdGhpcy5tQ2xpcHNbbmFtZV07XHJcbiAgICBpZiAoY2xpcCA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgbGV0IGluc3RhbmNlID0gbmV3IFNvdW5kSW5zdGFuY2UoY2xpcCk7XHJcbiAgICBpbnN0YW5jZS5jaGFubmVsID0gY2hhbm5lbDtcclxuICAgIGluc3RhbmNlLnZvbHVtZSA9IHZvbHVtZTtcclxuICAgIGluc3RhbmNlLmxvb3AgPSBsb29wO1xyXG4gICAgaW5zdGFuY2UucGFuID0gcGFuO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLl9wbGF5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGljdGlvbmFyeSBvZiBzdWIgc291bmRzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCBibGFjay1lbmdpbmV+U291bmRDbGlwPn1cclxuICAgKi9cclxuICBnZXQgc3ViU291bmRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNsaXBzO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNvdW5kIGZpbGUgYXNzZXQgY2xhc3MgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcgYXVkaW8gYXRsYXMgZmlsZXMuXHJcbiAqXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Bc3NldFxyXG4gKi9cclxuY2xhc3MgU291bmRBdGxhc0Fzc2V0IGV4dGVuZHMgQXNzZXQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IFNvdW5kQXRsYXNBc3NldCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNvdW5kIG5hbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdW5kVXJsICBVUkwgdG8gbG9hZCBhdWRpbyBhdGxhcyBmcm9tLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJsICBVUkwgdG8gbG9hZCBhdGxhcyBkYXRhIGZyb20uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgc291bmRVcmwsIGRhdGFVcmwpIHtcclxuICAgIHN1cGVyKEFzc2V0VHlwZS5TT1VORF9BVExBUywgbmFtZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5tU291bmRVcmwgPSBzb3VuZFVybDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EYXRhVXJsID0gZGF0YVVybDtcclxuXHJcbiAgICBpZiAoQmxhY2suZGV2aWNlLndlYkF1ZGlvU3VwcG9ydGVkID09PSBmYWxzZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmIChCbGFjay5lbmdpbmUuaGFzU3lzdGVtKE1hc3RlckF1ZGlvKSA9PT0gZmFsc2UpIHtcclxuICAgICAgRGVidWcud2FybignW1NvdW5kQXNzZXRdIExvYWRpbmcgc291bmQgZmlsZXMgd2l0aG91dCBNYXN0ZXJBdWRpbyBzeXN0ZW0uJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+WEhSQXNzZXRMb2FkZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUF1ZGlvWEhSID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+WEhSQXNzZXRMb2FkZXJ8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubURhdGFYSFIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkxvYWRlclJlcXVlc3RlZChmYWN0b3J5KSB7XHJcbiAgICB0aGlzLm1BdWRpb1hIUiA9IGZhY3RvcnkuZ2V0KExvYWRlclR5cGUuWEhSLCB0aGlzLm1Tb3VuZFVybCk7XHJcbiAgICB0aGlzLm1BdWRpb1hIUi5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgdGhpcy5hZGRMb2FkZXIodGhpcy5tQXVkaW9YSFIpO1xyXG5cclxuICAgIHRoaXMubURhdGFYSFIgPSBmYWN0b3J5LmdldChMb2FkZXJUeXBlLlhIUiwgdGhpcy5tRGF0YVVybCk7XHJcbiAgICB0aGlzLm1EYXRhWEhSLm1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgdGhpcy5tRGF0YVhIUi5yZXNwb25zZVR5cGUgPSAnanNvbic7XHJcbiAgICB0aGlzLmFkZExvYWRlcih0aGlzLm1EYXRhWEhSKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBsZXQgdW5kZWNvZGVkQXVkaW8gPSAvKiogQHR5cGUgeyFBcnJheUJ1ZmZlcn0gKi8gKHRoaXMubUF1ZGlvWEhSLmRhdGEpO1xyXG4gICAgQmxhY2suYXVkaW8uY29udGV4dC5kZWNvZGVBdWRpb0RhdGEodW5kZWNvZGVkQXVkaW8sIChidWZmZXIpID0+IHtcclxuICAgICAgc3VwZXIucmVhZHkobmV3IFNvdW5kQXRsYXNDbGlwKGJ1ZmZlciwgdGhpcy5tRGF0YVhIUi5kYXRhKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb21tYW5kIHRvIHVzZSBpbiBncmFwaGljc1xyXG4gKiBAY2F0IGRpc3BsYXlcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IEdyYXBoaWNzQ29tbWFuZFR5cGUgPSB7XHJcbiAgTElORV9TVFlMRSAgICAgICAgOiAnbGluZVN0eWxlJyxcclxuICBGSUxMX1NUWUxFICAgICAgICA6ICdmaWxsU3R5bGUnLFxyXG5cclxuICBBUkMgICAgICAgICAgICAgICA6ICdhcmMnLFxyXG4gIFJFQ1QgICAgICAgICAgICAgIDogJ3JlY3QnLFxyXG4gIFJPVU5ERURfUkVDVCAgICAgIDogJ3JvdW5kZWRSZWN0JyxcclxuICBCRVpJRVJfQ1VSVkVfVE8gICA6ICdiZXppZXJDdXJ2ZVRvJyxcclxuICBRVUFEUkFUSUNfQ1VSVkVfVE86ICdxdWFkcmF0aWNDdXJ2ZVRvJyxcclxuICBCRUdJTl9QQVRIICAgICAgICA6ICdiZWdpblBhdGgnLFxyXG4gIENMT1NFX1BBVEggICAgICAgIDogJ2Nsb3NlUGF0aCcsXHJcbiAgRklMTCAgICAgICAgICAgICAgOiAnZmlsbCcsXHJcbiAgTElORV9UTyAgICAgICAgICAgOiAnbGluZVRvJyxcclxuICBNT1ZFX1RPICAgICAgICAgICA6ICdtb3ZlVG8nLFxyXG4gIFNUUk9LRSAgICAgICAgICAgIDogJ3N0cm9rZScsXHJcbiAgQk9VTkRTICAgICAgICAgICAgOiAnYm91bmRzJyxcclxuXHJcbiAgU0hBRE9XX0NPTE9SICAgICAgOiAnc2hhZG93Q29sb3InLFxyXG4gIFNIQURPV19CTFVSICAgICAgIDogJ3NoYWRvd0JsdXInLFxyXG5cclxuICBMSU5FX0RBU0ggICA6ICdzZXRMaW5lRGFzaCcsXHJcbiAgRklMTF9HUkQgICAgOiAnZ3JhZGllbnRGaWxsU3R5bGUnLFxyXG4gIEZJTExfUEFUVEVSTjogJ3BhdHRlcm5GaWxsU3R5bGUnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGNsYXNzIGZvciBHcmFwaGljcy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzQ29tbWFuZCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgR3JhcGhpY3NDb21tYW5kXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HcmFwaGljc0NvbW1hbmRUeXBlfSB0eXBlXHJcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZGF0YVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7R3JhcGhpY3NDb21tYW5kVHlwZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtBcnJheTwqPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHZhbHVlIGF0IGdpdmVuIGluZGV4IGFzIGEgbnVtYmVyLiBVc2VkIGZvciBHQ0Mgb25seS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaXhcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldE51bWJlcihpeCkge1xyXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZGF0YVtpeF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB2YWx1ZSBhdCBnaXZlbiBpbmRleCBhcyBhIHN0cmluZy4gVXNlZCBmb3IgR0NDIG9ubHkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGl4XHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBnZXRTdHJpbmcoaXgpIHtcclxuICAgIHJldHVybiAvKiogQHR5cGUgeyFzdHJpbmd9ICovICh0aGlzLmRhdGFbaXhdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdmFsdWUgYXQgZ2l2ZW4gaW5kZXggYXMgYSBzdHJpbmcuIFVzZWQgZm9yIEdDQyBvbmx5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpeFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldEJvb2xlYW4oaXgpIHtcclxuICAgIHJldHVybiAvKiogQHR5cGUgeyFib29sZWFufSAqLyAodGhpcy5kYXRhW2l4XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHZhbHVlIGF0IGdpdmVuIGluZGV4IGFzIGFuIG9iamVjdC4gVXNlZCBmb3IgR0NDIG9ubHkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGl4XHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPYmplY3QoaXgpIHtcclxuICAgIHJldHVybiAvKiogQHR5cGUgeyFPYmplY3R9ICovICh0aGlzLmRhdGFbaXhdKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXRoIHN0YXRlIGhvbGRlciBmb3IgZ3JhcGhpY3MuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQGNhdCBkaXNwbGF5XHJcbiAqL1xyXG5jbGFzcyBHcmFwaGljc1BhdGgge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEdyYXBoaWNzUGF0aFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqIEB0eXBlIHtSZWNibGFjay1lbmdpbmV+dGFuZ2xlfG51bGx9ICovXHJcbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xyXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubWF4TGluZVdpZHRoID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubGFzdExpbmVXaWR0aCA9IDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmxpbmVNdWwgPSAwLjU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSm9pbnQgc3R5bGUgdG8gdXNlIGluIGRyYXdpbmcgbGluZXMuXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgSm9pbnRTdHlsZSA9IHtcclxuICBCRVZFTDogJ2JldmVsJyxcclxuICBNSVRFUjogJ21pdGVyJyxcclxuICBST1VORDogJ3JvdW5kJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgYmFzZSBhYnN0cmFjdCBjbGFzcyBmb3IgZ3JhcGhpY3MgZ3JhZGllbnQgZmlsbC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzR3JhZGllbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEdyYXBoaWNzR3JhZGllbnRcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdH0gKi9cclxuICAgIHRoaXMuc3RvcHMgPSB7fTtcclxuXHJcbiAgICAvKiogQHR5cGUge0NhbnZhc0dyYWRpZW50fG51bGx9ICovXHJcbiAgICB0aGlzLm5hdGl2ZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmV3IHN0b3AsIGRlZmluZWQgYnkgYW4gb2Zmc2V0IGFuZCBhIGNvbG9yLCB0byB0aGUgZ3JhZGllbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIEEgQ1NTIDxjb2xvcj4uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKSB7XHJcbiAgICB0aGlzLnN0b3BzW29mZnNldF0gPSBjb2xvcjtcclxuICAgIHRoaXMubmF0aXZlID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaW5lYXIgZ3JhZGllbnQgZmlsbCBzdHlsZSBmb3IgZ3JhcGhpY3MuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQGNhdCBkaXNwbGF5XHJcbiAqL1xyXG5jbGFzcyBHcmFwaGljc0xpbmVhckdyYWRpZW50IGV4dGVuZHMgR3JhcGhpY3NHcmFkaWVudCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgR3JhcGhpY3NMaW5lYXJHcmFkaWVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgwIFRoZSB4IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5MCBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geDEgVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5MSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeDAsIHkwLCB4MSwgeTEpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLngwID0geDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnkwID0geTA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLngxID0geDE7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLnkxID0geTE7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgdGhpcy5pc0Fic29sdXRlID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGFkZENvbG9yU3RvcChwZXJjZW50LCBjb2xvcikge1xyXG4gICAgdGhpcy5zdG9wc1twZXJjZW50XSA9IGNvbG9yO1xyXG4gICAgdGhpcy5uYXRpdmUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBjb3B5IG9mIHRoaXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0dyYXBoaWNzTGluZWFyR3JhZGllbnR9IE5ldyBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgY29uc3QgZyA9IG5ldyBHcmFwaGljc0xpbmVhckdyYWRpZW50KHRoaXMueDAsIHRoaXMueTAsIHRoaXMueDEsIHRoaXMueTEpO1xyXG4gICAgZy5pc0Fic29sdXRlID0gdGhpcy5pc0Fic29sdXRlO1xyXG5cclxuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnN0b3BzKSB7XHJcbiAgICAgIGcuc3RvcHNba2V5XSA9IHRoaXMuc3RvcHNba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYXBzIHN0eWxlIHRvIHVzZSBpbiBkcmF3aW5nIGxpbmVzLlxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IENhcHNTdHlsZSA9IHtcclxuICBOT05FOiAnbm9uZScsXHJcbiAgUk9VTkQ6ICdyb3VuZCcsXHJcbiAgU1FVQVJFOiAnc3F1YXJlJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN0cnVjdHVyZSBvYmplY3QgZm9yIGdyYXBoaWNzLiBTdG9yZXMgcGFyc2VkIGxheWVyZWQgZGF0YSwgcmVhZHkgZm9yIHJlbmRlci5cclxuICogTm9ybWFsbHkgeW91IHNob3VsZCBub3Qgd29yayB3aXRoIHRoaXMgb2JqZWN0LCBhbmQgdXNlIEdyYXBoaWNzIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKi9cclxuY2xhc3MgR3JhcGhpY3NEYXRhIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBHcmFwaGljc0RhdGFcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5HcmFwaGljc0RhdGE+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTm9kZXMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5HcmFwaGljc0NvbW1hbmQ+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29tbWFuZFF1ZXVlID0gW107XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGl2b3RYID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QaXZvdFkgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvc1ggPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvc1kgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTmFtZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRyaW1tZWQgbG9jYWwgYm91bmRzLlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGljcyBPYmplY3QgdG8gc3RvcmUgYm91bmRzIGJ5IHJlZmVyZW5jZS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NYXRyaXh9IHRyYW5zZm9ybSBNYXRyaXggdG8gdHJhbnNmb3JtIGNoaWxkcmVuIG5vZGVzLCBmb3IgaW50ZXJuYWwgdXNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gQ2FsY3VsYXRlZCBsb2NhbCBib3VuZHMuXHJcbiAgICovXHJcbiAgb25HZXRMb2NhbEJvdW5kcyhncmFwaGljcywgdHJhbnNmb3JtKSB7XHJcbiAgICBsZXQgcGF0aCA9IG5ldyBHcmFwaGljc1BhdGgoKTtcclxuICAgIGxldCBsZW4gPSB0aGlzLm1Db21tYW5kUXVldWUubGVuZ3RoO1xyXG5cclxuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5jbG9uZSgpLmFwcGVuZCh0aGlzLm1UcmFuc2Zvcm0pO1xyXG4gICAgY29uc3QgbSA9IHRyYW5zZm9ybS5kYXRhO1xyXG4gICAgY29uc3Qgc2NhbGVYID0gTWF0aC5zcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xyXG4gICAgY29uc3Qgc2NhbGVZID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgbGV0IGNtZCA9IHRoaXMubUNvbW1hbmRRdWV1ZVtpXTtcclxuXHJcbiAgICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuQkVHSU5fUEFUSDoge1xyXG4gICAgICAgICAgaWYgKHBhdGguYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS50cmFuc2Zvcm1SZWN0KHBhdGguYm91bmRzLCBwYXRoLmJvdW5kcyk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLm1Mb2NhbEJvdW5kcyA9IGdyYXBoaWNzLm1Mb2NhbEJvdW5kcyA/IGdyYXBoaWNzLm1Mb2NhbEJvdW5kcy51bmlvbihwYXRoLmJvdW5kcykgOiBwYXRoLmJvdW5kcztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwYXRoID0gbmV3IEdyYXBoaWNzUGF0aCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5CT1VORFM6IHtcclxuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY21kLmRhdGEubGVuZ3RoOyBrICs9IDIpIHtcclxuICAgICAgICAgICAgcGF0aC5wb2ludHMucHVzaChjbWQuZ2V0TnVtYmVyKGspLCBjbWQuZ2V0TnVtYmVyKGsgKyAxKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5MSU5FX1NUWUxFOiB7XHJcbiAgICAgICAgICBwYXRoLmxhc3RMaW5lV2lkdGggPSBjbWQuZ2V0TnVtYmVyKDApO1xyXG4gICAgICAgICAgbGV0IGpvaW50cyA9IGNtZC5nZXRTdHJpbmcoNCk7XHJcblxyXG4gICAgICAgICAgaWYgKGpvaW50cyA9PT0gSm9pbnRTdHlsZS5NSVRFUilcclxuICAgICAgICAgICAgcGF0aC5saW5lTXVsID0gMTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLkZJTEw6IHtcclxuICAgICAgICAgIGlmIChwYXRoLnBvaW50cy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbGV0IHRtcEJvdW5kcyA9IFJlY3RhbmdsZS5mcm9tUG9pbnRzWFkocGF0aC5wb2ludHMpO1xyXG4gICAgICAgICAgICBwYXRoLmJvdW5kcyA9IHBhdGguYm91bmRzID8gcGF0aC5ib3VuZHMudW5pb24odG1wQm91bmRzKSA6IHRtcEJvdW5kcztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLlNUUk9LRToge1xyXG4gICAgICAgICAgaWYgKHBhdGgubGFzdExpbmVXaWR0aCA+IHBhdGgubWF4TGluZVdpZHRoKVxyXG4gICAgICAgICAgICBwYXRoLm1heExpbmVXaWR0aCA9IHBhdGgubGFzdExpbmVXaWR0aDtcclxuXHJcbiAgICAgICAgICBpZiAocGF0aC5tYXhMaW5lV2lkdGggPT09IDApXHJcbiAgICAgICAgICAgIHBhdGgubWF4TGluZVdpZHRoID0gMTtcclxuXHJcbiAgICAgICAgICBwYXRoLm1heExpbmVXaWR0aCAqPSBwYXRoLmxpbmVNdWw7XHJcblxyXG4gICAgICAgICAgaWYgKHBhdGgucG9pbnRzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBsZXQgdG1wQm91bmRzID0gUmVjdGFuZ2xlLmZyb21Qb2ludHNYWShwYXRoLnBvaW50cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAocGF0aC5wb2ludHMubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgICB0bXBCb3VuZHMuaW5mbGF0ZShwYXRoLm1heExpbmVXaWR0aCAqIHNjYWxlWCwgcGF0aC5tYXhMaW5lV2lkdGggKiBzY2FsZVkpO1xyXG5cclxuICAgICAgICAgICAgcGF0aC5ib3VuZHMgPSBwYXRoLmJvdW5kcyA/IHBhdGguYm91bmRzLnVuaW9uKHRtcEJvdW5kcykgOiB0bXBCb3VuZHM7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF0aC5ib3VuZHMpIHtcclxuICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVJlY3QocGF0aC5ib3VuZHMsIHBhdGguYm91bmRzKTtcclxuICAgICAgZ3JhcGhpY3MubUxvY2FsQm91bmRzID0gZ3JhcGhpY3MubUxvY2FsQm91bmRzID8gZ3JhcGhpY3MubUxvY2FsQm91bmRzLnVuaW9uKHBhdGguYm91bmRzKSA6IHBhdGguYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5tTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHRoaXMubU5vZGVzW2ldLm9uR2V0TG9jYWxCb3VuZHMoZ3JhcGhpY3MsIHRyYW5zZm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdyYXBoaWNzLm1Mb2NhbEJvdW5kcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbGluZSBzdHlsZS4gWmVybyBvciBsZXNzIHZhbHVlcyBvZiBgbGluZVdpZHRoYCBhcmUgaWdub3JlZC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGluZVdpZHRoIExpbmUgd2lkdGguXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbY29sb3I9MF0gTGluZSBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFthbHBoYT0xXSBMaW5lIGFscGhhLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNhcHNTdHlsZT19IFtjYXBzPUNhcHNTdHlsZS5OT05FXSBMaW5lIGNhcHMgc3R5bGUuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Sm9pbnRTdHlsZT19IFtqb2ludHM9Sm9pbnRTdHlsZS5NSVRFUl0gTGluZSBqb2ludHMgc3R5bGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbbWl0ZXJMaW1pdD0zXSBNaXRlciBsaW1pdC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBsaW5lU3R5bGUobGluZVdpZHRoID0gMCwgY29sb3IgPSAwLCBhbHBoYSA9IDEsIGNhcHMgPSBDYXBzU3R5bGUuTk9ORSwgam9pbnRzID0gSm9pbnRTdHlsZS5NSVRFUiwgbWl0ZXJMaW1pdCA9IDMpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhLCBtaXRlckxpbWl0KTtcclxuICAgIGlmIChsaW5lV2lkdGggPD0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkxJTkVfU1RZTEUsIGxpbmVXaWR0aCwgY29sb3IsIGFscGhhLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzaGFkb3cgYmx1ciBsZXZlbC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2hhZG93Qmx1cihsZXZlbCkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIobGV2ZWwpO1xyXG5cclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLlNIQURPV19CTFVSLCBsZXZlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHNoYWRvdyBjb2xvci5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIFxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNoYWRvd0NvbG9yKGNvbG9yLCBhbHBoYSkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoY29sb3IsIGFscGhhKTtcclxuXHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5TSEFET1dfQ09MT1IsIGNvbG9yLCBhbHBoYSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFNldHMgZmlsbCBzdHlsZVxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gRmlsbCBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFthbHBoYT0xXSBGaWxsIGFscGhhLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGxTdHlsZShjb2xvciA9IDAsIGFscGhhID0gMSkge1xyXG4gICAgRGVidWcuaXNOdW1iZXIoY29sb3IsIGFscGhhKTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkZJTExfU1RZTEUsIGNvbG9yLCBhbHBoYSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGZpbGwgc3R5bGUgdG8gZ3JhZGllbnQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NHcmFkaWVudH0gZ3JhZGllbnQgRmlsbCBncmFkaWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGxHcmFkaWVudChncmFkaWVudCkge1xyXG4gICAgaWYgKGdyYWRpZW50IGluc3RhbmNlb2YgR3JhcGhpY3NMaW5lYXJHcmFkaWVudCkge1xyXG4gICAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5GSUxMX0dSRCwgLyoqIEB0eXBlIHtHcmFwaGljc0xpbmVhckdyYWRpZW50fSAqLyhncmFkaWVudCkpO1xyXG4gICAgfSAvLyByYWRpYWwgdG9kb1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBmaWxsIHN0eWxlIHRvIHBhdHRlcm4uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NQYXR0ZXJufSBwYXR0ZXJuIEZpbGwgcGF0dGVybi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGxQYXR0ZXJuKHBhdHRlcm4pIHtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkZJTExfUEFUVEVSTiwgcGF0dGVybik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGVzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5tUG9zWCA9IDA7XHJcbiAgICB0aGlzLm1Qb3NZID0gMDtcclxuXHJcbiAgICB0aGlzLm1Db21tYW5kUXVldWUgPSBbXTtcclxuICAgIHRoaXMubU5vZGVzID0gW107XHJcblxyXG4gICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIHBhdGggdG8gZ2l2ZW4geCBhbmQgeSBjb29yZGluYXRlcy5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeC1heGlzIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeS1heGlzIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBtb3ZlVG8oeCwgeSkge1xyXG4gICAgdGhpcy5tUG9zWCA9IHg7XHJcbiAgICB0aGlzLm1Qb3NZID0geTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLk1PVkVfVE8sIHgsIHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhd3MgYSBsaW5lIGJldHdlZW4gbGFzdCBwb2ludCBhbmQgZ2l2ZW4uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHgtYXhpcyBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHktYXhpcyBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgbGluZVRvKHgsIHkpIHtcclxuICAgIHRoaXMubVBvc1ggPSB4O1xyXG4gICAgdGhpcy5tUG9zWSA9IHk7XHJcblxyXG4gICAgdGhpcy5fX3B1c2hDb21tYW5kKEdyYXBoaWNzQ29tbWFuZFR5cGUuTElORV9UTywgeCwgeSk7XHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5CT1VORFMsIHRoaXMubVBvc1gsIHRoaXMubVBvc1ksIHgsIHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBhcmMgdG8gdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgICAgICAgICBUaGUgeC1heGlzIG9mIHRoZSBhcmMncyBjZW50ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgICAgICAgICAgICAgVGhlIHktYXhpcyBvZiB0aGUgYXJjJ3MgY2VudGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgICAgICAgIFRoZSByYWRpdXMgb2YgdGhlIGFyYy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSAgICBUaGUgc3RhcnRpbmcgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGUgICAgICBUaGUgZW5kaW5nIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gW2FudGljbG9ja3dpc2U9ZmFsc2VdIElmIHRydWUgdGhlIGFyYyB3aWxsIGJlIGRyYXduIGNvdW50ZXItY2xvY2t3aXNlLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcclxuICAgIGxldCBuZWVkc01vdmVUbyA9IGZhbHNlO1xyXG4gICAgbGV0IG1vdmVUb1ggPSAwO1xyXG4gICAgbGV0IG1vdmVUb1kgPSAwO1xyXG4gICAgbGV0IHBvaW50cyA9IFtdO1xyXG4gICAgbGV0IGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xyXG5cclxuICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmIChkaWZmID49IE1hdGhFeC5QSTIpIHtcclxuICAgICAgcG9pbnRzLnB1c2goeCAtIHJhZGl1cywgeSAtIHJhZGl1cywgeCArIHJhZGl1cywgeSArIHJhZGl1cyk7XHJcblxyXG4gICAgICBsZXQgZW5kID0gQ2lyY2xlLmdldENpcmN1bWZlcmVuY2VQb2ludCh4LCB5LCByYWRpdXMsIGVuZEFuZ2xlICsgTWF0aC5QSSAqIDAuNSk7XHJcblxyXG4gICAgICBuZWVkc01vdmVUbyA9IHRydWU7XHJcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIE1hdGhFeC5QSTI7XHJcbiAgICAgIG1vdmVUb1ggPSBlbmQueDtcclxuICAgICAgbW92ZVRvWSA9IGVuZC55O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRBbmdsZSAlIE1hdGhFeC5QSTIgKyAoc3RhcnRBbmdsZSA8IDAgPyBNYXRoRXguUEkyIDogMCk7XHJcbiAgICAgIGxldCBlbmQgPSBlbmRBbmdsZTtcclxuXHJcbiAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XHJcbiAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgc3RhcnQgPSBlbmRBbmdsZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2hpbGUgKGVuZCA8IHN0YXJ0KVxyXG4gICAgICAgIGVuZCArPSBNYXRoRXguUEkyO1xyXG5cclxuICAgICAgY29uc3QgcmlnaHQgPSBzdGFydCA9PT0gMCB8fCBlbmQgPj0gTWF0aEV4LlBJMjtcclxuICAgICAgY29uc3QgbGVmdCA9IHN0YXJ0IDw9IE1hdGguUEkgJiYgZW5kID49IE1hdGguUEkgfHwgZW5kID49IE1hdGguUEkgKiAzO1xyXG4gICAgICBjb25zdCBib3R0b20gPSBzdGFydCA8PSBNYXRoLlBJICogMC41ICYmIGVuZCA+PSBNYXRoLlBJICogMC41IHx8IGVuZCA+PSBNYXRoLlBJICogMi41O1xyXG4gICAgICBjb25zdCB0b3AgPSBzdGFydCA8PSBNYXRoLlBJICogMS41ICYmIGVuZCA+PSBNYXRoLlBJICogMS41IHx8IGVuZCA+PSBNYXRoLlBJICogMy41O1xyXG5cclxuICAgICAgbGV0IHN0YXJ0Q29zLCBlbmRDb3MsIHN0YXJ0U2luLCBlbmRTaW47XHJcblxyXG4gICAgICBpZiAoIWxlZnQgfHwgIXJpZ2h0KSB7XHJcbiAgICAgICAgc3RhcnRDb3MgPSBNYXRoLmNvcyhzdGFydCkgKiByYWRpdXM7XHJcbiAgICAgICAgZW5kQ29zID0gTWF0aC5jb3MoZW5kKSAqIHJhZGl1cztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0b3AgfHwgIWJvdHRvbSkge1xyXG4gICAgICAgIHN0YXJ0U2luID0gTWF0aC5zaW4oc3RhcnQpICogcmFkaXVzO1xyXG4gICAgICAgIGVuZFNpbiA9IE1hdGguc2luKGVuZCkgKiByYWRpdXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG1pblggPSBsZWZ0ID8gLXJhZGl1cyA6IE1hdGgubWluKHN0YXJ0Q29zLCBlbmRDb3MpO1xyXG4gICAgICBjb25zdCBtYXhYID0gcmlnaHQgPyByYWRpdXMgOiBNYXRoLm1heChzdGFydENvcywgZW5kQ29zKTtcclxuICAgICAgY29uc3QgbWluWSA9IHRvcCA/IC1yYWRpdXMgOiBNYXRoLm1pbihzdGFydFNpbiwgZW5kU2luKTtcclxuICAgICAgY29uc3QgbWF4WSA9IGJvdHRvbSA/IHJhZGl1cyA6IE1hdGgubWF4KHN0YXJ0U2luLCBlbmRTaW4pO1xyXG5cclxuICAgICAgcG9pbnRzLnB1c2gobWluWCArIHgsIG1pblkgKyB5LCBtYXhYICsgeCwgbWF4WSArIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkFSQywgeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5CT1VORFMsIC4uLnBvaW50cyk7XHJcblxyXG4gICAgaWYgKG5lZWRzTW92ZVRvID09PSB0cnVlKVxyXG4gICAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5NT1ZFX1RPLCBtb3ZlVG9YLCBtb3ZlVG9ZKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgY2lyY2xlIHRvIGN1cnJlbnQgcGF0aC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgICAgIFRoZSB4LWF4aXMgb2YgdGhlIGNpcmNsZSdzIGNlbnRlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAgICAgIFRoZSB5LWF4aXMgb2YgdGhlIGNpcmNsZSdzIGNlbnRlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBjaXJjbGUoeCwgeSwgcmFkaXVzKSB7XHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5BUkMsIHgsIHksIHJhZGl1cywgMCwgTWF0aEV4LlBJMik7XHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5CT1VORFMsIHggLSByYWRpdXMsIHkgLSByYWRpdXMsIHggKyByYWRpdXMsIHkgKyByYWRpdXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBjbG9zZWQgcmVjdGFuZ2xlIGxpa2UgcGF0aC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgcmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5SRUNULCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkJPVU5EUywgeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgY2xvc2VkIHJvdW5kZWQgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgcm91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xyXG5cclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLlJPVU5ERURfUkVDVCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkJPVU5EUywgeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3AxeFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjcDF5XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNwMnhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3AyeVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKi9cclxuICBiZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcclxuICAgIGNvbnN0IHJhbmdlWCA9IHRoaXMuX19iZXppZXJSYW5nZSh0aGlzLm1Qb3NYLCBjcDF4LCBjcDJ4LCB4LCBWZWN0b3IucG9vbC5nZXQoKSk7XHJcbiAgICBjb25zdCByYW5nZVkgPSB0aGlzLl9fYmV6aWVyUmFuZ2UodGhpcy5tUG9zWSwgY3AxeSwgY3AyeSwgeSwgVmVjdG9yLnBvb2wuZ2V0KCkpO1xyXG5cclxuICAgIHRoaXMubVBvc1ggPSB4O1xyXG4gICAgdGhpcy5tUG9zWSA9IHk7XHJcblxyXG4gICAgdGhpcy5fX3B1c2hDb21tYW5kKEdyYXBoaWNzQ29tbWFuZFR5cGUuQkVaSUVSX0NVUlZFX1RPLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkJPVU5EUywgcmFuZ2VYLngsIHJhbmdlWS54LCByYW5nZVgueSwgcmFuZ2VZLnkpO1xyXG5cclxuICAgIFZlY3Rvci5wb29sLnJlbGVhc2UocmFuZ2VYKTtcclxuICAgIFZlY3Rvci5wb29sLnJlbGVhc2UocmFuZ2VZKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3B4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNweVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKi9cclxuICBxdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5KSB7XHJcbiAgICBjb25zdCByYW5nZVggPSB0aGlzLl9fcXVhZHJhdGljUmFuZ2UodGhpcy5tUG9zWCwgY3B4LCB4LCBWZWN0b3IucG9vbC5nZXQoKSk7XHJcbiAgICBjb25zdCByYW5nZVkgPSB0aGlzLl9fcXVhZHJhdGljUmFuZ2UodGhpcy5tUG9zWSwgY3B5LCB5LCBWZWN0b3IucG9vbC5nZXQoKSk7XHJcblxyXG4gICAgdGhpcy5tUG9zWCA9IHg7XHJcbiAgICB0aGlzLm1Qb3NZID0geTtcclxuXHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5RVUFEUkFUSUNfQ1VSVkVfVE8sIGNweCwgY3B5LCB4LCB5KTtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkJPVU5EUywgcmFuZ2VYLngsIHJhbmdlWS54LCByYW5nZVgueSwgcmFuZ2VZLnkpO1xyXG5cclxuICAgIFZlY3Rvci5wb29sLnJlbGVhc2UocmFuZ2VYKTtcclxuICAgIFZlY3Rvci5wb29sLnJlbGVhc2UocmFuZ2VZKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAwXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAxXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAyXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAzXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmVjdG9yPX0gb3V0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBPdXQgdmVjdG9yIHdpdGggc2V0IHgsIHkgYXMgbWluIGFuZCBtYXggYmV6aWVyIGNvb3JkaW5hdGUgb24gcGFzc2VkIGF4aXNcclxuICAgKi9cclxuICBfX2JlemllclJhbmdlKHAwLCBwMSwgcDIsIHAzLCBvdXQpIHtcclxuICAgIG91dCA9IG91dCB8fCBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgY29uc3QgYSA9IChwMiAtIDIgKiBwMSArIHAwKSAtIChwMyAtIDIgKiBwMiArIHAxKTtcclxuICAgIGNvbnN0IGIgPSAyICogKHAxIC0gcDApIC0gMiAqIChwMiAtIHAxKTtcclxuICAgIGNvbnN0IGMgPSBwMCAtIHAxO1xyXG4gICAgY29uc3QgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XHJcblxyXG4gICAgbGV0IG1pbiA9IE1hdGgubWluKHAwLCBwMyk7XHJcbiAgICBsZXQgbWF4ID0gTWF0aC5tYXgocDAsIHAzKTtcclxuXHJcbiAgICBpZiAoZGlzY3JpbWluYW50ID49IDApIHtcclxuICAgICAgY29uc3QgZGlzY1Jvb3QgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcclxuICAgICAgY29uc3QgaW52MmEgPSAxIC8gKGEgKiAyKTtcclxuICAgICAgbGV0IHgxID0gKC1iICsgZGlzY1Jvb3QpICogaW52MmE7XHJcbiAgICAgIGxldCB4MiA9ICgtYiAtIGRpc2NSb290KSAqIGludjJhO1xyXG4gICAgICB4MSA9IGlzRmluaXRlKHgxKSA/IHgxIDogMC41O1xyXG4gICAgICB4MiA9IGlzRmluaXRlKHgyKSA/IHgyIDogMC41O1xyXG5cclxuICAgICAgaWYgKHgxID4gMCAmJiB4MSA8IDEpIHtcclxuICAgICAgICBjb25zdCBkb3QgPSB0aGlzLl9fYmV6aWVyRG90KHAwLCBwMSwgcDIsIHAzLCB4MSk7XHJcbiAgICAgICAgbWluID0gTWF0aC5taW4oZG90LCBtaW4pO1xyXG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRvdCwgbWF4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHgyID4gMCAmJiB4MiA8IDEpIHtcclxuICAgICAgICBjb25zdCBkb3QgPSB0aGlzLl9fYmV6aWVyRG90KHAwLCBwMSwgcDIsIHAzLCB4Mik7XHJcbiAgICAgICAgbWluID0gTWF0aC5taW4oZG90LCBtaW4pO1xyXG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRvdCwgbWF4KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG91dC54ID0gbWluO1xyXG4gICAgb3V0LnkgPSBtYXg7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAwXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAxXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAyXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHAzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBfX2JlemllckRvdChwMCwgcDEsIHAyLCBwMywgeCkge1xyXG4gICAgY29uc3QgeSA9IDEgLSB4O1xyXG4gICAgcmV0dXJuIHAwICogeSAqIHkgKiB5ICsgMyAqIHAxICogeCAqIHkgKiB5ICsgMyAqIHAyICogeCAqIHggKiB5ICsgcDMgKiB4ICogeCAqIHg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwMFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwMVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwMlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZlY3Rvcj19IG91dFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gT3V0IHZlY3RvciB3aXRoIHNldCB4LCB5IGFzIG1pbiBhbmQgbWF4IGJlemllciBjb29yZGluYXRlIG9uIHBhc3NlZCBheGlzXHJcbiAgICovXHJcbiAgX19xdWFkcmF0aWNSYW5nZShwMCwgcDEsIHAyLCBvdXQpIHtcclxuICAgIGNvbnN0IGEgPSBwMiAtIHAwO1xyXG4gICAgY29uc3QgYiA9IHAxIC0gcDA7XHJcbiAgICBjb25zdCBjID0gYiAvIGE7XHJcbiAgICBjb25zdCBkID0gcDAgKyAoYyA8IDAgfHwgYyA+IDEgPyBiICogYiAvICgyICogYiAtIGEpIDogMCk7XHJcblxyXG4gICAgb3V0LnggPSBNYXRoLm1pbihwMCwgcDIsIGQpO1xyXG4gICAgb3V0LnkgPSBNYXRoLm1heChwMCwgcDIsIGQpO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgbmV3IHBhdGguXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgYmVnaW5QYXRoKCkge1xyXG4gICAgdGhpcy5fX3B1c2hDb21tYW5kKEdyYXBoaWNzQ29tbWFuZFR5cGUuQkVHSU5fUEFUSCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbG9zZXMgY3VycmVudCBwYXRoLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNsb3NlUGF0aCgpIHtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLkNMT1NFX1BBVEgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbGluZSBkYXNoIHBhdHRlcm4gdXNlZCB3aGVuIHN0cm9raW5nIGxpbmVzLFxyXG4gICAqIHVzaW5nIGFuIGFycmF5IG9mIHZhbHVlcyB3aGljaCBzcGVjaWZ5IGFsdGVybmF0aW5nIGxlbmd0aHMgb2YgbGluZXMgYW5kIGdhcHMgd2hpY2ggZGVzY3JpYmUgdGhlIHBhdHRlcm4uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzZWdtZW50cyBBbiBBcnJheSBvZiBudW1iZXJzIHdoaWNoIHNwZWNpZnkgZGlzdGFuY2VzIHRvIGFsdGVybmF0ZWx5IGRyYXcgYSBsaW5lIGFuZCBhIGdhcCAoaW4gY29vcmRpbmF0ZSBzcGFjZSB1bml0cykuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXRMaW5lRGFzaChzZWdtZW50cykge1xyXG4gICAgdGhpcy5fX3B1c2hDb21tYW5kKEdyYXBoaWNzQ29tbWFuZFR5cGUuTElORV9EQVNILCBzZWdtZW50cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdHJva2VzIGN1cnJlbnQgcGF0aCB3aXRoIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUuLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHN0cm9rZSgpIHtcclxuICAgIHRoaXMuX19wdXNoQ29tbWFuZChHcmFwaGljc0NvbW1hbmRUeXBlLlNUUk9LRSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaWxscyBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBmaWxsIHN0eWxlLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb25aZXJvIFRoZSBhbGdvcml0aG0gYnkgd2hpY2ggdG8gZGV0ZXJtaW5lIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcGF0aCBvciBvdXRzaWRlIGEgcGF0aCwgVHJ1ZSBpcyBmb3IgXCJub256ZXJvXCIgYW5kIEZhbHNlIGlzIGZvciBcImV2ZW5vZGRcIi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGwoaXNOb25aZXJvKSB7XHJcbiAgICB0aGlzLl9fcHVzaENvbW1hbmQoR3JhcGhpY3NDb21tYW5kVHlwZS5GSUxMLCBpc05vblplcm8pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NDb21tYW5kVHlwZX0gdHlwZVxyXG4gICAqIEBwYXJhbSB7Li4uKn0gZGF0YVxyXG4gICAqL1xyXG4gIF9fcHVzaENvbW1hbmQodHlwZSwgLi4uZGF0YSkge1xyXG4gICAgbGV0IGNtZCA9IG5ldyBHcmFwaGljc0NvbW1hbmQodHlwZSwgZGF0YSk7XHJcbiAgICB0aGlzLm1Db21tYW5kUXVldWUucHVzaChjbWQpO1xyXG4gIH1cclxuXHJcbiAgc2VhcmNoTm9kZShuYW1lLCBwYXJlbnQgPSB0aGlzKSB7XHJcbiAgICBpZiAocGFyZW50Lm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhcmVudC5tTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnNlYXJjaE5vZGUobmFtZSwgcGFyZW50Lm1Ob2Rlc1tpXSk7XHJcblxyXG4gICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIG5hbWUgb2YgdGhpcyBHcmFwaGljc0RhdGEgaW5zdGFuY2UuIFVzZWQgZm9yIHNlYXJjaGluZyBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxyXG4gICAqL1xyXG4gIGdldCBuYW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubU5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IG5hbWUodmFsdWUpIHtcclxuICAgIHRoaXMubU5hbWUgPSB2YWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFBhcnNlckJhc2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqIFxyXG4gICAgICogSW5wdXQgZGF0YSB0byBwYXJzZVxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgZGF0YVxyXG4gICAqL1xyXG4gIHBhcnNlKGRhdGEpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBwYXR0ZXJuIGZpbGwgc3R5bGUgY2xhc3MgZm9yIEdyYXBoaWNzLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKi9cclxuY2xhc3MgR3JhcGhpY3NQYXR0ZXJuIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBHcmFwaGljc1BhdHRlcm5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihpbWFnZSwgcmVwZXRpdGlvbikge1xyXG5cclxuICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gKi9cclxuICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuXHJcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cclxuICAgIHRoaXMucmVwZXRpdGlvbiA9IHJlcGV0aXRpb247XHJcblxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNQYXR0ZXJufG51bGx9ICovXHJcbiAgICB0aGlzLm5hdGl2ZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGNvcHkgb2YgdGhpc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdyYXBoaWNzUGF0dGVybn0gTmV3IGluc3RhbmNlXHJcbiAgICovXHJcbiAgY2xvbmUoKSB7XHJcbiAgICByZXR1cm4gbmV3IEdyYXBoaWNzUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGV0aXRpb24pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbGwgUnVsZSBzdHlsZSB0byB1c2Ugb24gc2hhcGVzIGZpbGwuXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgRmlsbFJ1bGUgPSB7XHJcbiAgTk9ORV9aRVJPOiAnbm9uemVybycsXHJcbiAgRVZFTl9PREQgOiAnZXZlbm9kZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogQmxhY2sgVmVjdG9yIEdyYXBoaWNzIHN0eWxlXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgQlZHIHN0eWxlIHBhcnNlXHJcbiAqXHJcbiAqIEBjYXQgcGFyc2Vyc1xyXG4gKi9cclxuY2xhc3MgQlZHU3R5bGUge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEJWR1N0eWxlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Ryb2tlIGNvbG9yXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgdGhpcy5MID0gJy0nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3Ryb2tlIGFscGhhLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMubCA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lIHdpZHRoLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cclxuICAgIHRoaXMudyA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxsIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30qL1xyXG4gICAgdGhpcy5GID0gJzAnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbCBhbHBoYS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmYgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbCBydWxlLlxyXG4gICAgICoge25vbnplcm86IDEsIGV2ZW5vZGQ6IDB9XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5yID0gMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmUgY2FwLlxyXG4gICAgICoge2J1dHQ6ICdiJywgcm91bmQ6ICdyJywgc3F1YXJlOiAncyd9XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgdGhpcy5jID0gJ2InO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGluZSBqb2luLlxyXG4gICAgICoge21pdGVyOiAnbScsIHJvdW5kOiAncicsIGJldmVsOiAnYid9XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSAqL1xyXG4gICAgdGhpcy5qID0gJ20nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWl0ZXIgbGltaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gICAgdGhpcy5tID0gNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdsb2JhbCBhbHBoYS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICB0aGlzLmEgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGluZSBkYXNoLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gKi9cclxuICAgIHRoaXMuZCA9ICcnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbCBuZWNlc3NpdHkgZmxhZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm5lZWRzRmlsbCA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJva2UgbmVjZXNzaXR5IGZsYWcuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5uZWVkc1N0cm9rZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsQ29sb3IgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lQ29sb3IgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lQWxwaGEgPSAxO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkNhcHNTdHlsZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZUNhcCA9IENhcHNTdHlsZS5OT05FO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkpvaW50U3R5bGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxpbmVKb2luID0gSm9pbnRTdHlsZS5NSVRFUjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWl0ZXJMaW1pdCA9IHRoaXMubTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5GaWxsUnVsZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmlsbFJ1bGUgPSBGaWxsUnVsZS5OT05FX1pFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lIGRhc2ggc2VnbWVudHMgbGVuZ3RoLCB1bml0LlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZURhc2ggPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1lcmdlIHBhcmVudCBzdHlsZSB0byB0aGlzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkJWR1N0eWxlfSBzdHlsZSBQYXJlbnQgc3R5bGVcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIG1lcmdlKHN0eWxlKSB7XHJcbiAgICBpZiAoc3R5bGUuRilcclxuICAgICAgdGhpcy5GID0gc3R5bGUuRjtcclxuXHJcbiAgICBpZiAoc3R5bGUuTClcclxuICAgICAgdGhpcy5MID0gc3R5bGUuTDtcclxuXHJcbiAgICBpZiAoc3R5bGUudylcclxuICAgICAgdGhpcy53ID0gc3R5bGUudztcclxuXHJcbiAgICBpZiAoc3R5bGUubClcclxuICAgICAgdGhpcy5sICo9IHN0eWxlLmw7XHJcblxyXG4gICAgaWYgKHN0eWxlLmYpXHJcbiAgICAgIHRoaXMuZiAqPSBzdHlsZS5mO1xyXG5cclxuICAgIGlmIChzdHlsZS5yKVxyXG4gICAgICB0aGlzLnIgPSBzdHlsZS5yO1xyXG5cclxuICAgIGlmIChzdHlsZS5jKVxyXG4gICAgICB0aGlzLmMgPSBzdHlsZS5jO1xyXG5cclxuICAgIGlmIChzdHlsZS5qKVxyXG4gICAgICB0aGlzLmogPSBzdHlsZS5qO1xyXG5cclxuICAgIGlmIChzdHlsZS5tKVxyXG4gICAgICB0aGlzLm0gPSBzdHlsZS5tO1xyXG5cclxuICAgIGlmIChzdHlsZS5hKVxyXG4gICAgICB0aGlzLmEgPSBzdHlsZS5hO1xyXG5cclxuICAgIGlmIChzdHlsZS5kKVxyXG4gICAgICB0aGlzLmQgPSBzdHlsZS5kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHJlYWRhYmxlIHByb3BlcnRpZXMgdG8gdXNlIHRoaXMgc3R5bGUuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBjb21wdXRlKCkge1xyXG4gICAgdGhpcy5uZWVkc0ZpbGwgPSB0aGlzLkYgIT09ICctJztcclxuXHJcbiAgICBpZiAodGhpcy5uZWVkc0ZpbGwpXHJcbiAgICAgIHRoaXMuZmlsbENvbG9yID0gcGFyc2VJbnQodGhpcy5GLCAxNik7XHJcblxyXG4gICAgdGhpcy5saW5lV2lkdGggPSArdGhpcy53O1xyXG4gICAgdGhpcy5uZWVkc1N0cm9rZSA9IHRoaXMuTCAhPT0gJy0nICYmIHRoaXMubGluZVdpZHRoID4gMDtcclxuXHJcbiAgICBpZiAodGhpcy5uZWVkc1N0cm9rZSlcclxuICAgICAgdGhpcy5saW5lQ29sb3IgPSBwYXJzZUludCh0aGlzLkwsIDE2KTtcclxuXHJcbiAgICBjb25zdCBhbHBoYSA9IE51bWJlcih0aGlzLmEpO1xyXG4gICAgdGhpcy5saW5lQWxwaGEgPSBOdW1iZXIodGhpcy5sKSAqIGFscGhhO1xyXG4gICAgdGhpcy5maWxsQWxwaGEgPSBOdW1iZXIodGhpcy5mKSAqIGFscGhhO1xyXG5cclxuICAgIHRoaXMubGluZUNhcCA9IHsgYjogQ2Fwc1N0eWxlLk5PTkUsIHI6IENhcHNTdHlsZS5ST1VORCwgczogQ2Fwc1N0eWxlLlNRVUFSRSB9W3RoaXMuY107XHJcbiAgICB0aGlzLmxpbmVKb2luID0geyBtOiBKb2ludFN0eWxlLk1JVEVSLCByOiBKb2ludFN0eWxlLlJPVU5ELCBiOiBKb2ludFN0eWxlLkJFVkVMIH1bdGhpcy5qXTtcclxuICAgIHRoaXMubWl0ZXJMaW1pdCA9IE51bWJlcih0aGlzLm0pO1xyXG4gICAgdGhpcy5maWxsUnVsZSA9IHsgMTogRmlsbFJ1bGUuTk9ORV9aRVJPLCAwOiBGaWxsUnVsZS5FVkVOX09ERCB9W3RoaXMucl07XHJcbiAgICB0aGlzLmxpbmVEYXNoID0gdGhpcy5kLnNwbGl0KCcsJykubWFwKHYgPT4gTnVtYmVyKHYpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBjb3B5IG9mIHRoaXMgc3R5bGUuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkJWR1N0eWxlfSBDcmVhdGVkIHN0eWxlLlxyXG4gICAqL1xyXG4gIGNsb25lKCkge1xyXG4gICAgbGV0IHMgPSBuZXcgQlZHU3R5bGUoKTtcclxuICAgIHMuTCA9IHRoaXMuTDtcclxuICAgIHMubCA9IHRoaXMubDtcclxuICAgIHMudyA9IHRoaXMudztcclxuICAgIHMuRiA9IHRoaXMuRjtcclxuICAgIHMuZiA9IHRoaXMuZjtcclxuICAgIHMuciA9IHRoaXMucjtcclxuICAgIHMuYyA9IHRoaXMuYztcclxuICAgIHMuaiA9IHRoaXMuajtcclxuICAgIHMubSA9IHRoaXMubTtcclxuICAgIHMuYSA9IHRoaXMuYTtcclxuXHJcbiAgICByZXR1cm4gcztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGJhc2ljIHV0aWxpdHkgY2xhc3MgZm9yIGRyYXdpbmcgc2hhcGVzLlxyXG4gKlxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkRpc3BsYXlPYmplY3RcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgR3JhcGhpY3MgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HcmFwaGljc0RhdGF8c3RyaW5nfG51bGx9IGdyYXBoaWNzRGF0YSBUaGUgaWQgb2YgQlZHIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaW0gRmxhZyB0byBkZXRlcm1pbmUgdGhlIHBhc3NlZCBncmFwaGljc0RhdGEgbmVlZHMgdHJpbS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihncmFwaGljc0RhdGEgPSBudWxsLCB0cmltID0gZmFsc2UpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQm91bmRzID0gbmV3IFJlY3RhbmdsZSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGludGVybmFsIHVzYWdlXHJcbiAgICAgKlxyXG4gICAgICogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvY2FsQm91bmRzID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HcmFwaGljc0RhdGF8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUdyYXBoaWNzRGF0YSA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EYXRhT2Zmc2V0WCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EYXRhT2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVHJpbSA9IHRyaW07XHJcblxyXG4gICAgaWYgKGdyYXBoaWNzRGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICB0aGlzLm1HcmFwaGljc0RhdGEgPSBuZXcgR3JhcGhpY3NEYXRhKCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBncmFwaGljc0RhdGEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXMubUdyYXBoaWNzRGF0YSA9IEJsYWNrLmFzc2V0cy5nZXRHcmFwaGljc0RhdGEoZ3JhcGhpY3NEYXRhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubUdyYXBoaWNzRGF0YSA9IGdyYXBoaWNzRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHJpbSkge1xyXG4gICAgICB0aGlzLm1HcmFwaGljc0RhdGEub25HZXRMb2NhbEJvdW5kcyh0aGlzLCBuZXcgTWF0cml4KCkpO1xyXG5cclxuICAgICAgaWYgKHRoaXMubUxvY2FsQm91bmRzKSB7XHJcbiAgICAgICAgdGhpcy5tRGF0YU9mZnNldFggPSB0aGlzLm1Mb2NhbEJvdW5kcy54O1xyXG4gICAgICAgIHRoaXMubURhdGFPZmZzZXRZID0gdGhpcy5tTG9jYWxCb3VuZHMueTtcclxuICAgICAgICB0aGlzLm1Mb2NhbEJvdW5kcyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgZ2V0UmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gQmxhY2suZHJpdmVyLmdldFJlbmRlcmVyKCdHcmFwaGljcycsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkdldExvY2FsQm91bmRzKG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ2xpcFJlY3QgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5tQ2xpcFJlY3QuY29weVRvKG91dFJlY3QpO1xyXG4gICAgICByZXR1cm4gb3V0UmVjdDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEub25HZXRMb2NhbEJvdW5kcyh0aGlzLCBuZXcgTWF0cml4KCkpO1xyXG5cclxuICAgIHRoaXMubUxvY2FsQm91bmRzICYmIG91dFJlY3QuY29weUZyb20odGhpcy5tTG9jYWxCb3VuZHMpO1xyXG4gICAgdGhpcy5tTG9jYWxCb3VuZHMgPSBudWxsO1xyXG5cclxuICAgIGlmICghdGhpcy5tVHJpbSkge1xyXG4gICAgICBvdXRSZWN0LndpZHRoICs9IE1hdGgubWF4KDAsIG91dFJlY3QueCk7XHJcbiAgICAgIG91dFJlY3QuaGVpZ2h0ICs9IE1hdGgubWF4KDAsIG91dFJlY3QueSk7XHJcbiAgICAgIG91dFJlY3QueCA9IE1hdGgubWluKDAsIG91dFJlY3QueCk7XHJcbiAgICAgIG91dFJlY3QueSA9IE1hdGgubWluKDAsIG91dFJlY3QueSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dFJlY3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGxpbmUgc3R5bGUuIFplcm8gb3IgbGVzcyB2YWx1ZXMgb2YgYGxpbmVXaWR0aGAgYXJlIGlnbm9yZWQuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBMaW5lIHdpZHRoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW2NvbG9yPTBdIExpbmUgY29sb3IuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbYWxwaGE9MV0gTGluZSBhbHBoYS5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5DYXBzU3R5bGU9fSBbY2Fwcz1DYXBzU3R5bGUuTk9ORV0gTGluZSBjYXBzIHN0eWxlLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkpvaW50U3R5bGU9fSBbam9pbnRzPUpvaW50U3R5bGUuTUlURVJdIExpbmUgam9pbnRzIHN0eWxlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW21pdGVyTGltaXQ9M10gTWl0ZXIgbGltaXQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgbGluZVN0eWxlKGxpbmVXaWR0aCA9IDAsIGNvbG9yID0gMCwgYWxwaGEgPSAxLCBjYXBzID0gQ2Fwc1N0eWxlLk5PTkUsIGpvaW50cyA9IEpvaW50U3R5bGUuTUlURVIsIG1pdGVyTGltaXQgPSAzKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEubGluZVN0eWxlKGxpbmVXaWR0aCwgY29sb3IsIGFscGhhLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzaGFkb3cgYmx1ciBsZXZlbC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2hhZG93Qmx1cihsZXZlbCkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLnNoYWRvd0JsdXIobGV2ZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBzaGFkb3cgY29sb3IuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSBcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzaGFkb3dDb2xvcihjb2xvciwgYWxwaGEgPSAxKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuc2hhZG93Q29sb3IoY29sb3IsIGFscGhhKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgZmlsbCBzdHlsZVxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gRmlsbCBjb2xvci5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFthbHBoYT0xXSBGaWxsIGFscGhhLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGxTdHlsZShjb2xvciA9IDAsIGFscGhhID0gMSkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLmZpbGxTdHlsZShjb2xvciwgYWxwaGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBmaWxsIHN0eWxlIHRvIGdyYWRpZW50LlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdyYXBoaWNzR3JhZGllbnR9IGdyYWRpZW50IEZpbGwgZ3JhZGllbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBmaWxsR3JhZGllbnQoZ3JhZGllbnQpIHtcclxuICAgIHRoaXMubUdyYXBoaWNzRGF0YS5maWxsR3JhZGllbnQoZ3JhZGllbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBmaWxsIHN0eWxlIHRvIHBhdHRlcm4uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NQYXR0ZXJufSBwYXR0ZXJuIEZpbGwgcGF0dGVybi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGxQYXR0ZXJuKHBhdHRlcm4pIHtcclxuICAgIHRoaXMubUdyYXBoaWNzRGF0YS5maWxsUGF0dGVybihwYXR0ZXJuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIGFuZCByZXNldHMgZmlsbCBhbmQgbGluZSBzdHlsZXMuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLm1Cb3VuZHMuemVybygpO1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLmNsZWFyKCk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3ZlcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYSBwYXRoIHRvIGdpdmVuIHggYW5kIHkgY29vcmRpbmF0ZXMuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIHgtYXhpcyBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIHktYXhpcyBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgbW92ZVRvKHgsIHkpIHtcclxuICAgIHRoaXMubUdyYXBoaWNzRGF0YS5tb3ZlVG8oeCwgeSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmF3cyBhIGxpbmUgYmV0d2VlbiBsYXN0IHBvaW50IGFuZCBnaXZlbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgeC1heGlzIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgeS1heGlzIG9mIHRoZSBwb2ludC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBsaW5lVG8oeCwgeSkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLmxpbmVUbyh4LCB5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgICAgICAgVGhlIHgtYXhpcyBvZiB0aGUgYXJjJ3MgY2VudGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgICAgICAgIFRoZSB5LWF4aXMgb2YgdGhlIGFyYydzIGNlbnRlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzICAgICAgICBUaGUgcmFkaXVzIG9mIHRoZSBhcmMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgICAgVGhlIHN0YXJ0aW5nIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlICAgICAgVGhlIGVuZGluZyBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFthbnRpY2xvY2t3aXNlPWZhbHNlXSBJZiB0cnVlIHRoZSBhcmMgd2lsbCBiZSBkcmF3biBjb3VudGVyLWNsb2Nrd2lzZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBhcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSA9IGZhbHNlKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuYXJjKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjaXJjbGUgdG8gY3VycmVudCBwYXRoLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4ICAgICAgVGhlIHgtYXhpcyBvZiB0aGUgY2lyY2xlJ3MgY2VudGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5ICAgICAgVGhlIHktYXhpcyBvZiB0aGUgY2lyY2xlJ3MgY2VudGVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMpIHtcclxuICAgIHRoaXMubUdyYXBoaWNzRGF0YS5jaXJjbGUoeCwgeSwgcmFkaXVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgY2xvc2VkIHJlY3RhbmdsZSBsaWtlIHBhdGguXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGNsb3NlZCByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJvdW5kZWRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLnJvdW5kZWRSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNwMXhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3AxeVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjcDJ4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNwMnlcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICovXHJcbiAgYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3B4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNweVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKi9cclxuICBxdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5KSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEucXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgbmV3IHBhdGguXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgYmVnaW5QYXRoKCkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLmJlZ2luUGF0aCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvc2VzIGN1cnJlbnQgcGF0aC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBjbG9zZVBhdGgoKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuY2xvc2VQYXRoKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBsaW5lIGRhc2ggcGF0dGVybiB1c2VkIHdoZW4gc3Ryb2tpbmcgbGluZXMsXHJcbiAgICogdXNpbmcgYW4gYXJyYXkgb2YgdmFsdWVzIHdoaWNoIHNwZWNpZnkgYWx0ZXJuYXRpbmcgbGVuZ3RocyBvZiBsaW5lcyBhbmQgZ2FwcyB3aGljaCBkZXNjcmliZSB0aGUgcGF0dGVybi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IEFuIEFycmF5IG9mIG51bWJlcnMgd2hpY2ggc3BlY2lmeSBkaXN0YW5jZXMgdG8gYWx0ZXJuYXRlbHkgZHJhdyBhIGxpbmUgYW5kIGEgZ2FwIChpbiBjb29yZGluYXRlIHNwYWNlIHVuaXRzKS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldExpbmVEYXNoKHNlZ21lbnRzKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuc2V0TGluZURhc2goc2VnbWVudHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3Ryb2tlcyBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBsaW5lIHN0eWxlLi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzdHJva2UoKSB7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEuc3Ryb2tlKCk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaWxscyBjdXJyZW50IHBhdGggd2l0aCB0aGUgY3VycmVudCBmaWxsIHN0eWxlLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOb25aZXJvIFRoZSBhbGdvcml0aG0gYnkgd2hpY2ggdG8gZGV0ZXJtaW5lIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcGF0aCBvciBvdXRzaWRlIGEgcGF0aCwgVHJ1ZSBpcyBmb3IgXCJub256ZXJvXCIgYW5kIEZhbHNlIGlzIGZvciBcImV2ZW5vZGRcIi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGZpbGwoaXNOb25aZXJvID0gdHJ1ZSkge1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhLmZpbGwoaXNOb25aZXJvKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIGNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiBuZXcgR3JhcGhpY3NMaW5lYXJHcmFkaWVudCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHBhdGhDbWRzID0ge1xyXG4gIE1PVkVUTzogJ00nLFxyXG4gIE1PVkVUT19SRUw6ICdtJyxcclxuICBMSU5FVE86ICdMJyxcclxuICBMSU5FVE9fUkVMOiAnbCcsXHJcbiAgVkxJTkU6ICdWJyxcclxuICBWTElORV9SRUw6ICd2JyxcclxuICBITElORTogJ0gnLFxyXG4gIEhMSU5FX1JFTDogJ2gnLFxyXG4gIENVUlZFOiAnQycsXHJcbiAgQ1VSVkVfUkVMOiAnYycsXHJcbiAgU0NVUlZFOiAnUycsXHJcbiAgU0NVUlZFX1JFTDogJ3MnLFxyXG4gIFFDVVJWRTogJ1EnLFxyXG4gIFFDVVJWRV9SRUw6ICdxJyxcclxuICBTUUNVUlZFOiAnVCcsXHJcbiAgU1FDVVJWRV9SRUw6ICd0JyxcclxuICBBUkM6ICdBJyxcclxuICBBUkNfUkVMOiAnYScsXHJcbiAgQ0xPU0VfUEFUSDogJ1onLFxyXG59O1xyXG5cclxuY29uc3Qgc2hhcGVDbWRzID0ge1xyXG4gIFJFQ1Q6ICdyJyxcclxuICBDSVJDTEU6ICdjJyxcclxuICBFTExJUFNFOiAnZScsXHJcbiAgTElORTogJ2wnLFxyXG4gIFBPTFlMSU5FOiAncycsXHJcbiAgUEFUSDogJ3AnLFxyXG4gIFBPTFlHT046ICdnJyxcclxuICBDTElQUElORzogJ20nLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEJsYWNrIFZlY3RvciBHcmFwaGljcyBwYXJzZXIuXHJcbiAqIENyZWF0ZXMgR3JhcGhpY3NEYXRhIGZvciBHcmFwaGljcyBmcm9tIEJWRyBmb3JtYXQuXHJcbiAqXHJcbiAqIEBjYXQgcGFyc2Vyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+UGFyc2VyQmFzZVxyXG4gKi9cclxuXHJcbmNsYXNzIEJWR1BhcnNlciBleHRlbmRzIFBhcnNlckJhc2Uge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEJWR1BhcnNlclxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdH0gKi9cclxuICAgIHRoaXMuX2RlZnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfSBEYXRhIGZvciBHcmFwaGljcyByZW5kZXJlclxyXG4gICAqL1xyXG4gIHBhcnNlKGRhdGEpIHtcclxuICAgIHN1cGVyLnBhcnNlKGRhdGEpO1xyXG5cclxuICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuX19wYXJzZVN0eWxlcyhkYXRhWydzdHlsZXMnXSk7XHJcblxyXG4gICAgdGhpcy5fZGVmcyA9IHt9O1xyXG4gICAgdGhpcy5fX3BhcnNlRGVmcyhkYXRhWydkZWZzJ10sIHRoaXMuX2RlZnMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9fdHJhdmVyc2UoZGF0YSwgc3R5bGVzLCBuZXcgR3JhcGhpY3NEYXRhKCksIG5ldyBCVkdTdHlsZSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IGdvZXMgdGhyb3VnaCBjaGlsZHJlbiBub2RlcyBhbmQgYnVpbGRzIGZpbmFsIEdyYXBoaWNzRGF0YS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQlZHIG5vZGUuXHJcbiAgICogQHBhcmFtIHtBcnJheTxibGFjay1lbmdpbmV+QlZHU3R5bGU+fSBzdHlsZXMgUGFyc2VkIEJWRyBzdHlsZXMuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfSBwYXJlbnQgUGFyZW50IG5vZGUuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+QlZHU3R5bGV9IHBhcmVudFN0eWxlIFN0eWxlIGZvciBpbmhlcml0YW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfSBQYXJzZWQgZGF0YSByb290LlxyXG4gICAqL1xyXG4gIF9fdHJhdmVyc2Uobm9kZSwgc3R5bGVzLCBwYXJlbnQsIHBhcmVudFN0eWxlKSB7XHJcbiAgICBjb25zdCBkZWZzID0gdGhpcy5fZGVmcztcclxuICAgIGNvbnN0IGdyYXBoaWNzRGF0YSA9IG5ldyBHcmFwaGljc0RhdGEoKTtcclxuICAgIGxldCBzdHlsZSA9IHBhcmVudFN0eWxlLmNsb25lKCk7XHJcbiAgICBwYXJlbnQubU5vZGVzLnB1c2goZ3JhcGhpY3NEYXRhKTtcclxuXHJcbiAgICBpZiAobm9kZVsnaWQnXSlcclxuICAgICAgZ3JhcGhpY3NEYXRhLm5hbWUgPSBub2RlWydpZCddO1xyXG5cclxuICAgIGxldCB0ID0gbm9kZVsndCddO1xyXG4gICAgaWYgKHQpIHtcclxuICAgICAgY29uc3QgeCA9IHRbMF0gfHwgMDtcclxuICAgICAgY29uc3QgeSA9IHRbMV0gfHwgMDtcclxuICAgICAgY29uc3Qgc3ggPSB0WzJdIHx8IDE7XHJcbiAgICAgIGNvbnN0IHN5ID0gdFszXSB8fCAxO1xyXG4gICAgICBjb25zdCBweCA9IHRbNV0gfHwgMDtcclxuICAgICAgY29uc3QgcHkgPSB0WzZdIHx8IDA7XHJcblxyXG4gICAgICBncmFwaGljc0RhdGEubVRyYW5zZm9ybS5yb3RhdGUodFs0XSB8fCAwKTtcclxuICAgICAgZ3JhcGhpY3NEYXRhLm1UcmFuc2Zvcm0uc2NhbGUoc3gsIHN5KTtcclxuICAgICAgZ3JhcGhpY3NEYXRhLm1UcmFuc2Zvcm0uc2tldyh0WzddIHx8IDAsIHRbOF0gfHwgMCk7XHJcblxyXG4gICAgICBncmFwaGljc0RhdGEubVRyYW5zZm9ybS5kYXRhWzRdID0geCArIHB4IC8gc3g7XHJcbiAgICAgIGdyYXBoaWNzRGF0YS5tVHJhbnNmb3JtLmRhdGFbNV0gPSB5ICsgcHkgLyBzeTtcclxuXHJcbiAgICAgIGdyYXBoaWNzRGF0YS5tUGl2b3RYID0gcHg7XHJcbiAgICAgIGdyYXBoaWNzRGF0YS5tUGl2b3RZID0gcHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVbJ2NtZHMnXSkge1xyXG4gICAgICBjb25zdCBjbWRzID0gbm9kZVsnY21kcyddLnNwbGl0KCckJykuZmlsdGVyKHYgPT4gdikucmV2ZXJzZSgpO1xyXG4gICAgICBjb25zdCBsYXN0UmVjdCA9IG5ldyBSZWN0YW5nbGUoKTtcclxuICAgICAgbGV0IHByZXZOYW1lID0gJyc7XHJcblxyXG4gICAgICB3aGlsZSAoY21kcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgY21kID0gY21kcy5wb3AoKTtcclxuICAgICAgICBjb25zdCBuYW1lID0gY21kWzBdO1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjbWQuc2xpY2UoMSkuc3BsaXQoJywnKS5tYXAodiA9PiBOdW1iZXIodikpO1xyXG5cclxuICAgICAgICBncmFwaGljc0RhdGEuYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIGlmIChwcmV2TmFtZSAhPT0gJ1MnICYmIG5hbWUgIT09ICdTJykge1xyXG4gICAgICAgICAgZ3JhcGhpY3NEYXRhLmZpbGxTdHlsZSgweDAwMDAwMCwgMSk7XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEubGluZVN0eWxlKDEsIDB4MDAwMDAwLCAxLCBDYXBzU3R5bGUuTk9ORSwgSm9pbnRTdHlsZS5NSVRFUiwgNCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcmV2TmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgY2FzZSAnUyc6XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGVzW2FyZ3NbMF1dO1xyXG4gICAgICAgICAgICBzdHlsZSA9IHBhcmVudFN0eWxlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHN0eWxlLm1lcmdlKG5ld1N0eWxlKTtcclxuICAgICAgICAgICAgc3R5bGUuY29tcHV0ZSgpO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHNoYXBlQ21kcy5QQVRIOlxyXG4gICAgICAgICAgICB0aGlzLl9fZHJhd1BhdGgoY21kLCBncmFwaGljc0RhdGEpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2Ugc2hhcGVDbWRzLlJFQ1Q6IHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBhcmdzWzFdO1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbMl07XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbM107XHJcbiAgICAgICAgICAgIGNvbnN0IHJ4ID0gKGFyZ3NbNF0gPT09IHVuZGVmaW5lZCA/IGFyZ3NbNV0gOiBhcmdzWzRdKSB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCByeSA9IChhcmdzWzVdID09PSB1bmRlZmluZWQgPyBhcmdzWzRdIDogYXJnc1s1XSkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgIGxhc3RSZWN0LnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyeCAhPT0gMCAmJiByeSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5tb3ZlVG8oeCwgeSArIHJ5KTtcclxuICAgICAgICAgICAgICBncmFwaGljc0RhdGEucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcngsIHkpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5saW5lVG8oeCArIHdpZHRoIC0gcngsIHkpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5saW5lVG8oeCArIHJ4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICBncmFwaGljc0RhdGEucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkpO1xyXG4gICAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBncmFwaGljc0RhdGEucmVjdChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjYXNlIHNoYXBlQ21kcy5DSVJDTEU6XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBhcmdzWzJdICogMjtcclxuICAgICAgICAgICAgbGFzdFJlY3Quc2V0KDAsIDAsIGQsIGQpO1xyXG4gICAgICAgICAgICBncmFwaGljc0RhdGEuY2lyY2xlKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2Ugc2hhcGVDbWRzLkVMTElQU0U6XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gYXJnc1sxXTtcclxuICAgICAgICAgICAgY29uc3QgcnggPSBhcmdzWzJdO1xyXG4gICAgICAgICAgICBjb25zdCByeSA9IGFyZ3NbM107XHJcblxyXG4gICAgICAgICAgICBsZXQgYSA9IC8qKiBAdHlwZSB7IUFycmF5PCFBcnJheTxudW1iZXI+Pn0gKi8gKHRoaXMuX19hcmNUb0Jlemllcih4IC0gcngsIHksIHJ4LCByeSwgMCwgMCwgMCwgeCArIHJ4LCB5KSk7XHJcbiAgICAgICAgICAgIGxldCBiID0gLyoqIEB0eXBlIHshQXJyYXk8IUFycmF5PG51bWJlcj4+fSAqLyAodGhpcy5fX2FyY1RvQmV6aWVyKHggKyByeCwgeSwgcngsIHJ5LCAwLCAwLCAwLCB4IC0gcngsIHkpKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnZlcyA9IFsuLi5hLCAuLi5iXTtcclxuXHJcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5tb3ZlVG8oeCAtIHJ4LCB5KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGMgPSBjdXJ2ZXNbaV07XHJcbiAgICAgICAgICAgICAgZ3JhcGhpY3NEYXRhLmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGdyYXBoaWNzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHNoYXBlQ21kcy5MSU5FOlxyXG4gICAgICAgICAgICBjb25zdCB4MSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHkxID0gYXJnc1sxXTtcclxuICAgICAgICAgICAgY29uc3QgeDIgPSBhcmdzWzJdO1xyXG4gICAgICAgICAgICBjb25zdCB5MiA9IGFyZ3NbM107XHJcblxyXG4gICAgICAgICAgICBncmFwaGljc0RhdGEubW92ZVRvKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5saW5lVG8oeDIsIHkyKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIHNoYXBlQ21kcy5QT0xZTElORTpcclxuICAgICAgICAgIGNhc2Ugc2hhcGVDbWRzLlBPTFlHT046XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNtZC5zbGljZSgxKS5zcGxpdCgnLCcpLm1hcCh2ID0+IE51bWJlcih2KSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDIsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgZ3JhcGhpY3NEYXRhLmxpbmVUbyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuYW1lID09PSBzaGFwZUNtZHMuUE9MWUdPTiAmJiBncmFwaGljc0RhdGEuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzdHlsZS5uZWVkc0ZpbGwgJiYgbmFtZSAhPT0gJ1MnKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5fX2lzUmVmKHN0eWxlLkYpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbc3R5bGUuRi5zbGljZSgxKV0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBHcmFwaGljc1BhdHRlcm4pIHtcclxuICAgICAgICAgICAgICBncmFwaGljc0RhdGEuZmlsbFBhdHRlcm4oZGVmKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWYgaW5zdGFuY2VvZiBHcmFwaGljc0xpbmVhckdyYWRpZW50KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGRlZi5pc0Fic29sdXRlKSA7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVmLngwICo9IGxhc3RSZWN0LndpZHRoOyAvLyB0b2RvIG90aGVyIHVuaXRzIChOb3cgZm9yIHBlcmNlbnRzIG9ubHkpXHJcbiAgICAgICAgICAgICAgICBkZWYueDEgKj0gbGFzdFJlY3Qud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBkZWYueTAgKj0gbGFzdFJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZGVmLnkxICo9IGxhc3RSZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkZWYuc3RvcHMpIHtcclxuICAgICAgICAgICAgICAgIGRlZi5zdG9wc1trZXldID0gQ29sb3JIZWxwZXIuaW50VG9SR0JBKHBhcnNlSW50KGRlZi5zdG9wc1trZXldLnNsaWNlKDEpLCAxNiksIHN0eWxlLmZpbGxBbHBoYSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBncmFwaGljc0RhdGEuZmlsbEdyYWRpZW50KGRlZik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBncmFwaGljc0RhdGEuZmlsbFN0eWxlKHN0eWxlLmZpbGxDb2xvciwgc3R5bGUuZmlsbEFscGhhKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBncmFwaGljc0RhdGEuZmlsbChzdHlsZS5maWxsUnVsZSA9PT0gRmlsbFJ1bGUuTk9ORV9aRVJPKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdHlsZS5uZWVkc1N0cm9rZSkge1xyXG4gICAgICAgICAgZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZShzdHlsZS5saW5lV2lkdGgsIHN0eWxlLmxpbmVDb2xvcixcclxuICAgICAgICAgICAgc3R5bGUubGluZUFscGhhLCBzdHlsZS5saW5lQ2FwLCBzdHlsZS5saW5lSm9pbiwgc3R5bGUubWl0ZXJMaW1pdCk7XHJcblxyXG4gICAgICAgICAgZ3JhcGhpY3NEYXRhLnNldExpbmVEYXNoKHN0eWxlLmxpbmVEYXNoKTtcclxuICAgICAgICAgIGdyYXBoaWNzRGF0YS5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZVsnbm9kZXMnXSkge1xyXG4gICAgICBub2RlWydub2RlcyddLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgdGhpcy5fX3RyYXZlcnNlKGMsIHN0eWxlcywgZ3JhcGhpY3NEYXRhLCBzdHlsZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBncmFwaGljc0RhdGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgY29sb3Igc3RyaW5nIGlzIHVybCB0byBkZWZzIG9yIHNpbXBsZSBjb2xvci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIENvbG9yIG9yIHVybC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgX19pc1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoJyQnKSA9PT0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlcyByYXcgZGVmcyB0byB0aGlzIGRlZnMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmcyBSYXcgZGVmcy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzICBSZWZlcmVuY2UgdG8gdGhpcyBkZWZzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzIFBhcnNlZCBkYXRhLlxyXG4gICAqL1xyXG4gIF9fcGFyc2VEZWZzKGRlZnMsIHJlcykge1xyXG4gICAgaWYgKCFkZWZzKSB7XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaWQgaW4gZGVmcykge1xyXG4gICAgICBpZiAoIWRlZnMuaGFzT3duUHJvcGVydHkoaWQpKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGNvbnN0IGRlZiA9IGRlZnNbaWRdO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3QgY21kID0gZGVmLmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChjbWQpIHtcclxuICAgICAgICAgIGNhc2UgJ1InOiAvLyBMaW5lYXIgR3JhZGllbnRcclxuICAgICAgICAgICAgY29uc3QgcGFpcnMgPSBkZWYuc2xpY2UoMSkuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgY29uc3QgdiA9IHBhaXJzWzBdLnNwbGl0KCcsJykubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyYWRpZW50SW5mbyA9IG5ldyBHcmFwaGljc0xpbmVhckdyYWRpZW50KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pO1xyXG4gICAgICAgICAgICBncmFkaWVudEluZm8uaXNBYnNvbHV0ZSA9IHZbNF0gPT09IDA7XHJcbiAgICAgICAgICAgIHJlc1tpZF0gPSBncmFkaWVudEluZm87XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBwYWlyc1tpXTtcclxuICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBwYWlyLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSAnIycgKyB2YWx1ZXNbMV07XHJcblxyXG4gICAgICAgICAgICAgIGdyYWRpZW50SW5mby5hZGRDb2xvclN0b3AocGFyc2VGbG9hdCh2YWx1ZXNbMF0pLCBjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFBhdHRlcm5cclxuICAgICAgICBjb25zdCBzdHlsZXMgPSB0aGlzLl9fcGFyc2VTdHlsZXMoZGVmLnMpO1xyXG4gICAgICAgIGNvbnN0IGdEYXRhID0gdGhpcy5fX3RyYXZlcnNlKGRlZiwgc3R5bGVzLCBuZXcgR3JhcGhpY3NEYXRhKCksIG5ldyBCVkdTdHlsZSgpKTtcclxuICAgICAgICBjb25zdCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhnRGF0YSk7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IG5ldyBDYW52YXNSZW5kZXJUZXh0dXJlKGdyYXBoaWNzLndpZHRoLCBncmFwaGljcy5oZWlnaHQsIEJsYWNrLmRyaXZlci5yZW5kZXJTY2FsZUZhY3Rvcik7XHJcbiAgICAgICAgQmxhY2suZHJpdmVyLnJlbmRlcihncmFwaGljcywgcmVuZGVyVGV4dHVyZSwgbmV3IE1hdHJpeCgpKTtcclxuXHJcbiAgICAgICAgcmVzW2lkXSA9IG5ldyBHcmFwaGljc1BhdHRlcm4ocmVuZGVyVGV4dHVyZS5uYXRpdmUsIGRlZi5yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCVkcgc3R5bGVzIHBhcnNlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXk8YmxhY2stZW5naW5lfkJWR1N0eWxlPn0gUGFyc2VkIGRhdGEgc3R5bGVzLlxyXG4gICAqL1xyXG4gIF9fcGFyc2VTdHlsZXMoc3R5bGVzKSB7XHJcbiAgICBpZiAoIXN0eWxlcylcclxuICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgIHJldHVybiBzdHlsZXMubWFwKHMgPT4ge1xyXG4gICAgICBjb25zdCBzdHlsZSA9IHt9O1xyXG4gICAgICBjb25zdCBwcm9wcyA9IHMuc3BsaXQoJyAnKTtcclxuXHJcbiAgICAgIHByb3BzLmZvckVhY2gocCA9PiB7XHJcbiAgICAgICAgY29uc3QgY21kID0gcFswXTtcclxuICAgICAgICBzdHlsZVtjbWRdID0gcC5zbGljZSgxKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJWRyBwYXRoIGRhdGEgcGFyc2VyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBQYXRoIGRhdGEgYXR0cmlidXRlIHZhbHVlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgR3JhcGhpY3MgZGF0YSB0byBzdG9yZSBwYXJzZWQgdmFsdWVzIHRvLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX2RyYXdQYXRoKGRhdGEsIGdyYXBoaWNzRGF0YSkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcblxyXG4gICAgZGF0YVxyXG4gICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAubWFwKGl0ZW0gPT4ge1xyXG4gICAgICAgIHdoaWxlIChpdGVtLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgY29uc3QgYXJnID0gcGFyc2VGbG9hdChpdGVtKTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNOYU4oYXJnKSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChpdGVtLmNoYXJBdCgwKSk7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnNsaWNlKDEpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goYXJnKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyB0cnVlOyBpKyspIHtcclxuICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChpdGVtLnNsaWNlKDAsIGkpKSA9PT0gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbS5zbGljZShpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgdmFsdWVzLnJldmVyc2UoKTtcclxuXHJcbiAgICAvLyBDb250ZXh0IHBvc2l0aW9uXHJcbiAgICBsZXQgeCA9IDA7XHJcbiAgICBsZXQgeSA9IDA7XHJcblxyXG4gICAgLy8gUGF0aCBzdGFydCBwb3NpdGlvbiwgdG8gcmV0dXJuIG9uIGNsb3NlIHBhdGhcclxuICAgIGxldCBteCA9IDA7XHJcbiAgICBsZXQgbXkgPSAwO1xyXG5cclxuICAgIC8vIEJlemllciBjdXJ2ZSBjb250cm9sIHBvaW50IDEgcG9zaXRpb24sIHRvIGRyYXcgbmV4dCBzbW9vdGhlZCBiZXppZXIgY3VydmVcclxuICAgIGxldCBiY3ggPSAwO1xyXG4gICAgbGV0IGJjeSA9IDA7XHJcblxyXG4gICAgLy8gUXVhZHJhdGljIGN1cnZlIGNvbnRyb2wgcG9pbnQgMSBwb3NpdGlvbiwgdG8gZHJhdyBuZXh0IHNtb290aGVkIHF1YWRyYXRpYyBjdXJ2ZVxyXG4gICAgbGV0IHFjeCA9IDA7XHJcbiAgICBsZXQgcWN5ID0gMDtcclxuXHJcbiAgICAvLyBTdG9yZSBsYXN0IGNvbW1hbmRcclxuICAgIGxldCBwcmV2VmFsdWUgPSAnJztcclxuXHJcbiAgICAvLyAwIGZvciBhYnNvbHV0ZSBwYXRoIGFuZCB4LCB5IGZvciByZWxhdGl2ZVxyXG4gICAgbGV0IHJlbFggPSAwO1xyXG4gICAgbGV0IHJlbFkgPSAwO1xyXG5cclxuICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIGNvbnN0IGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICBjb25zdCB2ID0gbGFzdCA9PT0gbGFzdC50b1N0cmluZygpID8gdmFsdWVzLnBvcCgpIDogcHJldlZhbHVlO1xyXG4gICAgICBwcmV2VmFsdWUgPSB2O1xyXG4gICAgICByZWxYID0gcmVsWSA9IDA7XHJcblxyXG4gICAgICBpZiAodiA9PT0gdi50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgcmVsWCA9IHg7XHJcbiAgICAgICAgcmVsWSA9IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAodikge1xyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuTU9WRVRPOlxyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuTU9WRVRPX1JFTDpcclxuICAgICAgICAgIHggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgeSA9IHZhbHVlcy5wb3AoKSArIHJlbFk7XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgbXggPSB4O1xyXG4gICAgICAgICAgbXkgPSB5O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5MSU5FVE86XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5MSU5FVE9fUkVMOlxyXG4gICAgICAgICAgeCA9IHZhbHVlcy5wb3AoKSArIHJlbFg7XHJcbiAgICAgICAgICB5ID0gdmFsdWVzLnBvcCgpICsgcmVsWTtcclxuICAgICAgICAgIGdyYXBoaWNzRGF0YS5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIHBhdGhDbWRzLlZMSU5FOlxyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuVkxJTkVfUkVMOlxyXG4gICAgICAgICAgeSA9IHZhbHVlcy5wb3AoKSArIHJlbFk7XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5ITElORTpcclxuICAgICAgICBjYXNlIHBhdGhDbWRzLkhMSU5FX1JFTDpcclxuICAgICAgICAgIHggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgZ3JhcGhpY3NEYXRhLmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuQ1VSVkU6XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5DVVJWRV9SRUw6IHtcclxuICAgICAgICAgIGNvbnN0IGNwMXggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgY29uc3QgY3AxeSA9IHZhbHVlcy5wb3AoKSArIHJlbFk7XHJcbiAgICAgICAgICBjb25zdCBjcDJ4ID0gdmFsdWVzLnBvcCgpICsgcmVsWDtcclxuICAgICAgICAgIGNvbnN0IGNwMnkgPSB2YWx1ZXMucG9wKCkgKyByZWxZO1xyXG4gICAgICAgICAgeCA9IHZhbHVlcy5wb3AoKSArIHJlbFg7XHJcbiAgICAgICAgICB5ID0gdmFsdWVzLnBvcCgpICsgcmVsWTtcclxuICAgICAgICAgIGdyYXBoaWNzRGF0YS5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xyXG4gICAgICAgICAgYmN4ID0geCAqIDIgLSBjcDJ4O1xyXG4gICAgICAgICAgYmN5ID0geSAqIDIgLSBjcDJ5O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuU0NVUlZFOlxyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuU0NVUlZFX1JFTDoge1xyXG4gICAgICAgICAgY29uc3QgY3AyeCA9IHZhbHVlcy5wb3AoKSArIHJlbFg7XHJcbiAgICAgICAgICBjb25zdCBjcDJ5ID0gdmFsdWVzLnBvcCgpICsgcmVsWTtcclxuICAgICAgICAgIHggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgeSA9IHZhbHVlcy5wb3AoKSArIHJlbFk7XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEuYmV6aWVyQ3VydmVUbyhiY3gsIGJjeSwgY3AyeCwgY3AyeSwgeCwgeSk7XHJcbiAgICAgICAgICBiY3ggPSB4ICogMiAtIGNwMng7XHJcbiAgICAgICAgICBiY3kgPSB5ICogMiAtIGNwMnk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5RQ1VSVkU6XHJcbiAgICAgICAgY2FzZSBwYXRoQ21kcy5RQ1VSVkVfUkVMOiB7XHJcbiAgICAgICAgICBjb25zdCBjcHggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgY29uc3QgY3B5ID0gdmFsdWVzLnBvcCgpICsgcmVsWTtcclxuICAgICAgICAgIHggPSB2YWx1ZXMucG9wKCkgKyByZWxYO1xyXG4gICAgICAgICAgeSA9IHZhbHVlcy5wb3AoKSArIHJlbFk7XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEucXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSk7XHJcbiAgICAgICAgICBxY3ggPSB4ICogMiAtIGNweDtcclxuICAgICAgICAgIHFjeSA9IHkgKiAyIC0gY3B5O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgcGF0aENtZHMuU1FDVVJWRTpcclxuICAgICAgICBjYXNlIHBhdGhDbWRzLlNRQ1VSVkVfUkVMOiB7XHJcbiAgICAgICAgICB4ID0gdmFsdWVzLnBvcCgpICsgcmVsWDtcclxuICAgICAgICAgIHkgPSB2YWx1ZXMucG9wKCkgKyByZWxZO1xyXG4gICAgICAgICAgZ3JhcGhpY3NEYXRhLnF1YWRyYXRpY0N1cnZlVG8ocWN4LCBxY3ksIHgsIHkpO1xyXG4gICAgICAgICAgcWN4ID0geCAqIDIgLSBxY3g7XHJcbiAgICAgICAgICBxY3kgPSB5ICogMiAtIHFjeTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIHBhdGhDbWRzLkFSQzpcclxuICAgICAgICBjYXNlIHBhdGhDbWRzLkFSQ19SRUw6IHtcclxuICAgICAgICAgIGNvbnN0IHB4ID0geDtcclxuICAgICAgICAgIGNvbnN0IHB5ID0geTtcclxuICAgICAgICAgIGNvbnN0IHJ4ID0gdmFsdWVzLnBvcCgpO1xyXG4gICAgICAgICAgY29uc3QgcnkgPSB2YWx1ZXMucG9wKCk7XHJcbiAgICAgICAgICBjb25zdCB4QXhpc1JvdGF0aW9uID0gdmFsdWVzLnBvcCgpO1xyXG4gICAgICAgICAgY29uc3QgbGFyZ2VBcmNGbGFnID0gdmFsdWVzLnBvcCgpO1xyXG4gICAgICAgICAgY29uc3Qgc3dlZXBGbGFnID0gdmFsdWVzLnBvcCgpO1xyXG4gICAgICAgICAgeCA9IHZhbHVlcy5wb3AoKSArIHJlbFg7XHJcbiAgICAgICAgICB5ID0gdmFsdWVzLnBvcCgpICsgcmVsWTtcclxuXHJcbiAgICAgICAgICBjb25zdCBjdXJ2ZXMgPSB0aGlzLl9fYXJjVG9CZXppZXIocHgsIHB5LCByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KTtcclxuXHJcbiAgICAgICAgICBpZiAoIWN1cnZlcykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjdXJ2ZXNbaV07XHJcbiAgICAgICAgICAgIGdyYXBoaWNzRGF0YS5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIHBhdGhDbWRzLkNMT1NFX1BBVEg6XHJcbiAgICAgICAgICBncmFwaGljc0RhdGEuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICB4ID0gbXg7XHJcbiAgICAgICAgICB5ID0gbXk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHYgIT09IHBhdGhDbWRzLkNVUlZFICYmIHYgIT09IHBhdGhDbWRzLkNVUlZFX1JFTCAmJiB2ICE9PSBwYXRoQ21kcy5TQ1VSVkUgJiYgdiAhPT0gcGF0aENtZHMuU0NVUlZFX1JFTCkge1xyXG4gICAgICAgIGJjeCA9IHg7XHJcbiAgICAgICAgYmN5ID0geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHYgIT09IHBhdGhDbWRzLlFDVVJWRSAmJiB2ICE9PSBwYXRoQ21kcy5RQ1VSVkVfUkVMICYmIHYgIT09IHBhdGhDbWRzLlNRQ1VSVkUgJiYgdiAhPT0gcGF0aENtZHMuU1FDVVJWRV9SRUwpIHtcclxuICAgICAgICBxY3ggPSB4O1xyXG4gICAgICAgIHFjeSA9IHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFSQyBUTyBCRVpJRVIgU1RBUlRcclxuICAvKipcclxuICAgKiBBcHByb3hpbWF0ZSBjdXJ2ZSBjb3JuZXIuIFNpbmdsZSBiZXppZXIgc2hvdWxkbid0IGJlIGxvbmdlciB0aGFuIDkwIGRlZ3JlZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBTdGFydCBhbmdsZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaGV0YSBBbmdsZSBmcm9tIHN0YXJ0IHRvIGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBDZW50ZXIuXHJcbiAgICovXHJcbiAgX19hcHByb3hVbml0QXJjKHRoZXRhLCBkZWx0YVRoZXRhKSB7XHJcbiAgICBjb25zdCBhbHBoYSA9IDQgLyAzICogTWF0aC50YW4oZGVsdGFUaGV0YSAvIDQpO1xyXG4gICAgY29uc3QgeDEgPSBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICBjb25zdCB5MSA9IE1hdGguc2luKHRoZXRhKTtcclxuICAgIGNvbnN0IHgyID0gTWF0aC5jb3ModGhldGEgKyBkZWx0YVRoZXRhKTtcclxuICAgIGNvbnN0IHkyID0gTWF0aC5zaW4odGhldGEgKyBkZWx0YVRoZXRhKTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICB4MSwgeTEsXHJcbiAgICAgIHgxIC0geTEgKiBhbHBoYSwgeTEgKyB4MSAqIGFscGhhLFxyXG4gICAgICB4MiArIHkyICogYWxwaGEsIHkyIC0geDIgKiBhbHBoYSxcclxuICAgICAgeDIsIHkyLFxyXG4gICAgXTtcclxuICB9XHJcblxyXG4gIF9fdmVjdG9yQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcclxuICAgIGNvbnN0IHNpZ24gPSAodXggKiB2eSAtIHV5ICogdnggPCAwKSA/IC0xIDogMTtcclxuICAgIGNvbnN0IGRvdCA9IE1hdGhFeC5jbGFtcCh1eCAqIHZ4ICsgdXkgKiB2eSwgLTEsIDEpO1xyXG5cclxuICAgIHJldHVybiBzaWduICogTWF0aC5hY29zKGRvdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIGFyYyBjZW50ZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4MSBDb250ZXh0IGN1cnJlbnQgcG9zaXRpb24geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geTEgQ29udGV4dCBjdXJyZW50IHBvc2l0aW9uIHkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHgyIENvbnRleHQgdGFyZ2V0IChuZXh0KSBwb3NpdGlvbiB4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5MiBDb250ZXh0IHRhcmdldCAobmV4dCkgcG9zaXRpb24geS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmEgRmxhZyB0byBkZXRlcm1pbmUgd2hpY2ggYXJjIHRvIGRyYXcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZzIEFub3RoZXIgZmxhZyB0byBkZXRlcm1pbmUgd2hpY2ggYXJjIHRvIGRyYXcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJ4IEFyYyByYWRpdXMgeC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcnkgQXJjIHJhZGl1cyB5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaW5QaGkgU2luIG9mIHggYXhpcyByb3RhdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gY29zUGhpIENvcyBvZiB4IGF4aXMgcm90YXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gQ2VudGVyLlxyXG4gICAqL1xyXG4gIF9fZ2V0QXJjQ2VudGVyKHgxLCB5MSwgeDIsIHkyLCBmYSwgZnMsIHJ4LCByeSwgc2luUGhpLCBjb3NQaGkpIHtcclxuICAgIGNvbnN0IHgxcCA9IGNvc1BoaSAqICh4MSAtIHgyKSAvIDIgKyBzaW5QaGkgKiAoeTEgLSB5MikgLyAyO1xyXG4gICAgY29uc3QgeTFwID0gLXNpblBoaSAqICh4MSAtIHgyKSAvIDIgKyBjb3NQaGkgKiAoeTEgLSB5MikgLyAyO1xyXG5cclxuICAgIGNvbnN0IHJ4U3EgPSByeCAqIHJ4O1xyXG4gICAgY29uc3QgcnlTcSA9IHJ5ICogcnk7XHJcbiAgICBjb25zdCB4MXBTcSA9IHgxcCAqIHgxcDtcclxuICAgIGNvbnN0IHkxcFNxID0geTFwICogeTFwO1xyXG5cclxuICAgIGxldCByYWRpY2FsID0gTWF0aC5tYXgoMCwgKHJ4U3EgKiByeVNxKSAtIChyeFNxICogeTFwU3EpIC0gKHJ5U3EgKiB4MXBTcSkpO1xyXG4gICAgcmFkaWNhbCAvPSAocnhTcSAqIHkxcFNxKSArIChyeVNxICogeDFwU3EpO1xyXG4gICAgcmFkaWNhbCA9IE1hdGguc3FydChyYWRpY2FsKSAqIChmYSA9PT0gZnMgPyAtMSA6IDEpO1xyXG5cclxuICAgIGNvbnN0IGN4cCA9IHJhZGljYWwgKiByeCAvIHJ5ICogeTFwO1xyXG4gICAgY29uc3QgY3lwID0gcmFkaWNhbCAqIC1yeSAvIHJ4ICogeDFwO1xyXG5cclxuICAgIGNvbnN0IGN4ID0gY29zUGhpICogY3hwIC0gc2luUGhpICogY3lwICsgKHgxICsgeDIpIC8gMjtcclxuICAgIGNvbnN0IGN5ID0gc2luUGhpICogY3hwICsgY29zUGhpICogY3lwICsgKHkxICsgeTIpIC8gMjtcclxuXHJcbiAgICBjb25zdCB2MXggPSAoeDFwIC0gY3hwKSAvIHJ4O1xyXG4gICAgY29uc3QgdjF5ID0gKHkxcCAtIGN5cCkgLyByeTtcclxuICAgIGNvbnN0IHYyeCA9ICgteDFwIC0gY3hwKSAvIHJ4O1xyXG4gICAgY29uc3QgdjJ5ID0gKC15MXAgLSBjeXApIC8gcnk7XHJcblxyXG4gICAgY29uc3QgdGhldGEgPSB0aGlzLl9fdmVjdG9yQW5nbGUoMSwgMCwgdjF4LCB2MXkpO1xyXG4gICAgbGV0IGRlbHRhVGhldGEgPSB0aGlzLl9fdmVjdG9yQW5nbGUodjF4LCB2MXksIHYyeCwgdjJ5KTtcclxuXHJcbiAgICBpZiAoZnMgPT09IDAgJiYgZGVsdGFUaGV0YSA+IDApIHtcclxuICAgICAgZGVsdGFUaGV0YSAtPSBNYXRoLlBJICogMjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnMgPT09IDEgJiYgZGVsdGFUaGV0YSA8IDApIHtcclxuICAgICAgZGVsdGFUaGV0YSArPSBNYXRoLlBJICogMjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2N4LCBjeSwgdGhldGEsIGRlbHRhVGhldGFdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQlZHIHBhdGggZGF0YSBwYXJzZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBweCBDb250ZXh0IGN1cnJlbnQgcG9zaXRpb24geC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHkgQ29udGV4dCBjdXJyZW50IHBvc2l0aW9uIHkuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJ4IEFyYyByYWRpdXMgeC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcnkgQXJjIHJhZGl1cyB5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4QXhpc1JvdGF0aW9uIFJvdGF0aW9uIGluIGRlZ3JlZXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhcmdlRmxhZyBGbGFnIHRvIGRldGVybWluZSB3aGljaCBhcmMgdG8gZHJhdy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc3dlZXBGbGFnIEFub3RoZXIgZmxhZyB0byBkZXRlcm1pbmUgd2hpY2ggYXJjIHRvIGRyYXcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggQ29udGV4dCB0YXJnZXQgKG5leHQpIHBvc2l0aW9uIHguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgQ29udGV4dCB0YXJnZXQgKG5leHQpIHBvc2l0aW9uIHkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bnVtYmVyPj58bnVsbH0gQXJyYXkgb2YgYmV6aWVyIGN1cnZlcyBhdHRyaWJ1dGVzLlxyXG4gICAqL1xyXG4gIF9fYXJjVG9CZXppZXIocHgsIHB5LCByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XHJcbiAgICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICBjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XHJcblxyXG4gICAgY29uc3QgeDFwID0gY29zUGhpICogKHB4IC0geCkgLyAyICsgc2luUGhpICogKHB5IC0geSkgLyAyO1xyXG4gICAgY29uc3QgeTFwID0gLXNpblBoaSAqIChweCAtIHgpIC8gMiArIGNvc1BoaSAqIChweSAtIHkpIC8gMjtcclxuXHJcbiAgICBpZiAoeDFwID09PSAwICYmIHkxcCA9PT0gMCB8fCByeCA9PT0gMCB8fCByeSA9PT0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHJ4ID0gTWF0aC5hYnMocngpO1xyXG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XHJcblxyXG4gICAgY29uc3QgbGFtYmRhID0gKHgxcCAqIHgxcCkgLyAocnggKiByeCkgKyAoeTFwICogeTFwKSAvIChyeSAqIHJ5KTtcclxuXHJcbiAgICBpZiAobGFtYmRhID4gMSkge1xyXG4gICAgICBjb25zdCBsYW1iZGFSdCA9IE1hdGguc3FydChsYW1iZGEpO1xyXG4gICAgICByeCAqPSBsYW1iZGFSdDtcclxuICAgICAgcnkgKj0gbGFtYmRhUnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5fX2dldEFyY0NlbnRlcihweCwgcHksIHgsIHksIGxhcmdlRmxhZywgc3dlZXBGbGFnLCByeCwgcnksIHNpblBoaSwgY29zUGhpKTtcclxuICAgIGNvbnN0IGN1cnZlcyA9IFtdO1xyXG4gICAgbGV0IHRoZXRhID0gY2VudGVyWzJdO1xyXG4gICAgbGV0IGRlbHRhVGhldGEgPSBjZW50ZXJbM107XHJcblxyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoZGVsdGFUaGV0YSkgLyAoTWF0aC5QSSAqIDAuNSkpLCAxKTtcclxuICAgIGRlbHRhVGhldGEgLz0gc2VnbWVudHM7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XHJcbiAgICAgIGN1cnZlcy5wdXNoKHRoaXMuX19hcHByb3hVbml0QXJjKHRoZXRhLCBkZWx0YVRoZXRhKSk7XHJcbiAgICAgIHRoZXRhICs9IGRlbHRhVGhldGE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGN1cnZlcy5tYXAoZnVuY3Rpb24gKGN1cnZlKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICBjb25zdCB4ID0gY3VydmVbaV0gKiByeDtcclxuICAgICAgICBjb25zdCB5ID0gY3VydmVbaSArIDFdICogcnk7XHJcbiAgICAgICAgY29uc3QgeHAgPSBjb3NQaGkgKiB4IC0gc2luUGhpICogeTtcclxuICAgICAgICBjb25zdCB5cCA9IHNpblBoaSAqIHggKyBjb3NQaGkgKiB5O1xyXG5cclxuICAgICAgICBjdXJ2ZVtpXSA9IHhwICsgY2VudGVyWzBdO1xyXG4gICAgICAgIGN1cnZlW2kgKyAxXSA9IHlwICsgY2VudGVyWzFdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY3VydmU7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW5nbGUgSlNPTiBmaWxlIGFzc2V0IGNsYXNzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGpzb24gZmlsZS5cclxuICpcclxuICogQGNhdCBhc3NldHNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkFzc2V0XHJcbiAqL1xyXG5jbGFzcyBCVkdBc3NldCBleHRlbmRzIEFzc2V0IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBKU09OQXNzZXQgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBUaGUgVVJMIG9mIHRoZSBqc29uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgdXJsKSB7XHJcbiAgICBzdXBlcihBc3NldFR5cGUuVkVDVE9SX0dSQVBISUNTLCBuYW1lKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1VcmwgPSB1cmw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkdyYXBoaWNzRGF0YXxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tR3JhcGhpY3NEYXRhID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtYSFJBc3NldExvYWRlcnxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tWEhSID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25Mb2FkZXJSZXF1ZXN0ZWQoZmFjdG9yeSkge1xyXG4gICAgdGhpcy5tWEhSID0gZmFjdG9yeS5nZXQoTG9hZGVyVHlwZS5YSFIsIHRoaXMubVVybCk7XHJcbiAgICB0aGlzLm1YSFIubWltZVR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICB0aGlzLm1YSFIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xyXG4gICAgdGhpcy5hZGRMb2FkZXIodGhpcy5tWEhSKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBjb25zdCBkYXRhID0gLyoqIEB0eXBlIHshT2JqZWN0fSovKHRoaXMubVhIUi5kYXRhKTtcclxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCVkdQYXJzZXIoKTtcclxuXHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEgPSBwYXJzZXIucGFyc2UoZGF0YSk7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcbiAgICBzdXBlci5yZWFkeSh0aGlzLm1HcmFwaGljc0RhdGEpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbmdsZSBKU09OIGZpbGUgYXNzZXQgY2xhc3MgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcganNvbiBmaWxlLlxyXG4gKlxyXG4gKiBAY2F0IGFzc2V0c1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+QXNzZXRcclxuICovXHJcblxyXG5jbGFzcyBWZWN0b3JUZXh0dXJlQXNzZXQgZXh0ZW5kcyBBc3NldCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgSlNPTkFzc2V0IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYXNzZXQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgVGhlIFVSTCBvZiB0aGUganNvbi5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJha2VTZWxmIEZsYWcgdG8gYmFrZSBmdWxsIEJWRyBhcyB0ZXh0dXJlLiBJZiBmYWxzZSByb290IHdpbGwgbm90IGJlIGJha2VkLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFrZUNoaWxkcmVuIEZsYWcgdG8gYmFrZSBlYWNoIG5vZGUgd2l0aCBpZCB0byB0ZXh0dXJlcy4gSWYgZmFsc2Ugbm9uZSBjaGlsZHJlbiBub2RlcyB3aWxsIGJlIGJha2VkLlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gbmFtZXNUb0Jha2UgQ29uY3JldGUgbm9kZXMgaWRzIHRvIGJha2UuIFdvcmtzIG9ubHkgaWYgYmFrZUNoaWxkcmVuIGlzIHNldCB0byB0cnVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobmFtZSwgdXJsLCBiYWtlU2VsZiwgYmFrZUNoaWxkcmVuLCBuYW1lc1RvQmFrZSkge1xyXG4gICAgc3VwZXIoQXNzZXRUeXBlLlZFQ1RPUl9URVhUVVJFLCBuYW1lKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1VcmwgPSB1cmw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJha2VTZWxmID0gYmFrZVNlbGY7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJha2VDaGlsZHJlbiA9IGJha2VDaGlsZHJlbjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTmFtZXNUb0Jha2UgPSAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovIChiYWtlQ2hpbGRyZW4gJiYgbmFtZXNUb0Jha2UgPyBuYW1lc1RvQmFrZSA6IFtdKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5YSFJBc3NldExvYWRlcnxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tWEhSID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25Mb2FkZXJSZXF1ZXN0ZWQoZmFjdG9yeSkge1xyXG4gICAgdGhpcy5tWEhSID0gZmFjdG9yeS5nZXQoTG9hZGVyVHlwZS5YSFIsIHRoaXMubVVybCk7XHJcbiAgICB0aGlzLm1YSFIubWltZVR5cGUgPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICB0aGlzLm1YSFIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xyXG4gICAgdGhpcy5hZGRMb2FkZXIodGhpcy5tWEhSKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BbGxMb2FkZWQoKSB7XHJcbiAgICBjb25zdCBkYXRhID0gLyoqIEB0eXBlIHshT2JqZWN0fSovKHRoaXMubVhIUi5kYXRhKTtcclxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBCVkdQYXJzZXIoKTtcclxuXHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEgPSBwYXJzZXIucGFyc2UoZGF0YSk7XHJcbiAgICB0aGlzLm1HcmFwaGljc0RhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcbiAgICBjb25zdCBiYWtlZFRleHR1cmVzID0gdGhpcy5iYWtlVGV4dHVyZXMoKTtcclxuICAgIGNvbnN0IHJldCA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IG5hbWUgaW4gYmFrZWRUZXh0dXJlcykge1xyXG4gICAgICBpZiAoIWJha2VkVGV4dHVyZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICByZXQucHVzaCh7IG5hbWU6IG5hbWUsIGRhdGE6IGJha2VkVGV4dHVyZXNbbmFtZV0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIucmVhZHkocmV0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYmFrZWQgdGV4dHVyZXMgZnJvbSB0aGlzIGdyYXBoaWNzIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgYmxhY2stZW5naW5lfkNhbnZhc1JlbmRlclRleHR1cmU+fVxyXG4gICAqL1xyXG4gIGJha2VUZXh0dXJlcygpIHtcclxuICAgIGNvbnN0IHRleHR1cmVzID0ge307XHJcbiAgICBjb25zdCBuYW1lc1RvQmFrZSA9IHRoaXMubU5hbWVzVG9CYWtlO1xyXG5cclxuICAgIGlmICh0aGlzLm1CYWtlQ2hpbGRyZW4gJiYgbmFtZXNUb0Jha2UubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnN0IHRyYXZlcnNlID0gbm9kZXMgPT4ge1xyXG4gICAgICAgIG5vZGVzID0gLyoqIEB0eXBlIHtBcnJheTxHcmFwaGljc0RhdGE+fSAqLyhub2Rlcyk7XHJcblxyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAobm9kZXNbaV0ubmFtZSlcclxuICAgICAgICAgICAgbmFtZXNUb0Jha2UucHVzaCgvKiogQHR5cGUge3N0cmluZ30gKi8obm9kZXNbaV0ubmFtZSkpO1xyXG5cclxuICAgICAgICAgIHRyYXZlcnNlKC8qKiBAdHlwZSB7QXJyYXk8R3JhcGhpY3NEYXRhPn0gKi8obm9kZXNbaV0ubU5vZGVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdHJhdmVyc2UodGhpcy5tR3JhcGhpY3NEYXRhLm1Ob2Rlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubUJha2VTZWxmKVxyXG4gICAgICBuYW1lc1RvQmFrZS51bnNoaWZ0KHRoaXMubUdyYXBoaWNzRGF0YS5uYW1lKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5hbWVzVG9CYWtlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBjb25zdCBuYW1lID0gbmFtZXNUb0Jha2VbaV07XHJcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm1HcmFwaGljc0RhdGEuc2VhcmNoTm9kZShuYW1lKTtcclxuXHJcbiAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIERlYnVnLndhcm4oYFtCVkdBc3NldF0gR3JhcGhpY3NEYXRhIG5vZGUgd2l0aCBpZCAnJHtuYW1lfScgbm90IGZvdW5kLmApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBncmFwaGljcyA9IG5ldyBHcmFwaGljcyhub2RlLCBuYW1lICE9PSB0aGlzLm1HcmFwaGljc0RhdGEubmFtZSk7XHJcbiAgICAgIGNvbnN0IGRwciA9IDEgLyBCbGFjay5kcml2ZXIucmVuZGVyU2NhbGVGYWN0b3I7XHJcbiAgICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSBuZXcgQ2FudmFzUmVuZGVyVGV4dHVyZShncmFwaGljcy53aWR0aCwgZ3JhcGhpY3MuaGVpZ2h0LCAxKTtcclxuXHJcbiAgICAgIEJsYWNrLmRyaXZlci5yZW5kZXIoZ3JhcGhpY3MsIHJlbmRlclRleHR1cmUsIG5ldyBNYXRyaXgoKS5zY2FsZShkcHIsIGRwcikpO1xyXG5cclxuICAgICAgdGV4dHVyZXNbbmFtZV0gPSByZW5kZXJUZXh0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0dXJlcztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIEFzc2V0TWFuYWdlci5cclxuICogXHJcbiAqIEBjYXQgYXNzZXRzXHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBBc3NldE1hbmFnZXJTdGF0ZSA9IHtcclxuICBOT05FICAgICA6ICdub25lJyxcclxuICBMT0FESU5HICA6ICdsb2FkaW5nJyxcclxuICBGSU5JU0hFRCA6ICdmaW5pc2hlZCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGZhY3Rvcnkgb2JqZWN0IHVzZWQgdG8gZ2V0IG9yIGNyZWF0ZSBhIGxvYWRlci5cclxuICogQGNhdCBhc3NldHNcclxuICovXHJcbmNsYXNzIExvYWRlckZhY3Rvcnkge1xyXG4gIC8qKlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkFzc2V0TWFuYWdlcn0gYXNzZXRNYW5hZ2VyIFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGFzc2V0TWFuYWdlcikge1xyXG4gICAgdGhpcy5tQXNzZXRNYW5hZ2VyID0gYXNzZXRNYW5hZ2VyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBleGlzdGluZyBpbnN0YW5jZSBvZiB0aGUgbG9hZGVyIGlmIHVybCBpcyBhbHJlYWR5IGluIHF1ZXVlIG9yIGNyZWF0ZXMgbmV3IGluc3RhbmNlIGlmIG5vdC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xibGFjay1lbmdpbmV+TG9hZGVyVHlwZX0gdXJsIFxyXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXHJcbiAgICogXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Bc3NldExvYWRlcn1cclxuICAgKi9cclxuICBnZXQodHlwZSwgdXJsLCAuLi5hcmdzKSB7XHJcbiAgICBsZXQgYW0gPSB0aGlzLm1Bc3NldE1hbmFnZXI7XHJcbiAgICAvLyBUT0RPOiBpZGVhIGlzIHRvIG5vdCBjcmVhdGUgbmV3IGxvYWRlciBlYWNoIHRpbWUgaXQgaXMgcmVxdWVzdGVkLlxyXG4gICAgLy8gQnV0IHRoZSBwcm9ibGVtIHRoYXQgZm9yIGV4YW1wbGUgWEhSIGNhbiBoYXZlIGRpZmZlcmVudCByZXNwb25zZVR5cGVzLlxyXG5cclxuICAgIC8vIGxldCBsb2FkZXIgPSBhbS5tTG9hZGVyc1F1ZXVlW3VybF07XHJcblxyXG4gICAgLy8gaWYgKGxvYWRlciAhPSB1bmRlZmluZWQpXHJcbiAgICAvLyAgIHJldHVybiBsb2FkZXI7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBhbS5tTG9hZGVyVHlwZU1hcFt0eXBlXSh1cmwsIC4uLmFyZ3MpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIGFzc2V0cyBhbmQgbWFuYWdlcyBpdHMgaW4gbWVtb3J5IHN0YXRlLlxyXG4gKlxyXG4gKiBAZmlyZXMgQXNzZXRNYW5hZ2VyI3Byb2dyZXNzXHJcbiAqIEBmaXJlcyBBc3NldE1hbmFnZXIjY29tcGxldGVcclxuICogQGZpcmVzIEFzc2V0TWFuYWdlciNlcnJvclxyXG4gKlxyXG4gKiBAY2F0IGFzc2V0c1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TWVzc2FnZURpc3BhdGNoZXJcclxuICovXHJcbmNsYXNzIEFzc2V0TWFuYWdlciBleHRlbmRzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBBc3NldE1hbmFnZXIgaW5zdGFuY2UuIEFzc2V0TWFuYWdlciBleHBvc2VzIHN0YXRpYyBwcm9wZXJ0eVxyXG4gICAqIGNhbGxlZCAnZGVmYXVsdCcgYW5kIG1hbnkgaW50ZXJuYWwgY2xhc3NlcyB1c2VzIGRlZmF1bHQgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGlmIChCbGFjay5hc3NldHMgPT09IG51bGwpXHJcbiAgICAgIEJsYWNrLmFzc2V0cyA9IHRoaXM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRGVmYXVsdFBhdGggPSAnJztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ub3RhbExvYWRlZCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVG90YWxQZW5kaW5nID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ub3RhbEVycm9ycyA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzQWxsTG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTG9hZGluZ1Byb2dyZXNzID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+QXNzZXQ+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUXVldWUgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYmxhY2stZW5naW5lfkFzc2V0TG9hZGVyPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvYWRlcnNRdWV1ZSA9IHt9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Bc3NldE1hbmFnZXJTdGF0ZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YXRlID0gQXNzZXRNYW5hZ2VyU3RhdGUuTk9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkxvYWRlckZhY3Rvcnl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxvYWRlckZhY3RvcnkgPSBuZXcgTG9hZGVyRmFjdG9yeSh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm1Bc3NldHMgPSB7fTtcclxuICAgIHRoaXMubUFzc2V0VHlwZU1hcCA9IHt9O1xyXG4gICAgdGhpcy5tTG9hZGVyVHlwZU1hcCA9IHt9O1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJEZWZhdWx0VHlwZXMoKTtcclxuICB9XHJcblxyXG4gIHJlZ2lzdGVyRGVmYXVsdFR5cGVzKCkge1xyXG4gICAgLy8gVGV4dHVyZXNcclxuICAgIHRoaXMubUFzc2V0VHlwZU1hcFtBc3NldFR5cGUuVEVYVFVSRV0gPSBUZXh0dXJlQXNzZXQ7XHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlRFWFRVUkVfQVRMQVNdID0gQXRsYXNUZXh0dXJlQXNzZXQ7XHJcblxyXG4gICAgLy8gVmVjdG9yXHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlZFQ1RPUl9HUkFQSElDU10gPSBCVkdBc3NldDtcclxuXHJcbiAgICAvLyBWZWN0b3IgdGV4dHVyZXMgXHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlZFQ1RPUl9URVhUVVJFXSA9IFZlY3RvclRleHR1cmVBc3NldDtcclxuICAgIC8vdGhpcy5tQXNzZXRUeXBlTWFwW0Fzc2V0VHlwZS5WRUNUT1JfVEVYVFVSRV9BVExBU10gPSBWZWN0b3JUZXh0dXJlQXNzZXQ7XHJcblxyXG4gICAgLy8gRm9udHNcclxuICAgIHRoaXMubUFzc2V0VHlwZU1hcFtBc3NldFR5cGUuRk9OVF0gPSBGb250QXNzZXQ7XHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLkJJVE1BUF9GT05UXSA9IEJpdG1hcEZvbnRBc3NldDtcclxuXHJcbiAgICAvLyBKU09OICYgWE1MXHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlhNTF0gPSBYTUxBc3NldDtcclxuICAgIHRoaXMubUFzc2V0VHlwZU1hcFtBc3NldFR5cGUuSlNPTl0gPSBKU09OQXNzZXQ7XHJcblxyXG4gICAgLy8gU291bmRzXHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlNPVU5EXSA9IFNvdW5kQXNzZXQ7XHJcbiAgICB0aGlzLm1Bc3NldFR5cGVNYXBbQXNzZXRUeXBlLlNPVU5EX0FUTEFTXSA9IFNvdW5kQXRsYXNBc3NldDtcclxuXHJcbiAgICAvLyBMb2FkZXJzXHJcbiAgICB0aGlzLm1Mb2FkZXJUeXBlTWFwW0xvYWRlclR5cGUuRk9OVF9GQUNFXSA9IEZvbnRGYWNlQXNzZXRMb2FkZXI7XHJcbiAgICB0aGlzLm1Mb2FkZXJUeXBlTWFwW0xvYWRlclR5cGUuSU1BR0VdID0gSW1hZ2VBc3NldExvYWRlcjtcclxuICAgIHRoaXMubUxvYWRlclR5cGVNYXBbTG9hZGVyVHlwZS5YSFJdID0gWEhSQXNzZXRMb2FkZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGFzc2V0IHR5cGUuIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIG92ZXJyaWRlIEFzc2V0IHdpdGggeW91ciBvd24uXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXHJcbiAgICovXHJcbiAgc2V0QXNzZXRUeXBlKG5hbWUsIHR5cGUpIHtcclxuICAgIHRoaXMubUFzc2V0VHlwZU1hcFtuYW1lXSA9IHR5cGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGxvYWRlciB0eXBlLiBVc2UgdGhpcyBtZXRob2QgdG8gb3ZlcnJpZGUgZGVmYXVsdCBsb2FkZXJzIHdpdGggY3VzdG9tIG9uZXMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXHJcbiAgICovXHJcbiAgc2V0TG9hZGVyVHlwZShuYW1lLCB0eXBlKSB7XHJcbiAgICB0aGlzLm1Mb2FkZXJUeXBlTWFwW25hbWVdID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYXNzZXQgaW50byB0aGUgbG9hZGluZyBxdWV1ZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Bc3NldH0gYXNzZXQgXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZUFzc2V0KG5hbWUsIGFzc2V0KSB7XHJcbiAgICB0aGlzLl9fdmFsaWRhdGVTdGF0ZSgpO1xyXG4gICAgdGhpcy5fX3ZhbGlkYXRlTmFtZShhc3NldC50eXBlLCBuYW1lKTtcclxuXHJcbiAgICB0aGlzLm1RdWV1ZS5wdXNoKGFzc2V0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbmV3IGFzc2V0IGluc3RhbmNlIGJ5IGdpdmVuIHR5cGUuXHJcbiAgICogXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xibGFjay1lbmdpbmV+QXNzZXRUeXBlfSB0eXBlIFxyXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcclxuICAgKi9cclxuICBfX2dldEFzc2V0KHR5cGUsIC4uLmFyZ3MpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcy5tQXNzZXRUeXBlTWFwW3R5cGVdKC4uLmFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvciBjaGFuZ2VzIHRleHR1cmUgdG8gdGhlIGludGVybmFsIGxpc3QgZm9yIGZ1dHVyZSByZXVzZSBieSBnaXZlbiBuYW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dHVyZX0gdGV4dHVyZVxyXG4gICAqL1xyXG4gIGFkZFRleHR1cmUobmFtZSwgdGV4dHVyZSkge1xyXG4gICAgdGhpcy5tVGV4dHVyZXNbbmFtZV0gPSB0ZXh0dXJlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzaW5nbGUgaW1hZ2UgdG8gdGhlIGxvYWRpbmcgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBUaGUgVVJMIG9mIHRoZSBpbWFnZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBlbnF1ZXVlSW1hZ2UobmFtZSwgdXJsKSB7XHJcbiAgICB0aGlzLmVucXVldWVBc3NldChuYW1lLCB0aGlzLl9fZ2V0QXNzZXQoQXNzZXRUeXBlLlRFWFRVUkUsIG5hbWUsIHRoaXMubURlZmF1bHRQYXRoICsgdXJsKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGF0bGFzIHRvIHRoZSBsb2FkaW5nIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgIE5hbWUgb2YgdGhlIGFzc2V0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZVVybCBBdGxhcyBVUkwuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFVcmwgIFVSTCB0byB0aGUgLmpzb24gZmlsZSB3aGljaCBkZXNjcmliZXMgdGhlIGF0bGFzLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGVucXVldWVBdGxhcyhuYW1lLCBpbWFnZVVybCwgZGF0YVVybCkge1xyXG4gICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5URVhUVVJFX0FUTEFTLCBuYW1lLCB0aGlzLm1EZWZhdWx0UGF0aCArIGltYWdlVXJsLCB0aGlzLm1EZWZhdWx0UGF0aCArIGRhdGFVcmwpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYml0bWFwIGZvbnQgdG8gdGhlIGxvYWRpbmcgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgTmFtZSBvZiB0aGUgZm9udC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VVcmwgSW1hZ2UgVVJMLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB4bWxVcmwgICBVUkwgdG8gdGhlIC54bWwgZmlsZSB3aGljaCBkZXNjcmliZXMgdGhlIGZvbnQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZUJpdG1hcEZvbnQobmFtZSwgaW1hZ2VVcmwsIHhtbFVybCkge1xyXG4gICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5CSVRNQVBfRk9OVCwgbmFtZSwgdGhpcy5tRGVmYXVsdFBhdGggKyBpbWFnZVVybCwgdGhpcy5tRGVmYXVsdFBhdGggKyB4bWxVcmwpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgc2luZ2xlIHhtbCBmaWxlIHRvIHRoZSBsb2FkaW5nIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYXNzZXQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgVGhlIFVSTCBvZiB0aGUganNvbi5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBlbnF1ZXVlWE1MKG5hbWUsIHVybCkge1xyXG4gICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5YTUwsIG5hbWUsIHRoaXMubURlZmF1bHRQYXRoICsgdXJsKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHNpbmdsZSBqc29uIGZpbGUgdG8gdGhlIGxvYWRpbmcgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBUaGUgVVJMIG9mIHRoZSBqc29uLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGVucXVldWVKU09OKG5hbWUsIHVybCkge1xyXG4gICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5KU09OLCBuYW1lLCB0aGlzLm1EZWZhdWx0UGF0aCArIHVybCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzaW5nbGUgQmxhY2sgVmVjdG9yIEdyYXBoaWNzIGZpbGUgdG8gdGhlIGxvYWRpbmcgcXVldWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICBUaGUgVVJMIG9mIHRoZSBqc29uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZVZlY3RvcihuYW1lLCB1cmwpIHtcclxuICAgIHRoaXMuZW5xdWV1ZUFzc2V0KG5hbWUsIHRoaXMuX19nZXRBc3NldChBc3NldFR5cGUuVkVDVE9SX0dSQVBISUNTLCBuYW1lLCB0aGlzLm1EZWZhdWx0UGF0aCArIHVybCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzaW5nbGUgQmxhY2sgVmVjdG9yIEdyYXBoaWNzIGZpbGUgdG8gdGhlIGxvYWRpbmcgcXVldWUgYW5kIGJha2VzIGl0IGludG8gdGhlIFRleHR1cmUuXHJcbiAgICogXHJcbiAgICogSWYgYmFrZWQgYm90aCBncmFwaGljcyBkYXRhIGFuZCBiYWtlZCB0ZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGluc2lkZSB0aGlzIEFzc2V0TWFuYWdlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGFzc2V0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgb2YgdGhlIGpzb24uXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gW2Jha2VTZWxmPWZhbHNlXSBGbGFnIHRvIGJha2UgZnVsbCBCVkcgYXMgdGV4dHVyZS4gSWYgZmFsc2Ugcm9vdCB3aWxsIG5vdCBiZSBiYWtlZC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbYmFrZUNoaWxkcmVuPWZhbHNlXSBGbGFnIHRvIGJha2UgZWFjaCBub2RlIHdpdGggaWQgdG8gdGV4dHVyZXMuIElmIGZhbHNlIG5vbmUgY2hpbGRyZW4gbm9kZXMgd2lsbCBiZSBiYWtlZC5cclxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz49fSBbbmFtZXNUb0Jha2U9bnVsbF0gQ29uY3JldGUgbm9kZXMgaWRzIHRvIGJha2UuIFdvcmtzIG9ubHkgaWYgYmFrZUNoaWxkcmVuIGlzIHNldCB0byB0cnVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZVZlY3RvclRleHR1cmUobmFtZSwgdXJsLCBiYWtlU2VsZiA9IGZhbHNlLCBiYWtlQ2hpbGRyZW4gPSBmYWxzZSwgbmFtZXNUb0Jha2UgPSBudWxsKSB7XHJcbiAgICBpZiAoYmFrZVNlbGYgPT09IHRydWUgfHwgYmFrZUNoaWxkcmVuID09PSB0cnVlKVxyXG4gICAgICB0aGlzLmVucXVldWVBc3NldChuYW1lLCB0aGlzLl9fZ2V0QXNzZXQoQXNzZXRUeXBlLlZFQ1RPUl9URVhUVVJFLCBuYW1lLCB0aGlzLm1EZWZhdWx0UGF0aCArIHVybCwgYmFrZVNlbGYsIGJha2VDaGlsZHJlbiwgbmFtZXNUb0Jha2UpKTtcclxuICB9XHJcblxyXG4gIC8vIC8qKlxyXG4gIC8vICAqIEFkZHMgc2luZ2xlIEJsYWNrIFZlY3RvciBHcmFwaGljcyBmaWxlIHRvIHRoZSBsb2FkaW5nIHF1ZXVlIGFuZCBiYWtlcyBpdCBpbnRvIHRoZSBBdGxhc1RleHR1cmUuXHJcbiAgLy8gICogXHJcbiAgLy8gICogSWYgYmFrZWQgYm90aCBncmFwaGljcyBkYXRhIGFuZCBiYWtlZCB0ZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGluc2lkZSB0aGlzIEFzc2V0TWFuYWdlci5cclxuICAvLyAgKlxyXG4gIC8vICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGFzc2V0LlxyXG4gIC8vICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgb2YgdGhlIGpzb24uXHJcbiAgLy8gICogQHBhcmFtIHtib29sZWFuPX0gW2Jha2VTZWxmPWZhbHNlXSBGbGFnIHRvIGJha2UgZnVsbCBCVkcgYXMgdGV4dHVyZS4gSWYgZmFsc2Ugcm9vdCB3aWxsIG5vdCBiZSBiYWtlZC5cclxuICAvLyAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbYmFrZUNoaWxkcmVuPWZhbHNlXSBGbGFnIHRvIGJha2UgZWFjaCBub2RlIHdpdGggaWQgdG8gdGV4dHVyZXMuIElmIGZhbHNlIG5vbmUgY2hpbGRyZW4gbm9kZXMgd2lsbCBiZSBiYWtlZC5cclxuICAvLyAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz49fSBbbmFtZXNUb0Jha2U9bnVsbF0gQ29uY3JldGUgbm9kZXMgaWRzIHRvIGJha2UuIFdvcmtzIG9ubHkgaWYgYmFrZUNoaWxkcmVuIGlzIHNldCB0byB0cnVlLlxyXG4gIC8vICAqXHJcbiAgLy8gICogQHJldHVybnMge3ZvaWR9XHJcbiAgLy8gICovXHJcbiAgLy8gZW5xdWV1ZVZlY3RvckF0bGFzKG5hbWUsIHVybCwgYmFrZVNlbGYgPSBmYWxzZSwgYmFrZUNoaWxkcmVuID0gZmFsc2UsIG5hbWVzVG9CYWtlID0gbnVsbCkge1xyXG4gIC8vICAgaWYgKGJha2VTZWxmID09PSB0cnVlIHx8IGJha2VDaGlsZHJlbiA9PT0gdHJ1ZSlcclxuICAvLyAgICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5WRUNUT1JfVEVYVFVSRV9BVExBUywgbmFtZSwgdGhpcy5tRGVmYXVsdFBhdGggKyB1cmwsIGJha2VTZWxmLCBiYWtlQ2hpbGRyZW4sIG5hbWVzVG9CYWtlKSk7XHJcbiAgLy8gfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHNpbmdsZSBzb3VuZCB0byB0aGUgbG9hZGluZyBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHNvdW5kLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgb2YgdGhlIHNvdW5kLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGVucXVldWVTb3VuZChuYW1lLCB1cmwpIHtcclxuICAgIHRoaXMuZW5xdWV1ZUFzc2V0KG5hbWUsIHRoaXMuX19nZXRBc3NldChBc3NldFR5cGUuU09VTkQsIG5hbWUsIHRoaXMubURlZmF1bHRQYXRoICsgdXJsKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHNvdW5kIGF0bGFzIHRvIHRoZSBsb2FkaW5nIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgc291bmQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdW5kVXJsICBUaGUgVVJMIG9mIHRoZSBzb3VuZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVybCAgVGhlIFVSTCBvZiB0aGUgZGF0YSBKU09OLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIGVucXVldWVTb3VuZEF0bGFzKG5hbWUsIHNvdW5kVXJsLCBkYXRhVXJsKSB7XHJcbiAgICB0aGlzLmVucXVldWVBc3NldChuYW1lLCB0aGlzLl9fZ2V0QXNzZXQoQXNzZXRUeXBlLlNPVU5EX0FUTEFTLCBuYW1lLCB0aGlzLm1EZWZhdWx0UGF0aCArIHNvdW5kVXJsLCB0aGlzLm1EZWZhdWx0UGF0aCArIGRhdGFVcmwpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgbG9jYWwgZm9udCB0byB0aGUgbG9hZGluZyBxdWV1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGFzc2V0LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgIFRoZSBVUkwgdG8gdGhlIGZvbnQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZUZvbnQobmFtZSwgdXJsKSB7XHJcbiAgICB0aGlzLmVucXVldWVBc3NldChuYW1lLCB0aGlzLl9fZ2V0QXNzZXQoQXNzZXRUeXBlLkZPTlQsIG5hbWUsIHRoaXMubURlZmF1bHRQYXRoICsgdXJsLCB0cnVlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIEdvb2dsZSBGb250IHRvIHRoZSBsb2FkaW5nIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYXNzZXQuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5xdWV1ZUdvb2dsZUZvbnQobmFtZSkge1xyXG4gICAgdGhpcy5lbnF1ZXVlQXNzZXQobmFtZSwgdGhpcy5fX2dldEFzc2V0KEFzc2V0VHlwZS5GT05ULCBuYW1lLCAnJywgZmFsc2UpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBsb2FkaW5nIGFsbCBlbnF1ZXVlZCBhc3NldHMuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgY29tcGxldGVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGxvYWRRdWV1ZSgpIHtcclxuICAgIHRoaXMuX192YWxpZGF0ZVN0YXRlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMubVF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1TdGF0ZSA9IEFzc2V0TWFuYWdlclN0YXRlLkxPQURJTkc7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1RdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgaXRlbSA9IHRoaXMubVF1ZXVlW2ldO1xyXG5cclxuICAgICAgaXRlbS5vbkxvYWRlclJlcXVlc3RlZCh0aGlzLm1Mb2FkZXJGYWN0b3J5KTtcclxuXHJcbiAgICAgIGlmIChpdGVtLmxvYWRlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGl0ZW0ub25jZShNZXNzYWdlLkNPTVBMRVRFLCB0aGlzLm9uQXNzZXRMb2FkZWQsIHRoaXMpO1xyXG4gICAgICAgIGl0ZW0ub25jZShNZXNzYWdlLkVSUk9SLCB0aGlzLm9uQXNzZXRFcnJvciwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMubVRvdGFsUGVuZGluZysrO1xyXG5cclxuICAgICAgICBpdGVtLmxvYWRlcnMuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgICAgIC8vdGhpcy5tTG9hZGVyc1F1ZXVlW3gudXJsXSA9IHg7XHJcbiAgICAgICAgICB4LmxvYWQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExvYWRlciB3aWxsIG5vdGlmeSBBc3NldCB3aGVuIGl0cyByZWFkeS4gQXNzZXQgd2lsbCBub3RpZnkgQXNzZXRNYW5hZ2VyLlxyXG4gICAgLy8gZm9yIChjb25zdCBrZXkgaW4gdGhpcy5tTG9hZGVyc1F1ZXVlKSB7XHJcbiAgICAvLyAgIGlmICh0aGlzLm1Mb2FkZXJzUXVldWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgLy8gICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubUxvYWRlcnNRdWV1ZVtrZXldO1xyXG4gICAgLy8gICAgIGxvYWRlci5sb2FkKCk7XHJcbiAgICAvLyAgIH1cclxuICAgIC8vIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWVzc2FnZX0gbXNnXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvbkFzc2V0TG9hZGVkKG1zZykge1xyXG4gICAgdGhpcy5tVG90YWxMb2FkZWQrKztcclxuICAgIHRoaXMubUxvYWRpbmdQcm9ncmVzcyA9IHRoaXMubVRvdGFsTG9hZGVkIC8gdGhpcy5tVG90YWxQZW5kaW5nO1xyXG5cclxuICAgIGxldCBpdGVtID0gLyoqIEB0eXBlIHtBc3NldH0qLyAobXNnLnNlbmRlcik7XHJcbiAgICBpdGVtLm9mZihNZXNzYWdlLkNPTVBMRVRFLCBNZXNzYWdlLkVSUk9SKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQXNzZXRzW2l0ZW0udHlwZV0gPT0gbnVsbClcclxuICAgICAgdGhpcy5tQXNzZXRzW2l0ZW0udHlwZV0gPSB7fTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLmRhdGEpKSB7XHJcbiAgICAgIGxldCBvYmplY3RzID0gKGl0ZW0uZGF0YSk7XHJcblxyXG4gICAgICBvYmplY3RzLmZvckVhY2goeCA9PiB7XHJcbiAgICAgICAgdGhpcy5fX3ZhbGlkYXRlTmFtZSh4Lm5hbWUpO1xyXG4gICAgICAgIHRoaXMubUFzc2V0c1tpdGVtLnR5cGVdW3gubmFtZV0gPSB4LmRhdGE7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLm1Bc3NldHNbaXRlbS50eXBlXVtpdGVtLm5hbWVdID0gaXRlbS5kYXRhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zdGVkIHdoZW4gbG9hZGluZyBwcm9ncmVzcyBpcyBjaGFuZ2VkLlxyXG4gICAgICogQGV2ZW50IEFzc2V0TWFuYWdlciNwcm9ncmVzc1xyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5QUk9HUkVTUywgdGhpcy5tTG9hZGluZ1Byb2dyZXNzKTtcclxuXHJcbiAgICBpZiAodGhpcy5tVG90YWxMb2FkZWQgPT09IHRoaXMubVRvdGFsUGVuZGluZykge1xyXG4gICAgICB0aGlzLm1RdWV1ZS5zcGxpY2UoMCwgdGhpcy5tUXVldWUubGVuZ3RoKTtcclxuICAgICAgdGhpcy5tTG9hZGVyc1F1ZXVlID0ge307XHJcbiAgICAgIHRoaXMubVN0YXRlID0gQXNzZXRNYW5hZ2VyU3RhdGUuRklOSVNIRUQ7XHJcbiAgICAgIHRoaXMubVRvdGFsTG9hZGVkID0gMDtcclxuICAgICAgdGhpcy5tVG90YWxFcnJvcnMgPSAwO1xyXG4gICAgICB0aGlzLm1Ub3RhbFBlbmRpbmcgPSAwO1xyXG4gICAgICB0aGlzLm1Jc0FsbExvYWRlZCA9IHRydWU7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUG9zdGVkIHdoZW4gYWxsIGFzc2V0cyBmaW5pc2hlZCBsb2FkaW5nLlxyXG4gICAgICAgKiBAZXZlbnQgQXNzZXRNYW5hZ2VyI2NvbXBsZXRlXHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkFzc2V0RXJyb3IobXNnKSB7XHJcbiAgICB0aGlzLm1Ub3RhbEVycm9ycysrO1xyXG5cclxuICAgIGxldCB0b3RhbCA9IHRoaXMubVRvdGFsTG9hZGVkICsgdGhpcy5tVG90YWxFcnJvcnM7XHJcbiAgICB0aGlzLm1Mb2FkaW5nUHJvZ3Jlc3MgPSB0aGlzLm1Ub3RhbExvYWRlZCAvIHRoaXMubVRvdGFsUGVuZGluZztcclxuXHJcbiAgICBsZXQgaXRlbSA9IC8qKiBAdHlwZSB7QXNzZXR9Ki8gKG1zZy5zZW5kZXIpO1xyXG5cclxuICAgIGl0ZW0ub2ZmKE1lc3NhZ2UuQ09NUExFVEUsIE1lc3NhZ2UuRVJST1IpO1xyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gRXJyb3IgbG9hZGluZyBhc3NldCAnJHtpdGVtLm5hbWV9Jy5gKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvc3RlZCB3aGVuIGVycm9yIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgYXNzZXRzLlxyXG4gICAgICogQGV2ZW50IEFzc2V0TWFuYWdlciNjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5FUlJPUiwgaXRlbSk7XHJcblxyXG4gICAgaWYgKHRvdGFsID09PSB0aGlzLm1Ub3RhbFBlbmRpbmcpIHtcclxuICAgICAgdGhpcy5tUXVldWUuc3BsaWNlKDAsIHRoaXMubVF1ZXVlLmxlbmd0aCk7XHJcbiAgICAgIHRoaXMubUxvYWRlcnNRdWV1ZSA9IHt9O1xyXG4gICAgICB0aGlzLm1TdGF0ZSA9IEFzc2V0TWFuYWdlclN0YXRlLkZJTklTSEVEO1xyXG4gICAgICB0aGlzLm1Ub3RhbExvYWRlZCA9IDA7XHJcbiAgICAgIHRoaXMubVRvdGFsRXJyb3JzID0gMDtcclxuICAgICAgdGhpcy5tVG90YWxQZW5kaW5nID0gMDtcclxuICAgICAgdGhpcy5tSXNBbGxMb2FkZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIEJpdG1hcEZvbnREYXRhIG9iamVjdCBieSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFzc2V0IHRvIHNlYXJjaC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Qml0bWFwRm9udERhdGF8bnVsbH0gUmV0dXJucyBhIEJpdG1hcEZvbnREYXRhIGlmIGZvdW5kIG9yIG51bGwuXHJcbiAgICovXHJcbiAgZ2V0Qml0bWFwRm9udChuYW1lKSB7XHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5CaXRtYXBGb250RGF0YX0gKi9cclxuICAgIGxldCBmb250ID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5CSVRNQVBfRk9OVF1bbmFtZV07XHJcblxyXG4gICAgaWYgKGZvbnQgIT0gbnVsbClcclxuICAgICAgcmV0dXJuIGZvbnQ7XHJcblxyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gQml0bWFwRm9udERhdGEgJyR7bmFtZX0nIHdhcyBub3QgZm91bmQuYCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgVGV4dHVyZSBvYmplY3QgYnkgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBc3NldC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VGV4dHVyZXxudWxsfSBSZXR1cm5zIGEgVGV4dHVyZSBpZiBmb3VuZCBvciBudWxsLlxyXG4gICAqL1xyXG4gIGdldFRleHR1cmUobmFtZSkge1xyXG4gICAgbGV0IHRleHR1cmVzID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5URVhUVVJFXTtcclxuICAgIGlmICh0ZXh0dXJlcyAhPSBudWxsKSB7XHJcbiAgICAgIC8qKiBAdHlwZSB7VGV4dHVyZX0gKi9cclxuICAgICAgbGV0IHQgPSB0ZXh0dXJlc1tuYW1lXTtcclxuXHJcbiAgICAgIGlmICh0ICE9IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHRleHR1cmVBdGxhc2VzID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5URVhUVVJFX0FUTEFTXTtcclxuICAgIGlmICh0ZXh0dXJlQXRsYXNlcyAhPSBudWxsKSB7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiB0ZXh0dXJlQXRsYXNlcykge1xyXG4gICAgICAgIGxldCB0ID0gdGV4dHVyZUF0bGFzZXNba2V5XS5zdWJUZXh0dXJlc1tuYW1lXTtcclxuXHJcbiAgICAgICAgaWYgKHQgIT0gbnVsbClcclxuICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHZlY3RvclRleHR1cmVzID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5WRUNUT1JfVEVYVFVSRV07XHJcbiAgICBpZiAodmVjdG9yVGV4dHVyZXMgIT0gbnVsbCkge1xyXG4gICAgICBsZXQgdCA9IHZlY3RvclRleHR1cmVzW25hbWVdO1xyXG5cclxuICAgICAgaWYgKHQgIT0gbnVsbClcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdmVjdG9yVGV4dHVyZUF0bGFzZXMgPSB0aGlzLm1Bc3NldHNbQXNzZXRUeXBlLlZFQ1RPUl9URVhUVVJFX0FUTEFTXTtcclxuICAgIGlmICh2ZWN0b3JUZXh0dXJlQXRsYXNlcyAhPSBudWxsKSB7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiB2ZWN0b3JUZXh0dXJlQXRsYXNlcykge1xyXG4gICAgICAgIGxldCB0ID0gdmVjdG9yVGV4dHVyZUF0bGFzZXNba2V5XS5zdWJUZXh0dXJlc1tuYW1lXTtcclxuXHJcbiAgICAgICAgaWYgKHQgIT0gbnVsbClcclxuICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gVGV4dHVyZSAnJHtuYW1lfScgd2FzIG5vdCBmb3VuZC5gKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBHcmFwaGljcyBkYXRhIGJ5IGdpdmVuIG5hbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5HcmFwaGljc0RhdGF9XHJcbiAgICovXHJcbiAgZ2V0R3JhcGhpY3NEYXRhKG5hbWUpIHtcclxuICAgIGxldCB2ZWN0b3JzID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5WRUNUT1JfR1JBUEhJQ1NdO1xyXG5cclxuICAgIGlmICh2ZWN0b3JzID09IG51bGwpXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7R3JhcGhpY3NEYXRhfSAqL1xyXG4gICAgbGV0IGRhdGEgPSB2ZWN0b3JzW25hbWVdO1xyXG5cclxuICAgIGlmIChkYXRhKVxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuXHJcbiAgICBmb3IgKGxldCBrZXkgaW4gdmVjdG9ycykge1xyXG4gICAgICBkYXRhID0gdmVjdG9yc1trZXldLnNlYXJjaE5vZGUobmFtZSk7XHJcblxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gR3JhcGhpY3NEYXRhICcke25hbWV9JyB3YXMgbm90IGZvdW5kLmApO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFycmF5IG9mIFRleHR1cmUgYnkgZ2l2ZW4gbmFtZSBtYXNrLlxyXG4gICAqIFNlYXJjaGVzIGFjcm9zcyBhbGwgbG9hZGVkIGltYWdlcyBhbmQgYXRsYXNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lTWFzayBUaGUgbmFtZSBtYXNrLlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxibGFjay1lbmdpbmV+VGV4dHVyZT58bnVsbH1cclxuICAgKi9cclxuICBnZXRUZXh0dXJlcyhuYW1lTWFzaykge1xyXG4gICAgbGV0IHRleHR1cmVzID0gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5URVhUVVJFXTtcclxuICAgIGxldCB0ZXh0dXJlQXRsYXNlcyA9IHRoaXMubUFzc2V0c1tBc3NldFR5cGUuVEVYVFVSRV9BVExBU107XHJcbiAgICBsZXQgdmVjdG9yVGV4dHVyZXMgPSB0aGlzLm1Bc3NldHNbQXNzZXRUeXBlLlZFQ1RPUl9URVhUVVJFXTtcclxuICAgIGxldCB2ZWN0b3JUZXh0dXJlQXRsYXNlcyA9IHRoaXMubUFzc2V0c1tBc3NldFR5cGUuVkVDVE9SX1RFWFRVUkVfQVRMQVNdO1xyXG5cclxuICAgIGxldCBvdXQgPSBbXTtcclxuICAgIGxldCBuYW1lcyA9IFtdO1xyXG5cclxuICAgIGxldCByZSA9IG5ldyBSZWdFeHAoJ14nICsgbmFtZU1hc2suc3BsaXQoJyonKS5qb2luKCcuKicpICsgJyQnKTtcclxuXHJcbiAgICAvLyBjb2xsZWN0IHNpbmdsZSB0ZXh0dXJlc1xyXG4gICAgaWYgKHRleHR1cmVzICE9IG51bGwpIHtcclxuICAgICAgZm9yIChsZXQga2V5IGluIHRleHR1cmVzKVxyXG4gICAgICAgIGlmIChyZS50ZXN0KGtleSkpXHJcbiAgICAgICAgICBuYW1lcy5wdXNoKHsgbmFtZToga2V5LCBhdGxhczogbnVsbCwgaXNCYWtlZFZlY3RvcjogZmFsc2UgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZlY3RvclRleHR1cmVzICE9IG51bGwpIHtcclxuICAgICAgZm9yIChsZXQga2V5IGluIHZlY3RvclRleHR1cmVzKVxyXG4gICAgICAgIGlmIChyZS50ZXN0KGtleSkpXHJcbiAgICAgICAgICBuYW1lcy5wdXNoKHsgbmFtZToga2V5LCBhdGxhczogbnVsbCwgaXNCYWtlZFZlY3RvcjogdHJ1ZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb2xsZWN0IHRleHR1cmVzIGZyb20gYWxsIGF0bGFzZXNcclxuICAgIGlmICh0ZXh0dXJlQXRsYXNlcyAhPSBudWxsKSB7XHJcbiAgICAgIGZvciAobGV0IGtleSBpbiB0ZXh0dXJlQXRsYXNlcykge1xyXG4gICAgICAgIGxldCBhdGxhcyA9IHRleHR1cmVBdGxhc2VzW2tleV07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGtleTIgaW4gYXRsYXMuc3ViVGV4dHVyZXMpXHJcbiAgICAgICAgICBpZiAocmUudGVzdChrZXkyKSlcclxuICAgICAgICAgICAgbmFtZXMucHVzaCh7IG5hbWU6IGtleTIsIGF0bGFzOiBhdGxhcywgaXNCYWtlZFZlY3RvcjogZmFsc2UgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjb2xsZWN0IHRleHR1cmUgZnJvbSB2ZWN0b3IgYXRsYXNlc1xyXG4gICAgaWYgKHZlY3RvclRleHR1cmVBdGxhc2VzICE9IG51bGwpIHtcclxuICAgICAgZm9yIChsZXQga2V5IGluIHZlY3RvclRleHR1cmVBdGxhc2VzKSB7XHJcbiAgICAgICAgbGV0IGF0bGFzID0gdmVjdG9yVGV4dHVyZUF0bGFzZXNba2V5XTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQga2V5MiBpbiBhdGxhcy5zdWJUZXh0dXJlcylcclxuICAgICAgICAgIGlmIChyZS50ZXN0KGtleTIpKVxyXG4gICAgICAgICAgICBuYW1lcy5wdXNoKHsgbmFtZToga2V5MiwgYXRsYXM6IGF0bGFzLCBpc0Jha2VkVmVjdG9yOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQXRsYXNUZXh0dXJlLm5hdHVyYWxTb3J0KG5hbWVzLCAnbmFtZScpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGFvID0gbmFtZXNbaV07XHJcblxyXG4gICAgICBpZiAoYW8uYXRsYXMgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAoYW8uaXNCYWtlZFZlY3RvciA9PT0gdHJ1ZSlcclxuICAgICAgICAgIG91dC5wdXNoKHZlY3RvclRleHR1cmVzW2FvLm5hbWVdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBvdXQucHVzaCh0ZXh0dXJlc1thby5uYW1lXSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZVxyXG4gICAgICAgIG91dC5wdXNoKGFvLmF0bGFzLm1TdWJUZXh0dXJlc1thby5uYW1lXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG91dC5sZW5ndGggPiAwKVxyXG4gICAgICByZXR1cm4gb3V0O1xyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBBdGxhc1RleHR1cmUgYnkgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBc3NldC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+QXRsYXNUZXh0dXJlfG51bGx9IFJldHVybnMgYXRsYXMgb3IgbnVsbC5cclxuICAgKi9cclxuICBnZXRBdGxhcyhuYW1lKSB7XHJcbiAgICBsZXQgYXRsYXNzZXMgPSB0aGlzLm1Bc3NldHNbQXNzZXRUeXBlLlRFWFRVUkVfQVRMQVNdO1xyXG4gICAgaWYgKGF0bGFzc2VzID09IG51bGwpXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGlmIChhdGxhc3Nlc1tuYW1lXSAhPSBudWxsKVxyXG4gICAgICByZXR1cm4gYXRsYXNzZXNbbmFtZV07XHJcblxyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gQXRsYXMgJyR7bmFtZX0nIHdhcyBub3QgZm91bmQuYCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYFNvdW5kQ2xpcGAgYnkgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzb3VuZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+U291bmRDbGlwfSBSZXR1cm5zIHNvdW5kIG9yIG51bGwuXHJcbiAgICovXHJcbiAgZ2V0U291bmQobmFtZSkge1xyXG4gICAgbGV0IHNvdW5kcyA9IHRoaXMubUFzc2V0c1tBc3NldFR5cGUuU09VTkRdO1xyXG4gICAgbGV0IHNvdW5kQXRsYXNlcyA9IHRoaXMubUFzc2V0c1tBc3NldFR5cGUuU09VTkRfQVRMQVNdO1xyXG5cclxuICAgIGlmIChzb3VuZHMgIT0gbnVsbCkge1xyXG4gICAgICAvKiogQHR5cGUge1NvdW5kQ2xpcH0gKi9cclxuICAgICAgbGV0IHMgPSBzb3VuZHNbbmFtZV07XHJcblxyXG4gICAgICBpZiAocyAhPSBudWxsKVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzb3VuZEF0bGFzZXMgIT0gbnVsbCkge1xyXG4gICAgICBmb3IgKGxldCBrZXkgaW4gc291bmRBdGxhc2VzKSB7XHJcbiAgICAgICAgbGV0IHMgPSBzb3VuZEF0bGFzZXNba2V5XS5zdWJTb3VuZHNbbmFtZV07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbClcclxuICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRGVidWcud2FybihgW0Fzc2V0TWFuYWdlcl0gU291bmQgJyR7bmFtZX0nIHdhcyBub3QgZm91bmQuYCk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYFNvdW5kQXRsYXNDbGlwYCBieSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNvdW5kLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Tb3VuZENsaXB9IFJldHVybnMgc291bmQgb3IgbnVsbC5cclxuICAgKi9cclxuICBnZXRTb3VuZEF0bGFzKG5hbWUpIHtcclxuICAgIGlmICh0aGlzLm1Bc3NldHNbQXNzZXRUeXBlLlNPVU5EX0FUTEFTXSA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5TT1VORF9BVExBU11bbmFtZV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIE9iamVjdCBwYXJzZWQgZnJvbSBKU09OIGJ5IGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgSlNPTiBhc3NldC5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IG9yIG51bGwuXHJcbiAgICovXHJcbiAgZ2V0SlNPTihuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5KU09OXSA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQXNzZXRzW0Fzc2V0VHlwZS5KU09OXVtuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgT2JqZWN0IHBhcnNlZCBmcm9tIGBDdXRzb21Bc3NldGAgYnkgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBhc3NldC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXNzZXQuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgb2JqZWN0IG9yIG51bGwuXHJcbiAgICovXHJcbiAgZ2V0Q3VzdG9tQXNzZXQodHlwZSwgbmFtZSkge1xyXG4gICAgaWYgKHRoaXMubUFzc2V0c1t0eXBlXSA9PSBudWxsKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQXNzZXRzW3R5cGVdW25hbWVdO1xyXG4gIH1cclxuXHJcbiAgX192YWxpZGF0ZVN0YXRlKCkge1xyXG4gICAgRGVidWcuYXNzZXJ0KHRoaXMubVN0YXRlID09PSBBc3NldE1hbmFnZXJTdGF0ZS5OT05FIHx8IHRoaXMubVN0YXRlID09PSBBc3NldE1hbmFnZXJTdGF0ZS5GSU5JU0hFRCwgJ0lsbGVnYWwgc3RhdGUuJyk7XHJcbiAgfVxyXG5cclxuICBfX3ZhbGlkYXRlTmFtZSh0eXBlLCBuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5tQXNzZXRzW3R5cGVdICYmIHRoaXMubUFzc2V0c1t0eXBlXVtuYW1lXSlcclxuICAgICAgRGVidWcuYXNzZXJ0KHRoaXMubURpY3Rpb25hcnlbbmFtZV0gPT0gbnVsbCwgJ0Fzc2V0IHdpdGggc3VjaCBuYW1lIGlzIGFscmVhZHkgYWRkZWQuJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBhbGwgbG9hZGVkIHJlc291cmNlcy5cclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgLy8gdG9kbzogZm9yIGVhY2ggYXNzZXQgY2FsbCBhYm9ydFxyXG4gICAgdGhpcy5tUXVldWUuZm9yRWFjaCh4ID0+IHtcclxuICAgICAgeC5hYm9ydCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgZGVmYXVsdCBwYXRoIGZvciBsb2FkaW5nLiBVc2VmdWwgd2hlbiBVUkxzIGdldHRpbmcgdG9vIGxvbmcuXHJcbiAgICogVGhlIGFzc2V0IHBhdGggd2lsbCBiZSBjb25jYXRlbmF0ZWQgd2l0aCBkZWZhdWx0UGF0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgZGVmYXVsdFBhdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRGVmYXVsdFBhdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBkZWZhdWx0UGF0aCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tRGVmYXVsdFBhdGggPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgVHJ1ZSBpZiBhbGwgYXNzZXRzIHdlcmUgbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgaXNBbGxMb2FkZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSXNBbGxMb2FkZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIGxvYWRpbmcuXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbnVtRXJyb3JzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVRvdGFsRXJyb3JzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Bc3NldE1hbmFnZXJTdGF0ZX1cclxuICAgKi9cclxuICBnZXQgc3RhdGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU3RhdGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbHdheXMgcmV0dXJucyAnQXNzZXRNYW5hZ2VyJywgY2FuIGJlIHVzZWQgdG8gb3ZlcmhlYXIgQXNzZXRNYW5hZ2VyJ3MgbWVzc2FnZXMuXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cclxuICAgKi9cclxuICBnZXQgcGF0aCgpIHtcclxuICAgIHJldHVybiAnQXNzZXRNYW5hZ2VyJztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIFJlbmRlclNlc3Npb24gb2JqZWN0IGhvbGRzIHN0YXRlIG9mIGN1cnJlbnQgZnJhbWUgcmVuZGVyZXJzLlxyXG4gKlxyXG4gKiBAY2F0IGRyaXZlcnNcclxuICovXHJcbmNsYXNzIFJlbmRlclNlc3Npb24ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFJlbmRlclNlc3Npb24uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvKiogQHR5cGUge0FycmF5PFJlbmRlcmVyPn0gKi9cclxuICAgIHRoaXMucGFyZW50UmVuZGVyZXJzID0gW107XHJcblxyXG4gICAgLyoqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+UmVuZGVyZXI+fSAqL1xyXG4gICAgdGhpcy5lbmRQYXNzUGFyZW50UmVuZGVyZXJzID0gW107XHJcblxyXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xyXG4gICAgdGhpcy5pc0JhY2tCdWZmZXJBY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7TWJsYWNrLWVuZ2luZX5hdHJpeHxudWxsfSAqL1xyXG4gICAgdGhpcy5jdXN0b21UcmFuc2Zvcm0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXRzIHN0YXRlIGZvciBmdXR1cmUgcmV1c2UuXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLnBhcmVudFJlbmRlcmVycy5zcGxpY2UoMCwgdGhpcy5wYXJlbnRSZW5kZXJlcnMubGVuZ3RoKTtcclxuICAgIHRoaXMuZW5kUGFzc1BhcmVudFJlbmRlcmVycy5zcGxpY2UoMCwgdGhpcy5lbmRQYXNzUGFyZW50UmVuZGVyZXJzLmxlbmd0aCk7XHJcbiAgICB0aGlzLmlzQmFja0J1ZmZlckFjdGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLmN1c3RvbVRyYW5zZm9ybSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBgVGV4dEZpZWxkYCBvYmplY3RzIGJ5IGRpZmZlcmVudCBkcml2ZXJzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+UmVuZGVyZXJcclxuICogQGNhdCBkcml2ZXJzXHJcbiAqL1xyXG5jbGFzcyBUZXh0UmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgVGV4dFJlbmRlcmVyLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVHJhbnNmb3JtQ2FjaGUgPSBuZXcgTWF0cml4KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeHxudWxsfSBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRyYW5zZm9ybSA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Vc2VUcmFuc2Zvcm1DYWNoZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db250ZXh0ID0gLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovICh0aGlzLm1DYW52YXMuZ2V0Q29udGV4dCgnMmQnKSk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbnRleHQubWl0ZXJMaW1pdCA9IDI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflRleHRNZXRyaWNzRGF0YXxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTWV0cmljcyA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICBwcmVSZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZCA9IHRoaXMuZ2FtZU9iamVjdC5tQ2xpcFJlY3QgIT09IG51bGwgJiYgdGhpcy5nYW1lT2JqZWN0Lm1DbGlwUmVjdC5pc0VtcHR5ID09PSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnNraXBDaGlsZHJlbiA9ICEodGhpcy5nYW1lT2JqZWN0Lm1BbHBoYSA+IDAgJiYgdGhpcy5nYW1lT2JqZWN0Lm1WaXNpYmxlID09PSB0cnVlKTtcclxuICAgIHRoaXMuc2tpcFNlbGYgPSB0aGlzLnNraXBDaGlsZHJlbiA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gIHVwbG9hZChkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIGxldCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtUZXh0RmllbGR9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG5cclxuICAgIGlmIChnYW1lT2JqZWN0Lm1EaXJ0eSAmIERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUpIHtcclxuICAgICAgZ2FtZU9iamVjdC5vbkdldExvY2FsQm91bmRzKCk7XHJcbiAgICAgIHRoaXMubU1ldHJpY3MgPSBnYW1lT2JqZWN0Lm1NZXRyaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChnYW1lT2JqZWN0Lm1EaXJ0eSAmIERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUgfHwgZ2FtZU9iamVjdC5tRGlydHkgJiBEaXJ0eUZsYWcuUkVOREVSKVxyXG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgIHRoaXMubVRyYW5zZm9ybSA9IHRoaXMubVVzZVRyYW5zZm9ybUNhY2hlID09PSB0cnVlID8gdGhpcy5tVHJhbnNmb3JtQ2FjaGUgOiB0aGlzLmdhbWVPYmplY3Qud29ybGRUcmFuc2Zvcm1hdGlvbjtcclxuXHJcbiAgICBkcml2ZXIuc2V0U25hcFRvUGl4ZWxzKGdhbWVPYmplY3Quc25hcFRvUGl4ZWxzKTtcclxuICAgIGRyaXZlci5zZXRUcmFuc2Zvcm0odGhpcy5tVHJhbnNmb3JtKTtcclxuICAgIGRyaXZlci5zZXRHbG9iYWxBbHBoYSh0aGlzLmFscGhhKTtcclxuICAgIGRyaXZlci5zZXRHbG9iYWxCbGVuZE1vZGUodGhpcy5ibGVuZE1vZGUpO1xyXG5cclxuICAgIGlmICh0aGlzLmVuZFBhc3NSZXF1aXJlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICBkcml2ZXIuYmVnaW5DbGlwKGdhbWVPYmplY3QubUNsaXBSZWN0LCBnYW1lT2JqZWN0Lm1QaXZvdFgsIGdhbWVPYmplY3QubVBpdm90WSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5UZXh0TWV0cmljc0RhdGF9IG1ldHJpY3NcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5UZXh0U2VnbWVudE1ldHJpY3NEYXRhfSBzZWdtZW50XHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlcn0gZHJpdmVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Rm9udE1ldHJpY3N9IGZvbnRNZXRyaWNzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1N0cm9rZVxyXG4gICAqL1xyXG4gIHJlbmRlclNlZ21lbnQobWV0cmljcywgc2VnbWVudCwgY3R4LCBkcml2ZXIsIGZvbnRNZXRyaWNzLCBpc1N0cm9rZSkge1xyXG4gICAgbGV0IGdhbWVPYmplY3QgPSAvKiogQHR5cGUge1RleHRGaWVsZH0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgbGV0IGJhc2VsaW5lID0gZm9udE1ldHJpY3MuYmFzZWxpbmVOb3JtYWxpemVkICogc2VnbWVudC5zdHlsZS5zaXplO1xyXG5cclxuICAgIGlmIChpc1N0cm9rZSA9PT0gdHJ1ZSkge1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gc2VnbWVudC5zdHlsZS5zdHJva2VUaGlja25lc3M7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9ySGVscGVyLmludFRvUkdCQShzZWdtZW50LnN0eWxlLnN0cm9rZUNvbG9yLCBzZWdtZW50LnN0eWxlLnN0cm9rZUFscGhhKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvckhlbHBlci5pbnRUb1JHQkEoc2VnbWVudC5zdHlsZS5jb2xvciwgc2VnbWVudC5zdHlsZS5hbHBoYSk7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LmZvbnQgPSBgJHtzZWdtZW50LnN0eWxlLndlaWdodH0gJHtzZWdtZW50LnN0eWxlLnN0eWxlfSAke3NlZ21lbnQuc3R5bGUuc2l6ZX1weCAke3NlZ21lbnQuc3R5bGUuZmFtaWx5fWA7XHJcblxyXG4gICAgbGV0IGx4ID0gc2VnbWVudC5ib3VuZHMueCAtIE1hdGgubWluKG1ldHJpY3Muc3Ryb2tlQm91bmRzLngsIG1ldHJpY3Muc2hhZG93Qm91bmRzLngpO1xyXG4gICAgbGV0IGx5ID0gYmFzZWxpbmUgKyBzZWdtZW50LmJvdW5kcy55IC0gTWF0aC5taW4obWV0cmljcy5zdHJva2VCb3VuZHMueSwgbWV0cmljcy5zaGFkb3dCb3VuZHMueSk7XHJcblxyXG4gICAgbHggKz0gZ2FtZU9iamVjdC5wYWRkaW5nLng7XHJcbiAgICBseSArPSBnYW1lT2JqZWN0LnBhZGRpbmcueTtcclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC5hbGlnbiA9PT0gJ2NlbnRlcicpXHJcbiAgICAgIGx4ICs9IG1ldHJpY3MuYm91bmRzLndpZHRoICogMC41IC0gbWV0cmljcy5saW5lV2lkdGhbc2VnbWVudC5saW5lSW5kZXhdICogMC41O1xyXG4gICAgZWxzZSBpZiAoZ2FtZU9iamVjdC5hbGlnbiA9PT0gJ3JpZ2h0JylcclxuICAgICAgbHggKz0gbWV0cmljcy5ib3VuZHMud2lkdGggLSBtZXRyaWNzLmxpbmVXaWR0aFtzZWdtZW50LmxpbmVJbmRleF07XHJcblxyXG4gICAgaWYgKGlzU3Ryb2tlID09PSB0cnVlKVxyXG4gICAgICBjdHguc3Ryb2tlVGV4dChzZWdtZW50LnRleHQsIGx4LCBseSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIGN0eC5maWxsVGV4dChzZWdtZW50LnRleHQsIGx4LCBseSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICByZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7VGV4dEZpZWxkfSAqLyAodGhpcy5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC5tSGlnaFF1YWxpdHkgPT09IHRydWUgJiYgZ2FtZU9iamVjdC5tRGlydHkgJiBEaXJ0eUZsYWcuUkVOREVSKSB7XHJcbiAgICAgIGdhbWVPYmplY3QubURpcnR5IF49IERpcnR5RmxhZy5SRU5ERVI7XHJcbiAgICAgIGdhbWVPYmplY3QubURpcnR5IHw9IERpcnR5RmxhZy5SRU5ERVJfQ0FDSEU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QubURpcnR5ICYgRGlydHlGbGFnLlJFTkRFUl9DQUNIRSkge1xyXG4gICAgICBnYW1lT2JqZWN0Lm1EaXJ0eSBePSBEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFO1xyXG5cclxuICAgICAgY29uc3QgY3ZzID0gdGhpcy5tQ2FudmFzO1xyXG4gICAgICBjb25zdCBjdHggPSB0aGlzLm1Db250ZXh0O1xyXG4gICAgICBsZXQgc2NhbGUgPSAxO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xyXG5cclxuICAgICAgaWYgKGdhbWVPYmplY3QubUhpZ2hRdWFsaXR5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLm1UcmFuc2Zvcm0uZGF0YTtcclxuICAgICAgICBsZXQgZ2FtZU9iamVjdFNjYWxlWCA9IE1hdGguc3FydCgoZGF0YVswXSAqIGRhdGFbMF0pICsgKGRhdGFbMl0gKiBkYXRhWzJdKSk7XHJcbiAgICAgICAgbGV0IGdhbWVPYmplY3RTY2FsZVkgPSBNYXRoLnNxcnQoKGRhdGFbMV0gKiBkYXRhWzFdKSArIChkYXRhWzNdICogZGF0YVszXSkpO1xyXG4gICAgICAgIHNjYWxlID0gTWF0aC5tYXgoZ2FtZU9iamVjdFNjYWxlWCwgZ2FtZU9iamVjdFNjYWxlWSkgKiBkcml2ZXIucmVuZGVyU2NhbGVGYWN0b3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBjYW52YXNCb3VuZHMgPSB0aGlzLm1NZXRyaWNzLnN0cm9rZUJvdW5kcy5jbG9uZSgpO1xyXG4gICAgICBjYW52YXNCb3VuZHMudW5pb24odGhpcy5tTWV0cmljcy5zaGFkb3dCb3VuZHMpO1xyXG4gICAgICBjYW52YXNCb3VuZHMuaW5mbGF0ZShnYW1lT2JqZWN0LnBhZGRpbmcucmlnaHQsIGdhbWVPYmplY3QucGFkZGluZy5ib3R0b20pO1xyXG4gICAgICBjYW52YXNCb3VuZHMuc2NhbGUoc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgIGN2cy53aWR0aCA9IGNhbnZhc0JvdW5kcy53aWR0aDtcclxuICAgICAgY3ZzLmhlaWdodCA9IGNhbnZhc0JvdW5kcy5oZWlnaHQ7XHJcblxyXG4gICAgICBsZXQgZm9udE1ldHJpY3MgPSBGb250TWV0cmljcy5nZXQoZ2FtZU9iamVjdC5tRGVmYXVsdFN0eWxlLmZhbWlseSk7XHJcbiAgICAgIGxldCBzZWdtZW50cyA9IHRoaXMubU1ldHJpY3Muc2VnbWVudHM7XHJcblxyXG4gICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoc2VnbWVudHNbaV0uc3R5bGUuZHJvcFNoYWRvdykge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IENvbG9ySGVscGVyLmludFRvUkdCQShzZWdtZW50c1tpXS5zdHlsZS5zaGFkb3dDb2xvciwgc2VnbWVudHNbaV0uc3R5bGUuc2hhZG93QWxwaGEpO1xyXG4gICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzZWdtZW50c1tpXS5zdHlsZS5zaGFkb3dCbHVyO1xyXG4gICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBzZWdtZW50c1tpXS5zdHlsZS5zaGFkb3dEaXN0YW5jZVggKiBzY2FsZTtcclxuICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2VnbWVudHNbaV0uc3R5bGUuc2hhZG93RGlzdGFuY2VZICogc2NhbGU7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlclNlZ21lbnQodGhpcy5tTWV0cmljcywgc2VnbWVudHNbaV0sIGN0eCwgZHJpdmVyLCBmb250TWV0cmljcywgZmFsc2UpO1xyXG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgIGlmIChzZWdtZW50LnN0eWxlLnN0cm9rZVRoaWNrbmVzcyA+IDApIHtcclxuICAgICAgICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcbiAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IDI7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlclNlZ21lbnQodGhpcy5tTWV0cmljcywgc2VnbWVudCwgY3R4LCBkcml2ZXIsIGZvbnRNZXRyaWNzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5yZW5kZXJTZWdtZW50KHRoaXMubU1ldHJpY3MsIHNlZ21lbnRzW2ldLCBjdHgsIGRyaXZlciwgZm9udE1ldHJpY3MsIGZhbHNlKTtcclxuXHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAvLyB3aGF0cyB0aGUgbWF4IHRleHR1cmUgc2l6ZT9cclxuICAgICAgaWYgKHRoaXMudGV4dHVyZSA9PT0gbnVsbClcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZShjdnMsIG51bGwsIG51bGwsIDEgLyBzY2FsZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnRleHR1cmUuc2V0KGN2cywgbnVsbCwgbnVsbCwgMSAvIHNjYWxlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaWdub3JlICovXHJcbiAgdXBkYXRlVHJhbnNmb3JtKCkge1xyXG4gICAgbGV0IGdhbWVPYmplY3QgPSAvKiogQHR5cGUge1RleHRGaWVsZH0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICBsZXQgdHJhbnNmb3JtID0gZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uO1xyXG5cclxuICAgIGxldCBmaWVsZFhPZmZzZXQgPSAwO1xyXG4gICAgbGV0IGZpZWxkWU9mZnNldCA9IDA7XHJcblxyXG4gICAgbGV0IGZpbHRlck9mZnNldFggPSBNYXRoLm1pbih0aGlzLm1NZXRyaWNzLnN0cm9rZUJvdW5kcy54LCB0aGlzLm1NZXRyaWNzLnNoYWRvd0JvdW5kcy54KTtcclxuICAgIGxldCBmaWx0ZXJPZmZzZXRZID0gTWF0aC5taW4odGhpcy5tTWV0cmljcy5zdHJva2VCb3VuZHMueSwgdGhpcy5tTWV0cmljcy5zaGFkb3dCb3VuZHMueSk7XHJcblxyXG4gICAgY29uc3QgaGFzRmlsdGVyID0gZmlsdGVyT2Zmc2V0WCAhPT0gMCB8fCBmaWx0ZXJPZmZzZXRZICE9PSAwO1xyXG5cclxuICAgIGlmIChnYW1lT2JqZWN0Lm1BdXRvU2l6ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgaWYgKGdhbWVPYmplY3QuYWxpZ24gPT09ICdjZW50ZXInKVxyXG4gICAgICAgIGZpZWxkWE9mZnNldCA9IChnYW1lT2JqZWN0Lm1GaWVsZFdpZHRoIC0gdGhpcy5tTWV0cmljcy5ib3VuZHMud2lkdGgpICogMC41O1xyXG4gICAgICBlbHNlIGlmIChnYW1lT2JqZWN0LmFsaWduID09PSAncmlnaHQnKVxyXG4gICAgICAgIGZpZWxkWE9mZnNldCA9IGdhbWVPYmplY3QubUZpZWxkV2lkdGggLSB0aGlzLm1NZXRyaWNzLmJvdW5kcy53aWR0aDtcclxuXHJcbiAgICAgIGlmIChnYW1lT2JqZWN0Lm1WZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJylcclxuICAgICAgICBmaWVsZFlPZmZzZXQgPSAoZ2FtZU9iamVjdC5tRmllbGRIZWlnaHQgLSB0aGlzLm1NZXRyaWNzLmJvdW5kcy5oZWlnaHQpICogMC41O1xyXG4gICAgICBlbHNlIGlmIChnYW1lT2JqZWN0Lm1WZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJylcclxuICAgICAgICBmaWVsZFlPZmZzZXQgPSBnYW1lT2JqZWN0Lm1GaWVsZEhlaWdodCAtIHRoaXMubU1ldHJpY3MuYm91bmRzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzRmlsdGVyID09PSB0cnVlIHx8IGdhbWVPYmplY3QubUF1dG9TaXplID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLm1Vc2VUcmFuc2Zvcm1DYWNoZSA9IHRydWU7XHJcbiAgICAgIHRyYW5zZm9ybS5jb3B5VG8odGhpcy5tVHJhbnNmb3JtQ2FjaGUpO1xyXG4gICAgICB0aGlzLm1UcmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUoKGZpbHRlck9mZnNldFggKyBmaWVsZFhPZmZzZXQpIC0gZ2FtZU9iamVjdC5wYWRkaW5nLngsIChmaWx0ZXJPZmZzZXRZICsgZmllbGRZT2Zmc2V0KSAtIGdhbWVPYmplY3QucGFkZGluZy55KTtcclxuICAgIH0gZWxzZSBpZiAoZ2FtZU9iamVjdC5wYWRkaW5nLmlzRW1wdHkgPT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMubVVzZVRyYW5zZm9ybUNhY2hlID0gdHJ1ZTtcclxuICAgICAgdHJhbnNmb3JtLmNvcHlUbyh0aGlzLm1UcmFuc2Zvcm1DYWNoZSk7XHJcbiAgICAgIHRoaXMubVRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZSgtZ2FtZU9iamVjdC5wYWRkaW5nLngsIC1nYW1lT2JqZWN0LnBhZGRpbmcueSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1Vc2VUcmFuc2Zvcm1DYWNoZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgYEJpdG1hcFRleHRGaWVsZGAgb2JqZWN0cyBieSBkaWZmZXJlbnQgZHJpdmVycy5cclxuICpcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lflJlbmRlcmVyXHJcbiAqIEBjYXQgZHJpdmVyc1xyXG4gKi9cclxuY2xhc3MgQml0bWFwVGV4dFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEJpdG1hcFRleHRSZW5kZXJlci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQGlnbm9yZSBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAaWdub3JlIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udGV4dCA9IC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAodGhpcy5tQ2FudmFzLmdldENvbnRleHQoJzJkJykpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflRleHR1cmV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHJlbmRlcihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIGxldCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtCaXRtYXBUZXh0RmllbGR9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG5cclxuICAgIGlmIChnYW1lT2JqZWN0Lm1UZXh0ID09PSBudWxsKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QubURpcnR5ICYgRGlydHlGbGFnLlJFTkRFUl9DQUNIRSkge1xyXG4gICAgICBjb25zdCBjdnMgPSB0aGlzLm1DYW52YXM7XHJcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMubUNvbnRleHQ7XHJcblxyXG4gICAgICBsZXQgZGF0YSA9IGdhbWVPYmplY3QubURhdGE7XHJcbiAgICAgIGxldCB0ZXh0ID0gZ2FtZU9iamVjdC5tVGV4dDtcclxuICAgICAgbGV0IGNhbnZhc0JvdW5kcyA9IGdhbWVPYmplY3Qub25HZXRMb2NhbEJvdW5kcygpO1xyXG5cclxuICAgICAgLy8gcmVtb3ZlIGRpcnR5IGZsYWcgb25seSBhZnRlciBnZXR0aW5nIGJvdW5kc1xyXG4gICAgICBnYW1lT2JqZWN0Lm1EaXJ0eSBePSBEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFO1xyXG5cclxuICAgICAgbGV0IHByZXZDaGFyQ29kZSA9IC0xO1xyXG4gICAgICBsZXQgY3ggPSAwO1xyXG4gICAgICBsZXQgY3kgPSAwO1xyXG5cclxuICAgICAgY3ZzLndpZHRoID0gY2FudmFzQm91bmRzLndpZHRoO1xyXG4gICAgICBjdnMuaGVpZ2h0ID0gY2FudmFzQm91bmRzLmhlaWdodDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgaWYgKC8oPzpcXHJcXG58XFxyfFxcbikvLnRlc3QodGV4dC5jaGFyQXQoaSkpKSB7XHJcbiAgICAgICAgICBjeCA9IDA7XHJcbiAgICAgICAgICBjeSArPSBkYXRhLmxpbmVIZWlnaHQgKiBnYW1lT2JqZWN0Lm1MaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgcHJldkNoYXJDb2RlID0gLTE7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjaGFyRGF0YSA9IGRhdGEuY2hhcnNbY2hhckNvZGVdO1xyXG5cclxuICAgICAgICBpZiAoY2hhckRhdGEgPT0gbnVsbClcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBsZXQgdGV4dHVyZSA9IGNoYXJEYXRhLnRleHR1cmU7XHJcblxyXG4gICAgICAgIGlmIChwcmV2Q2hhckNvZGUgPj0gMCAmJiBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV0pXHJcbiAgICAgICAgICBjeCArPSBjaGFyRGF0YS5rZXJuaW5nW3ByZXZDaGFyQ29kZV07XHJcblxyXG4gICAgICAgIGNvbnN0IHcgPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGggPSB0ZXh0dXJlLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gc2tpcCBlbXB0eSBjaGFyIChzcGFjZSBmb3IgZXhhbXBsZSlcclxuICAgICAgICBpZiAodyA9PT0gMCB8fCBoID09PSAwKVxyXG4gICAgICAgICAgY29udGludWVcclxuXHJcbiAgICAgICAgY29uc3Qgb3ggPSB0ZXh0dXJlLnVudHJpbW1lZFJlZ2lvbi54ICsgY2hhckRhdGEueE9mZnNldCArIGN4O1xyXG4gICAgICAgIGNvbnN0IG95ID0gdGV4dHVyZS51bnRyaW1tZWRSZWdpb24ueSArIGNoYXJEYXRhLnlPZmZzZXQgKyBjeTtcclxuXHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZXh0dXJlLm5hdGl2ZSwgdGV4dHVyZS5yZWdpb24ueCwgdGV4dHVyZS5yZWdpb24ueSwgdywgaCwgfn5veCwgfn5veSwgdywgaCk7XHJcblxyXG4gICAgICAgIGN4ICs9IGNoYXJEYXRhLnhBZHZhbmNlO1xyXG4gICAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy50ZXh0dXJlID09PSBudWxsKVxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKGN2cyk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aGlzLnRleHR1cmUuc2V0KGN2cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBgR3JhcGhpY3NgIG9iamVjdHMgYnkgZGlmZmVyZW50IGRyaXZlcnMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5SZW5kZXJlclxyXG4gKiBAY2F0IGRyaXZlcnNcclxuICovXHJcbmNsYXNzIEdyYXBoaWNzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYERpc3BsYXlPYmplY3RgIG9iamVjdHMgb24gY2FudmFzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+UmVuZGVyZXJcclxuICogQGNhdCBkcml2ZXJzLmNhbnZhc1xyXG4gKi9cclxuY2xhc3MgRGlzcGxheU9iamVjdFJlbmRlcmVyQ2FudmFzIGV4dGVuZHMgUmVuZGVyZXIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcERpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5DYW52YXNSZW5kZXJUZXh0dXJlfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DYWNoZVRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlQm91bmRzID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNDbGlwcGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5tSXNDYWNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1CYWtlSW52ZXJ0ZWRNYXRyaXggPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgcHJlUmVuZGVyKGRyaXZlciwgc2Vzc2lvbikge1xyXG4gICAgbGV0IGdhbWVPYmplY3QgPSAvKiogQHR5cGUge0Rpc3BsYXlPYmplY3R9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG5cclxuICAgIHRoaXMubUlzQ2xpcHBlZCA9IGdhbWVPYmplY3QubUNsaXBSZWN0ICE9PSBudWxsO1xyXG4gICAgdGhpcy5lbmRQYXNzUmVxdWlyZWQgPSB0aGlzLm1Jc0NsaXBwZWQ7XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QubUNhY2hlQXNCaXRtYXAgPT09IHRydWUpIHtcclxuICAgICAgaWYgKGdhbWVPYmplY3QubUNhY2hlQXNCaXRtYXBEeW5hbWljID09PSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1Jc0NhY2hlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHRoaXMubUlzQ2FjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGdhbWVPYmplY3Quc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICAgICAgICAgIHRoaXMuX19yZWZyZXNoQml0bWFwQ2FjaGUoKTtcclxuICAgICAgICAgIHRoaXMubUNhY2hlQXNCaXRtYXBEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5lbmRQYXNzUmVxdWlyZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZ2FtZU9iamVjdC5tRGlydHkgfD0gRGlydHlGbGFnLlJFTkRFUjtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGlzU3RhdGljID0gZ2FtZU9iamVjdC5jaGVja1N0YXRpYyh0cnVlKTtcclxuXHJcbiAgICAgICAgaWYgKGlzU3RhdGljID09PSB0cnVlICYmIHRoaXMubUNhY2hlQXNCaXRtYXBEaXJ0eSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgZ2FtZU9iamVjdC5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gICAgICAgICAgdGhpcy5fX3JlZnJlc2hCaXRtYXBDYWNoZSgpO1xyXG4gICAgICAgICAgdGhpcy5tQ2FjaGVBc0JpdG1hcERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdGF0aWMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICB0aGlzLm1DYWNoZUFzQml0bWFwRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgZ2FtZU9iamVjdC5tRGlydHkgfD0gRGlydHlGbGFnLlJFTkRFUjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNraXBDaGlsZHJlbiA9IGdhbWVPYmplY3QubUNhY2hlQXNCaXRtYXAgPT09IHRydWUgJiYgdGhpcy5tQ2FjaGVBc0JpdG1hcERpcnR5ID09PSBmYWxzZSB8fCB0aGlzLm1Jc0NsaXBwZWQgJiYgZ2FtZU9iamVjdC5tQ2xpcFJlY3QuaXNFbXB0eTtcclxuICAgIHRoaXMuc2tpcFNlbGYgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAodGhpcy5za2lwQ2hpbGRyZW4gPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5lbmRQYXNzUmVxdWlyZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5za2lwU2VsZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICBiZWdpbihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIGxldCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fSAqLyAodGhpcy5nYW1lT2JqZWN0KTtcclxuICAgIGlmICh0aGlzLnNraXBDaGlsZHJlbiA9PT0gdHJ1ZSAmJiBzZXNzaW9uLmlzQmFja0J1ZmZlckFjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLmFscGhhID0gMTtcclxuICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGUuTk9STUFMO1xyXG4gICAgICB0aGlzLmNvbG9yID0gbnVsbDtcclxuICAgICAgdGhpcy5za2lwU2VsZiA9IGdhbWVPYmplY3QubUFscGhhIDw9IDAgfHwgZ2FtZU9iamVjdC5tVmlzaWJsZSA9PT0gZmFsc2UgfHwgdGhpcy5tSXNDbGlwcGVkICYmIGdhbWVPYmplY3QubUNsaXBSZWN0LmlzRW1wdHk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5hbHBoYSA9IGdhbWVPYmplY3QubUFscGhhICogdGhpcy5wYXJlbnQuYWxwaGE7XHJcbiAgICAgIHRoaXMuY29sb3IgPSBnYW1lT2JqZWN0Lm1Db2xvciA9PT0gbnVsbCA/IHRoaXMucGFyZW50LmNvbG9yIDogZ2FtZU9iamVjdC5tQ29sb3I7XHJcbiAgICAgIHRoaXMuYmxlbmRNb2RlID0gZ2FtZU9iamVjdC5tQmxlbmRNb2RlID09PSBCbGVuZE1vZGUuQVVUTyA/IHRoaXMucGFyZW50LmJsZW5kTW9kZSA6IGdhbWVPYmplY3QubUJsZW5kTW9kZTtcclxuXHJcbiAgICAgIHRoaXMuc2tpcENoaWxkcmVuID0gZ2FtZU9iamVjdC5tQWxwaGEgPD0gMCB8fCBnYW1lT2JqZWN0Lm1WaXNpYmxlID09PSBmYWxzZTtcclxuICAgICAgdGhpcy5za2lwU2VsZiA9IHRoaXMuc2tpcENoaWxkcmVuID09PSB0cnVlIHx8IHRoaXMubUlzQ2xpcHBlZCA9PT0gZmFsc2UgfHwgdGhpcy5tSXNDbGlwcGVkICYmIGdhbWVPYmplY3QubUNsaXBSZWN0LmlzRW1wdHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICB1cGxvYWQoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7RGlzcGxheU9iamVjdH0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICBsZXQgdHJhbnNmb3JtID0gZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLnNraXBDaGlsZHJlbiA9PT0gdHJ1ZSAmJiB0aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUpIHtcclxuICAgICAgdHJhbnNmb3JtID0gdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlO1xyXG5cclxuICAgICAgaWYgKGdhbWVPYmplY3QubUNhY2hlQXNCaXRtYXBEeW5hbWljID09PSBmYWxzZSkge1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKVxyXG4gICAgICAgICAgLmFwcGVuZCh0aGlzLmdhbWVPYmplY3Qud29ybGRUcmFuc2Zvcm1hdGlvbilcclxuICAgICAgICAgIC5hcHBlbmQodGhpcy5tQmFrZUludmVydGVkTWF0cml4KVxyXG4gICAgICAgICAgLmFwcGVuZCh0aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc2tpcENoaWxkcmVuID09PSB0cnVlIHx8IHRoaXMuZW5kUGFzc1JlcXVpcmVkID09PSB0cnVlKSB7XHJcbiAgICAgIGRyaXZlci5zZXRTbmFwVG9QaXhlbHMoZ2FtZU9iamVjdC5zbmFwVG9QaXhlbHMpO1xyXG4gICAgICBkcml2ZXIuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgIGRyaXZlci5zZXRHbG9iYWxBbHBoYSh0aGlzLmFscGhhKTtcclxuICAgICAgZHJpdmVyLnNldEdsb2JhbEJsZW5kTW9kZSh0aGlzLmJsZW5kTW9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuZW5kUGFzc1JlcXVpcmVkID09PSB0cnVlKVxyXG4gICAgICBkcml2ZXIuYmVnaW5DbGlwKGdhbWVPYmplY3QubUNsaXBSZWN0LCBnYW1lT2JqZWN0Lm1QaXZvdFgsIGdhbWVPYmplY3QubVBpdm90WSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICByZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBpZiAodGhpcy5za2lwQ2hpbGRyZW4gPT09IHRydWUgJiYgc2Vzc2lvbi5pc0JhY2tCdWZmZXJBY3RpdmUgPT09IHRydWUpXHJcbiAgICAgIGRyaXZlci5kcmF3VGV4dHVyZSh0aGlzLm1DYWNoZVRleHR1cmUpO1xyXG4gIH1cclxuXHJcbiAgX19yZWZyZXNoQml0bWFwQ2FjaGUoKSB7XHJcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdhbWVPYmplY3QuZ2V0Qm91bmRzKEJsYWNrLnN0YWdlLCB0cnVlKTtcclxuICAgIGNvbnN0IHNmID0gQmxhY2suc3RhZ2Uuc2NhbGVGYWN0b3I7XHJcbiAgICBjb25zdCBmcyA9IEJsYWNrLmRyaXZlci5yZW5kZXJTY2FsZUZhY3RvciAqIHNmO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7TWF0cml4fSAqL1xyXG4gICAgbGV0IG0gPSBNYXRyaXgucG9vbC5nZXQoKTtcclxuICAgIG0uc2V0KDEsIDAsIDAsIDEsIH5+KC1ib3VuZHMueCAqIHNmIC0gQmxhY2suc3RhZ2UubVgpLCB+figtYm91bmRzLnkgKiBzZiAtIEJsYWNrLnN0YWdlLm1ZKSk7XHJcblxyXG4gICAgaWYgKHRoaXMubUlzQ2xpcHBlZCA9PT0gdHJ1ZSAmJiB0aGlzLnNraXBDaGlsZHJlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICBtLmRhdGFbNF0gKz0gdGhpcy5nYW1lT2JqZWN0Lm1QaXZvdFggKiBzZjtcclxuICAgICAgbS5kYXRhWzVdICs9IHRoaXMuZ2FtZU9iamVjdC5tUGl2b3RZICogc2Y7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubUNhY2hlQm91bmRzID09PSBudWxsKVxyXG4gICAgICB0aGlzLm1DYWNoZUJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBib3VuZHMuY29weVRvKHRoaXMubUNhY2hlQm91bmRzKTtcclxuICAgIGJvdW5kcy53aWR0aCAqPSBmcztcclxuICAgIGJvdW5kcy5oZWlnaHQgKj0gZnM7XHJcblxyXG4gICAgaWYgKHRoaXMubUNhY2hlVGV4dHVyZSA9PT0gbnVsbClcclxuICAgICAgdGhpcy5tQ2FjaGVUZXh0dXJlID0gbmV3IENhbnZhc1JlbmRlclRleHR1cmUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0LCAxKTtcclxuICAgIGVsc2VcclxuICAgICAgdGhpcy5tQ2FjaGVUZXh0dXJlLnJlc2l6ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIDEpO1xyXG5cclxuICAgIEJsYWNrLmRyaXZlci5yZW5kZXIodGhpcy5nYW1lT2JqZWN0LCB0aGlzLm1DYWNoZVRleHR1cmUsIG0pO1xyXG4gICAgTWF0cml4LnBvb2wucmVsZWFzZShtKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlID09PSBudWxsKVxyXG4gICAgICB0aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUgPSBuZXcgTWF0cml4KCk7XHJcblxyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlLmNvcHlGcm9tKG0pO1xyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlLnNjYWxlKDEgLyBCbGFjay5kcml2ZXIucmVuZGVyU2NhbGVGYWN0b3IsIDEgLyBCbGFjay5kcml2ZXIucmVuZGVyU2NhbGVGYWN0b3IpO1xyXG4gICAgdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlLmRhdGFbNF0gPSAtdGhpcy5tQ2FjaGVBc0JpdG1hcE1hdHJpeENhY2hlLmRhdGFbNF07XHJcbiAgICB0aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUuZGF0YVs1XSA9IC10aGlzLm1DYWNoZUFzQml0bWFwTWF0cml4Q2FjaGUuZGF0YVs1XTtcclxuXHJcbiAgICB0aGlzLm1CYWtlSW52ZXJ0ZWRNYXRyaXggPSB0aGlzLmdhbWVPYmplY3Qud29ybGRUcmFuc2Zvcm1hdGlvbkludmVydGVkLmNsb25lKCk7XHJcbiAgICAvL3RoaXMubUNhY2hlVGV4dHVyZS5fX2R1bXBUb0RvY3VtZW50KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVuZGVycyBgVGV4dEZpZWxkYCBvYmplY3RzIG9uIGNhbnZhcy5cclxuICpcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lflRleHRSZW5kZXJlclxyXG4gKiBAY2F0IGRyaXZlcnMuY2FudmFzXHJcbiAqL1xyXG5jbGFzcyBUZXh0UmVuZGVyZXJDYW52YXMgZXh0ZW5kcyBUZXh0UmVuZGVyZXIge1xyXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gIHJlbmRlcihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIHN1cGVyLnJlbmRlcihkcml2ZXIsIHNlc3Npb24pO1xyXG5cclxuICAgIGRyaXZlci5kcmF3VGV4dHVyZShSZW5kZXJlci5nZXRDb2xvcmVkVGV4dHVyZSh0aGlzLnRleHR1cmUsIHRoaXMuZ2FtZU9iamVjdC5tQ29sb3IpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGBCaXRtYXBUZXh0RmllbGRgIG9iamVjdHMgb24gY2FudmFzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+Qml0bWFwVGV4dFJlbmRlcmVyXHJcbiAqIEBjYXQgZHJpdmVycy5jYW52YXNcclxuICovXHJcbmNsYXNzIEJpdG1hcFRleHRSZW5kZXJlckNhbnZhcyBleHRlbmRzIEJpdG1hcFRleHRSZW5kZXJlciB7XHJcbiAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgcmVuZGVyKGRyaXZlciwgc2Vzc2lvbikge1xyXG4gICAgc3VwZXIucmVuZGVyKGRyaXZlciwgc2Vzc2lvbik7XHJcblxyXG4gICAgZHJpdmVyLmRyYXdUZXh0dXJlKFJlbmRlcmVyLmdldENvbG9yZWRUZXh0dXJlKHRoaXMudGV4dHVyZSwgdGhpcy5nYW1lT2JqZWN0Lm1Db2xvcikpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGRpc3RyaWJ1dGlvbiBvYmplY3RzLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqL1xyXG5jbGFzcyBTY2F0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyByYW5kb20gdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHsqfSBBbnkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB2YWx1ZSBhdCBnaXZlbiBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFBvc2l0aW9uIHRvIGdldCB2YWx1ZSBhdC5cclxuICAgKiBAcmV0dXJuIHsqfSBBbnkgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGdldFZhbHVlQXQodCkge31cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgYmFzZSBjbGFzcyBmb3IgbnVtYmVyIHNjYXR0ZXJzLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5TY2F0dGVyXHJcbiAqL1xyXG5jbGFzcyBGbG9hdFNjYXR0ZXJCYXNlIGV4dGVuZHMgU2NhdHRlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgRmxvYXRTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBsYXN0IHZhbHVlIG9mIGBnZXRWYWx1ZUF0YCByZXN1bHQuXHJcbiAgICAgKiBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52YWx1ZSA9IDA7XHJcbiAgfVxyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgcmFuZG9tIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdChNYXRoLnJhbmRvbSgpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIG51bWJlciBzY2F0dGVyIGZvciBkZWZpbmluZyBhIHJhbmdlIGluIDFEIHNwYWNlLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlXHJcbiAqL1xyXG5jbGFzcyBGbG9hdFNjYXR0ZXIgZXh0ZW5kcyBGbG9hdFNjYXR0ZXJCYXNlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBGbG9hdFNjYXR0ZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgICAgW21pbj0wXSAgVGhlIG1pbiB2YWx1ZSBhbG9uZyB4LWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgIFttYXg9bnVsbF0gIFRoZSBtYXggdmFsdWUgYWxvbmcgeC1heGlzLlxyXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbZWFzZT1udWxsXSBFYXNpbmcgZnVuY3Rpb24uIElmIG51bGwgbGluZWFyIGZ1bmN0aW9uIGlzIHVzZWQgYXMgZGVmYXVsdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihtaW4gPSAwLCBtYXggPSBudWxsLCBlYXNlID0gbnVsbCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbWluIHZhbHVlLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pbiA9IG1pbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbWF4IHZhbHVlLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heCA9IG1heCA9PT0gbnVsbCA/IG1pbiA6IG1heDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsIGVhc2luZyBmdW5jdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUgez9mdW5jdGlvbihudW1iZXIpOm51bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lYXNlID0gZWFzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdmFsdWUgYXQgZ2l2ZW4gcG9zaXRpb24gd2l0aGluIGRlZmluZWQgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdCBUaGUgcG9zaXRpb24uXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICovXHJcbiAgZ2V0VmFsdWVBdCh0KSB7XHJcbiAgICBpZiAodGhpcy5lYXNlICE9PSBudWxsKVxyXG4gICAgICB0ID0gdGhpcy5lYXNlKHQpO1xyXG5cclxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm1pbiArIHQgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBGbG9hdFNjYXR0ZXJCYXNlIGZyb20gYSBzZXQgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4ubnVtYmVyfGJsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlfSB2YWx1ZXMgU2V0IG9mIHZhbHVlcy5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2V9XHJcbiAgICovXHJcbiAgc3RhdGljIGZyb21PYmplY3QoLi4udmFsdWVzKSB7XHJcbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgRmxvYXRTY2F0dGVyQmFzZSlcclxuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RmxvYXRTY2F0dGVyQmFzZX0gKi8gKHZhbHVlc1swXSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGbG9hdFNjYXR0ZXIoLi4udmFsdWVzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVtaXR0ZXIuXHJcbiAqIEBjYXQgcGFydGljbGVzXHJcbiAqIEBzdGF0aWNcclxuICogQGNvbnN0YW50XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBFbWl0dGVyU3RhdGUgPSB7XHJcbiAgUEVORElORzogMCxcclxuICBFTUlUVElORzogMSxcclxuICBQQVVTRUQ6IDIsXHJcbiAgRklOSVNIRUQ6IDMsXHJcbn07XHJcblxyXG4vKipcclxuICogSW5kaWNhdGVzIHRoZSBvcmRlciBpbiB3aGljaCBwYXJ0aWNsZXMgd2lsbCBiZSByZW5kZXJlZC5cclxuICogQGNhdCBwYXJ0aWNsZXNcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IEVtaXR0ZXJTb3J0T3JkZXIgPSB7XHJcbiAgRlJPTlRfVE9fQkFDSzogJ2Zyb250VG9CYWNrJyxcclxuICBCQUNLX1RPX0ZST05UOiAnYmFja1RvRnJvbnQnXHJcbn07XHJcblxyXG4vKipcclxuICogQSBiYXNlIHV0aWxpdHkgY2xhc3MgdXNlZCBieSBwYXJ0aWNsZSBzeXN0ZW1zLiBNdXN0IGJlIGV4dGVuZGVkLlxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlc1xyXG4gKi9cclxuY2xhc3MgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0luaXRpYWxpemVyIEluZGljYXRlcyB3aGVuZXZlciB0aGlzIG1vZGlmaWVyIHdpbGwgYmUgYXBwbGllZCB0byBwYXJ0aWNsZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24gc3RhZ2Ugb3IgcGFydGljbGUgbGlmZXRpbWUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaXNJbml0aWFsaXplciA9IHRydWUpIHtcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc0luaXRpYWxpemVyID0gaXNJbml0aWFsaXplcjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uIFxyXG4gICAgICogQHR5cGUge1NjYXR0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2NhdHRlciA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbmV2ZXIgdGhpcyBtb2RpZmllciBpcyBhY3RpdmUgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIG9uIGVhY2ggRW1pdHRlcidzIHVwZGF0ZSBiZWZvcmUgYE1vZGlmaWVyLnVwZGF0ZWBcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHQgVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHByZVVwZGF0ZShkdCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBvbiBlYWNoIEVtaXR0ZXIncyB1cGRhdGUgZm9yIGVhY2ggcGFydGljbGUuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtIHtFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhpcyBtb2RpZmllciBhdHRhY2hlZCB0by5cclxuICAgKiBAcGFyYW0ge1BhcnRpY2xlfSBwYXJ0aWNsZSBJbnN0YW5jZSBvZiBgUGFydGljbGVgLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdCBUaW1lIHNpbmNlIGxhc3QgdXBkYXRlLlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBvbiBlYWNoIEVtaXR0ZXIncyB1cGRhdGUgYWZ0ZXIgYE1vZGlmaWVyLnVwZGF0ZWBcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHQgVGltZSBzaW5jZSBsYXN0IHVwZGF0ZS5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHBvc3RVcGRhdGUoZHQpIHsgfVxyXG5cclxuICAvKipcclxuICAgKiBTcGVjaWZpZXMgaWYgdGhlIG1vZGlmaWVyIGlzIGluaXRpYWxpemVyIG9yIGFjdGlvbi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc0luaXRpYWxpemVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUlzSW5pdGlhbGl6ZXI7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHBhcnRpY2xlIVxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlc1xyXG4gKi9cclxuY2xhc3MgUGFydGljbGUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgaW5kZXggb2YgYSB0ZXh0dXJlLiAqL1xyXG4gICAgdGhpcy50ZXh0dXJlSW5kZXggPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgeCBzY2FsZSBvZiB0aGlzIHBhcnRpY2xlLiAqL1xyXG4gICAgdGhpcy5zY2FsZVggPSAxO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgeCBzY2FsZSBvZiB0aGlzIHBhcnRpY2xlLiAqL1xyXG4gICAgdGhpcy5zY2FsZVkgPSAxO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBBbiBhbHBoYSB2YWx1ZS4gKi9cclxuICAgIHRoaXMuYWxwaGEgPSAxO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgbGlmZSBvZiB0aGlzIHBhcnRpY2xlLiAqL1xyXG4gICAgdGhpcy5saWZlID0gMTtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gVGhlIGFnZSBvZiB0aGlzIHBhcnRpY2xlLiAqL1xyXG4gICAgdGhpcy5hZ2UgPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBSZWxhdGlvbiBvZiBsaWZlIHRvIGFnZS4gKi9cclxuICAgIHRoaXMuZW5lcmd5ID0gdGhpcy5hZ2UgLyB0aGlzLmxpZmU7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IFRoZSBtYXNzLiAqL1xyXG4gICAgdGhpcy5tYXNzID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gWC1jb21wb25lbnQuICovXHJcbiAgICB0aGlzLnggPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBZLWNvbXBvbmVudC4gKi9cclxuICAgIHRoaXMueSA9IDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IFJvdGF0aW9uIG9mIHRoaXMgcGFydGljbGUuICovXHJcbiAgICB0aGlzLnIgPSAwO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBWZWxvY2l0eSBieSB4LiAqL1xyXG4gICAgdGhpcy52eCA9IDA7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IFZlbG9jaXR5IGJ5IHkuICovXHJcbiAgICB0aGlzLnZ5ID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gUGFydGljbGUgeC1hY2NlbGVyYXRpb24uICovXHJcbiAgICB0aGlzLmF4ID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcn0gUGFydGljbGUgeS1hY2NlbGVyYXRpb24uICovXHJcbiAgICB0aGlzLmF5ID0gMDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcnxudWxsfSBQYXJ0aWNsZSB0aW50aW5nIGNvbG9yLiAqL1xyXG4gICAgdGhpcy5jb2xvciA9IG51bGw7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IFBhcnRpY2xlIG9yaWdpbiBwb2ludCBhbG9uZyB4LWF4aXMuICovXHJcbiAgICB0aGlzLmFuY2hvclggPSAwLjU7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9IFBhcnRpY2xlIG9yaWdpbiBwb2ludCBhbG9uZyB5LWF4aXMuICovXHJcbiAgICB0aGlzLmFuY2hvclkgPSAwLjU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldHMgcGFydGljbGUgdG8gZGVmYXVsdCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlc2V0KCkge1xyXG4gICAgdGhpcy5zY2FsZVggPSB0aGlzLnNjYWxlWSA9IHRoaXMuYWxwaGEgPSB0aGlzLmxpZmUgPSAxO1xyXG4gICAgdGhpcy50ZXh0dXJlSW5kZXggPSB0aGlzLmFnZSA9IHRoaXMuZW5lcmd5ID0gdGhpcy5tYXNzID0gdGhpcy54ID0gdGhpcy55ID0gdGhpcy5yID0gdGhpcy52eCA9IHRoaXMudnkgPSB0aGlzLmF4ID0gdGhpcy5heSA9IDA7XHJcbiAgICB0aGlzLmFuY2hvclggPSB0aGlzLmFuY2hvclkgPSAwLjU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnRlcm5hbCB1cGRhdGUgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR0IFRpbWUgc2luY2UgbGFzdCB1cGRhdGUuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICB1cGRhdGUoZHQpIHtcclxuICAgIGlmICh0aGlzLmxpZmUgPD0gMCkge1xyXG4gICAgICB0aGlzLmxpZmUgPSAwO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy54ICs9IHRoaXMudnggKiBkdDtcclxuICAgIHRoaXMueSArPSB0aGlzLnZ5ICogZHQ7XHJcblxyXG4gICAgaWYgKHRoaXMubWFzcyA+IDApIHtcclxuICAgICAgdGhpcy5heCAqPSAxIC8gdGhpcy5tYXNzO1xyXG4gICAgICB0aGlzLmF5ICo9IDEgLyB0aGlzLm1hc3M7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy52eCArPSB0aGlzLmF4ICogZHQ7XHJcbiAgICB0aGlzLnZ5ICs9IHRoaXMuYXkgKiBkdDtcclxuXHJcbiAgICB0aGlzLmF4ID0gMDtcclxuICAgIHRoaXMuYXkgPSAwO1xyXG5cclxuICAgIHRoaXMubGlmZSAtPSBkdDtcclxuICAgIHRoaXMuYWdlICs9IGR0O1xyXG5cclxuICAgIHRoaXMuZW5lcmd5ID0gdGhpcy5hZ2UgLyAodGhpcy5hZ2UgKyB0aGlzLmxpZmUpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVE9ETzogcHJldHR5IG11Y2ggdGhlIGVtaXR0ZXIgaXMgYWx3YXlzIGRpcnR5IGFuZCBjYWNoaW5nIHNob3VsZCBub3QgYmUgYXBwbGllZCBvbnRvIGl0LlxyXG4vLyBUT0RPOiBxL2EgZXZlcnkgcHJvcGVydHlcclxuXHJcbi8qKlxyXG4gKiBQYXJ0aWNsZSBlbWl0dGVyLlxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+RGlzcGxheU9iamVjdFxyXG4gKi9cclxuY2xhc3MgRW1pdHRlciBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5UZXh0dXJlPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRleHR1cmVzID0gW107XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8YmxhY2stZW5naW5lflBhcnRpY2xlPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBhcnRpY2xlcyA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5QYXJ0aWNsZT59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZWN5Y2xlZCA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5Nb2RpZmllcj59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jbml0aWFsaXplcnMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+TW9kaWZpZXI+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQWN0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3BhY2UgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc0xvY2FsID0gdHJ1ZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1NYXhQYXJ0aWNsZXMgPSAxMDAwMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRW1pdENvdW50ID0gbmV3IEZsb2F0U2NhdHRlcigxMCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUVtaXROdW1SZXBlYXRzID0gbmV3IEZsb2F0U2NhdHRlcigwLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRW1pdE51bVJlcGVhdHNMZWZ0ID0gdGhpcy5tRW1pdE51bVJlcGVhdHMuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRW1pdER1cmF0aW9uID0gbmV3IEZsb2F0U2NhdHRlcigxIC8gNjApO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUVtaXREdXJhdGlvbkxlZnQgPSB0aGlzLm1FbWl0RHVyYXRpb24uZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRW1pdEludGVydmFsID0gbmV3IEZsb2F0U2NhdHRlcigxIC8gNjApO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUVtaXRJbnRlcnZhbExlZnQgPSB0aGlzLm1FbWl0SW50ZXJ2YWwuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRW1pdERlbGF5ID0gbmV3IEZsb2F0U2NhdHRlcigxKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1FbWl0RGVsYXlMZWZ0ID0gdGhpcy5tRW1pdERlbGF5LmdldFZhbHVlKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTmV4dFVwZGF0ZUF0ID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+RW1pdHRlclN0YXRlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RhdGUgPSBFbWl0dGVyU3RhdGUuUEVORElORztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5fX3RtcExvY2FsID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9fdG1wV29ybGQgPSBuZXcgTWF0cml4KCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkVtaXR0ZXJTb3J0T3JkZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Tb3J0T3JkZXIgPSBFbWl0dGVyU29ydE9yZGVyLkZST05UX1RPX0JBQ0s7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz58bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGV4dHVyZU5hbWVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QcmVzaW11bGF0ZVNlY29uZHMgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUN1cnJlbnRQcmVzaW11bGF0aW9uVGltZSA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgZW1pdHRpbmcgcGFydGljbGVzLiBCeSBkZWZhdWx0IGVtaXR0ZXIgd2lsbCBzdGFydCBlbWl0dGluZyBhdXRvbWF0aWNhbGx5LlxyXG4gICAqL1xyXG4gIHBsYXkoKSB7XHJcbiAgICBpZiAodGhpcy5tU3RhdGUgPT09IEVtaXR0ZXJTdGF0ZS5FTUlUVElORylcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIC8vIHJlc3VtZSBvciByZXN0YXJ0XHJcbiAgICBpZiAodGhpcy5tU3RhdGUgIT09IEVtaXR0ZXJTdGF0ZS5QQVVTRUQpIHtcclxuICAgICAgdGhpcy5tRW1pdE51bVJlcGVhdHNMZWZ0ID0gdGhpcy5tRW1pdE51bVJlcGVhdHMuZ2V0VmFsdWUoKTtcclxuICAgICAgdGhpcy5tRW1pdER1cmF0aW9uTGVmdCA9IHRoaXMubUVtaXREdXJhdGlvbi5nZXRWYWx1ZSgpO1xyXG4gICAgICB0aGlzLm1FbWl0SW50ZXJ2YWxMZWZ0ID0gdGhpcy5tRW1pdEludGVydmFsLmdldFZhbHVlKCk7XHJcbiAgICAgIHRoaXMubUVtaXREZWxheUxlZnQgPSB0aGlzLm1FbWl0RGVsYXkuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgIHRoaXMubVN0YXRlID0gRW1pdHRlclN0YXRlLlBFTkRJTkc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZXMgdGhlIGVtaXR0aW5nIHByb2Nlc3MuXHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLm1TdGF0ZSA9IEVtaXR0ZXJTdGF0ZS5QQVVTRUQ7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogU3RvcHMgZW1pdHRpbmcgcHJvY2VzcyBhbmQgZGVzdHJveXMgYWxsIHBhcnRpY2xlcy5cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5tUGFydGljbGVzID0gW107XHJcbiAgICB0aGlzLm1SZWN5Y2xlZCA9IFtdO1xyXG5cclxuICAgIHRoaXMubVN0YXRlID0gRW1pdHRlclN0YXRlLkZJTklTSEVEO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltdWxhdGVzIGN1cnJlbnQgZW1taXR0ZXIgZm9yIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUgKHNlY29uZHMpLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRpbWUgaW4gc2Vjb3VuZHNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzaW11bGF0ZSh0aW1lKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih0aW1lKTtcclxuICAgIERlYnVnLmFzc2VydCh0aW1lID4gMCk7XHJcblxyXG4gICAgdGhpcy5tQ3VycmVudFByZXNpbXVsYXRpb25UaW1lID0gMDtcclxuICAgIHRoaXMubVByZXNpbXVsYXRlU2Vjb25kcyA9IHRpbWU7XHJcblxyXG4gICAgd2hpbGUgKHRoaXMubUN1cnJlbnRQcmVzaW11bGF0aW9uVGltZSA8PSB0aGlzLm1QcmVzaW11bGF0ZVNlY29uZHMpIHtcclxuICAgICAgdGhpcy5vblVwZGF0ZSgpO1xyXG4gICAgICB0aGlzLm1DdXJyZW50UHJlc2ltdWxhdGlvblRpbWUgKz0gQmxhY2sudGltZS5kZWx0YTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1QcmVzaW11bGF0ZVNlY29uZHMgPSAwO1xyXG4gICAgdGhpcy5tQ3VycmVudFByZXNpbXVsYXRpb25UaW1lID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgZ2V0UmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gQmxhY2suZHJpdmVyLmdldFJlbmRlcmVyKCdFbWl0dGVyJywgdGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIHF1aWNrIGFkZGluZyBtb2RpZmllcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihibGFjay1lbmdpbmV+R2FtZU9iamVjdHxibGFjay1lbmdpbmV+Q29tcG9uZW50fGJsYWNrLWVuZ2luZX5Nb2RpZmllcil9IG1vZGlmaWVycyBUaGUgbGlzdCBvZiBtb2RpZmllcnMuXHJcbiAgICogQHJldHVybnMge0VtaXR0ZXJ9XHJcbiAgICovXHJcbiAgYWRkKC4uLm1vZGlmaWVycykge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGFpID0gbW9kaWZpZXJzW2ldO1xyXG5cclxuICAgICAgaWYgKGFpIGluc3RhbmNlb2YgTW9kaWZpZXIpXHJcbiAgICAgICAgdGhpcy5hZGRNb2RpZmllcihhaSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzdXBlci5hZGQoYWkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIG1vZGlmaWVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Nb2RpZmllcn0gbW9kaWZpZXIgTW9kaWZpZXIgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Nb2RpZmllcn1cclxuICAgKi9cclxuICBhZGRNb2RpZmllcihtb2RpZmllcikge1xyXG4gICAgaWYgKG1vZGlmaWVyLmlzSW5pdGlhbGl6ZXIpXHJcbiAgICAgIHRoaXMubUluaXRpYWxpemVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgIGVsc2VcclxuICAgICAgdGhpcy5tQWN0aW9ucy5wdXNoKG1vZGlmaWVyKTtcclxuXHJcbiAgICByZXR1cm4gbW9kaWZpZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGdpdmVuIG1vZGlmaWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TW9kaWZpZXJ9IG1vZGlmaWVyIE1vZGlmaWVyIHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vZGlmaWVyIHdhcyByZW1vdmVkLlxyXG4gICAqL1xyXG4gIHJlbW92ZU1vZGlmaWVyKG1vZGlmaWVyKSB7XHJcbiAgICBsZXQgYXJyYXkgPSB0aGlzLm1BY3Rpb25zO1xyXG5cclxuICAgIGlmIChtb2RpZmllci5pc0luaXRpYWxpemVyKVxyXG4gICAgICBhcnJheSA9IHRoaXMubUluaXRpYWxpemVycztcclxuXHJcbiAgICBsZXQgaXggPSBhcnJheS5pbmRleE9mKG1vZGlmaWVyKTtcclxuICAgIGlmIChpeCA+PSAwKSB7XHJcbiAgICAgIGFycmF5LnNwbGljZShpeCwgMSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhY2t5IG1ldGhvZCB3aGljaCByZXR1cm5zIHRpbWUgbm93IG9yIHByZXNpbXVsYXRpb24gdGltZSBkZXBlbmRpbmcgb24gYSBjYXNlLlxyXG4gICAqL1xyXG4gIF9fZ2V0VGltZSgpIHtcclxuICAgIHJldHVybiBCbGFjay50aW1lLm5vdztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgZGVsYXksIGR1cmF0aW9uLCBpbnRlcnZhbC4gVXNlIHRoaXMgZnVuY3Rpb24gZWFjaCB0aW1lIHlvdSBjaGFuZ2Ugb25lIG9mIHRob3NlIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdD0wXVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgdXBkYXRlTmV4dFRpY2soZHQgPSAwKSB7XHJcbiAgICBsZXQgdCA9IEJsYWNrLnRpbWUubm93O1xyXG4gICAgbGV0IGZpcnN0RW1pdCA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh0aGlzLm1TdGF0ZSA9PT0gRW1pdHRlclN0YXRlLlBFTkRJTkcpIHtcclxuICAgICAgdGhpcy5tTmV4dFVwZGF0ZUF0ID0gdCArIHRoaXMubUVtaXREZWxheUxlZnQ7XHJcbiAgICAgIHRoaXMubUVtaXREZWxheUxlZnQgLT0gZHQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5tRW1pdERlbGF5TGVmdCA8PSAwKSB7XHJcbiAgICAgICAgdGhpcy5tRW1pdERlbGF5TGVmdCA9IHRoaXMubUVtaXREZWxheS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIHRoaXMubVN0YXRlID0gRW1pdHRlclN0YXRlLkVNSVRUSU5HO1xyXG4gICAgICAgIGZpcnN0RW1pdCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5tU3RhdGUgPT09IEVtaXR0ZXJTdGF0ZS5FTUlUVElORykge1xyXG4gICAgICBpZiAodGhpcy5tRW1pdER1cmF0aW9uTGVmdCA8PSAwKSB7XHJcbiAgICAgICAgdGhpcy5tRW1pdER1cmF0aW9uTGVmdCA9IHRoaXMubUVtaXREdXJhdGlvbi5nZXRWYWx1ZSgpO1xyXG5cclxuICAgICAgICB0aGlzLm1FbWl0TnVtUmVwZWF0c0xlZnQtLTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubUVtaXROdW1SZXBlYXRzTGVmdCA8PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLm1TdGF0ZSA9IEVtaXR0ZXJTdGF0ZS5GSU5JU0hFRDtcclxuXHJcbiAgICAgICAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMubVN0YXRlID0gRW1pdHRlclN0YXRlLlBFTkRJTkc7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHdlIGFyZSBnZXR0aW5nIHZhbHVlIGhlcmUgZWFjaCB1cGRhdGUgdG8gbWFrZSBzdXJlIHdlIGFyZSB1cCB0byBkYXRlIVxyXG4gICAgICAgIGlmIChmaXJzdEVtaXQpIHtcclxuICAgICAgICAgIC8vIGZvciBhIGZpcnN0IGVtaXQgd2UgZG8gbm90IHdhbnQgdG8gYWRkIGFuIGV4dHJhIGRlbGF5LiBlbWl0IG5vdyFcclxuICAgICAgICAgIHRoaXMubU5leHRVcGRhdGVBdCA9IHQ7XHJcbiAgICAgICAgICB0aGlzLm1FbWl0SW50ZXJ2YWxMZWZ0ID0gdGhpcy5tRW1pdEludGVydmFsLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5tRW1pdEludGVydmFsTGVmdCAtPSBkdDtcclxuICAgICAgICAgIHRoaXMubU5leHRVcGRhdGVBdCA9IHQgKyB0aGlzLm1FbWl0SW50ZXJ2YWxMZWZ0O1xyXG5cclxuICAgICAgICAgIC8vIHJlc2V0IGludGVydmFsXHJcbiAgICAgICAgICBpZiAodGhpcy5tRW1pdEludGVydmFsTGVmdCA8PSAwKVxyXG4gICAgICAgICAgICB0aGlzLm1FbWl0SW50ZXJ2YWxMZWZ0ID0gdGhpcy5tRW1pdEludGVydmFsLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLm1FbWl0RHVyYXRpb25MZWZ0IC09IGR0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvblVwZGF0ZSgpIHtcclxuICAgIGlmICh0aGlzLm1TdGF0ZSA9PT0gRW1pdHRlclN0YXRlLlBBVVNFRClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBkdCA9IEJsYWNrLnRpbWUuZGVsdGE7XHJcblxyXG4gICAgLy8gcmF0ZSBsb2dpY1xyXG4gICAgdGhpcy51cGRhdGVOZXh0VGljayhkdCk7XHJcblxyXG4gICAgaWYgKEJsYWNrLnRpbWUubm93ID49IHRoaXMubU5leHRVcGRhdGVBdCAmJiB0aGlzLm1TdGF0ZSA9PT0gRW1pdHRlclN0YXRlLkVNSVRUSU5HKSB7XHJcbiAgICAgIHRoaXMuX19jcmVhdGUodGhpcy5tRW1pdENvdW50LmdldFZhbHVlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1haW4gdXBkYXRlIGxvZ2luXHJcbiAgICBjb25zdCBhbGVuZ3RoID0gdGhpcy5tQWN0aW9ucy5sZW5ndGg7XHJcbiAgICBjb25zdCBwbGVuZ3RoID0gdGhpcy5tUGFydGljbGVzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGFsZW5ndGg7IGsrKylcclxuICAgICAgaWYgKHRoaXMubUFjdGlvbnNba10uaXNBY3RpdmUgPT09IHRydWUpXHJcbiAgICAgICAgdGhpcy5tQWN0aW9uc1trXS5wcmVVcGRhdGUoZHQpO1xyXG5cclxuICAgIGxldCBwYXJ0aWNsZTtcclxuXHJcbiAgICBsZXQgaSA9IHBsZW5ndGg7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgIHBhcnRpY2xlID0gdGhpcy5tUGFydGljbGVzW2ldO1xyXG5cclxuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBhbGVuZ3RoOyBrKyspXHJcbiAgICAgICAgaWYgKHRoaXMubUFjdGlvbnNba10uaXNBY3RpdmUgPT09IHRydWUpXHJcbiAgICAgICAgICB0aGlzLm1BY3Rpb25zW2tdLnVwZGF0ZSh0aGlzLCBwYXJ0aWNsZSwgZHQpO1xyXG5cclxuICAgICAgcGFydGljbGUudXBkYXRlKGR0KTtcclxuXHJcbiAgICAgIGlmIChwYXJ0aWNsZS5saWZlID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5tUmVjeWNsZWQucHVzaChwYXJ0aWNsZSk7XHJcbiAgICAgICAgdGhpcy5tUGFydGljbGVzLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgYWxlbmd0aDsgaysrKVxyXG4gICAgICBpZiAodGhpcy5tQWN0aW9uc1trXS5pc0FjdGl2ZSA9PT0gdHJ1ZSlcclxuICAgICAgICB0aGlzLm1BY3Rpb25zW2tdLnBvc3RVcGRhdGUoZHQpO1xyXG5cclxuICAgIC8vIHNldCBkdW1teSBkaXJ0eSBmbGFnIHNvIHVuY2hhbmdlZCBmcmFtZXMgY2FuIGJlIGRldGVjdGVkXHJcbiAgICBpZiAodGhpcy5tVmlzaWJsZSA9PT0gdHJ1ZSAmJiB0aGlzLm1BbHBoYSA+IDApXHJcbiAgICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLkxPQ0FMLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2NyZWF0ZShhbW91bnQpIHtcclxuICAgIGxldCBtYXRyaXggPSB0aGlzLndvcmxkVHJhbnNmb3JtYXRpb24uY2xvbmUoKTtcclxuICAgIGxldCBtaW52ID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5tSXNMb2NhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgbWludiA9IHRoaXMubVNwYWNlLndvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZC5jbG9uZSgpO1xyXG4gICAgICBtYXRyaXgucHJlcGVuZChtaW52KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcbiAgICAgIGxldCBwID0gbnVsbDtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1SZWN5Y2xlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcCA9IHRoaXMubVJlY3ljbGVkLnBvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh0aGlzLm1QYXJ0aWNsZXMubGVuZ3RoID49IHRoaXMubU1heFBhcnRpY2xlcylcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgcCA9IG5ldyBQYXJ0aWNsZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwLnJlc2V0KCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRoaXMubUluaXRpYWxpemVycy5sZW5ndGg7IGsrKylcclxuICAgICAgICBpZiAodGhpcy5tSW5pdGlhbGl6ZXJzW2tdLmlzQWN0aXZlID09PSB0cnVlKVxyXG4gICAgICAgICAgdGhpcy5tSW5pdGlhbGl6ZXJzW2tdLnVwZGF0ZSh0aGlzLCBwLCAwKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1Jc0xvY2FsID09PSBmYWxzZSkge1xyXG4gICAgICAgIG1hdHJpeC50cmFuc2Zvcm1YWShwLngsIHAueSwgVmVjdG9yLl9fY2FjaGUpO1xyXG4gICAgICAgIHAueCA9IFZlY3Rvci5fX2NhY2hlLng7XHJcbiAgICAgICAgcC55ID0gVmVjdG9yLl9fY2FjaGUueTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5tUGFydGljbGVzLnB1c2gocCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGN1cnJlbnQgZW1pdHRlciBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5FbWl0dGVyU3RhdGV9XHJcbiAgICovXHJcbiAgZ2V0IHN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwYXJ0aWNsZXMgY2FuIGJlIGNyZWF0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG1heFBhcnRpY2xlcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXhQYXJ0aWNsZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBtYXhQYXJ0aWNsZXModmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGFyZ3VtZW50IGVycm9yLicpO1xyXG5cclxuICAgIHRoaXMubU1heFBhcnRpY2xlcyA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRoZSBudW1iZXIgb2YgcGFydGljbGVzIHRvIGJlIGVtaXR0ZWQgcGVyIHtAbGluayBFbWl0dGVyI2VtaXRJbnRlcnZhbH1cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGVtaXRDb3VudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1FbWl0Q291bnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZW1pdENvdW50KHZhbHVlKSB7XHJcbiAgICB0aGlzLm1FbWl0Q291bnQgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgbnVtYmVyIG9mIFwiZHVyYXRpb25zXCIgdG8gdG8gcmVwZWF0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlcn1cclxuICAgKi9cclxuICBnZXQgZW1pdE51bVJlcGVhdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRW1pdE51bVJlcGVhdHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZW1pdE51bVJlcGVhdHModmFsdWUpIHtcclxuICAgIHRoaXMubUVtaXROdW1SZXBlYXRzID0gdmFsdWU7XHJcbiAgICB0aGlzLm1FbWl0TnVtUmVwZWF0c0xlZnQgPSB0aGlzLm1FbWl0TnVtUmVwZWF0cy5nZXRWYWx1ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfVxyXG4gICAqL1xyXG4gIGdldCBlbWl0RHVyYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRW1pdER1cmF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGVtaXREdXJhdGlvbih2YWx1ZSkge1xyXG4gICAgdGhpcy5tRW1pdER1cmF0aW9uID0gdmFsdWU7XHJcbiAgICB0aGlzLm1FbWl0RHVyYXRpb25MZWZ0ID0gdGhpcy5tRW1pdER1cmF0aW9uLmdldFZhbHVlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfVxyXG4gICAqL1xyXG4gIGdldCBlbWl0SW50ZXJ2YWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRW1pdEludGVydmFsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGVtaXRJbnRlcnZhbCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tRW1pdEludGVydmFsID0gdmFsdWU7XHJcbiAgICB0aGlzLm1FbWl0SW50ZXJ2YWxMZWZ0ID0gdGhpcy5tRW1pdEludGVydmFsLmdldFZhbHVlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfVxyXG4gICAqL1xyXG4gIGdldCBlbWl0RGVsYXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRW1pdERlbGF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGVtaXREZWxheSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tRW1pdERlbGF5ID0gdmFsdWU7XHJcbiAgICB0aGlzLm1FbWl0RGVsYXlMZWZ0ID0gdGhpcy5tRW1pdERlbGF5LmdldFZhbHVlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRoZSBzcGFjZSB3aGVyZSBlbWl0dGluZyBzaW11bGF0aW9uIHdpbGwgaGFwcGVuLCBpZ25vcmluZyBzcGFjZSB0cmFuc2Zvcm1hdGlvbiwgc28gYWxsIGZvcmNlcyBhcmUgcmVsYXRpdmUgdG8gZ2xvYmFsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9XHJcbiAgICovXHJcbiAgZ2V0IHNwYWNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNwYWNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ2FtZU9iamVjdFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNwYWNlKGdhbWVPYmplY3QpIHtcclxuICAgIHRoaXMubVNwYWNlID0gZ2FtZU9iamVjdDtcclxuICAgIHRoaXMubUlzTG9jYWwgPSB0aGlzLm1TcGFjZSA9PT0gbnVsbCB8fCB0aGlzLm1TcGFjZSA9PT0gdGhpcztcclxuICAgIHRoaXMuc2V0UmVuZGVyRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBhIGxpc3Qgb2YgdGV4dHVyZXMgdG8gdXNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXk8YmxhY2stZW5naW5lflRleHR1cmU+fVxyXG4gICAqL1xyXG4gIGdldCB0ZXh0dXJlcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1UZXh0dXJlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8YmxhY2stZW5naW5lflRleHR1cmU+fSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHRleHR1cmVzKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1UZXh0dXJlcyA9IHZhbHVlO1xyXG5cclxuICAgIERlYnVnLmFzc2VydCghKHRoaXMubVRleHR1cmVzID09PSBudWxsIHx8IHRoaXMubVRleHR1cmVzLmxlbmd0aCA9PT0gMCksICdBdCBsZWFzdCBvbmUgdGV4dHVyZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xyXG5cclxuICAgIHRoaXMuc2V0UmVuZGVyRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbGlzdCBvZiB0ZXh0dXJlcyB1c2VkIGJ5IHRoaXMgZW1pdHRlci5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cclxuICAgKi9cclxuICBnZXQgdGV4dHVyZU5hbWVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVRleHR1cmVOYW1lcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBsaXN0IG9mIHRleHR1cmVzIHdpdGggZ2l2ZW4gc3RyaW5nLiBJdCB1c2VzIEFzc2V0TWFuYWdlciB0byBmaW5kIHRleHR1cmVzLlxyXG4gICAgKiBcclxuICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2YWx1ZVxyXG4gICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAgKi9cclxuICBzZXQgdGV4dHVyZU5hbWVzKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1UZXh0dXJlTmFtZXMgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnRleHR1cmVzID0gdmFsdWUubWFwKHggPT4gQmxhY2suYXNzZXRzLmdldFRleHR1cmUoeCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIHRoZSBvcmRlciBpbiB3aGljaCBwYXJ0aWNsZXMgd2lsbCBiZSBzb3J0ZWQgd2hlbiByZW5kZXJpbmcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+RW1pdHRlclNvcnRPcmRlcn1cclxuICAgKi9cclxuICBnZXQgc29ydE9yZGVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNvcnRPcmRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkVtaXR0ZXJTb3J0T3JkZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc29ydE9yZGVyKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1Tb3J0T3JkZXIgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0UmVuZGVyRGlydHkoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGBQYXJ0aWNsZWAgb2JqZWN0cyBvbiBjYW52YXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5SZW5kZXJlclxyXG4gKiBAY2F0IGRyaXZlcnMuY2FudmFzXHJcbiAqL1xyXG5jbGFzcyBFbWl0dGVyUmVuZGVyZXJDYW52YXMgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgRW1pdHRlclJlbmRlcmVyQ2FudmFzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmlzTG9jYWwgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWF0cml4fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5fX3RtcExvY2FsID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLl9fdG1wV29ybGQgPSBuZXcgTWF0cml4KCk7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICBwcmVSZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7RW1pdHRlcn0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgdGhpcy5lbmRQYXNzUmVxdWlyZWQgPSB0aGlzLmdhbWVPYmplY3QubUNsaXBSZWN0ICE9PSBudWxsICYmIHRoaXMuZ2FtZU9iamVjdC5tQ2xpcFJlY3QuaXNFbXB0eSA9PT0gZmFsc2U7XHJcbiAgICB0aGlzLnNraXBDaGlsZHJlbiA9ICEoZ2FtZU9iamVjdC5tQWxwaGEgPiAwICYmIGdhbWVPYmplY3QubVRleHR1cmVzLmxlbmd0aCA+IDAgJiYgZ2FtZU9iamVjdC5tVmlzaWJsZSA9PT0gdHJ1ZSk7XHJcbiAgICB0aGlzLnNraXBTZWxmID0gIShnYW1lT2JqZWN0Lm1UZXh0dXJlcy5sZW5ndGggPiAwICYmIGdhbWVPYmplY3QubVBhcnRpY2xlcy5sZW5ndGggPiAwKTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gIHJlbmRlcihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIGxldCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtFbWl0dGVyfSAqLyAodGhpcy5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICBkcml2ZXIuc2V0U25hcFRvUGl4ZWxzKGdhbWVPYmplY3Quc25hcFRvUGl4ZWxzKTtcclxuXHJcbiAgICBsZXQgcGxlbmd0aCA9IGdhbWVPYmplY3QubVBhcnRpY2xlcy5sZW5ndGg7XHJcbiAgICBsZXQgbG9jYWxUcmFuc2Zvcm0gPSB0aGlzLl9fdG1wTG9jYWw7XHJcbiAgICBsZXQgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLl9fdG1wV29ybGQ7XHJcbiAgICBsb2NhbFRyYW5zZm9ybS5pZGVudGl0eSgpO1xyXG5cclxuICAgIGlmIChnYW1lT2JqZWN0LnNvcnRPcmRlciA9PT0gRW1pdHRlclNvcnRPcmRlci5GUk9OVF9UT19CQUNLKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbmd0aDsgaSsrKVxyXG4gICAgICAgIHRoaXMuX19yZW5kZXJQYXJ0aWNsZShnYW1lT2JqZWN0Lm1QYXJ0aWNsZXNbaV0sIGxvY2FsVHJhbnNmb3JtLCB3b3JsZFRyYW5zZm9ybSwgZHJpdmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSBwbGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcclxuICAgICAgICB0aGlzLl9fcmVuZGVyUGFydGljbGUoZ2FtZU9iamVjdC5tUGFydGljbGVzW2ldLCBsb2NhbFRyYW5zZm9ybSwgd29ybGRUcmFuc2Zvcm0sIGRyaXZlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5QYXJ0aWNsZX0gcGFydGljbGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NYXRyaXh9IGxvY2FsVHJhbnNmb3JtXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWF0cml4fSB3b3JsZFRyYW5zZm9ybVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlcn0gZHJpdmVyXHJcbiAgICovXHJcbiAgX19yZW5kZXJQYXJ0aWNsZShwYXJ0aWNsZSwgbG9jYWxUcmFuc2Zvcm0sIHdvcmxkVHJhbnNmb3JtLCBkcml2ZXIpIHtcclxuICAgIGxldCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtFbWl0dGVyfSAqLyAodGhpcy5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICBsZXQgdGV4dHVyZSA9IGdhbWVPYmplY3QudGV4dHVyZXNbcGFydGljbGUudGV4dHVyZUluZGV4XTtcclxuICAgIGxldCB0dyA9IHRleHR1cmUuZGlzcGxheVdpZHRoICogcGFydGljbGUuYW5jaG9yWDtcclxuICAgIGxldCB0aCA9IHRleHR1cmUuZGlzcGxheUhlaWdodCAqIHBhcnRpY2xlLmFuY2hvclk7XHJcblxyXG4gICAgaWYgKHBhcnRpY2xlLnIgPT09IDApIHtcclxuICAgICAgbGV0IHR4ID0gcGFydGljbGUueCAtIHR3ICogcGFydGljbGUuc2NhbGVYO1xyXG4gICAgICBsZXQgdHkgPSBwYXJ0aWNsZS55IC0gdGggKiBwYXJ0aWNsZS5zY2FsZVk7XHJcbiAgICAgIGxvY2FsVHJhbnNmb3JtLnNldChwYXJ0aWNsZS5zY2FsZVgsIDAsIDAsIHBhcnRpY2xlLnNjYWxlWSwgdHgsIHR5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBjb3MgPSBNYXRoLmNvcyhwYXJ0aWNsZS5yKTtcclxuICAgICAgbGV0IHNpbiA9IE1hdGguc2luKHBhcnRpY2xlLnIpO1xyXG4gICAgICBsZXQgYSA9IHBhcnRpY2xlLnNjYWxlWCAqIGNvcztcclxuICAgICAgbGV0IGIgPSBwYXJ0aWNsZS5zY2FsZVggKiBzaW47XHJcbiAgICAgIGxldCBjID0gcGFydGljbGUuc2NhbGVZICogLXNpbjtcclxuICAgICAgbGV0IGQgPSBwYXJ0aWNsZS5zY2FsZVkgKiBjb3M7XHJcblxyXG4gICAgICBsZXQgdHggPSBwYXJ0aWNsZS54IC0gdHcgKiBhIC0gdGggKiBjO1xyXG4gICAgICBsZXQgdHkgPSBwYXJ0aWNsZS55IC0gdHcgKiBiIC0gdGggKiBkO1xyXG4gICAgICBsb2NhbFRyYW5zZm9ybS5zZXQoYSwgYiwgYywgZCwgdHgsIHR5KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC5tSXNMb2NhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICB3b3JsZFRyYW5zZm9ybS5pZGVudGl0eSgpO1xyXG4gICAgICB3b3JsZFRyYW5zZm9ybS5jb3B5RnJvbShsb2NhbFRyYW5zZm9ybSk7XHJcbiAgICAgIHdvcmxkVHJhbnNmb3JtLnByZXBlbmQoZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdvcmxkVHJhbnNmb3JtLmNvcHlGcm9tKGdhbWVPYmplY3QubVNwYWNlLndvcmxkVHJhbnNmb3JtYXRpb24pO1xyXG4gICAgICB3b3JsZFRyYW5zZm9ybS5hcHBlbmQobG9jYWxUcmFuc2Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGRyaXZlci5zZXRHbG9iYWxBbHBoYShnYW1lT2JqZWN0Lm1BbHBoYSAqIHBhcnRpY2xlLmFscGhhKTtcclxuICAgIGRyaXZlci5zZXRUcmFuc2Zvcm0od29ybGRUcmFuc2Zvcm0pO1xyXG4gICAgZHJpdmVyLmRyYXdUZXh0dXJlKFJlbmRlcmVyLmdldENvbG9yZWRUZXh0dXJlKHRleHR1cmUsIHBhcnRpY2xlLmNvbG9yID09PSBudWxsID8gZ2FtZU9iamVjdC5tQ29sb3IgOiBwYXJ0aWNsZS5jb2xvcikpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYFNwcml0ZWAgb2JqZWN0cyBvbiBjYW52YXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5SZW5kZXJlclxyXG4gKiBAY2F0IGRyaXZlcnMuY2FudmFzXHJcbiAqL1xyXG5cclxuY2xhc3MgU3ByaXRlUmVuZGVyZXJDYW52YXMgZXh0ZW5kcyBSZW5kZXJlcntcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtDYW52YXNQYXR0ZXJufG51bGx9ICovXHJcbiAgICB0aGlzLnBhdHRlcm4gPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lflRleHR1cmV8bnVsbH0gKi9cclxuICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkNhbnZhc1JlbmRlclRleHR1cmV8bnVsbH0gKi9cclxuICAgIHRoaXMuc2xpY2VUZXh0dXJlQ2FjaGUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfG51bGx9ICovXHJcbiAgICB0aGlzLnNpemVXaWR0aENhY2hlID0gbnVsbDtcclxuXHJcbiAgICAvKiogQHR5cGUge251bWJlcnxudWxsfSAqL1xyXG4gICAgdGhpcy5zaXplSGVpZ2h0Q2FjaGUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lflRleHR1cmV9ICovXHJcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICBwcmVSZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7U3ByaXRlfSAqLyAodGhpcy5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICBjb25zdCBza2lwID0gZ2FtZU9iamVjdC5tQ2xpcFJlY3QgIT09IG51bGwgJiYgZ2FtZU9iamVjdC5tQ2xpcFJlY3QuaXNFbXB0eTtcclxuXHJcbiAgICB0aGlzLmVuZFBhc3NSZXF1aXJlZCA9IGdhbWVPYmplY3QubUNsaXBSZWN0ICE9PSBudWxsICYmICFnYW1lT2JqZWN0Lm1DbGlwUmVjdC5pc0VtcHR5O1xyXG4gICAgdGhpcy5za2lwQ2hpbGRyZW4gPSBza2lwIHx8IGdhbWVPYmplY3QubUFscGhhIDw9IDAgfHwgZ2FtZU9iamVjdC5tVmlzaWJsZSA9PT0gZmFsc2U7XHJcbiAgICB0aGlzLnNraXBTZWxmID0gc2tpcCB8fCBnYW1lT2JqZWN0Lm1UZXh0dXJlID09PSBudWxsIHx8IGdhbWVPYmplY3QubUFscGhhIDw9IDAgfHwgZ2FtZU9iamVjdC5tVmlzaWJsZSA9PT0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZW5kZXJTbGljZTlHcmlkKGRyaXZlciwgdGV4dHVyZSwgZ3JpZCkge1xyXG4gICAgY29uc3QgZHByID0gZHJpdmVyLm1EZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgbGV0IGRlc2lyZWRXaWR0aCA9IHRleHR1cmUud2lkdGggKiB0aGlzLmdhbWVPYmplY3QubVNjYWxlWDtcclxuICAgIGxldCBkZXNpcmVkSGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgKiB0aGlzLmdhbWVPYmplY3QubVNjYWxlWTtcclxuXHJcbiAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGUgPT09IHRleHR1cmUgJiYgdGhpcy5zaXplV2lkdGhDYWNoZSA9PT0gZGVzaXJlZFdpZHRoICYmIHRoaXMuc2l6ZUhlaWdodENhY2hlID09PSBkZXNpcmVkSGVpZ2h0KVxyXG4gICAgICByZXR1cm4gdGhpcy5zbGljZVRleHR1cmVDYWNoZTtcclxuXHJcbiAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHRleHR1cmU7XHJcbiAgICB0aGlzLnNpemVXaWR0aENhY2hlID0gZGVzaXJlZFdpZHRoO1xyXG4gICAgdGhpcy5zaXplSGVpZ2h0Q2FjaGUgPSBkZXNpcmVkSGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IHNvdXJjZVggPSB0ZXh0dXJlLnJlZ2lvbi54O1xyXG4gICAgY29uc3Qgc291cmNlWSA9IHRleHR1cmUucmVnaW9uLnk7XHJcbiAgICBjb25zdCBzb3VyY2VXaWR0aCA9IHRleHR1cmUucmVnaW9uLndpZHRoO1xyXG4gICAgY29uc3Qgc291cmNlSGVpZ2h0ID0gdGV4dHVyZS5yZWdpb24uaGVpZ2h0O1xyXG5cclxuICAgIGNvbnN0IGRlc3RYID0gdGV4dHVyZS51bnRyaW1tZWRSZWdpb24ueCAqIGRwcjtcclxuICAgIGNvbnN0IGRlc3RZID0gdGV4dHVyZS51bnRyaW1tZWRSZWdpb24ueSAqIGRwcjtcclxuXHJcbiAgICBpZiAodGhpcy5zbGljZVRleHR1cmVDYWNoZSA9PT0gbnVsbClcclxuICAgICAgdGhpcy5zbGljZVRleHR1cmVDYWNoZSA9IG5ldyBDYW52YXNSZW5kZXJUZXh0dXJlKGRlc2lyZWRXaWR0aCwgZGVzaXJlZEhlaWdodCwgMSAvIHRleHR1cmUuc2NhbGUpO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLnNsaWNlVGV4dHVyZUNhY2hlLnJlc2l6ZShkZXNpcmVkV2lkdGgsIGRlc2lyZWRIZWlnaHQsIDEgLyB0ZXh0dXJlLnNjYWxlKTtcclxuXHJcbiAgICBjb25zdCBjdHggPSB0aGlzLnNsaWNlVGV4dHVyZUNhY2hlLnJlbmRlclRhcmdldC5jb250ZXh0O1xyXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbih0aGlzLmdhbWVPYmplY3Quc2NhbGVYLCB0aGlzLmdhbWVPYmplY3Quc2NhbGVZKTtcclxuXHJcbiAgICBpZiAoc2NhbGUgPD0gMSkge1xyXG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgMCwgMCk7XHJcbiAgICAgIGRlc2lyZWRXaWR0aCAvPSBzY2FsZTtcclxuICAgICAgZGVzaXJlZEhlaWdodCAvPSBzY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBncmlkTGVmdCA9IGdyaWQueCAvIHRleHR1cmUuc2NhbGU7XHJcbiAgICBjb25zdCBncmlkVG9wID0gZ3JpZC55IC8gdGV4dHVyZS5zY2FsZTtcclxuICAgIGNvbnN0IGdyaWRSaWdodCA9IHNvdXJjZVdpZHRoIC0gZ3JpZC5yaWdodCAvIHRleHR1cmUuc2NhbGU7XHJcbiAgICBjb25zdCBncmlkQm90dG9tID0gc291cmNlSGVpZ2h0IC0gZ3JpZC5ib3R0b20gLyB0ZXh0dXJlLnNjYWxlO1xyXG5cclxuICAgIC8vIG5vbi1zY2FsYWJsZVxyXG4gICAgY29uc3Qgc3JjT2Zmc2V0WCA9IHNvdXJjZVggKyBzb3VyY2VXaWR0aCAtIGdyaWRSaWdodDtcclxuICAgIGNvbnN0IGRzdE9mZnNldFggPSBkZXN0WCArIGRlc2lyZWRXaWR0aCAvIHRleHR1cmUuc2NhbGUgLSBncmlkUmlnaHQ7XHJcblxyXG4gICAgY29uc3Qgc3JjT2Zmc2V0WSA9IHNvdXJjZVkgKyBzb3VyY2VIZWlnaHQgLSBncmlkQm90dG9tO1xyXG4gICAgY29uc3QgZHN0T2Zmc2V0WSA9IGRlc3RZICsgZGVzaXJlZEhlaWdodCAvIHRleHR1cmUuc2NhbGUgLSBncmlkQm90dG9tO1xyXG5cclxuICAgIC8vIHRvcCBsZWZ0XHJcbiAgICBjdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCBzb3VyY2VYLCBzb3VyY2VZLCBncmlkTGVmdCwgZ3JpZFRvcCwgZGVzdFgsIGRlc3RZLCBncmlkTGVmdCwgZ3JpZFRvcCk7XHJcblxyXG4gICAgLy8gdG9wIHJpZ2h0XHJcbiAgICBjdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCBzcmNPZmZzZXRYLCBzb3VyY2VZLCBncmlkUmlnaHQsIGdyaWRUb3AsIGRzdE9mZnNldFgsIGRlc3RZLCBncmlkUmlnaHQsIGdyaWRUb3ApO1xyXG5cclxuICAgIC8vIGJvdHRvbSByaWdodFxyXG4gICAgY3R4LmRyYXdJbWFnZSh0ZXh0dXJlLm5hdGl2ZSwgc3JjT2Zmc2V0WCwgc3JjT2Zmc2V0WSwgZ3JpZFJpZ2h0LCBncmlkQm90dG9tLCBkc3RPZmZzZXRYLCBkc3RPZmZzZXRZLCBncmlkUmlnaHQsIGdyaWRCb3R0b20pO1xyXG5cclxuICAgIC8vIGJvdHRvbSBsZWZ0XHJcbiAgICBjdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCBzb3VyY2VYLCBzcmNPZmZzZXRZLCBncmlkTGVmdCwgZ3JpZEJvdHRvbSwgZGVzdFgsIGRzdE9mZnNldFksIGdyaWRMZWZ0LCBncmlkQm90dG9tKTtcclxuXHJcbiAgICAvLyBzY2FsYWJsZVxyXG4gICAgY29uc3Qgc3JjTGVmdE9mZnNldCA9IHNvdXJjZVggKyBncmlkTGVmdDtcclxuICAgIGNvbnN0IGRzdExlZnRPZmZzZXQgPSBkZXN0WCArIGdyaWRMZWZ0O1xyXG5cclxuICAgIGNvbnN0IHNyY1RvcE9mZnNldCA9IHNvdXJjZVkgKyBncmlkVG9wO1xyXG4gICAgY29uc3QgZHN0VG9wT2Zmc2V0ID0gZGVzdFkgKyBncmlkVG9wO1xyXG5cclxuICAgIGNvbnN0IHNyY1JpZ2h0T2Zmc2V0ID0gc291cmNlWCArIHNvdXJjZVdpZHRoIC0gZ3JpZFJpZ2h0O1xyXG4gICAgY29uc3QgZHN0UmlnaHRPZmZzZXQgPSBkZXN0WCArIGRlc2lyZWRXaWR0aCAvIHRleHR1cmUuc2NhbGUgLSBncmlkUmlnaHQ7XHJcblxyXG4gICAgY29uc3Qgc3JjQm90dG9tT2Zmc2V0ID0gc291cmNlWSArIHNvdXJjZUhlaWdodCAtIGdyaWRCb3R0b207XHJcbiAgICBjb25zdCBkc3RCb3R0b21PZmZzZXQgPSBkZXN0WSArIGRlc2lyZWRIZWlnaHQgLyB0ZXh0dXJlLnNjYWxlIC0gZ3JpZEJvdHRvbTtcclxuXHJcbiAgICBjb25zdCBzcmNDZW50ZXJXaWR0aCA9IHNvdXJjZVdpZHRoIC0gZ3JpZExlZnQgLSBncmlkUmlnaHQ7XHJcbiAgICBjb25zdCBkc3RDZW50ZXJXaWR0aCA9IGRlc2lyZWRXaWR0aCAvIHRleHR1cmUuc2NhbGUgLSBncmlkTGVmdCAtIGdyaWRSaWdodDtcclxuXHJcbiAgICBjb25zdCBzcmNDZW50ZXJIZWlnaHQgPSBzb3VyY2VIZWlnaHQgLSBncmlkVG9wIC0gZ3JpZEJvdHRvbTtcclxuICAgIGNvbnN0IGRzdENlbnRlckhlaWdodCA9IGRlc2lyZWRIZWlnaHQgLyB0ZXh0dXJlLnNjYWxlIC0gZ3JpZFRvcCAtIGdyaWRCb3R0b207XHJcblxyXG4gICAgLy8gdG9wXHJcbiAgICBjdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCBzcmNMZWZ0T2Zmc2V0LCBzb3VyY2VZLCBzcmNDZW50ZXJXaWR0aCwgZ3JpZFRvcCwgZHN0TGVmdE9mZnNldCwgZGVzdFksIGRzdENlbnRlcldpZHRoLCBncmlkVG9wKTtcclxuXHJcbiAgICAvLyByaWdodFxyXG4gICAgY3R4LmRyYXdJbWFnZSh0ZXh0dXJlLm5hdGl2ZSwgc3JjUmlnaHRPZmZzZXQsIHNyY1RvcE9mZnNldCwgZ3JpZFJpZ2h0LCBzcmNDZW50ZXJIZWlnaHQsIGRzdFJpZ2h0T2Zmc2V0LCBkc3RUb3BPZmZzZXQsIGdyaWRSaWdodCwgZHN0Q2VudGVySGVpZ2h0KTtcclxuXHJcbiAgICAvLyBib3R0b21cclxuICAgIGN0eC5kcmF3SW1hZ2UodGV4dHVyZS5uYXRpdmUsIHNyY0xlZnRPZmZzZXQsIHNyY0JvdHRvbU9mZnNldCwgc3JjQ2VudGVyV2lkdGgsIGdyaWRCb3R0b20sIGRzdExlZnRPZmZzZXQsIGRzdEJvdHRvbU9mZnNldCwgZHN0Q2VudGVyV2lkdGgsIGdyaWRCb3R0b20pO1xyXG5cclxuICAgIC8vIGxlZnRcclxuICAgIGN0eC5kcmF3SW1hZ2UodGV4dHVyZS5uYXRpdmUsIHNvdXJjZVgsIHNyY1RvcE9mZnNldCwgZ3JpZExlZnQsIHNyY0NlbnRlckhlaWdodCwgZGVzdFgsIGRzdFRvcE9mZnNldCwgZ3JpZExlZnQsIGRzdENlbnRlckhlaWdodCk7XHJcblxyXG4gICAgLy9jZW50ZXJcclxuICAgIGN0eC5kcmF3SW1hZ2UodGV4dHVyZS5uYXRpdmUsIHNyY0xlZnRPZmZzZXQsIHNyY1RvcE9mZnNldCwgc3JjQ2VudGVyV2lkdGgsIHNyY0NlbnRlckhlaWdodCwgZHN0TGVmdE9mZnNldCwgZHN0VG9wT2Zmc2V0LCBkc3RDZW50ZXJXaWR0aCwgZHN0Q2VudGVySGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zbGljZVRleHR1cmVDYWNoZTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gIHJlbmRlcihkcml2ZXIsIHNlc3Npb24pIHtcclxuICAgIGxldCBjdHggPSAvKiogQHR5cGUge0NhbnZhc0RyaXZlcn0qLyAoZHJpdmVyKS5tQ3R4O1xyXG4gICAgbGV0IGdhbWVPYmplY3QgPSAvKiogQHR5cGUge1Nwcml0ZX0gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcblxyXG4gICAgbGV0IHRleHR1cmUgPSBSZW5kZXJlci5nZXRDb2xvcmVkVGV4dHVyZShnYW1lT2JqZWN0Lm1UZXh0dXJlLCB0aGlzLmNvbG9yKTtcclxuXHJcbiAgICBpZiAoZ2FtZU9iamVjdC5tU2xpY2U5Z3JpZCAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nYW1lT2JqZWN0LndvcmxkVHJhbnNmb3JtYXRpb24uZGF0YTtcclxuICAgICAgY29uc3QgbSA9IE1hdHJpeC5wb29sLmdldCgpLnNldChkYXRhWzBdIC8gdGhpcy5nYW1lT2JqZWN0LnNjYWxlWCwgZGF0YVsxXSAvIHRoaXMuZ2FtZU9iamVjdC5zY2FsZVgsIGRhdGFbMl0gLyB0aGlzLmdhbWVPYmplY3Quc2NhbGVZLCBkYXRhWzNdIC8gdGhpcy5nYW1lT2JqZWN0LnNjYWxlWSwgZGF0YVs0XSwgZGF0YVs1XSk7XHJcbiAgICAgIGRyaXZlci5zZXRUcmFuc2Zvcm0obSk7XHJcbiAgICAgIE1hdHJpeC5wb29sLnJlbGVhc2UobSk7XHJcblxyXG4gICAgICB0ZXh0dXJlID0gdGhpcy5yZW5kZXJTbGljZTlHcmlkKGRyaXZlciwgdGV4dHVyZSwgZ2FtZU9iamVjdC5tU2xpY2U5Z3JpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QubVRpbGluZyA9PT0gbnVsbCkge1xyXG4gICAgICBkcml2ZXIuZHJhd1RleHR1cmUodGV4dHVyZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB3ZSBnb3Qgc29tZSB0aWxpbmdcclxuICAgICAgaWYgKHRoaXMucGF0dGVybiA9PT0gbnVsbCB8fCB0aGlzLnBhdHRlcm5UZXh0dXJlICE9PSB0ZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyQ2FudmFzID0gbmV3IFJlbmRlclRhcmdldENhbnZhcyh0ZXh0dXJlLndpZHRoLCB0ZXh0dXJlLmhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgciA9IHRleHR1cmUucmVnaW9uO1xyXG4gICAgICAgIGNvbnN0IHUgPSB0ZXh0dXJlLnVudHJpbW1lZFJlZ2lvbjtcclxuICAgICAgICByZW5kZXJDYW52YXMuY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZS5uYXRpdmUsIHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCwgdS54LCB1LnksIHIud2lkdGgsIHIuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4ocmVuZGVyQ2FudmFzLm5hdGl2ZSwgJ3JlcGVhdCcpO1xyXG4gICAgICAgIHRoaXMucGF0dGVyblRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gLyoqIEB0eXBlIHtDYW52YXNQYXR0ZXJufSAqLyh0aGlzLnBhdHRlcm4pO1xyXG5cclxuICAgICAgbGV0IGRwciA9IGRyaXZlci5yZW5kZXJTY2FsZUZhY3RvcjtcclxuXHJcbiAgICAgIGxldCBtID0gZ2FtZU9iamVjdC53b3JsZFRyYW5zZm9ybWF0aW9uLmNsb25lKCk7XHJcbiAgICAgIG0uc2NhbGUoZ2FtZU9iamVjdC50aWxpbmcuc2NhbGVYICogZHByLCBnYW1lT2JqZWN0LnRpbGluZy5zY2FsZVkgKiBkcHIpO1xyXG4gICAgICBtLnRyYW5zbGF0ZShnYW1lT2JqZWN0LnRpbGluZy53cmFwWCAvIGRwciwgZ2FtZU9iamVjdC50aWxpbmcud3JhcFkgLyBkcHIpO1xyXG5cclxuICAgICAgZHJpdmVyLnNldFRyYW5zZm9ybShtKTtcclxuXHJcbiAgICAgIC8vIGRyYXcgcGF0dGVyblxyXG4gICAgICBjdHguZmlsbFJlY3QoLWdhbWVPYmplY3QudGlsaW5nLndyYXBYLCAtZ2FtZU9iamVjdC50aWxpbmcud3JhcFksIGdhbWVPYmplY3QudGlsaW5nLndpZHRoIC8gZ2FtZU9iamVjdC50aWxpbmcuc2NhbGVYLCBnYW1lT2JqZWN0LnRpbGluZy5oZWlnaHQgLyBnYW1lT2JqZWN0LnRpbGluZy5zY2FsZVkpO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGBHcmFwaGljc2Agb2JqZWN0cyBvbiBjYW52YXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5HcmFwaGljc1JlbmRlcmVyXHJcbiAqIEBjYXQgZHJpdmVycy5jYW52YXNcclxuICovXHJcblxyXG5jbGFzcyBHcmFwaGljc1JlbmRlcmVyQ2FudmFzIGV4dGVuZHMgR3JhcGhpY3NSZW5kZXJlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgR3JhcGhpY3NSZW5kZXJlckNhbnZhcy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXREb2MgKi9cclxuICByZW5kZXIoZHJpdmVyLCBzZXNzaW9uKSB7XHJcbiAgICBsZXQgZ2FtZU9iamVjdCA9IC8qKiBAdHlwZSB7R3JhcGhpY3N9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgdGhpcy5fX2RyYXdDb21tYW5kQnVmZmVyKGRyaXZlcik7XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QubUNvbG9yICE9PSBudWxsICYmIGdhbWVPYmplY3QubUNvbG9yICE9PSAweEZGRkZGRikge1xyXG4gICAgICBkcml2ZXIuY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xyXG4gICAgICB0aGlzLl9fZHJhd0NvbW1hbmRCdWZmZXIoZHJpdmVyLCBnYW1lT2JqZWN0Lm1Db2xvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlIGNvbnRleHQgdG8gZHJhdy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VmlkZW9OdWxsRHJpdmVyfSBkcml2ZXIgRHJpdmVyIHRvIGRyYXcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8bnVsbD19IFtjb2xvcj1udWxsXSBUaW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX2RyYXdDb21tYW5kQnVmZmVyKGRyaXZlciwgY29sb3IgPSBudWxsKSB7XHJcbiAgICBjb25zdCBnYW1lT2JqZWN0ID0gLyoqIEB0eXBlIHtHcmFwaGljc30gKi8gKHRoaXMuZ2FtZU9iamVjdCk7XHJcbiAgICBjb25zdCBjdHggPSBkcml2ZXIuY29udGV4dDtcclxuXHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IE1hdHJpeC5wb29sLmdldCgpLmNvcHlGcm9tKGdhbWVPYmplY3Qud29ybGRUcmFuc2Zvcm1hdGlvbik7XHJcbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKC1nYW1lT2JqZWN0Lm1EYXRhT2Zmc2V0WCwgLWdhbWVPYmplY3QubURhdGFPZmZzZXRZKTtcclxuXHJcbiAgICB0aGlzLl9fcmVuZGVyTm9kZShkcml2ZXIsIGNvbG9yLCBnYW1lT2JqZWN0Lm1HcmFwaGljc0RhdGEsIHRyYW5zZm9ybSk7XHJcblxyXG4gICAgTWF0cml4LnBvb2wucmVsZWFzZSh0cmFuc2Zvcm0pO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IGRyYXdzIGVhY2ggbm9kZSBvZiBHcmFwaGljc0RhdGEuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlcn0gZHJpdmVyIERyaXZlciB0byBkcmF3LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGNvbG9yIFRpbnQuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R3JhcGhpY3NEYXRhfSBub2RlIENvbW1hbmRzIHByb3ZpZGVyLlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfk1hdHJpeH0gdHJhbnNmb3JtIEdyYXBoaWNzIERhdGEgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3JlbmRlck5vZGUoZHJpdmVyLCBjb2xvciwgbm9kZSwgdHJhbnNmb3JtKSB7XHJcbiAgICBjb25zdCBjb21tYW5kcyA9IG5vZGUubUNvbW1hbmRRdWV1ZTtcclxuICAgIGNvbnN0IGN0eCA9IGRyaXZlci5jb250ZXh0O1xyXG4gICAgY29uc3QgbGVuID0gY29tbWFuZHMubGVuZ3RoO1xyXG4gICAgY29uc3QgciA9IGRyaXZlci5yZW5kZXJTY2FsZUZhY3RvcjtcclxuICAgIGNvbnN0IHB4ID0gbm9kZS5tUGl2b3RYO1xyXG4gICAgY29uc3QgcHkgPSBub2RlLm1QaXZvdFk7XHJcblxyXG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLmNsb25lKCkuYXBwZW5kKG5vZGUubVRyYW5zZm9ybSk7XHJcbiAgICBkcml2ZXIuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBjb25zdCBjbWQgPSBjb21tYW5kc1tpXTtcclxuXHJcbiAgICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuTElORV9TVFlMRToge1xyXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNtZC5nZXROdW1iZXIoMCkgKiByO1xyXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3JIZWxwZXIuaW50VG9SR0JBKGNvbG9yID09PSBudWxsID8gY21kLmdldE51bWJlcigxKSA6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyhjb2xvciksIGNtZC5nZXROdW1iZXIoMikpO1xyXG4gICAgICAgICAgY3R4LmxpbmVDYXAgPSBjbWQuZ2V0U3RyaW5nKDMpO1xyXG4gICAgICAgICAgY3R4LmxpbmVKb2luID0gY21kLmdldFN0cmluZyg0KTtcclxuICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gY21kLmdldE51bWJlcig1KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLkZJTExfU1RZTEU6IHtcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvckhlbHBlci5pbnRUb1JHQkEoY29sb3IgPT09IG51bGwgPyBjbWQuZ2V0TnVtYmVyKDApIDogLyoqIEB0eXBlIHtudW1iZXJ9ICovKGNvbG9yKSwgY21kLmdldE51bWJlcigxKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5GSUxMX0dSRDoge1xyXG4gICAgICAgICAgY29uc3QgZ3JhZGllbnRJbmZvID0gLyoqIEB0eXBlIHtHcmFwaGljc0xpbmVhckdyYWRpZW50fSAqLyhjbWQuZ2V0T2JqZWN0KDApKTtcclxuICAgICAgICAgIGxldCBncmQgPSBncmFkaWVudEluZm8ubmF0aXZlO1xyXG5cclxuICAgICAgICAgIGlmICghZ3JkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRwciA9IEJsYWNrLmRyaXZlci5yZW5kZXJTY2FsZUZhY3RvcjtcclxuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZ3JkID0gZ3JhZGllbnRJbmZvLm5hdGl2ZSA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChncmFkaWVudEluZm8ueDAgKiBkcHIsIGdyYWRpZW50SW5mby55MCAqIGRwcixcclxuICAgICAgICAgICAgICBncmFkaWVudEluZm8ueDEgKiBkcHIsIGdyYWRpZW50SW5mby55MSAqIGRwcik7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZ3JhZGllbnRJbmZvLnN0b3BzKSB7XHJcbiAgICAgICAgICAgICAgZW50cmllcy5wdXNoKHsgcGVyY2VudDogcGFyc2VGbG9hdChrZXkpLCBjb2xvcjogZ3JhZGllbnRJbmZvLnN0b3BzW2tleV0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVudHJpZXMuc29ydCgoYSwgYikgPT4gYS5wZXJjZW50IC0gYi5wZXJjZW50KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZW50cmllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaV07XHJcbiAgICAgICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChlbnRyeS5wZXJjZW50LCBlbnRyeS5jb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gLyoqIEB0eXBlIHtDYW52YXNHcmFkaWVudH0gKi8oZ3JkKTtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5GSUxMX1BBVFRFUk46IHtcclxuICAgICAgICAgIGNvbnN0IHBhdHRlcm5JbmZvID0gLyoqIEB0eXBlIHtHcmFwaGljc1BhdHRlcm59ICovKGNtZC5nZXRPYmplY3QoMCkpO1xyXG4gICAgICAgICAgbGV0IHBhdHRlcm4gPSBwYXR0ZXJuSW5mby5uYXRpdmU7XHJcblxyXG4gICAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuSW5mby5uYXRpdmUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuSW5mby5pbWFnZSwgcGF0dGVybkluZm8ucmVwZXRpdGlvbik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IC8qKiBAdHlwZSB7Q2FudmFzUGF0dGVybn0gKi8ocGF0dGVybik7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuQVJDOiB7XHJcbiAgICAgICAgICBjdHguYXJjKGNtZC5nZXROdW1iZXIoMCkgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoMSkgKiByIC0gcHksIGNtZC5nZXROdW1iZXIoMikgKiByLCBjbWQuZ2V0TnVtYmVyKDMpLCBjbWQuZ2V0TnVtYmVyKDQpLCBjbWQuZ2V0Qm9vbGVhbig1KSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5SRUNUOiB7XHJcbiAgICAgICAgICBjdHgucmVjdChjbWQuZ2V0TnVtYmVyKDApICogciAtIHB4LCBjbWQuZ2V0TnVtYmVyKDEpICogciAtIHB5LCBjbWQuZ2V0TnVtYmVyKDIpICogciwgY21kLmdldE51bWJlcigzKSAqIHIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuUk9VTkRFRF9SRUNUOiB7XHJcbiAgICAgICAgICBjb25zdCB4ID0gY21kLmdldE51bWJlcigwKTtcclxuICAgICAgICAgIGNvbnN0IHkgPSBjbWQuZ2V0TnVtYmVyKDEpO1xyXG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBjbWQuZ2V0TnVtYmVyKDIpO1xyXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gY21kLmdldE51bWJlcigzKTtcclxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGNtZC5nZXROdW1iZXIoNCk7XHJcblxyXG4gICAgICAgICAgY3R4Lm1vdmVUbyh4ICogciAtIHB4LCAoeSArIHJhZGl1cykgKiByIC0gcHkpO1xyXG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCAqIHIgLSBweCwgeSAqIHIgLSBweSwgKHggKyByYWRpdXMpICogciAtIHB4LCB5ICogciAtIHB5KTtcclxuICAgICAgICAgIGN0eC5saW5lVG8oKHggKyB3aWR0aCAtIHJhZGl1cykgKiByIC0gcHgsIHkgKiByIC0gcHkpO1xyXG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oKHggKyB3aWR0aCkgKiByIC0gcHgsIHkgKiByIC0gcHksICh4ICsgd2lkdGgpICogciAtIHB4LCAoeSArIHJhZGl1cykgKiByIC0gcHkpO1xyXG4gICAgICAgICAgY3R4LmxpbmVUbygoeCArIHdpZHRoKSAqIHIgLSBweCwgKHkgKyBoZWlnaHQgLSByYWRpdXMpICogciAtIHB5KTtcclxuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKCh4ICsgd2lkdGgpICogciAtIHB4LCAoeSArIGhlaWdodCkgKiByIC0gcHksICh4ICsgd2lkdGggLSByYWRpdXMpICogciAtIHB4LCAoeSArIGhlaWdodCkgKiByIC0gcHkpO1xyXG4gICAgICAgICAgY3R4LmxpbmVUbygoeCArIHJhZGl1cykgKiByIC0gcHgsICh5ICsgaGVpZ2h0KSAqIHIgLSBweSk7XHJcbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICogciAtIHB4LCAoeSArIGhlaWdodCkgKiByIC0gcHksIHggKiByIC0gcHgsICh5ICsgaGVpZ2h0IC0gcmFkaXVzKSAqIHIgLSBweSk7XHJcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5CRVpJRVJfQ1VSVkVfVE86IHtcclxuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC5nZXROdW1iZXIoMCkgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoMSkgKiByIC0gcHksIGNtZC5nZXROdW1iZXIoMikgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoMykgKiByIC0gcHksIGNtZC5nZXROdW1iZXIoNCkgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoNSkgKiByIC0gcHkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5RVUFEUkFUSUNfQ1VSVkVfVE86IHtcclxuICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC5nZXROdW1iZXIoMCkgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoMSkgKiByIC0gcHksIGNtZC5nZXROdW1iZXIoMikgKiByIC0gcHgsIGNtZC5nZXROdW1iZXIoMykgKiByIC0gcHkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5CRUdJTl9QQVRIOiB7XHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLkNMT1NFX1BBVEg6IHtcclxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuRklMTDoge1xyXG4gICAgICAgICAgY3R4LmZpbGwoY21kLmdldEJvb2xlYW4oMCkgPT09IHRydWUgPyAnbm9uemVybycgOiAnZXZlbm9kZCcpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuTElORV9UTzoge1xyXG4gICAgICAgICAgY3R4LmxpbmVUbyhjbWQuZ2V0TnVtYmVyKDApICogciAtIHB4LCBjbWQuZ2V0TnVtYmVyKDEpICogciAtIHB5KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLk1PVkVfVE86IHtcclxuICAgICAgICAgIGN0eC5tb3ZlVG8oY21kLmdldE51bWJlcigwKSAqIHIgLSBweCwgY21kLmdldE51bWJlcigxKSAqIHIgLSBweSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5MSU5FX0RBU0g6IHtcclxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChjbWQuZ2V0TnVtYmVyKDApKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2FzZSBHcmFwaGljc0NvbW1hbmRUeXBlLlNUUk9LRToge1xyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuU0hBRE9XX0JMVVI6IHtcclxuICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gY21kLmdldE51bWJlcigwKSAqIHI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhc2UgR3JhcGhpY3NDb21tYW5kVHlwZS5TSEFET1dfQ09MT1I6IHtcclxuICAgICAgICAgIGxldCBzdHJpbmdDb2xvciA9IENvbG9ySGVscGVyLmludFRvUkdCQShjb2xvciA9PT0gbnVsbCA/IGNtZC5nZXROdW1iZXIoMCkgOiAvKiogQHR5cGUge251bWJlcn0gKi8oY29sb3IpLCBjbWQuZ2V0TnVtYmVyKDEpKTtcclxuICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHN0cmluZ0NvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEdyYXBoaWNzQ29tbWFuZFR5cGUuQk9VTkRTOiB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBEZWJ1Zy5lcnJvcihgVW5zdXBwb3J0ZWQgY2FudmFzIGNvbW1hbmQgJyR7Y21kLnR5cGV9Jy5gKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2RlLm1Ob2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIHRoaXMuX19yZW5kZXJOb2RlKGRyaXZlciwgY29sb3IsIG5vZGUubU5vZGVzW2ldLCB0cmFuc2Zvcm0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGN1c3RvbSB2aWRlbyBkcml2ZXJzLiBWaWRlb0RyaXZlciBpcyB1c2VkIHRvIHJlbmRlciB0aGluZ3Mgb250byB0aGUgc2NyZWVuLlxyXG4gKlxyXG4gKiBAY2F0IGRyaXZlcnNcclxuICovXHJcbmNsYXNzIFZpZGVvTnVsbERyaXZlciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgVmlkZW9OdWxsRHJpdmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lckVsZW1lbnQgVGhlIEhUTUwgZWxlbWVudCBjb250YWluZXIgZm9yIHJlbmRlcmluZy5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoICAgICAgICAgICAgICAgICBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lckVsZW1lbnQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DbGllbnRXaWR0aCA9IHdpZHRoO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2xpZW50SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeH0gQWN0dWFsIG9iamVjdCAtIGRvIG5vdCBjaGFuZ2UgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5NYXRyaXh9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZW5kZXJTZXNzaW9ufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQWN0aXZlU2Vzc2lvbiA9IG5ldyBSZW5kZXJTZXNzaW9uKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+UmVuZGVyU2Vzc2lvbj59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TZXNzaW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7Kn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxhc3RSZW5kZXJUZXh0dXJlID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TbmFwVG9QaXhlbHMgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubURldmljZVBpeGVsUmF0aW8gPSBCbGFjay5lbmdpbmUudXNlSGlEUFIgPT09IHRydWUgPyBCbGFjay5kZXZpY2UuZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIDogMTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5CbGVuZE1vZGV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUdsb2JhbEJsZW5kTW9kZSA9IEJsZW5kTW9kZS5BVVRPO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tR2xvYmFsQWxwaGEgPSAxO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlbmRlcmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RhZ2VSZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKG5ldzogYmxhY2stZW5naW5lflJlbmRlcmVyKT59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZW5kZXJlck1hcCA9IHt9O1xyXG5cclxuICAgIEJsYWNrLmVuZ2luZS52aWV3cG9ydC5vbigncmVzaXplJywgdGhpcy5fX29uUmVzaXplLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWFpbiByZW5kZXIgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ2FtZU9iamVjdCAgICAgICAgICAgICAgICAgICAgQSBHYW1lT2JqZWN0IGluc3RhbmNlIHRvIHJlbmRlciBvbnRvIFJlbmRlclRhcmdldC5cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5DYW52YXNSZW5kZXJUZXh0dXJlfSBbcmVuZGVyVGV4dHVyZT1udWxsXSBEZXN0aW5hdGlvbiBzdXJmYWNlIHRvIHJlbmRlciBnYW1lIG9iamVjdCBvbi4gV2lsbCBiZSByZW5kZXJlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb250byBiYWNrYnVmZmVyIGlmIG51bGwuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWF0cml4fSBbY3VzdG9tVHJhbnNmb3JtPW51bGxdICAgICAgICAgICAgQW4gb3B0aW9uYWwgZXh0cmEgb2Zmc2V0LlxyXG4gICAqL1xyXG4gIHJlbmRlcihnYW1lT2JqZWN0LCByZW5kZXJUZXh0dXJlID0gbnVsbCwgY3VzdG9tVHJhbnNmb3JtID0gbnVsbCkge1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmYWN0b3J5IG1ldGhvZCB3aGljaCByZXR1cm5zIG5ldyBSZW5kZXJlciBpbnN0YW5jZSBiYXNlZCBvbiBpbnRlcm5hbCBHYW1lT2JqZWN0IHRvIFJlbmRlcmVyIG1hcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICAgICAgVGhlIHR5cGUgb2YgdGhlIEdhbWVPYmplY3QgdG8gZmluZCByZW5kZXJlciBmb3IuXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gb3duZXIgVGhlIG93bmVyIG9mIHRoaXMgcmVuZGVyZXIuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5SZW5kZXJlcn0gTmV3IHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdldFJlbmRlcmVyKHR5cGUsIG93bmVyKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVuZGVyU2Vzc2lvbn1cclxuICAgKi9cclxuICBfX3NhdmVTZXNzaW9uKCkge1xyXG4gICAgbGV0IHNlc3Npb24gPSBWaWRlb051bGxEcml2ZXIuc2Vzc2lvblBvb2wuZ2V0KCk7XHJcbiAgICBzZXNzaW9uLnJlc2V0KCk7XHJcblxyXG4gICAgdGhpcy5tU2Vzc2lvbnMucHVzaChzZXNzaW9uKTtcclxuXHJcbiAgICB0aGlzLm1BY3RpdmVTZXNzaW9uID0gc2Vzc2lvbjtcclxuICAgIHJldHVybiBzZXNzaW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19yZXN0b3JlU2Vzc2lvbigpIHtcclxuICAgIHRoaXMubVNlc3Npb25zLnBvcCgpO1xyXG4gICAgdGhpcy5tQWN0aXZlU2Vzc2lvbiA9IHRoaXMubVNlc3Npb25zW3RoaXMubVNlc3Npb25zLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlbmRlclNlc3Npb259IHNlc3Npb25cclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBnYW1lT2JqZWN0XHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVuZGVyZXJ9IHBhcmVudFJlbmRlcmVyXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19jb2xsZWN0UGFyZW50UmVuZGVyYWJsZXMoc2Vzc2lvbiwgZ2FtZU9iamVjdCwgcGFyZW50UmVuZGVyZXIpIHtcclxuICAgIGxldCBjdXJyZW50ID0gZ2FtZU9iamVjdDtcclxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbGV0IHBhcmVudHMgPSBbXTtcclxuICAgIGZvciAoY3VycmVudCA9IGN1cnJlbnQucGFyZW50OyBjdXJyZW50ICE9PSBudWxsOyBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQpXHJcbiAgICAgIHBhcmVudHMuc3BsaWNlKDAsIDAsIGN1cnJlbnQpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjdXJyZW50ID0gcGFyZW50c1tpXTtcclxuXHJcbiAgICAgIGxldCByZW5kZXJlciA9IGN1cnJlbnQubVJlbmRlcmVyO1xyXG5cclxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBzZXNzaW9uLnBhcmVudFJlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcclxuICAgICAgcmVuZGVyZXIucGFyZW50ID0gcGFyZW50UmVuZGVyZXI7XHJcbiAgICAgIHBhcmVudFJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG4gICAgICByZW5kZXJlci5wcmVSZW5kZXIodGhpcywgc2Vzc2lvbik7XHJcblxyXG4gICAgICBpZiAocmVuZGVyZXIuZW5kUGFzc1JlcXVpcmVkID09PSB0cnVlKVxyXG4gICAgICAgIHNlc3Npb24uZW5kUGFzc1BhcmVudFJlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vdGlmaWVzIHJlbmRlcmVyIGFib3V0IG5ldyBjbGlwcGluZy5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IGNsaXBSZWN0IFRoZSByZWdpb24gdG8gY2xpcC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHggUGl2b3QteC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHkgUGl2b3QteS5cclxuICAgKi9cclxuICBiZWdpbkNsaXAoY2xpcFJlY3QsIHB4LCBweSkge1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm90aWZpZXMgcmVuZGVyZXIgdG8gc3RvcCBsYXN0IGNsaXBwaW5nLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBlbmRDbGlwKCkge1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NZXNzYWdlfSBtc2dcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHJlY3RcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX29uUmVzaXplKG1zZywgcmVjdCkge1xyXG4gICAgUmVuZGVyZXIuX19kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgbGV0IHcgPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgbGV0IGggPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmNsaWVudEhlaWdodDtcclxuXHJcbiAgICB0aGlzLm1DbGllbnRXaWR0aCA9IHc7XHJcbiAgICB0aGlzLm1DbGllbnRIZWlnaHQgPSBoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzdGFydCgpIHtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGFueXRoaW5nLiBVc3VhbGx5IHVzZWQgdG8gY2xlYXIgYmFjay1idWZmZXIuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgYmVnaW5GcmFtZSgpIHtcclxuICAgIHRoaXMuY2xlYXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCBhZnRlciByZW5kZXJpbmcgaXMgZmluaXNoZWQuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgZW5kRnJhbWUoKSB7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcclxuICAgKiBAcmV0dXJuIHs/YmxhY2stZW5naW5lflRleHR1cmV9XHJcbiAgICovXHJcbiAgZ2V0VGV4dHVyZUZyb21DYW52YXMoY2FudmFzKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgd29ybGQgdHJhbnNmb3JtYXRpb24gZm9yIGZ1dHVyZSB1c2UuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+TWF0cml4fSBtIEFuIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBzdG9yZS5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXRUcmFuc2Zvcm0obSkge1xyXG4gICAgdGhpcy5tVHJhbnNmb3JtID0gbTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyBpZiB0cmFuc2Zvcm0gc2hvdWxkIGJlIHNuYXBwZWQgdG8gcGl4ZWxzLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0U25hcFRvUGl4ZWxzKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1TbmFwVG9QaXhlbHMgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgZ2xvYmFsIGFscGhhLiBVc2VkIHRvIGNhbGN1bGF0ZSBhbHBoYSByZWxhdGl2ZSB0byBwYXJlbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXRHbG9iYWxBbHBoYSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1HbG9iYWxBbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0R2xvYmFsQWxwaGEodmFsdWUpIHtcclxuICAgIHRoaXMubUdsb2JhbEFscGhhID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgZ2xvYmFsIGJsZW5kaW5nIG1vZGUuIFVzZWQgdG8gY2FsY3VsYXRlIGJsZW5kIG1vZGUgcmVsYXRpdmUgdG8gcGFyZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4gez9ibGFjay1lbmdpbmV+QmxlbmRNb2RlfVxyXG4gICAqL1xyXG4gIGdldEdsb2JhbEJsZW5kTW9kZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1HbG9iYWxCbGVuZE1vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gez9ibGFjay1lbmdpbmV+QmxlbmRNb2RlfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0R2xvYmFsQmxlbmRNb2RlKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1HbG9iYWxCbGVuZE1vZGUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIHRleHR1cmUgb250byBiYWNrLWJ1ZmZlci4gYWxwaGEsIGJsZW5kIG1vZGUgYW5kIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBtdXN0IGJlIHNldCBwcmlvciB0byBjYWxsaW5nIHRoaXNcclxuICAgKiBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dHVyZX0gdGV4dHVyZSBJbnN0YW5jZSBvZiB0aGUgVGV4dHVyZSB0byBkcmF3LlxyXG4gICAqIFxyXG4gICAqL1xyXG4gIGRyYXdUZXh0dXJlKHRleHR1cmUpIHtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXdzIHRleHR1cmUgb250byBiYWNrLWJ1ZmZlciB3aXRoIGdpdmVuIG9mZnNldC4gYWxwaGEsIGJsZW5kIG1vZGUgYW5kIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBtdXN0IGJlIHNldCBwcmlvciB0byBjYWxsaW5nIHRoaXNcclxuICAgKiBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfSB0ZXh0dXJlIEluc3RhbmNlIG9mIHRoZSBUZXh0dXJlIHRvIGRyYXcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG94IE9mZnNldCBhbG9uZyB4LWF4aXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gb3kgT2Zmc2V0IGFsb25nIHktYXhpc1xyXG4gICAqL1xyXG4gIGRyYXdUZXh0dXJlV2l0aE9mZnNldCh0ZXh0dXJlLCBveCwgb3kpIHtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFycyBiYWNrLWJ1ZmZlci5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBjbGVhcigpIHtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3Bvc2VzIGFsbCBhbGxvY2F0ZWQgcmVzb3VyY2VzLlxyXG4gICAqL1xyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBWaWRlb051bGxEcml2ZXIuc2Vzc2lvblBvb2wucmVsZWFzZUFsbCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIFJldHVybnMgY3VycmVudCByZW5kZXJpbmcgY29udGV4dCBvciBudWxsLlxyXG4gICAqIEByZXR1cm5zIHsqfVxyXG4gICAqL1xyXG4gIGdldCBjb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGRldmljZSBwaXhlbCByYXRpbyBvciAxIGluIGNhc2UgaGlnaCBEUFIgc3VwcG9ydCBpcyBkaXNhYmxlZC5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZW5kZXJTY2FsZUZhY3RvcigpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZXZpY2VQaXhlbFJhdGlvO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlY3ljbGFibGUgc2Vzc2lvbiBwb29sLiBEbyBub3QgcmVjeWNsZSBtYW51YWxseS5cclxuICpcclxuICogQHR5cGUge2JsYWNrLWVuZ2luZX5PYmplY3RQb29sfVxyXG4gKiBAbm9jb2xsYXBzZVxyXG4gKi9cclxuVmlkZW9OdWxsRHJpdmVyLnNlc3Npb25Qb29sID0gbmV3IE9iamVjdFBvb2woUmVuZGVyU2Vzc2lvbik7XHJcblxyXG4vKipcclxuICogVmlkZW8gZHJpdmVyIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgZ2FtZSBvYmplY3RzIG9udG8gSFRNTCBjYW52YXMgZWxlbWVudC5cclxuICpcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlclxyXG4gKiBAY2F0IGRyaXZlcnMuY2FudmFzXHJcbiAqL1xyXG5jbGFzcyBDYW52YXNEcml2ZXIgZXh0ZW5kcyBWaWRlb051bGxEcml2ZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIENhbnZhc0RyaXZlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyRWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gZHJhdyBpbnRvLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgICAgICAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lckVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ3R4ID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fY3JlYXRlQ2FudmFzKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEBpbmhlcml0RG9jIFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZW5kZXJlck1hcCA9IHtcclxuICAgICAgJ0Rpc3BsYXlPYmplY3QnOiBEaXNwbGF5T2JqZWN0UmVuZGVyZXJDYW52YXMsXHJcbiAgICAgICdTcHJpdGUnOiBTcHJpdGVSZW5kZXJlckNhbnZhcyxcclxuICAgICAgJ0VtaXR0ZXInOiBFbWl0dGVyUmVuZGVyZXJDYW52YXMsXHJcbiAgICAgICdUZXh0JzogVGV4dFJlbmRlcmVyQ2FudmFzLFxyXG4gICAgICAnQml0bWFwVGV4dCc6IEJpdG1hcFRleHRSZW5kZXJlckNhbnZhcyxcclxuICAgICAgJ0dyYXBoaWNzJzogR3JhcGhpY3NSZW5kZXJlckNhbnZhc1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGdldFJlbmRlcmVyKHR5cGUsIG93bmVyKSB7XHJcbiAgICBsZXQgcmVuZGVyZXIgPSBuZXcgdGhpcy5tUmVuZGVyZXJNYXBbdHlwZV0oKTtcclxuICAgIHJlbmRlcmVyLmdhbWVPYmplY3QgPSAvKiogQHR5cGUge0Rpc3BsYXlPYmplY3R9ICovIChvd25lcik7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHJlbmRlcihnYW1lT2JqZWN0LCByZW5kZXJUZXh0dXJlID0gbnVsbCwgY3VzdG9tVHJhbnNmb3JtID0gbnVsbCkge1xyXG4gICAgbGV0IGlzQmFja0J1ZmZlckFjdGl2ZSA9IHJlbmRlclRleHR1cmUgPT09IG51bGw7XHJcblxyXG4gICAgaWYgKFJlbmRlcmVyLnNraXBVbmNoYW5nZWRGcmFtZXMgPT09IHRydWUgJiYgaXNCYWNrQnVmZmVyQWN0aXZlID09PSB0cnVlICYmIFJlbmRlcmVyLl9fZGlydHkgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbGV0IHNlc3Npb24gPSB0aGlzLl9fc2F2ZVNlc3Npb24oKTtcclxuICAgIHNlc3Npb24uaXNCYWNrQnVmZmVyQWN0aXZlID0gaXNCYWNrQnVmZmVyQWN0aXZlO1xyXG4gICAgc2Vzc2lvbi5jdXN0b21UcmFuc2Zvcm0gPSBjdXN0b21UcmFuc2Zvcm07XHJcblxyXG4gICAgbGV0IHBhcmVudFJlbmRlcmVyID0gdGhpcy5tU3RhZ2VSZW5kZXJlcjtcclxuXHJcbiAgICAvLyBSZW5kZXJUZXh0dXJlIHJlbGF0ZWRcclxuICAgIGlmIChyZW5kZXJUZXh0dXJlICE9PSBudWxsKSB7XHJcbiAgICAgIC8vIFN3YXAgY29udGV4dFxyXG4gICAgICB0aGlzLm1MYXN0UmVuZGVyVGV4dHVyZSA9IHRoaXMubUN0eDtcclxuICAgICAgdGhpcy5tQ3R4ID0gcmVuZGVyVGV4dHVyZS5yZW5kZXJUYXJnZXQuY29udGV4dDtcclxuXHJcbiAgICAgIC8vIGNsZWFyIGNvbnRleHQgY2FjaGVcclxuICAgICAgdGhpcy5tR2xvYmFsQWxwaGEgPSAtMTtcclxuICAgICAgdGhpcy5tR2xvYmFsQmxlbmRNb2RlID0gbnVsbDtcclxuXHJcbiAgICAgIHBhcmVudFJlbmRlcmVyLmFscGhhID0gMTtcclxuICAgICAgcGFyZW50UmVuZGVyZXIuYmxlbmRNb2RlID0gQmxlbmRNb2RlLk5PUk1BTDtcclxuICAgICAgcGFyZW50UmVuZGVyZXIuY29sb3IgPSBudWxsO1xyXG5cclxuICAgICAgLy8gY29sbGVjdCBwYXJlbnRzIG9mIGdpdmVuIEdhbWVPYmplY3RcclxuICAgICAgdGhpcy5fX2NvbGxlY3RQYXJlbnRSZW5kZXJhYmxlcyhzZXNzaW9uLCBnYW1lT2JqZWN0LCB0aGlzLm1TdGFnZVJlbmRlcmVyKTtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZXNzaW9uLnBhcmVudFJlbmRlcmVycy5sZW5ndGg7IGkgIT09IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHJlbmRlcmVyID0gc2Vzc2lvbi5wYXJlbnRSZW5kZXJlcnNbaV07XHJcbiAgICAgICAgcmVuZGVyZXIuYmVnaW4odGhpcywgc2Vzc2lvbik7XHJcblxyXG4gICAgICAgIGlmIChyZW5kZXJlci5za2lwU2VsZiA9PT0gZmFsc2UpXHJcbiAgICAgICAgICByZW5kZXJlci51cGxvYWQodGhpcywgc2Vzc2lvbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZXNzaW9uLnBhcmVudFJlbmRlcmVycy5sZW5ndGggPiAwKVxyXG4gICAgICAgIHBhcmVudFJlbmRlcmVyID0gc2Vzc2lvbi5wYXJlbnRSZW5kZXJlcnNbc2Vzc2lvbi5wYXJlbnRSZW5kZXJlcnMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW5kZXJPYmplY3QoZ2FtZU9iamVjdCwgc2Vzc2lvbiwgcGFyZW50UmVuZGVyZXIpO1xyXG5cclxuICAgIGlmIChyZW5kZXJUZXh0dXJlICE9PSBudWxsKSB7XHJcbiAgICAgIHdoaWxlIChzZXNzaW9uLmVuZFBhc3NQYXJlbnRSZW5kZXJlcnMubGVuZ3RoID4gMClcclxuICAgICAgICBzZXNzaW9uLmVuZFBhc3NQYXJlbnRSZW5kZXJlcnMucG9wKCkuZW5kKHRoaXMsIHNlc3Npb24pO1xyXG5cclxuICAgICAgdGhpcy5tQ3R4ID0gdGhpcy5tTGFzdFJlbmRlclRleHR1cmU7XHJcblxyXG4gICAgICB0aGlzLm1HbG9iYWxBbHBoYSA9IC0xO1xyXG4gICAgICB0aGlzLm1HbG9iYWxCbGVuZE1vZGUgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19yZXN0b3JlU2Vzc2lvbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlbmRlclNlc3Npb259IHNlc3Npb24gXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmVuZGVyZXJ9IHBhcmVudFJlbmRlcmVyXHJcbiAgICovXHJcbiAgcmVuZGVyT2JqZWN0KGNoaWxkLCBzZXNzaW9uLCBwYXJlbnRSZW5kZXJlcikge1xyXG4gICAgbGV0IHNraXBDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgbGV0IHJlbmRlcmVyID0gLyoqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fSAqLyAoY2hpbGQpLm1SZW5kZXJlcjtcclxuXHJcbiAgICBpZiAocmVuZGVyZXIgIT0gbnVsbCkge1xyXG4gICAgICByZW5kZXJlci5wYXJlbnQgPSBwYXJlbnRSZW5kZXJlcjtcclxuICAgICAgcmVuZGVyZXIucHJlUmVuZGVyKHRoaXMsIHNlc3Npb24pO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5tQ29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNvbXAgPSBjaGlsZC5tQ29tcG9uZW50c1tpXTtcclxuICAgICAgICBjb21wLm9uUmVuZGVyKCk7XHJcbiAgICAgIH1cclxuICAgICAgLyoqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fSAqLyAoY2hpbGQpLm9uUmVuZGVyKCk7XHJcblxyXG4gICAgICByZW5kZXJlci5iZWdpbih0aGlzLCBzZXNzaW9uKTtcclxuXHJcbiAgICAgIGlmIChyZW5kZXJlci5za2lwU2VsZiA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZW5kZXJlci51cGxvYWQodGhpcywgc2Vzc2lvbik7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHNlc3Npb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBza2lwQ2hpbGRyZW4gPSByZW5kZXJlci5za2lwQ2hpbGRyZW47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNraXBDaGlsZHJlbiA9PT0gZmFsc2UpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgdGhpcy5yZW5kZXJPYmplY3QoY2hpbGQubUNoaWxkcmVuW2ldLCBzZXNzaW9uLCByZW5kZXJlciB8fCBwYXJlbnRSZW5kZXJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbmRlcmVyICE9IG51bGwgJiYgcmVuZGVyZXIuZW5kUGFzc1JlcXVpcmVkID09PSB0cnVlKVxyXG4gICAgICByZW5kZXJlci5lbmQodGhpcywgc2Vzc2lvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fY3JlYXRlQ2FudmFzKCkge1xyXG4gICAgbGV0IGRwciA9IHRoaXMubURldmljZVBpeGVsUmF0aW87XHJcblxyXG4gICAgbGV0IGN2cyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XHJcbiAgICBjdnMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgY3ZzLmlkID0gJ2NhbnZhcyc7XHJcblxyXG4gICAgY3ZzLndpZHRoID0gdGhpcy5tQ2xpZW50V2lkdGggKiBkcHI7XHJcbiAgICBjdnMuaGVpZ2h0ID0gdGhpcy5tQ2xpZW50SGVpZ2h0ICogZHByO1xyXG4gICAgY3ZzLnN0eWxlLndpZHRoID0gdGhpcy5tQ2xpZW50V2lkdGggKyAncHgnO1xyXG4gICAgY3ZzLnN0eWxlLmhlaWdodCA9IHRoaXMubUNsaWVudEhlaWdodCArICdweCc7XHJcblxyXG4gICAgdGhpcy5tQ29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChjdnMpO1xyXG5cclxuICAgIHRoaXMubUN0eCA9IC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqLyAoY3ZzLmdldENvbnRleHQoJzJkJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5NZXNzYWdlfSBtc2dcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9IHJlY3RcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX29uUmVzaXplKG1zZywgcmVjdCkge1xyXG4gICAgc3VwZXIuX19vblJlc2l6ZShtc2csIHJlY3QpO1xyXG5cclxuICAgIC8vIGNhbnZhcyB3aWxsIHJlc2V0IHN0YXRlIGFmdGVyIGNoYW5naW5nIHNpemVcclxuICAgIHRoaXMubUdsb2JhbEJsZW5kTW9kZSA9IG51bGw7XHJcbiAgICB0aGlzLm1HbG9iYWxBbHBoYSA9IC0xO1xyXG5cclxuICAgIGxldCBkcHIgPSB0aGlzLm1EZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgdGhpcy5tQ3R4LmNhbnZhcy53aWR0aCA9IHRoaXMubUNsaWVudFdpZHRoICogZHByO1xyXG4gICAgdGhpcy5tQ3R4LmNhbnZhcy5oZWlnaHQgPSB0aGlzLm1DbGllbnRIZWlnaHQgKiBkcHI7XHJcbiAgICB0aGlzLm1DdHguY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5tQ2xpZW50V2lkdGggKyAncHgnO1xyXG4gICAgdGhpcy5tQ3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLm1DbGllbnRIZWlnaHQgKyAncHgnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBkcmF3VGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICBpZiAodGV4dHVyZS5pc1ZhbGlkID09PSBmYWxzZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBkcHIgPSB0aGlzLm1EZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuICAgIGxldCBzb3VyY2VYID0gdGV4dHVyZS5yZWdpb24ueDtcclxuICAgIGxldCBzb3VyY2VZID0gdGV4dHVyZS5yZWdpb24ueTtcclxuICAgIGxldCBzb3VyY2VXaWR0aCA9IHRleHR1cmUucmVnaW9uLndpZHRoO1xyXG4gICAgbGV0IHNvdXJjZUhlaWdodCA9IHRleHR1cmUucmVnaW9uLmhlaWdodDtcclxuXHJcbiAgICBsZXQgZGVzdFggPSB0ZXh0dXJlLnVudHJpbW1lZFJlZ2lvbi54ICogZHByO1xyXG4gICAgbGV0IGRlc3RZID0gdGV4dHVyZS51bnRyaW1tZWRSZWdpb24ueSAqIGRwcjtcclxuICAgIGxldCBkZXN0V2lkdGggPSB0ZXh0dXJlLnJlbmRlcldpZHRoICogZHByO1xyXG4gICAgbGV0IGRlc3RIZWlnaHQgPSB0ZXh0dXJlLnJlbmRlckhlaWdodCAqIGRwcjtcclxuXHJcbiAgICB0aGlzLm1DdHguZHJhd0ltYWdlKHRleHR1cmUubmF0aXZlLCBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCBkZXN0WCwgZGVzdFksIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGRyYXdUZXh0dXJlV2l0aE9mZnNldCh0ZXh0dXJlLCBveCwgb3kpIHtcclxuICAgIGlmICh0ZXh0dXJlLmlzVmFsaWQgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgbGV0IGRwciA9IHRoaXMubURldmljZVBpeGVsUmF0aW87XHJcblxyXG4gICAgbGV0IHNvdXJjZVggPSB0ZXh0dXJlLnJlZ2lvbi54O1xyXG4gICAgbGV0IHNvdXJjZVkgPSB0ZXh0dXJlLnJlZ2lvbi55O1xyXG4gICAgbGV0IHNvdXJjZVdpZHRoID0gdGV4dHVyZS5yZWdpb24ud2lkdGg7XHJcbiAgICBsZXQgc291cmNlSGVpZ2h0ID0gdGV4dHVyZS5yZWdpb24uaGVpZ2h0O1xyXG5cclxuICAgIGxldCBkZXN0WCA9IChveCArIHRleHR1cmUudW50cmltbWVkUmVnaW9uLngpICogZHByO1xyXG4gICAgbGV0IGRlc3RZID0gKG95ICsgdGV4dHVyZS51bnRyaW1tZWRSZWdpb24ueSkgKiBkcHI7XHJcbiAgICBsZXQgZGVzdFdpZHRoID0gdGV4dHVyZS5yZW5kZXJXaWR0aCAqIGRwcjtcclxuICAgIGxldCBkZXN0SGVpZ2h0ID0gdGV4dHVyZS5yZW5kZXJIZWlnaHQgKiBkcHI7XHJcblxyXG4gICAgdGhpcy5tQ3R4LmRyYXdJbWFnZSh0ZXh0dXJlLm5hdGl2ZSwgc291cmNlWCwgc291cmNlWSwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgZGVzdFgsIGRlc3RZLCBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBiZWdpbkNsaXAoY2xpcFJlY3QsIHB4LCBweSkge1xyXG4gICAgbGV0IGRwciA9IHRoaXMubURldmljZVBpeGVsUmF0aW87XHJcblxyXG4gICAgdGhpcy5tQ3R4LnNhdmUoKTtcclxuICAgIHRoaXMubUN0eC5iZWdpblBhdGgoKTtcclxuICAgIHRoaXMubUN0eC5yZWN0KChjbGlwUmVjdC54ICsgcHgpICogZHByLCAoY2xpcFJlY3QueSArIHB5KSAqIGRwciwgY2xpcFJlY3Qud2lkdGggKiBkcHIsIGNsaXBSZWN0LmhlaWdodCAqIGRwcik7XHJcblxyXG4gICAgdGhpcy5tQ3R4LmNsaXAoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgZW5kQ2xpcCgpIHtcclxuICAgIHRoaXMubUN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgdGhpcy5tR2xvYmFsQWxwaGEgPSAtMTtcclxuICAgIHRoaXMubUdsb2JhbEJsZW5kTW9kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgIGxldCBkcHIgPSB0aGlzLm1EZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgbGV0IHNlc3Npb24gPSB0aGlzLm1BY3RpdmVTZXNzaW9uO1xyXG5cclxuICAgIGlmIChzZXNzaW9uLmlzQmFja0J1ZmZlckFjdGl2ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgaWYgKHNlc3Npb24uY3VzdG9tVHJhbnNmb3JtID09PSBudWxsKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLmNsb25lKCk7IC8vIFRPRE86IHRvbyBtdWNoIGFsbG9jYXRpb25zXHJcbiAgICAgICAgdHJhbnNmb3JtLmRhdGFbNF0gLT0gQmxhY2suc3RhZ2UubVg7XHJcbiAgICAgICAgdHJhbnNmb3JtLmRhdGFbNV0gLT0gQmxhY2suc3RhZ2UubVk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLmNsb25lKCk7IC8vIFRPRE86IHRvbyBtdWNoIGFsbG9jYXRpb25zXHJcbiAgICAgICAgdHJhbnNmb3JtLnByZXBlbmQoc2Vzc2lvbi5jdXN0b21UcmFuc2Zvcm0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEJsYWNrLmNhbWVyYSAhPT0gbnVsbCkge1xyXG4gICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0uY2xvbmUoKTtcclxuICAgICAgdHJhbnNmb3JtLnByZXBlbmQoQmxhY2suY2FtZXJhLndvcmxkVHJhbnNmb3JtYXRpb25JbnZlcnRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG5cclxuICAgIGxldCBtdiA9IHRyYW5zZm9ybS52YWx1ZTtcclxuICAgIERlYnVnLmlzTnVtYmVyKG12WzBdLCBtdlsxXSwgbXZbMl0sIG12WzNdLCBtdls0XSwgbXZbNV0pO1xyXG5cclxuICAgIGlmICh0aGlzLm1TbmFwVG9QaXhlbHMgPT09IHRydWUpXHJcbiAgICAgIHRoaXMubUN0eC5zZXRUcmFuc2Zvcm0obXZbMF0sIG12WzFdLCBtdlsyXSwgbXZbM10sIChtdls0XSAqIGRwcikgfCAwLCAobXZbNV0gKiBkcHIpIHwgMCk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMubUN0eC5zZXRUcmFuc2Zvcm0obXZbMF0sIG12WzFdLCBtdlsyXSwgbXZbM10sIG12WzRdICogZHByLCBtdls1XSAqIGRwcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHNldEdsb2JhbEFscGhhKHZhbHVlKSB7XHJcbiAgICBEZWJ1Zy5pc051bWJlcih2YWx1ZSk7XHJcblxyXG4gICAgaWYgKHZhbHVlID09IHRoaXMubUdsb2JhbEFscGhhKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tR2xvYmFsQWxwaGEgPSB2YWx1ZTtcclxuICAgIHRoaXMubUN0eC5nbG9iYWxBbHBoYSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBzZXRHbG9iYWxCbGVuZE1vZGUoYmxlbmRNb2RlKSB7XHJcbiAgICBpZiAoYmxlbmRNb2RlID09PSBCbGVuZE1vZGUuQVVUTylcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGJsZW5kTW9kZSA9IENhbnZhc0JsZW5kTW9kZVtibGVuZE1vZGVdO1xyXG5cclxuICAgIGlmICh0aGlzLm1HbG9iYWxCbGVuZE1vZGUgPT09IGJsZW5kTW9kZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUdsb2JhbEJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcclxuICAgIHRoaXMubUN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgaWYgKFJlbmRlcmVyLnNraXBVbmNoYW5nZWRGcmFtZXMgPT09IHRydWUgJiYgUmVuZGVyZXIuX19kaXJ0eSA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICAvLyBUT0RPOiBjbGVhciBvbmx5IGNoYW5nZWQgcmVnaW9uXHJcbiAgICB0aGlzLm1DdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cclxuICAgIGxldCB2aWV3cG9ydCA9IEJsYWNrLmVuZ2luZS52aWV3cG9ydDtcclxuICAgIGlmICh2aWV3cG9ydC5pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLm1DdHguZmlsbFN0eWxlID0gQ29sb3JIZWxwZXIuaGV4Q29sb3JUb1N0cmluZyh2aWV3cG9ydC5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICB0aGlzLm1DdHguZmlsbFJlY3QoMCwgMCwgdmlld3BvcnQuc2l6ZS53aWR0aCAqIHRoaXMubURldmljZVBpeGVsUmF0aW8sIHZpZXdwb3J0LnNpemUuaGVpZ2h0ICogdGhpcy5tRGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm1DdHguY2xlYXJSZWN0KDAsIDAsIHZpZXdwb3J0LnNpemUud2lkdGggKiB0aGlzLm1EZXZpY2VQaXhlbFJhdGlvLCB2aWV3cG9ydC5zaXplLmhlaWdodCAqIHRoaXMubURldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBnZXRUZXh0dXJlRnJvbUNhbnZhcyhjYW52YXMpIHtcclxuICAgIHJldHVybiBuZXcgVGV4dHVyZShjYW52YXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ3R4ICE9PSBudWxsKVxyXG4gICAgICB0aGlzLm1DdHguY2FudmFzLnJlbW92ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIFJldHVybnMgY3VycmVudCByZW5kZXJpbmcgY29udGV4dCBvciBudWxsLlxyXG4gICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XHJcbiAgICovXHJcbiAgZ2V0IGNvbnRleHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQ3R4O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGlsaW5nLFxyXG4gKiBAY2F0IGRpc3BsYXlcclxuICovXHJcbmNsYXNzIFRpbGluZ0luZm8ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IFRpbGluZ0luZm8gaW5zdGFuY2UuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgZGVzdGluYXRpb24gdGV4dHVyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgZGVzdGluYXRpb24gdGV4dHVyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYIEluZGljYXRlcyBob3cgbXVjaCBzb3VyY2UgdGV4dHVyZSBzaG91bGQgYmUgc2NhbGVkIGFsb25nIHgtYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZIEluZGljYXRlcyBob3cgbXVjaCBzb3VyY2UgdGV4dHVyZSBzaG91bGQgYmUgc2NhbGVkIGFsb25nIHktYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd3JhcFggIEluZGljYXRlcyBob3cgbWFueSBwaXhlbHMgbmVlZHMgdG8gYmUgd3JhcHBlZCBhcm91bmQgYWxvbmcgeC1heGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3cmFwWSAgSW5kaWNhdGVzIGhvdyBtYW55IHBpeGVscyBuZWVkcyB0byBiZSB3cmFwcGVkIGFyb3VuZCBhbG9uZyB5LWF4aXMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwLCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCB3cmFwWCA9IDAsIHdyYXBZID0gMCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgZGVzdGluYXRpb24gdGV4dHVyZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgZGVzdGluYXRpb24gdGV4dHVyZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIGhvdyBtdWNoIHNvdXJjZSB0ZXh0dXJlIHNob3VsZCBiZSBzY2FsZWQgYWxvbmcgeC1heGlzLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaG93IG11Y2ggc291cmNlIHRleHR1cmUgc2hvdWxkIGJlIHNjYWxlZCBhbG9uZyB5LWF4aXMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBob3cgbWFueSBwaXhlbHMgbmVlZHMgdG8gYmUgd3JhcHBlZCBhcm91bmQgYWxvbmcgeC1heGlzLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy53cmFwWCA9IHdyYXBYO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIGhvdyBtYW55IHBpeGVscyBuZWVkcyB0byBiZSB3cmFwcGVkIGFyb3VuZCBhbG9uZyB5LWF4aXMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLndyYXBZID0gd3JhcFk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3ByaXRlIGlzIHVzZWQgdG8gcmVuZGVyIFRleHR1cmUgb250byBzY3JlZW4uXHJcbiAqXHJcbiAqIEBjYXQgZGlzcGxheVxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+RGlzcGxheU9iamVjdFxyXG4gKi9cclxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgRGlzcGxheU9iamVjdCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBTcHJpdGUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfHN0cmluZ3xudWxsfSB0ZXh0dXJlIFRoZSBUZXh0dXJlIGluc3RhbmNlIG9yIG51bGwuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodGV4dHVyZSA9IG51bGwsIHVzZVRleHR1cmVQcm9wcyA9IHRydWUpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflRleHR1cmV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRleHR1cmUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGV4dHVyZU5hbWUgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5UaWxpbmdJbmZvfG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UaWxpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVNsaWNlOWdyaWQgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Vc2VUZXh0dXJlUHJvcHMgPSB1c2VUZXh0dXJlUHJvcHM7XHJcblxyXG4gICAgaWYgKHRleHR1cmUgIT09IG51bGwgJiYgdGV4dHVyZS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgIHRoaXMubVRleHR1cmVOYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0dXJlKTtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gQmxhY2suYXNzZXRzLmdldFRleHR1cmUoLyoqIEB0eXBlIHtzdHJpbmd9ICovKHRleHR1cmUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudGV4dHVyZSA9IC8qKiBAdHlwZSB7VGV4dHVyZX0gKi8gKHRleHR1cmUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBnZXRSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiBCbGFjay5kcml2ZXIuZ2V0UmVuZGVyZXIoJ1Nwcml0ZScsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHJlY3RhbmdsZSB0aGF0IGNvbXBsZXRlbHkgZW5jbG9zZXMgdGhlIG9iamVjdCBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGU9fSBvdXRSZWN0IFJlY3RhbmdsZSB0byBiZSByZXR1cm5lZC5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBUaGUgbmV3IFJlY3RhbmdsZSBvciBvdXRSZWN0IGlmIGl0IHdhcyBwYXNzZWQgYXMgYSBwYXJhbS5cclxuICAgKi9cclxuICBvbkdldExvY2FsQm91bmRzKG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBpZiAoIXRoaXMubVRleHR1cmUpXHJcbiAgICAgIHJldHVybiBvdXRSZWN0O1xyXG5cclxuICAgIGlmICh0aGlzLm1DbGlwUmVjdCAhPT0gbnVsbClcclxuICAgICAgdGhpcy5tQ2xpcFJlY3QuY29weVRvKG91dFJlY3QpO1xyXG4gICAgZWxzZSBpZiAodGhpcy50aWxpbmcgIT09IG51bGwpXHJcbiAgICAgIG91dFJlY3Quc2V0KDAsIDAsIHRoaXMudGlsaW5nLndpZHRoLCB0aGlzLnRpbGluZy5oZWlnaHQpO1xyXG4gICAgZWxzZVxyXG4gICAgICBvdXRSZWN0LnNldCgwLCAwLCB0aGlzLm1UZXh0dXJlLmRpc3BsYXlXaWR0aCwgdGhpcy5tVGV4dHVyZS5kaXNwbGF5SGVpZ2h0KTtcclxuXHJcbiAgICByZXR1cm4gb3V0UmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVGV4dHVyZSBvbiB0aGlzIHNwcml0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfG51bGx9IFRoZSBjdXJyZW50IHRleHR1cmUgc2V0IG9uIHRoaXMgU3ByaXRlIG9yIG51bGwuXHJcbiAgICovXHJcbiAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVGV4dHVyZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIFRleHR1cmUgb24gdGhpcyBzcHJpdGUgYnkgbmFtZS5cclxuICAgKiBPbmx5IEJsYWNrLmFzc2V0cyBpcyB1c2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dHVyZXxudWxsfSB0ZXh0dXJlIFRleHR1cmUgdG8gYXBwbHkgb24uXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgdGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICBpZiAodGhpcy5tVGV4dHVyZSA9PT0gdGV4dHVyZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0ZXh0dXJlID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubVRleHR1cmUgPSBudWxsO1xyXG4gICAgICB0aGlzLm1UZXh0dXJlTmFtZSA9IG51bGw7XHJcblxyXG4gICAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgICAgdGhpcy5zZXRSZW5kZXJEaXJ0eSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tVGV4dHVyZSA9IHRleHR1cmU7XHJcblxyXG4gICAgaWYgKHRoaXMubVVzZVRleHR1cmVQcm9wcyA9PT0gdHJ1ZSkge1xyXG4gICAgICBpZiAodGV4dHVyZS5zbGljZTlib3JkZXJzKVxyXG4gICAgICAgIHRoaXMuc2xpY2U5Z3JpZCA9IHRleHR1cmUuc2xpY2U5Ym9yZGVycy5jbG9uZSgpO1xyXG5cclxuICAgICAgaWYgKHRleHR1cmUucmVnaXN0cmF0aW9uUG9pbnQgIT09IG51bGwpXHJcbiAgICAgICAgdGhpcy5hbGlnblBpdm90T2Zmc2V0KHRleHR1cmUucmVnaXN0cmF0aW9uUG9pbnQueCwgdGV4dHVyZS5yZWdpc3RyYXRpb25Qb2ludC55KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0UmVuZGVyRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGV4dHVyZSBuYW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7P3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgdGV4dHVyZU5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVGV4dHVyZU5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHRleHR1cmUgYnkgaXRzIG5hbWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVcclxuICAgKi9cclxuICBzZXQgdGV4dHVyZU5hbWUodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1UZXh0dXJlTmFtZSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubVRleHR1cmVOYW1lID0gdmFsdWU7XHJcbiAgICB0aGlzLnRleHR1cmUgPSBCbGFjay5hc3NldHMuZ2V0VGV4dHVyZSgvKiogQHR5cGUge3N0cmluZ30gKi8odmFsdWUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgc2V0cyB0aWxpbmcgaW5mb3JtYXRpb24uXHJcbiAgICpcclxuICAgKiBOT1RFOiBhZnRlciBjaGFuZ2luZyBvbmUgb2YgVGlsaW5nSW5mbyBwcm9wZXJ0aWVzIG1ha2Ugc3VyZSB0byBjYWxsIGBzZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFKWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflRpbGluZ0luZm98bnVsbH1cclxuICAgKi9cclxuICBnZXQgdGlsaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVRpbGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflRpbGluZ0luZm98bnVsbH0gdmFsdWVcclxuICAgKi9cclxuICBzZXQgdGlsaW5nKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1UaWxpbmcgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnNldFJlbmRlckRpcnR5KCk7XHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyBuaW5lIHNsaWNlIGdyaWQgcmVjdGFuZ2xlLlxyXG4gICAqXHJcbiAgICogTk9URTogYWZ0ZXIgY2hhbmdpbmcgeCwgeSwgd2lkdGggb3IgaGVpZ2h0IG9mIG5pbmUgc2xpY2UgZ3JpZCBhdHRyaWJ1dGVzIG1ha2Ugc3VyZSB0byBjYWxsIGBzZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFKWAgdG8gcmVmcmVzaCByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0IHNsaWNlOWdyaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU2xpY2U5Z3JpZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZXxudWxsfSB2YWx1ZVxyXG4gICAqL1xyXG4gIHNldCBzbGljZTlncmlkKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1TbGljZTlncmlkID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXRSZW5kZXJEaXJ0eSgpO1xyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IEZvbnRBbGlnbiA9IHtcclxuICBOT05FOiAnbm9uZScsXHJcbiAgTEVGVDogJ2xlZnQnLFxyXG4gIFJJR0hUOiAncmlnaHQnLFxyXG4gIENFTlRFUjogJ2NlbnRlcidcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2F0IGRpc3BsYXkudGV4dFxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgRm9udFZlcnRpY2FsQWxpZ24gPSB7XHJcbiAgVE9QOiAndG9wJyxcclxuICBNSURETEU6ICdtaWRkbGUnLFxyXG4gIEJPVFRPTTogJ2JvdHRvbSdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGRpc3BsYXkgdGV4dC5cclxuICpcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICogQGZpcmVzIFRleHRGaWVsZCNjaGFuZ2VcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkRpc3BsYXlPYmplY3RcclxuICovXHJcbmNsYXNzIFRleHRGaWVsZCBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFRleHRGaWVsZFxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gW3RleHQ9JyddIFRleHQgdG8gYmUgZGlzcGxheWVkIGluc2lkZSB0aGlzIHRleHQgZmllbGRcclxuICAgKiBAcGFyYW0gIHtzdHJpbmc9fSBmYW1pbHkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb250IG5hbWVcclxuICAgKiBAcGFyYW0gIHtudW1iZXI9fSBbY29sb3I9MHgwXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0IGNvbG9yIGFzIGhleGFkZWNpbWFsIG51bWJlciBlZyAweGZmMDAwMCAodG90YWwgcmVkKVxyXG4gICAqIEBwYXJhbSAge251bWJlcj19IFtzaXplPTE0XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQgc2l6ZVxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5Gb250U3R5bGU9fSBbc3R5bGU9YmxhY2stZW5naW5lfkZvbnRTdHlsZS5OT1JNQUxdICAgIFRleHQgc3R5bGUgZWcgaXRhbGljXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkZvbnRXZWlnaHQ9fSBbd2VpZ2h0PWJsYWNrLWVuZ2luZX5Gb250V2VpZ2h0Lk5PUk1BTF0gRm9udCB0aGlja25lc3MuIFRoZSB2YWx1ZSBpcyBzZXQgZnJvbSAxMDAgdG8gOTAwIGluIGluY3JlbWVudHMgb2YgMTAwLlxyXG4gICAqIEBwYXJhbSAge251bWJlcj19IFtzdHJva2VUaGlja25lc3M9MF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLiAwIG1lYW5zIHRoYXQgbm8gc3Ryb2tlXHJcbiAgICogQHBhcmFtICB7bnVtYmVyPX0gW3N0cm9rZUNvbG9yPTB4ZmZmZmZmXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3Ryb2tlIGNvbG9yIGFzIGhleGFkZWNpbWFsIG51bWJlciBlZyAweDAwZmYwMCAodG90YWwgZ3JlZW4pXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IodGV4dCA9ICcnLCBmYW1pbHkgPSAnc2Fucy1zZXJpZicsIGNvbG9yID0gMHgwMDAwMDAsIHNpemUgPSAxNCwgc3R5bGUgPSBGb250U3R5bGUuTk9STUFMLCB3ZWlnaHQgPSBGb250V2VpZ2h0Lk5PUk1BTCwgc3Ryb2tlVGhpY2tuZXNzID0gMCwgc3Ryb2tlQ29sb3IgPSAweGZmZmZmZikge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UZXh0ID0gdGV4dDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGVCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGV4dFdpZHRoID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UZXh0SGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VGV4dFN0eWxlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRGVmYXVsdFN0eWxlID0gbmV3IFRleHRTdHlsZShmYW1pbHksIGNvbG9yLCBzaXplLCBzdHlsZSwgd2VpZ2h0LCBzdHJva2VUaGlja25lc3MsIHN0cm9rZUNvbG9yKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxibGFjay1lbmdpbmV+VGV4dFN0eWxlPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0eWxlcyA9IHt9O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BdXRvU2l6ZSA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkZvbnRBbGlnbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUFsaWduID0gRm9udEFsaWduLkxFRlQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkZvbnRWZXJ0aWNhbEFsaWdufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVmVydGljYWxBbGlnbiA9IEZvbnRWZXJ0aWNhbEFsaWduLk1JRERMRTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTXVsdGlsaW5lID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTGluZUhlaWdodCA9IDEuMjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGV4dEJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaWVsZFdpZHRoID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaWVsZEhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBhZGRpbmcgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5UZXh0TWV0cmljc0RhdGF8bnVsbH0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU1ldHJpY3MgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1IaWdoUXVhbGl0eSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBnZXRSZW5kZXJlcigpIHtcclxuICAgIHJldHVybiBCbGFjay5kcml2ZXIuZ2V0UmVuZGVyZXIoJ1RleHQnLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25HZXRMb2NhbEJvdW5kcyhvdXRSZWN0ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBvdXRSZWN0ID0gb3V0UmVjdCB8fCBuZXcgUmVjdGFuZ2xlKCk7XHJcblxyXG4gICAgaWYgKHRoaXMubURpcnR5ICYgRGlydHlGbGFnLlJFTkRFUl9DQUNIRSkge1xyXG4gICAgICBsZXQgdGV4dCA9IHRoaXMudGV4dDtcclxuICAgICAgaWYgKHRoaXMubU11bHRpbGluZSA9PT0gZmFsc2UpXHJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuL2csICcnKTtcclxuXHJcbiAgICAgIGxldCBzdHlsZXMgPSBbdGhpcy5tRGVmYXVsdFN0eWxlXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGtleSBpbiAvKiogQHR5cGUgeyFPYmplY3R9ICovKHRoaXMubVN0eWxlcykpIHtcclxuICAgICAgICBzdHlsZXMucHVzaCh0aGlzLm1TdHlsZXNba2V5XSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubU1ldHJpY3MgPSBUZXh0TWV0cmljc0V4Lm1lYXN1cmUodGV4dCwgdGhpcy5tTGluZUhlaWdodCwgLi4uc3R5bGVzKTtcclxuICAgICAgdGhpcy5tVGV4dEJvdW5kcy5jb3B5RnJvbSh0aGlzLm1NZXRyaWNzLmJvdW5kcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubUNsaXBSZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubUNsaXBSZWN0LmNvcHlUbyhvdXRSZWN0KTtcclxuICAgICAgcmV0dXJuIG91dFJlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubUF1dG9TaXplID09PSBmYWxzZSkge1xyXG4gICAgICBvdXRSZWN0LndpZHRoID0gdGhpcy5tRmllbGRXaWR0aDtcclxuICAgICAgb3V0UmVjdC5oZWlnaHQgPSB0aGlzLm1GaWVsZEhlaWdodDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG91dFJlY3Qud2lkdGggPSB0aGlzLm1UZXh0Qm91bmRzLndpZHRoO1xyXG4gICAgICBvdXRSZWN0LmhlaWdodCA9IHRoaXMubVRleHRCb3VuZHMuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIG91dFJlY3Qud2lkdGggKz0gdGhpcy5tUGFkZGluZy5yaWdodDtcclxuICAgIG91dFJlY3QuaGVpZ2h0ICs9IHRoaXMubVBhZGRpbmcuYm90dG9tO1xyXG5cclxuICAgIHJldHVybiBvdXRSZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvciB1cGRhdGVzIGdpdmVuIHRleHQgc3R5bGUgYnkgZ2l2ZW4gdGFnIG5hbWUuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+VGV4dFN0eWxlfSBzdHlsZSBcclxuICAgKi9cclxuICBzZXRTdHlsZShuYW1lLCBzdHlsZSkge1xyXG4gICAgRGVidWcuYXNzZXJ0KG5hbWUgIT09ICdkZWYnLCBgUGxlYXNlIHVzZSAnc2V0RGVmYXVsdFN0eWxlJyBpbnN0ZWFkLmApO1xyXG4gICAgc3R5bGUubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgdGhpcy5tU3R5bGVzW25hbWVdID0gc3R5bGU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGRlZmF1bHQgdGV4dCBzdHlsZSB3aXRoIGEgZ2l2ZW4gb25lLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflRleHRTdHlsZX0gc3R5bGUgXHJcbiAgICovXHJcbiAgc2V0RGVmYXVsdFN0eWxlKHN0eWxlKSB7XHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUgPSBzdHlsZTtcclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgc3R5bGUgYnkgZ2l2ZW4gbmFtZS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcclxuICAgKi9cclxuICByZW1vdmVTdHlsZShuYW1lKSB7XHJcbiAgICBkZWxldGUgdGhpcy5tU3R5bGVzW25hbWVdO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0ZXh0IHN0eWxlIGJ5IGdpdmVuIG5hbWUgb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflRleHRTdHlsZX0gXHJcbiAgICovXHJcbiAgZ2V0U3R5bGUobmFtZSkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXMubVN0eWxlc1tuYW1lXSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBub3QgZGVmYXVsdCBzdHlsZXMuXHJcbiAgICogXHJcbiAgICogQHJldHVybiB7QXJyYXk8YmxhY2stZW5naW5lflRleHRTdHlsZT59IFxyXG4gICAqL1xyXG4gIGdldEFsbFN0eWxlcygpIHtcclxuICAgIGxldCBzdHlsZXMgPSBbXTtcclxuICAgIGZvciAobGV0IHMgaW4gdGhpcy5tU3R5bGVzKVxyXG4gICAgICBzdHlsZXMucHVzaCh0aGlzLm1TdHlsZXNbc10pO1xyXG4gICAgcmV0dXJuIHN0eWxlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZGVmYXVsdCB0ZXh0IHN0eWxlLlxyXG4gICAqL1xyXG4gIGdldERlZmF1bHRTdHlsZShuYW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRGVmYXVsdFN0eWxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IG11bHRpbGluZSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tTXVsdGlsaW5lID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQvU2V0IG11bHRpTGluZSB2YWx1ZSBzd2l0Y2hlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IG11bHRpbGluZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1NdWx0aWxpbmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBsaW5lSGVpZ2h0KHZhbHVlKSB7XHJcbiAgICB0aGlzLm1MaW5lSGVpZ2h0ID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQvU2V0IGxpbmVzIHZlcnRpY2FsIG9mZnNldC4gRnJvbSB0b3AgcHJldmlvdXMgdG8gdG9wIG5leHQgbGluZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbGluZUhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1MaW5lSGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldCB0ZXh0IHNpemUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRGVmYXVsdFN0eWxlLnNpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBzaXplKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tRGVmYXVsdFN0eWxlLnNpemUgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRGVmYXVsdFN0eWxlLnNpemUgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXQgdGV4dCBmb250LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBmb250KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5mYW1pbHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmb250KHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tRGVmYXVsdFN0eWxlLmZhbWlseSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuZmFtaWx5ID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTcGVjaWZpZXMgdGV4dCBjb2xvciBhcyBoZXhhZGVjaW1hbCBudW1iZXIgZWcgMHhmZjAwMDAgKHRvdGFsIHJlZCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHRleHRDb2xvcigpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuY29sb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB0ZXh0Q29sb3IodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1EZWZhdWx0U3R5bGUuY29sb3IgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRGVmYXVsdFN0eWxlLmNvbG9yID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgdGV4dCBhbHBoYSBpbiByYW5nZSBbMC4uMV0uXHJcbiAgICogTk9URTogVGhpcyBwcm9wZXJ0eSB3aWxsIGFmZmVjdCBzaGFkb3cgYWxwaGEuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHRleHRBbHBoYSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuYWxwaGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB0ZXh0QWxwaGEodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1EZWZhdWx0U3R5bGUuYWxwaGEgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRGVmYXVsdFN0eWxlLmFscGhhID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQvU2V0IHRleHQgc3R5bGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Rm9udFN0eWxlfVxyXG4gICAqL1xyXG4gIGdldCBmb250U3R5bGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRGVmYXVsdFN0eWxlLnN0eWxlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Rm9udFN0eWxlfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGZvbnRTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubURlZmF1bHRTdHlsZS5zdHlsZSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuc3R5bGUgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWNpZmllcyB0aGUgZm9udCB0aGljay4gVGhlIHZhbHVlIGlzIHNldCBmcm9tIDEwMCB0byA5MDAgaW4gaW5jcmVtZW50cyBvZiAxMDAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Rm9udFdlaWdodH1cclxuICAgKi9cclxuICBnZXQgd2VpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS53ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Gb250V2VpZ2h0fSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHdlaWdodCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubURlZmF1bHRTdHlsZS53ZWlnaHQgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRGVmYXVsdFN0eWxlLndlaWdodCA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3BlY2lmaWVzIHRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGV4dCAobGVmdCB8IGNlbnRlciB8IHJpZ2h0KS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Gb250QWxpZ259XHJcbiAgICovXHJcbiAgZ2V0IGFsaWduKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUFsaWduO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Rm9udEFsaWdufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGFsaWduKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tQWxpZ24gPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tQWxpZ24gPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWNpZmllcyB0aGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRoZSB0ZXh0ICh0b3AgfCBtaWRkbGUgfCBib3R0b20pLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkZvbnRWZXJ0aWNhbEFsaWdufVxyXG4gICAqL1xyXG4gIGdldCB2QWxpZ24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVmVydGljYWxBbGlnbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkZvbnRWZXJ0aWNhbEFsaWdufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHZBbGlnbih2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubVZlcnRpY2FsQWxpZ24gPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tVmVydGljYWxBbGlnbiA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3BlY2lmaWVzIHN0cm9rZSBjb2xvciBhcyBoZXhhZGVjaW1hbCBudW1iZXIgZWcgMHhmZjAwMDAgKHRvdGFsIHJlZClcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHN0cm9rZUNvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5zdHJva2VDb2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHN0cm9rZUNvbG9yKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5tRGVmYXVsdFN0eWxlLnN0cm9rZUNvbG9yID09PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubURlZmF1bHRTdHlsZS5zdHJva2VDb2xvciA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eSgvKiogQHR5cGUge0RpcnR5RmxhZ30gKi8oRGlydHlGbGFnLlJFTkRFUl9DQUNIRSB8IERpcnR5RmxhZy5SRU5ERVIpLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgIHN0cm9rZSBhbHBoYSBpbiByYW5nZSBbMC4uMV0uXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBzdHJva2VBbHBoYSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuc3Ryb2tlQWxwaGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBzdHJva2VBbHBoYSh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubURlZmF1bHRTdHlsZS5zdHJva2VBbHBoYSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuc3Ryb2tlQWxwaGEgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0RGlydHkoLyoqIEB0eXBlIHtEaXJ0eUZsYWd9ICovKERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUgfCBEaXJ0eUZsYWcuUkVOREVSKSwgZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3BlY2lmaWVzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS4gMCBtZWFucyB0aGF0IG5vIHN0cm9rZS5cclxuICAgKiBOb3RlOiBpZiBhdXRvU2l6ZSBpcyB0cnVlIHN0cm9rZSB3b3JrcyBsaWtlIGZpbHRlciBtZWFuaW5nIHRoYXQgcG9zaXRpb24gb2YgdGhlIHRleHQgd2lsbCBub3QgYmUgYWRqdXN0ZWQgYW5kIGJvdW5kcyB3aWxsIGJlIHRoZSBzYW1lLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gXHJcbiAgICovXHJcbiAgZ2V0IHN0cm9rZVRoaWNrbmVzcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc3Ryb2tlVGhpY2tuZXNzKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubURlZmF1bHRTdHlsZS5zdHJva2VUaGlja25lc3MpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuc3Ryb2tlVGhpY2tuZXNzID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KC8qKiBAdHlwZSB7RGlydHlGbGFnfSAqLyhEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFIHwgRGlydHlGbGFnLlJFTkRFUiksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWNpZmllcyB0aGUgd2lkdGggb2YgdGhlIHRleHQgZmllbGQuIElmIGF1dG9TaXplIHNldCBhcyBmYWxzZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBmaWVsZFdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUZpZWxkV2lkdGg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmaWVsZFdpZHRoKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubUZpZWxkV2lkdGgpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1GaWVsZFdpZHRoID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKiogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHRleHQgZmllbGQsIGlmIGF1dG9TaXplIHNldCBhcyBmYWxzZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBmaWVsZEhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1GaWVsZEhlaWdodDtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmaWVsZEhlaWdodCh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLm1GaWVsZEhlaWdodClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUZpZWxkSGVpZ2h0ID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhpcyB0ZXh0IGZpZWxkLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgdGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1UZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgdGV4dCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubVRleHQgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tVGV4dCA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zdHMgZXZlcnkgdGltZSB0ZXh0IGhhcyBiZWVuIGNoYW5nZWQuXHJcbiAgICAgKiBAZXZlbnQgVGV4dEZpZWxkI2NoYW5nZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5DSEFOR0UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzaXplIG9mIHRoZSBmaWVsZCB3aWxsIGFkanVzdCB0byB0aGUgc2l6ZSBvZiB0aGUgdGV4dC4gTm90ZTogaWYgdGhpcyBzZXQgYXMgdHJ1ZSwgeW91IG5lZWQgdG8gc3BlY2lmeSBmaWVsZEhlaWdodCBhbmQgZmllbGRXaWR0aCBtYW51YWxseVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgYXV0b1NpemUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tQXV0b1NpemU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgYXV0b1NpemUodmFsdWUpIHtcclxuICAgIGlmICh0aGlzLm1BdXRvU2l6ZSA9PT0gdmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1BdXRvU2l6ZSA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gZXh0cmEgcGFkZGluZy4gQWxzbyB1c2VmdWwgZm9yIGJhZCBwcmVwYXJlZCBmb250cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5SZWN0YW5nbGV9XHJcbiAgICovXHJcbiAgZ2V0IHBhZGRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUGFkZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBwYWRkaW5nKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1QYWRkaW5nID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHNldHMgd2hlbmV2ZXIgdG8gZHJvcCBzaGFkb3cgb3Igbm90LlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFxyXG4gICAqL1xyXG4gIGdldCBkcm9wU2hhZG93KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5kcm9wU2hhZG93O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGRyb3BTaGFkb3codmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5tRGVmYXVsdFN0eWxlLmRyb3BTaGFkb3cpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuZHJvcFNoYWRvdyA9IHZhbHVlO1xyXG5cclxuICAgIHRoaXMuc2V0RGlydHkoRGlydHlGbGFnLlJFTkRFUl9DQUNIRSwgZmFsc2UpO1xyXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9zZXRzIHRoZSBjb2xvciBvZiB0aGUgc2hhZG93LlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gXHJcbiAgICovXHJcbiAgZ2V0IHNoYWRvd0NvbG9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dDb2xvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNoYWRvd0NvbG9yKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dDb2xvcilcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dDb2xvciA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eSgvKiogQHR5cGUge0RpcnR5RmxhZ30gKi8oRGlydHlGbGFnLlJFTkRFUl9DQUNIRSB8IERpcnR5RmxhZy5SRU5ERVIpLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgYWxwaGEgY29tcG9uZW50IG9mIHRoZSBzaGFkb3dzLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gXHJcbiAgICovXHJcbiAgZ2V0IHNoYWRvd0FscGhhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dBbHBoYTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNoYWRvd0FscGhhKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dBbHBoYSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dBbHBoYSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eSgvKiogQHR5cGUge0RpcnR5RmxhZ30gKi8oRGlydHlGbGFnLlJFTkRFUl9DQUNIRSB8IERpcnR5RmxhZy5SRU5ERVIpLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgdGhlIHNoYWRvdyBibHVyIHJhZGl1cy5cclxuICAgKiBcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFxyXG4gICAqL1xyXG4gIGdldCBzaGFkb3dCbHVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dCbHVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2hhZG93Qmx1cih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLm1EZWZhdWx0U3R5bGUuc2hhZG93Qmx1cilcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dCbHVyID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KC8qKiBAdHlwZSB7RGlydHlGbGFnfSAqLyhEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFIHwgRGlydHlGbGFnLlJFTkRFUiksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyBzaGFkb3cgZGlzdGFuY2Ugb24geCBheGlzLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gXHJcbiAgICovXHJcbiAgZ2V0IHNoYWRvd0Rpc3RhbmNlWCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuc2hhZG93RGlzdGFuY2VYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2hhZG93RGlzdGFuY2VYKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dEaXN0YW5jZVgpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuc2hhZG93RGlzdGFuY2VYID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KC8qKiBAdHlwZSB7RGlydHlGbGFnfSAqLyhEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFIHwgRGlydHlGbGFnLlJFTkRFUiksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyBzaGFkb3cgZGlzdGFuY2Ugb24geSBheGlzLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gXHJcbiAgICovXHJcbiAgZ2V0IHNoYWRvd0Rpc3RhbmNlWSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWZhdWx0U3R5bGUuc2hhZG93RGlzdGFuY2VZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2hhZG93RGlzdGFuY2VZKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHRoaXMubURlZmF1bHRTdHlsZS5zaGFkb3dEaXN0YW5jZVkpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1EZWZhdWx0U3R5bGUuc2hhZG93RGlzdGFuY2VZID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KC8qKiBAdHlwZSB7RGlydHlGbGFnfSAqLyhEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFIHwgRGlydHlGbGFnLlJFTkRFUiksIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvc2V0cyByZW5kZXIgcXVhbGl0eSBvZiB0aGlzIHRleHQgZmllbGQuIEZhbHNlIGJ5IGRlZmF1bHQuXHJcbiAgICogV2hlbiB0cnVlIGZvbnQgd2lsbCByZXNwZWN0IG9iamVjdCdzIHNjYWxlIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uIFRoZSBkb3duc2lkZSBpcyBpdCBtYXkgY2F1c2UgZm9udCBzaGFraW5nIHdoZW4gYW5pbWF0aW5nLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBoaWdoUXVhbGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1IaWdoUXVhbGl0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBoaWdoUXVhbGl0eSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tSGlnaFF1YWxpdHkgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGRpc3BsYXkgdGV4dC5cclxuICpcclxuICogQGNhdCBkaXNwbGF5LnRleHRcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkRpc3BsYXlPYmplY3RcclxuICovXHJcbmNsYXNzIEJpdG1hcFRleHRGaWVsZCBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgQml0bWFwVGV4dEZpZWxkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8YmxhY2stZW5naW5lfkJpdG1hcEZvbnREYXRhfSBmb250ICAgICBUaGUgbmFtZSBvZiB0aGUgYml0bWFwIGZvbnRcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHRleHQgICAgICAgICAgICAgICAgICAgVGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoaXMgdGV4dCBmaWVsZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGZvbnQsIHRleHQgPSAnJykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICBpZiAoZm9udCAhPT0gbnVsbCAmJiBmb250LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXHJcbiAgICAgIHRoaXMubURhdGEgPSBCbGFjay5hc3NldHMuZ2V0Qml0bWFwRm9udCgvKiogQHR5cGUge3N0cmluZ30gKi8oZm9udCkpO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLm1EYXRhID0gLyoqIEB0eXBlIHtCaXRtYXBGb250RGF0YX0gKi8gKGZvbnQpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge3N0cmluZ30gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRleHQgPSB0ZXh0O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1BdXRvU2l6ZSA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU11bHRpbGluZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUxpbmVIZWlnaHQgPSAxLjI7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJlY3RhbmdsZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmVjdGFuZ2xlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGV4dEJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaWVsZFdpZHRoID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaWVsZEhlaWdodCA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIGdldFJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIEJsYWNrLmRyaXZlci5nZXRSZW5kZXJlcignQml0bWFwVGV4dCcsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkdldExvY2FsQm91bmRzKG91dFJlY3QgPSB1bmRlZmluZWQpIHtcclxuICAgIG91dFJlY3QgPSBvdXRSZWN0IHx8IG5ldyBSZWN0YW5nbGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5tQ2xpcFJlY3QgIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5tQ2xpcFJlY3QuY29weVRvKG91dFJlY3QpO1xyXG4gICAgICByZXR1cm4gb3V0UmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5tRGlydHkgJiBEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFKSB7XHJcbiAgICAgIGxldCB0ZXh0ID0gdGhpcy50ZXh0O1xyXG4gICAgICBpZiAodGhpcy5tTXVsdGlsaW5lID09PSBmYWxzZSlcclxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZywgJycpO1xyXG5cclxuICAgICAgVGV4dE1ldHJpY3NFeC5tZWFzdXJlQml0bWFwKHRleHQsIHRoaXMubURhdGEsIHRoaXMubUxpbmVIZWlnaHQsIHRoaXMubVRleHRCb3VuZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm1BdXRvU2l6ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgb3V0UmVjdC53aWR0aCA9IHRoaXMubUZpZWxkV2lkdGg7XHJcbiAgICAgIG91dFJlY3QuaGVpZ2h0ID0gdGhpcy5tRmllbGRIZWlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvdXRSZWN0LndpZHRoID0gdGhpcy5tVGV4dEJvdW5kcy53aWR0aDtcclxuICAgICAgb3V0UmVjdC5oZWlnaHQgPSB0aGlzLm1UZXh0Qm91bmRzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb3V0UmVjdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBtdWx0aWxpbmUodmFsdWUpIHtcclxuICAgIHRoaXMubU11bHRpbGluZSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQvU2V0IG11bHRpTGluZSB2YWx1ZSBzd2l0Y2hlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IG11bHRpbGluZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1NdWx0aWxpbmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBsaW5lSGVpZ2h0KHZhbHVlKSB7XHJcbiAgICB0aGlzLm1MaW5lSGVpZ2h0ID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldC9TZXQgbGluZXMgdmVydGljYWwgb2Zmc2V0LiBGcm9tIHRvcCBwcmV2aW91cyB0byB0b3AgbmV4dCBsaW5lLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBsaW5lSGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUxpbmVIZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTcGVjaWZpZXMgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGZpZWxkLiBJZiBhdXRvU2l6ZSBzZXQgYXMgZmFsc2VcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZmllbGRXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1GaWVsZFdpZHRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZmllbGRXaWR0aCh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLm1GaWVsZFdpZHRoKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRmllbGRXaWR0aCA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKiogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHRleHQgZmllbGQsIGlmIGF1dG9TaXplIHNldCBhcyBmYWxzZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBmaWVsZEhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1GaWVsZEhlaWdodDtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmaWVsZEhlaWdodCh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLm1GaWVsZEhlaWdodClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUZpZWxkSGVpZ2h0ID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlRleHQgdG8gYmUgZGlzcGxheWVkIGluc2lkZSB0aGlzIHRleHQgZmllbGQuXHJcblxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgdGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1UZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgdGV4dCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubVRleHQgPT09IHZhbHVlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tVGV4dCA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXREaXJ0eShEaXJ0eUZsYWcuUkVOREVSX0NBQ0hFLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNpemUgb2YgdGhlIGZpZWxkIHdpbGwgYWRqdXN0IHRvIHRoZSBzaXplIG9mIHRoZSB0ZXh0LiBOb3RlOiBpZiB0aGlzIHNldCBhcyB0cnVlLCB5b3UgbmVlZCB0byBzcGVjaWZ5IGZpZWxkSGVpZ2h0IGFuZCBmaWVsZFdpZHRoIG1hbnVhbGx5XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBhdXRvU2l6ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1BdXRvU2l6ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBhdXRvU2l6ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMubUF1dG9TaXplID09PSB2YWx1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUF1dG9TaXplID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldERpcnR5KERpcnR5RmxhZy5SRU5ERVJfQ0FDSEUsIGZhbHNlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIFZlY3RvciBzY2F0dGVycy5cclxuICpcclxuICogQGNhdCBzY2F0dGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+U2NhdHRlclxyXG4gKi9cclxuY2xhc3MgVmVjdG9yU2NhdHRlckJhc2UgZXh0ZW5kcyBTY2F0dGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBWZWN0b3JTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBsYXN0IHZhbHVlIG9mIGBnZXRWYWx1ZUF0YCByZXN1bHQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudmFsdWUgPSBuZXcgVmVjdG9yKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHJhbmRvbSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9LlxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdChNYXRoLnJhbmRvbSgpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgZm9yIGNvbG9yIHNjYXR0ZXJzLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqIEBleHRlbmRzIFNjYXR0ZXJcclxuICovXHJcbmNsYXNzIENvbG9yU2NhdHRlckJhc2UgZXh0ZW5kcyBTY2F0dGVyIHsgIFxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBsYXN0IHZhbHVlIG9mIGBnZXRWYWx1ZUF0YCByZXN1bHQuXHJcbiAgICAgKiBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52YWx1ZSA9IDA7XHJcbiAgfVxyXG4gICAgXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyByYW5kb20gdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0KE1hdGgucmFuZG9tKCkpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY29sb3Igc2NhdHRlci5cclxuICpcclxuICogQGNhdCBzY2F0dGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZVxyXG4gKi9cclxuY2xhc3MgQ29sb3JTY2F0dGVyIGV4dGVuZHMgQ29sb3JTY2F0dGVyQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ29sb3JTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRDb2xvcj0wXVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kQ29sb3I9bnVsbF1cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbihudW1iZXIpOm51bWJlcn0gW2Vhc2U9bnVsbF0gRWFzaW5nIGZ1bmN0aW9uLiBJZiBudWxsIGxpbmVhciBmdW5jdGlvbiBpcyB1c2VkIGFzIGRlZmF1bHQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc3RhcnRDb2xvciwgZW5kQ29sb3IgPSBudWxsLCBlYXNlID0gbnVsbCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgc3RhcnRpbmcgY29sb3JcclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydENvbG9yID0gc3RhcnRDb2xvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgZW5kaW5nIGNvbG9yXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciA9PT0gbnVsbCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsIGVhc2luZyBmdW5jdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lYXNlID0gZWFzZTtcclxuICB9XHJcblxyXG4gIGdldFZhbHVlQXQodCkge1xyXG4gICAgaWYgKHRoaXMuZWFzZSAhPT0gbnVsbClcclxuICAgICAgdCA9IHRoaXMuZWFzZSh0KTtcclxuXHJcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5zdGFydENvbG9yID09PSB0aGlzLmVuZENvbG9yID8gdGhpcy5zdGFydENvbG9yIDogQ29sb3JIZWxwZXIubGVycEhTVih0aGlzLnN0YXJ0Q29sb3IsIHRoaXMuZW5kQ29sb3IsIHQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ29sb3JTY2F0dGVyQmFzZSBmcm9tIGEgc2V0IG9mIG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLm51bWJlcnxibGFjay1lbmdpbmV+Q29sb3JTY2F0dGVyQmFzZX0gdmFsdWVzIFNldCBvZiB2YWx1ZXMuXHJcbiAgICogQHJldHVybnMge2JsYWNrLWVuZ2luZX5Db2xvclNjYXR0ZXJCYXNlfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmcm9tT2JqZWN0KC4uLnZhbHVlcykge1xyXG4gICAgaWYgKHZhbHVlc1swXSBpbnN0YW5jZW9mIENvbG9yU2NhdHRlckJhc2UpXHJcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0NvbG9yU2NhdHRlckJhc2V9ICovICh2YWx1ZXNbMF0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgQ29sb3JTY2F0dGVyKC4uLnZhbHVlcyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSB2ZWN0b3Igc2NhdHRlciBmb3IgZGVmaW5pbmcgYSByYW5nZSBpbiAyRCBzcGFjZS5cclxuICpcclxuICogQGNhdCBzY2F0dGVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2VcclxuICovXHJcbmNsYXNzIFZlY3RvclNjYXR0ZXIgZXh0ZW5kcyBWZWN0b3JTY2F0dGVyQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgVmVjdG9yU2NhdHRlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgW21pblg9MF0gICAgICAgICAgICAgICAgICAgICBUaGUgbWluIHZhbHVlIGFsb25nIHgtYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIFttaW5ZPTBdICAgICAgICAgICAgICAgICAgICAgVGhlIG1pbiB2YWx1ZSBhbG9uZyB5LWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbbWF4WD1udWxsXSAgICAgICAgICAgICAgICAgIFRoZSBtYXggdmFsdWUgYWxvbmcgeC1heGlzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW21heFk9bnVsbF0gICAgICAgICAgICAgICAgICBUaGUgbWF4IHZhbHVlIGFsb25nIHktYXhpcy5cclxuICAgKiBAcGFyYW0gez9mdW5jdGlvbihudW1iZXIpOm51bWJlcn0gW2Vhc2U9bnVsbF0gRWFzaW5nIGZ1bmN0aW9uLiBJZiBudWxsIGxpbmVhciBmdW5jdGlvbiBpcyB1c2VkIGFzIGRlZmF1bHQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IobWluWCA9IDAsIG1pblkgPSAwLCBtYXhYID0gbnVsbCwgbWF4WSA9IG51bGwsIGVhc2UgPSBudWxsKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtaW4gdmFsdWUgYWxvbmcgeC1heGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pblggPSBtaW5YO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtaW4gdmFsdWUgYWxvbmcgeS1heGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pblkgPSBtaW5ZO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtYXggdmFsdWUgYWxvbmcgeC1heGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFggPSBtYXhYID09PSBudWxsID8gbWluWCA6IG1heFg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1heCB2YWx1ZSBhbG9uZyB5LWF4aXMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF4WSA9IG1heFkgPT09IG51bGwgPyBtaW5ZIDogbWF4WTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbmFsIGVhc2luZyBmdW5jdGlvbi5cclxuICAgICAqIFxyXG4gICAgICogQHR5cGUgez9mdW5jdGlvbihWZWN0b3IpOlZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5lYXNlID0gZWFzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSByYW5kb20gVmVjdG9yIG9iamVjdCBhdCBnaXZlbiBwb3NpdGlvbiB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2UuXHJcbiAgICpcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBWZWN0b3Igb2JqZWN0IHdpdGggcmFuZG9tIHZhbHVlcyB3aXRoaW5nIGRlZmluZWQgcmFuZ2UuXHJcbiAgICovXHJcbiAgZ2V0VmFsdWUoKSB7XHJcbiAgICB0aGlzLnZhbHVlLnggPSBNYXRoLnJhbmRvbSgpICogKHRoaXMubWF4WCAtIHRoaXMubWluWCkgKyB0aGlzLm1pblg7XHJcbiAgICB0aGlzLnZhbHVlLnkgPSBNYXRoLnJhbmRvbSgpICogKHRoaXMubWF4WSAtIHRoaXMubWluWSkgKyB0aGlzLm1pblk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgVmVjdG9yIG9iamVjdCBhdCBnaXZlbiBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IFRoZSBwb3NpdGlvbi5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VmVjdG9yfSBWZWN0b3Igb2JqZWN0IHJlcHJlc2VudGluZyB2YWx1ZXMgaW4gYSByYW5nZSBhdCBnaXZlbiBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXRWYWx1ZUF0KHQpIHtcclxuICAgIGlmICh0aGlzLmVhc2UgIT09IG51bGwpXHJcbiAgICAgIHQgPSB0aGlzLmVhc2UodCk7XHJcblxyXG4gICAgdGhpcy52YWx1ZS54ID0gdGhpcy5taW5YICsgdCAqICh0aGlzLm1heFggLSB0aGlzLm1pblgpO1xyXG4gICAgdGhpcy52YWx1ZS55ID0gdGhpcy5taW5ZICsgdCAqICh0aGlzLm1heFkgLSB0aGlzLm1pblkpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgVmVjdG9yU2NhdHRlciBmcm9tIGEgc2V0IG9mIG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLm51bWJlcnxibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2V9IHZhbHVlcyBTZXQgb2YgdmFsdWVzLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2V9XHJcbiAgICovXHJcbiAgc3RhdGljIGZyb21PYmplY3QoLi4udmFsdWVzKSB7XHJcbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgVmVjdG9yU2NhdHRlckJhc2UpXHJcbiAgICAgIHJldHVybiAvKiogQHR5cGUge1ZlY3RvclNjYXR0ZXJCYXNlfSAqLyAodmFsdWVzWzBdKTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFZlY3RvclNjYXR0ZXIoLi4udmFsdWVzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHBhcnRpY2xlJ3Mgc3RhcnRpbmcgdmVsb2NpdHkuXHJcbiAqXHJcbiAqIEBjYXQgc2NhdHRlcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lflZlY3RvclNjYXR0ZXJCYXNlXHJcbiAqL1xyXG5jbGFzcyBWZWN0b3JDdXJ2ZVNjYXR0ZXIgZXh0ZW5kcyBWZWN0b3JTY2F0dGVyQmFzZSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgVmVjdG9yQ3VydmVTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi5udW1iZXJ9IHBvaW50cyBDb29yZGluYXRlczogc3RhcnRYLCBzdGFydFksIGNwU3RhcnRYLCBjcFN0YXJ0WSwgY3BFbmRYLCBjcEVuZFksIGVuZFgvc3RhcnQyWCwgZW5kWS9zdGFydDJZLCBjcDJTdGFydFgsIGNwMlN0YXJ0WC4uLiA4IG9yIDE0IG9yIDIwLi4uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5DdXJ2ZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUN1cnZlID0gbmV3IEN1cnZlKCk7XHJcbiAgICB0aGlzLm1DdXJ2ZS5iYWtlZCA9IHRydWU7XHJcbiAgICB0aGlzLm1DdXJ2ZS5zZXQoLi4ucG9pbnRzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUG9pbnRzQ2FjaGUgPSBwb2ludHM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlID0gbmV3IFZlY3RvcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBjdXJ2ZSB3aXRoIG5ldyBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZVxyXG4gICAqL1xyXG4gIHNldCBwb2ludHModmFsdWUpIHtcclxuICAgIHRoaXMubVBvaW50c0NhY2hlID0gdmFsdWU7XHJcbiAgICB0aGlzLm1DdXJ2ZS5zZXQoLi4udmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBsaXN0IG9mIHBvaW50cy5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cclxuICAgKi9cclxuICBnZXQgcG9pbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBvaW50c0NhY2hlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIFZlY3RvciBhdCBnaXZlbiBwb3NpdGlvbiBvbiBhIGN1cnZlLlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHBvc2l0aW9uLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFZlY3RvciBvYmplY3QgcmVwcmVzZW50aW5nIGEgdmFsdWUgb24gYSBjdXJ2ZSBhdCBnaXZlbiBwb3NpdGlvbi5cclxuICAgKi9cclxuICBnZXRWYWx1ZUF0KHQpIHtcclxuICAgIHRoaXMubUN1cnZlLmludGVycG9sYXRlKHQsIHRoaXMubUNhY2hlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQ2FjaGU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBudW1iZXIgc2NhdHRlciBmb3IgZGVmaW5pbmcgYSByYW5nZSBpbiBhIGNpcmN1bGFyIHNoYXBlLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZVxyXG4gKi9cclxuY2xhc3MgUmFkaWFsU2NhdHRlciBleHRlbmRzIFZlY3RvclNjYXR0ZXJCYXNlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBWZWN0b3JTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGNlbnRlciBvZiBhIGNpcmNsZSBhbG9uZyB4LWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGNlbnRlciBvZiBhIGNpcmNsZSBhbG9uZyB5LWF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblJhZGl1cyBUaGUgbWluIHJhZGl1cyB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW21heFJhZGl1cz1udWxsXSBUaGUgbWF4IHJhZGl1cyB2YWx1ZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIG1pblJhZGl1cyA9IDAsIG1heFJhZGl1cyA9IG51bGwpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1pbiB2YWx1ZSBhbG9uZyB4LWF4aXMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueCA9IHg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1pbiB2YWx1ZSBhbG9uZyB5LWF4aXMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMueSA9IHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIG1heCB2YWx1ZSBhbG9uZyB4LWF4aXMuXHJcbiAgICAgKiBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWluUmFkaXVzID0gbWluUmFkaXVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtYXggdmFsdWUgYWxvbmcgeS1heGlzLlxyXG4gICAgICogXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1heFJhZGl1cyA9IG1heFJhZGl1cyA9PT0gbnVsbCA/IG1pblJhZGl1cyA6IG1heFJhZGl1cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSByYW5kb20gVmVjdG9yIG9iamVjdCBhdCBnaXZlbiBwb3NpdGlvbiB3aXRoaW4gYSByYW5nZSBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflZlY3Rvcn0gVmVjdG9yIG9iamVjdCB3aXRoIHJhbmRvbSB2YWx1ZXMgd2l0aGluZyBkZWZpbmVkIHJhbmdlLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdChNYXRoLnJhbmRvbSgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBWZWN0b3Igb2JqZWN0IGF0IGdpdmVuIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHBvc2l0aW9uLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5WZWN0b3J9IFZlY3RvciBvYmplY3QgcmVwcmVzZW50aW5nIHZhbHVlcyBpbiBhIHJhbmdlIGF0IGdpdmVuIHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlQXQodCkge1xyXG4gICAgY29uc3QgciA9IHRoaXMubWluUmFkaXVzICsgdCAqICh0aGlzLm1heFJhZGl1cyAtIHRoaXMubWluUmFkaXVzKTtcclxuXHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTsgLy8gTWF0aEV4LlBJMj9cclxuICAgIGNvbnN0IHJTcSA9IHIgKiByO1xyXG4gICAgY29uc3QgcnggPSB0aGlzLnggKyAoTWF0aC5zcXJ0KHJTcSkgKiBNYXRoLmNvcyhhbmdsZSkpO1xyXG4gICAgY29uc3QgcnkgPSB0aGlzLnkgKyAoTWF0aC5zcXJ0KHJTcSkgKiBNYXRoLnNpbihhbmdsZSkpO1xyXG5cclxuICAgIHRoaXMudmFsdWUueCA9IHJ4O1xyXG4gICAgdGhpcy52YWx1ZS55ID0gcnk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBudW1iZXIgc2NhdHRlciBmb3IgZGVmaW5pbmcgYSByYW5nZSBpbiAyRCBzcGFjZSBvbiBhIGN1cnZlLlxyXG4gKlxyXG4gKiBAY2F0IHNjYXR0ZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlXHJcbiAqL1xyXG5jbGFzcyBGbG9hdEN1cnZlU2NhdHRlciBleHRlbmRzIEZsb2F0U2NhdHRlckJhc2Uge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEZsb2F0Q3VydmVTY2F0dGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi5udW1iZXJ9IHBvaW50cyBDb29yZGluYXRlczogc3RhcnRYLCBzdGFydFksIGNwU3RhcnRYLCBjcFN0YXJ0WSwgY3BFbmRYLCBjcEVuZFksIGVuZFgvc3RhcnQyWCwgZW5kWS9zdGFydDJZLCBjcDJTdGFydFgsIGNwMlN0YXJ0WC4uLiA4IG9yIDE0IG9yIDIwLi4uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5DdXJ2ZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUN1cnZlID0gbmV3IEN1cnZlKCk7XHJcbiAgICB0aGlzLm1DdXJ2ZS5iYWtlZCA9IHRydWU7XHJcbiAgICB0aGlzLm1DdXJ2ZS5zZXQoLi4ucG9pbnRzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUG9pbnRzQ2FjaGUgPSBwb2ludHM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNhY2hlID0gbmV3IFZlY3RvcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBjdXJ2ZSB3aXRoIG5ldyBhcnJheSBvZiBwb2ludHMuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB2YWx1ZVxyXG4gICAqL1xyXG4gIHNldCBwb2ludHModmFsdWUpIHtcclxuICAgIHRoaXMubVBvaW50c0NhY2hlID0gdmFsdWU7XHJcbiAgICB0aGlzLm1DdXJ2ZS5zZXQoLi4udmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBsaXN0IG9mIHBvaW50cy5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cclxuICAgKi9cclxuICBnZXQgcG9pbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBvaW50c0NhY2hlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG51bWJlciBhdCBnaXZlbiBwb3NpdGlvbiBvbiBhIGN1cnZlLlxyXG4gICAqXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgVGhlIHBvc2l0aW9uLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSB2YWx1ZSBvbiBhIGN1cnZlIGF0IGdpdmVuIHBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIGdldFZhbHVlQXQodCkge1xyXG4gICAgdGhpcy5tQ3VydmUuaW50ZXJwb2xhdGUodCwgdGhpcy5tQ2FjaGUpO1xyXG5cclxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm1DYWNoZS55O1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBhY2NlbGVyYXRpb24gdG8gcGFydGljbGVzIGFsb25nIGdpdmVuIGRpcmVjdGlvbi5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgQWNjZWxlcmF0aW9uIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEFjY2VsZXJhdGlvbiBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2UpfSB2YWx1ZXMgQW4gVmVjdG9yU2NhdHRlckJhc2Ugd2hpY2ggZGVmaW5lcyBhY2NlbGVyYXRpb24gZGlyZWN0aW9uLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoZmFsc2UpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gVmVjdG9yU2NhdHRlci5mcm9tT2JqZWN0KC4uLnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHVwZGF0ZShlbWl0dGVyLCBwYXJ0aWNsZSwgZHQpIHtcclxuICAgIHRoaXMuc2NhdHRlci5nZXRWYWx1ZSgpO1xyXG4gICAgXHJcbiAgICBwYXJ0aWNsZS5heCArPSB0aGlzLnNjYXR0ZXIudmFsdWUueDtcclxuICAgIHBhcnRpY2xlLmF5ICs9IHRoaXMuc2NhdHRlci52YWx1ZS55O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgcGFydGljbGUncyBhbHBoYSB2YWx1ZSBhY2NvcmRpbmcgdG8gaXRzIGVuZXJneSB2YWx1ZS5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgQWxwaGFPdmVyTGlmZSBleHRlbmRzIE1vZGlmaWVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBBbHBoYU92ZXJMaWZlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi4obnVtYmVyfGJsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlKX0gdmFsdWVzIEEgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgb2YgYWxwaGEgcHJvcGVydHkuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcihmYWxzZSk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZX0gTW9kaWZpZXIncyBvYmplY3QgdG8gZ2V0IHZhbHVlcyBmcm9tLiAgKi9cclxuICAgIHRoaXMuc2NhdHRlciA9IEZsb2F0U2NhdHRlci5mcm9tT2JqZWN0KC4uLnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHVwZGF0ZShlbWl0dGVyLCBwYXJ0aWNsZSwgZHQpIHtcclxuICAgIHBhcnRpY2xlLmFscGhhID0gdGhpcy5zY2F0dGVyLmdldFZhbHVlQXQocGFydGljbGUuZW5lcmd5KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHBhcnRpY2xlJ3MgY29sb3IgdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyBlbmVyZ3kgdmFsdWUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIENvbG9yT3ZlckxpZmUgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQ29sb3JPdmVyTGlmZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+Q29sb3JTY2F0dGVyQmFzZSl9IHZhbHVlcyBBIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIG9mIGNvbG9yIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoZmFsc2UpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkNvbG9yU2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBDb2xvclNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS5jb2xvciA9IHRoaXMuc2NhdHRlci5nZXRWYWx1ZUF0KHBhcnRpY2xlLmVuZXJneSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0cyBwYXJ0aWNsZSdzIHNjYWxlIHZhbHVlIGFjY29yZGluZyB0byBpdHMgZW5lcmd5IHZhbHVlLlxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlcy5tb2RpZmllcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1vZGlmaWVyXHJcbiAqL1xyXG5jbGFzcyBTY2FsZU92ZXJMaWZlIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IFNjYWxlT3ZlclRpbWUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihudW1iZXJ8YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2UpfSB2YWx1ZXMgQSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBvZiBzY2FsZSBwcm9wZXJ0eS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciguLi52YWx1ZXMpIHtcclxuICAgIHN1cGVyKGZhbHNlKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlfSBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gRmxvYXRTY2F0dGVyLmZyb21PYmplY3QoLi4udmFsdWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkge1xyXG4gICAgcGFydGljbGUuc2NhbGVYID0gcGFydGljbGUuc2NhbGVZID0gdGhpcy5zY2F0dGVyLmdldFZhbHVlQXQocGFydGljbGUuZW5lcmd5KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHBhcnRpY2xlJ3Mgcm90YXRpb24gdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyBlbmVyZ3kgdmFsdWUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIFJvdGF0aW9uT3ZlckxpZmUgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgUm90YXRpb25PdmVyTGlmZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZSl9IHZhbHVlcyBBIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIG9mIGFscGhhIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoZmFsc2UpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBGbG9hdFNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS5yID0gdGhpcy5zY2F0dGVyLmdldFZhbHVlQXQocGFydGljbGUuZW5lcmd5KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHBhcnRpY2xlJ3MgdGV4dHVyZSBhY2NvcmRpbmcgdG8gaXRzIGVuZXJneSB2YWx1ZS5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgVGV4dHVyZU92ZXJMaWZlIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IFRleHR1cmVPdmVyTGlmZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZSl9IHZhbHVlcyBBIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIG9mIHRleHR1cmVJbmRleCBwcm9wZXJ0eS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciguLi52YWx1ZXMpIHtcclxuICAgIHN1cGVyKGZhbHNlKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlfSBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gRmxvYXRTY2F0dGVyLmZyb21PYmplY3QoLi4udmFsdWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkge1xyXG4gICAgcGFydGljbGUudGV4dHVyZUluZGV4ID0gTWF0aC5yb3VuZCh0aGlzLnNjYXR0ZXIuZ2V0VmFsdWVBdChwYXJ0aWNsZS5lbmVyZ3kpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2VzIHBhcnRpY2xlIGFscGhhIGFjY29yZGluZyB0byBpdHMgbGlmZS5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgQW5jaG9yT3ZlckxpZmUgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQWNjZWxlcmF0aW9uIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi4obnVtYmVyfGJsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZSl9IHZhbHVlcyBBbiBWZWN0b3JTY2F0dGVyQmFzZSB3aGljaCBkZWZpbmVzIGFjY2VsZXJhdGlvbiBkaXJlY3Rpb24uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcihmYWxzZSk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yU2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBWZWN0b3JTY2F0dGVyLmZyb21PYmplY3QoLi4udmFsdWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkge1xyXG4gICAgdGhpcy5zY2F0dGVyLmdldFZhbHVlQXQocGFydGljbGUuZW5lcmd5KTtcclxuXHJcbiAgICBwYXJ0aWNsZS5hbmNob3JYID0gdGhpcy5zY2F0dGVyLnZhbHVlLng7XHJcbiAgICBwYXJ0aWNsZS5hbmNob3JZID0gdGhpcy5zY2F0dGVyLnZhbHVlLnk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUm90YXRlcyBwYXJ0aWNsZSBhbG9uZyB2ZWxvY2l0eSB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIE9yaWVudGVkIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIG9yaWVudGVkIG1vZGlmaWVyLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGFuZ2xlU2hpZnQgPSAwKSB7XHJcbiAgICBzdXBlcihmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFuZ2xlU2hpZnQgPSBhbmdsZVNoaWZ0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS5yID0gKE1hdGguYXRhbjIocGFydGljbGUudnksIHBhcnRpY2xlLnZ4KSAqIE1hdGhFeC5SQUQyREVHIC0gKDkwICsgdGhpcy5hbmdsZVNoaWZ0KSkgKiBkdDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIFZlY3RvckZpZWxkIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFZlY3RvckZpZWxkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtyZXNvbHV0aW9uPTAuMV1cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uID0gMC4xKSB7XHJcbiAgICBzdXBlcihmYWxzZSk7XHJcblxyXG4gICAgdGhpcy54ID0geDtcclxuICAgIHRoaXMueSA9IHk7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XHJcbiAgICB0aGlzLmZpZWxkID0gW107XHJcblxyXG4gICAgdGhpcy53aWR0aFNjYWxlZCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICB0aGlzLmhlaWdodFNjYWxlZCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xyXG5cclxuICAgIHRoaXMucmVzZXQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyB0aGlzIHZlY3RvciBmaWVsZCBkYXRhLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgcmVzZXQoKSB7ICAgIFxyXG4gICAgdGhpcy5maWVsZC5zcGxpY2UoMCwgdGhpcy5maWVsZC5sZW5ndGgpOyAvLyB3aHk/XHJcblxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodFNjYWxlZDsgeSsrKVxyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGhTY2FsZWQ7IHgrKylcclxuICAgICAgICB0aGlzLmZpZWxkLnB1c2gobmV3IFZlY3RvcigwLCAwKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGZpZWxkIGRhdGEgd2l0aCBhIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXREYXRhKGZuKSB7XHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0U2NhbGVkOyB5KyspIHtcclxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoU2NhbGVkOyB4KyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHggKyB5ICogdGhpcy53aWR0aFNjYWxlZDtcclxuICAgICAgICBmbih4LCB5LCB0aGlzLmZpZWxkW2luZGV4XSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdmFsdWUgYXQgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICAgKiBAcGFyYW0ge251bWJlcn0geVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+VmVjdG9yfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0VmVjdG9yQXQoeCwgeSkge1xyXG4gICAgeCA9IE1hdGguZmxvb3IoeCAqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICB5ID0gTWF0aC5mbG9vcih5ICogdGhpcy5yZXNvbHV0aW9uKTtcclxuICAgIGxldCBpeCA9IH5+KHggKyB5ICogdGhpcy53aWR0aFNjYWxlZCk7XHJcblxyXG4gICAgaWYgKGl4IDwgMCB8fCBpeCA+PSB0aGlzLmZpZWxkLmxlbmd0aClcclxuICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZmllbGRbaXhdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBsZXQgdiA9IHRoaXMuZ2V0VmVjdG9yQXQocGFydGljbGUueCwgcGFydGljbGUueSk7XHJcblxyXG4gICAgaWYgKHYgPT09IG51bGwpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBwYXJ0aWNsZS5heCA9IHYueDtcclxuICAgIHBhcnRpY2xlLmF5ID0gdi55O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgaW5pdGlhbCBwYXJ0aWNsZSBsaWZlIHZhbHVlLlxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlcy5tb2RpZmllcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1vZGlmaWVyXHJcbiAqL1xyXG5jbGFzcyBJbml0aWFsTGlmZSBleHRlbmRzIE1vZGlmaWVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBJbml0aWFsTGlmZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZSl9IHZhbHVlcyBNaW4gYW5kIG1heCB2YWx1ZXMgaW4gc2Vjb25kcy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvciguLi52YWx1ZXMpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIEB0eXBlIHtibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZX0gTW9kaWZpZXIncyBvYmplY3QgdG8gZ2V0IHZhbHVlcyBmcm9tLiAgKi9cclxuICAgIHRoaXMuc2NhdHRlciA9IEZsb2F0U2NhdHRlci5mcm9tT2JqZWN0KC4uLnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHVwZGF0ZShlbWl0dGVyLCBwYXJ0aWNsZSwgZHQpIHtcclxuICAgIHBhcnRpY2xlLmxpZmUgPSB0aGlzLnNjYXR0ZXIuZ2V0VmFsdWUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgbWFzcyB2YWx1ZS5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgSW5pdGlhbE1hc3MgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgSW5pdGlhbE1hc3MgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihudW1iZXJ8RmJsYWNrLWVuZ2luZX5sb2F0U2NhdHRlckJhc2UpfSB2YWx1ZXMgTWluIGFuZCBtYXggdmFsdWVzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlfSBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gRmxvYXRTY2F0dGVyLmZyb21PYmplY3QoLi4udmFsdWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkge1xyXG4gICAgcGFydGljbGUubWFzcyA9IHRoaXMuc2NhdHRlci5nZXRWYWx1ZSgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldHMgaW5pdGlhbCBwYXJ0aWNsZSBzY2FsZSB2YWx1ZS5cclxuICpcclxuICogQGNhdCBwYXJ0aWNsZXMubW9kaWZpZXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Nb2RpZmllclxyXG4gKi9cclxuY2xhc3MgSW5pdGlhbFNjYWxlIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEluaXRpYWxTY2FsZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+RmxvYXRTY2F0dGVyQmFzZSl9IHZhbHVlcyBNaW4gYW5kIG1heCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBGbG9hdFNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS5zY2FsZVggPSBwYXJ0aWNsZS5zY2FsZVkgPSB0aGlzLnNjYXR0ZXIuZ2V0VmFsdWUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgdmVsb2NpdHkgdmVjdG9yLlxyXG4gKlxyXG4gKiBAY2F0IHBhcnRpY2xlcy5tb2RpZmllcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfk1vZGlmaWVyXHJcbiAqL1xyXG5jbGFzcyBJbml0aWFsVmVsb2NpdHkgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgSW5pdGlhbFZlbG9jaXR5IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi4obnVtYmVyfGJsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZSl9IHZhbHVlcyBNaW4gYW5kIG1heCB2ZWN0b3JzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZX0gTW9kaWZpZXIncyBvYmplY3QgdG8gZ2V0IHZhbHVlcyBmcm9tLiAgKi9cclxuICAgIHRoaXMuc2NhdHRlciA9IFZlY3RvclNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICB0aGlzLnNjYXR0ZXIuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICBwYXJ0aWNsZS52eCA9IHRoaXMuc2NhdHRlci52YWx1ZS54O1xyXG4gICAgcGFydGljbGUudnkgPSB0aGlzLnNjYXR0ZXIudmFsdWUueTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIEluaXRpYWxQb3NpdGlvbiBleHRlbmRzIE1vZGlmaWVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBJbml0aWFsUG9zaXRpb24gaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihudW1iZXJ8YmxhY2stZW5naW5lflZlY3RvclNjYXR0ZXJCYXNlKX0gdmFsdWVzIFJlY3RhbmdsZSBjb29yZGluYXRlcywgaXRzIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3RvclNjYXR0ZXJCYXNlfSBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gVmVjdG9yU2NhdHRlci5mcm9tT2JqZWN0KC4uLnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHVwZGF0ZShlbWl0dGVyLCBwYXJ0aWNsZSwgZHQpIHtcclxuICAgIGxldCB2ID0gdGhpcy5zY2F0dGVyLmdldFZhbHVlKCk7XHJcbiAgICBwYXJ0aWNsZS54ID0gdi54O1xyXG4gICAgcGFydGljbGUueSA9IHYueTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgcm90YXRpb24gdmFsdWUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIEluaXRpYWxSb3RhdGlvbiBleHRlbmRzIE1vZGlmaWVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBJbml0aWFsUm90YXRpb24gaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihudW1iZXJ8YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2UpfSB2YWx1ZXMgTWluIGFuZCBtYXggdmFsdWVzIGluIHJhZGlhbnMuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBGbG9hdFNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS5yID0gdGhpcy5zY2F0dGVyLmdldFZhbHVlKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0cyBpbml0aWFsIHBhcnRpY2xlIHRleHR1cmUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIEluaXRpYWxUZXh0dXJlIGV4dGVuZHMgTW9kaWZpZXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IEluaXRpYWxUZXh0dXJlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi4obnVtYmVyfGJsYWNrLWVuZ2luZX5GbG9hdFNjYXR0ZXJCYXNlKX0gdmFsdWVzIE1pbiBhbmQgbWF4IGluZGV4ZXMgZnJvbSB0ZXh0dXJlIGxpc3QuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoLi4udmFsdWVzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBAdHlwZSB7YmxhY2stZW5naW5lfkZsb2F0U2NhdHRlckJhc2V9IE1vZGlmaWVyJ3Mgb2JqZWN0IHRvIGdldCB2YWx1ZXMgZnJvbS4gICovXHJcbiAgICB0aGlzLnNjYXR0ZXIgPSBGbG9hdFNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBwYXJ0aWNsZS50ZXh0dXJlSW5kZXggPSBNYXRoLnJvdW5kKHRoaXMuc2NhdHRlci5nZXRWYWx1ZSgpKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgY29sb3IgdmFsdWUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIEluaXRpYWxDb2xvciBleHRlbmRzIE1vZGlmaWVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBJbml0aWFsTGlmZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Li4uKG51bWJlcnxibGFjay1lbmdpbmV+Q29sb3JTY2F0dGVyQmFzZSl9IHZhbHVlcyBUd28gY29sb3IgdmFsdWVzLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5Db2xvclNjYXR0ZXJCYXNlfSBNb2RpZmllcidzIG9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uICAqL1xyXG4gICAgdGhpcy5zY2F0dGVyID0gQ29sb3JTY2F0dGVyLmZyb21PYmplY3QoLi4udmFsdWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdXBkYXRlKGVtaXR0ZXIsIHBhcnRpY2xlLCBkdCkge1xyXG4gICAgcGFydGljbGUuY29sb3IgPSB0aGlzLnNjYXR0ZXIuZ2V0VmFsdWUoKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGluaXRpYWwgcGFydGljbGUgc2NhbGUgdmFsdWUuXHJcbiAqXHJcbiAqIEBjYXQgcGFydGljbGVzLm1vZGlmaWVyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TW9kaWZpZXJcclxuICovXHJcbmNsYXNzIEluaXRpYWxBbmNob3IgZXh0ZW5kcyBNb2RpZmllciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgSW5pdGlhbFNjYWxlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi4obnVtYmVyfGJsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZSl9IHZhbHVlc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLnZhbHVlcykge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3JTY2F0dGVyQmFzZX0gTW9kaWZpZXIncyBvYmplY3QgdG8gZ2V0IHZhbHVlcyBmcm9tLiAgKi9cclxuICAgIHRoaXMuc2NhdHRlciA9IFZlY3RvclNjYXR0ZXIuZnJvbU9iamVjdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB1cGRhdGUoZW1pdHRlciwgcGFydGljbGUsIGR0KSB7XHJcbiAgICBsZXQgdiA9IHRoaXMuc2NhdHRlci5nZXRWYWx1ZSgpO1xyXG4gICAgcGFydGljbGUuYW5jaG9yWCA9IHYueDtcclxuICAgIHBhcnRpY2xlLmFuY2hvclkgPSB2Lnk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHJlYWRvbmx5XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqIEBjYXQgaW5wdXRcclxuICovXHJcbmNvbnN0IEtleSA9IHtcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEE6IDY1LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQjogNjYsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBDOiA2NyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEQ6IDY4LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRTogNjksXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBGOiA3MCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEc6IDcxLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgSDogNzIsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBJOiA3MyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEo6IDc0LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgSzogNzUsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBMOiA3NixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE06IDc3LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTjogNzgsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBPOiA3OSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFA6IDgwLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgUTogODEsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBSOiA4MixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFM6IDgzLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgVDogODQsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBVOiA4NSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFY6IDg2LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgVzogODcsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBYOiA4OCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFk6IDg5LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgWjogOTAsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBESUdJVF8wOiA0OCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIERJR0lUXzE6IDQ5LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRElHSVRfMjogNTAsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBESUdJVF8zOiA1MSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIERJR0lUXzQ6IDUyLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRElHSVRfNTogNTMsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBESUdJVF82OiA1NCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIERJR0lUXzc6IDU1LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRElHSVRfODogNTYsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBESUdJVF85OiA1NyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF8wOiA5NixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF8xOiA5NyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF8yOiA5OCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF8zOiA5OSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF80OiAxMDAsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBOVU1QQURfNTogMTAxLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTlVNUEFEXzY6IDEwMixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF83OiAxMDMsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBOVU1QQURfODogMTA0LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTlVNUEFEXzk6IDEwNSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTVBBRF9NVUxUSVBMWTogMTA2LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTlVNUEFEX0FERDogMTA3LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTlVNUEFEX1NVQlRSQUNUOiAxMDksXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBOVU1QQURfREVDSU1BTDogMTEwLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTlVNUEFEX0RJVklERTogMTExLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgTEVGVF9BUlJPVzogMzcsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBVUF9BUlJPVzogMzgsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBSSUdIVF9BUlJPVzogMzksXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBET1dOX0FSUk9XOiA0MCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEJBQ0tTUEFDRTogOCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFRBQjogOSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEVOVEVSOiAxMyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFNISUZUOiAxNixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIENUUkw6IDE3LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQUxUOiAxOCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEYxOiAxMTIsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBGMjogMTEzLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRjM6IDExNCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEY0OiAxMTUsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBGNTogMTE2LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRjY6IDExNyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEY3OiAxMTgsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBGODogMTE5LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRjk6IDEyMCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEYxMDogMTIxLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRjExOiAxMjIsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBGMTI6IDEyMyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFBBVVNFX0JSRUFLOiAxOSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIENBUFNfTE9DSzogMjAsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBFU0NBUEU6IDI3LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgUEFHRV9VUDogMzMsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBQQUdFX0RPV046IDM0LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRU5EOiAzNSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIEhPTUU6IDM2LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgSU5TRVJUOiA0NSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIERFTEVURTogNDYsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBMRUZUX1dJTkRPVzogOTEsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBSSUdIVF9XSU5ET1c6IDkyLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQ09OVEVYVF9NRU5VOiA5MyxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIE5VTV9MT0NLOiAxNDQsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBTQ1JPTExfTE9DSzogMTQ1LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgU0VNSV9DT0xPTjogMTg2LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRVFVQUxfU0lHTjogMTg3LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQ09NTUE6IDE4OCxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIERBU0g6IDE4OSxcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFBFUklPRDogMTkwLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgRk9SV0FSRF9TTEFTSDogMTkxLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQkFDS1FVT1RFOiAxOTIsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBCUkFLRVRfTEVGVDogMjE5LFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQkFDS19TTEFTSDogMjIwLFxyXG4gIC8qKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgQlJBS0VUX1JJR0hUOiAyMjEsXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBTSU5HTEVfUVVPVEU6IDIyMixcclxuICAvKipcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIFNQQUNFOiAzMlxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgc3RhdGljIGNsYXNzIHdpdGggbWFueSBzdGF0aWMgZWFzaW5nIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGNhdCBhbmltYXRpb25cclxuICogXHJcbiAqIEBzdGF0aWNcclxuICogQHN0YXRpY0NsYXNzXHJcbiAqL1xyXG5jbGFzcyBFYXNlIHtcclxuICAvKipcclxuICAgKiBsaW5lYXJcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGxpbmVhcihrKSB7XHJcbiAgICByZXR1cm4gaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1YWRyYXRpY0luXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIHF1YWRyYXRpY0luKGspIHtcclxuICAgIHJldHVybiBrICogaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1YWRyYXRpY091dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBxdWFkcmF0aWNPdXQoaykge1xyXG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcXVhZHJhdGljSW5PdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgcXVhZHJhdGljSW5PdXQoaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xyXG5cclxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGN1YmljSW5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY3ViaWNJbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY3ViaWNPdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY3ViaWNPdXQoaykge1xyXG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGN1YmljSW5PdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY3ViaWNJbk91dChrKSB7XHJcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxyXG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xyXG5cclxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcXVhcnRpY0luXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIHF1YXJ0aWNJbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrICogaztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1YXJ0aWNPdXRcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIHF1YXJ0aWNPdXQoaykge1xyXG4gICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1YXJ0aWNJbk91dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBxdWFydGljSW5PdXQoaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XHJcblxyXG4gICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1aW50aWNJblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBxdWludGljSW4oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrICogayAqIGsgKiBrO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogcXVpbnRpY091dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBxdWludGljT3V0KGspIHtcclxuICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHF1aW50aWNJbk91dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBxdWludGljSW5PdXQoaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xyXG5cclxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzaW51c29pZGFsSW5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgc2ludXNvaWRhbEluKGspIHtcclxuICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHNpbnVzb2lkYWxPdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgc2ludXNvaWRhbE91dChrKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHNpbnVzb2lkYWxJbk91dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBzaW51c29pZGFsSW5PdXQoaykge1xyXG4gICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGV4cG9uZW50aWFsSW5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZXhwb25lbnRpYWxJbihrKSB7XHJcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBleHBvbmVudGlhbE91dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBleHBvbmVudGlhbE91dChrKSB7XHJcbiAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBleHBvbmVudGlhbEluT3V0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGV4cG9uZW50aWFsSW5PdXQoaykge1xyXG4gICAgaWYgKGsgPT09IDApXHJcbiAgICAgIHJldHVybiAwO1xyXG5cclxuICAgIGlmIChrID09PSAxKVxyXG4gICAgICByZXR1cm4gMTtcclxuXHJcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxyXG4gICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xyXG5cclxuICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjaXJjdWxhckluXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGNpcmN1bGFySW4oaykge1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNpcmN1bGFyT3V0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGNpcmN1bGFyT3V0KGspIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBjaXJjdWxhckluT3V0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGNpcmN1bGFySW5PdXQoaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcclxuXHJcbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogZWxhc3RpY0luXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGVsYXN0aWNJbihrKSB7XHJcbiAgICBpZiAoayA9PT0gMClcclxuICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgaWYgKGsgPT09IDEpXHJcbiAgICAgIHJldHVybiAxO1xyXG5cclxuICAgIHJldHVybiAtTWF0aC5wb3coMiwgMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGVsYXN0aWNPdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZWxhc3RpY091dChrKSB7XHJcbiAgICBpZiAoayA9PT0gMClcclxuICAgICAgcmV0dXJuIDA7XHJcblxyXG4gICAgaWYgKGsgPT09IDEpXHJcbiAgICAgIHJldHVybiAxO1xyXG5cclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gMC4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBlbGFzdGljSW5PdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZWxhc3RpY0luT3V0KGspIHtcclxuICAgIGlmIChrID09PSAwKVxyXG4gICAgICByZXR1cm4gMDtcclxuXHJcbiAgICBpZiAoayA9PT0gMSlcclxuICAgICAgcmV0dXJuIDE7XHJcblxyXG4gICAgayAqPSAyO1xyXG5cclxuICAgIGlmIChrIDwgMSlcclxuICAgICAgcmV0dXJuIC0wLjUgKiBNYXRoLnBvdygyLCAxMCAqIChrIC0gMSkpICogTWF0aC5zaW4oKGsgLSAxLjEpICogNSAqIE1hdGguUEkpO1xyXG5cclxuICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYmFja0luXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGJhY2tJbihrKSB7XHJcbiAgICBjb25zdCBzID0gMS43MDE1ODtcclxuICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYmFja091dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBiYWNrT3V0KGspIHtcclxuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xyXG4gICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBiYWNrSW5PdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgYmFja0luT3V0KGspIHtcclxuICAgIGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XHJcblxyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcclxuXHJcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBib3VuY2VJblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBib3VuY2VJbihrKSB7XHJcbiAgICByZXR1cm4gMSAtIEVhc2UuYm91bmNlT3V0KDEgLSBrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGJvdW5jZU91dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGsgVmFsdWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBib3VuY2VPdXQoaykge1xyXG4gICAgaWYgKGsgPCAoMSAvIDIuNzUpKVxyXG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XHJcbiAgICBlbHNlIGlmIChrIDwgKDIgLyAyLjc1KSlcclxuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcclxuICAgIGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpXHJcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAoMi4yNSAvIDIuNzUpKSAqIGsgKyAwLjkzNzU7XHJcblxyXG4gICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGJvdW5jZUluT3V0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGJvdW5jZUluT3V0KGspIHtcclxuICAgIGlmIChrIDwgMC41KVxyXG4gICAgICByZXR1cm4gRWFzZS5ib3VuY2VJbihrICogMikgKiAwLjU7XHJcblxyXG4gICAgcmV0dXJuIEVhc2UuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBzbW9vdGhzdGVwXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gayBWYWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIHNtb290aGVyU3RlcChrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrICogKGsgKiAoNi4wICogayAtIDE1LjApICsgMTAuMCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJwb2xhdGlvbiBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBjYXQgYW5pbWF0aW9uXHJcbiAqIEBzdGF0aWNcclxuICovXHJcbmNsYXNzIEludGVycG9sYXRpb24ge1xyXG4gIC8qKlxyXG4gICAqIExpbmVhciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gIHYgVGhlIGlucHV0IGFycmF5IG9mIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBwZXJjZW50YWdlIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMS5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIpOm51bWJlcj19IGxlcnBGdW5jdGlvbiBJbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVcclxuICAgKi9cclxuICBzdGF0aWMgbGluZWFyKHYsIGssIGxlcnBGdW5jdGlvbikge1xyXG4gICAgbGV0IG0gPSB2Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgZiA9IG0gKiBrO1xyXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKGYpO1xyXG5cclxuICAgIGxlcnBGdW5jdGlvbiA9IGxlcnBGdW5jdGlvbiB8fCBNYXRoRXgubGVycDtcclxuXHJcbiAgICBpZiAoayA8IDApXHJcbiAgICAgIHJldHVybiBsZXJwRnVuY3Rpb24odlswXSwgdlsxXSwgZik7XHJcblxyXG4gICAgaWYgKGsgPiAxKVxyXG4gICAgICByZXR1cm4gbGVycEZ1bmN0aW9uKHZbbV0sIHZbbSAtIDFdLCBtIC0gZik7XHJcblxyXG4gICAgcmV0dXJuIGxlcnBGdW5jdGlvbih2W2ldLCB2W2kgKyAxID4gbSA/IG0gOiBpICsgMV0sIGYgLSBpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1YmljIGJlemllciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gIHYgVGhlIGlucHV0IGFycmF5IG9mIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBwZXJjZW50YWdlIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIGJlemllcih2LCBrKSB7XHJcbiAgICBsZXQgYiA9IDA7XHJcbiAgICBsZXQgbiA9IHYubGVuZ3RoO1xyXG4gICAgbGV0IHBvdyA9IE1hdGgucG93O1xyXG4gICAgLy8gQmVybnN0ZWluIGJhc2lzIHBvbHlub21pYWxzXHJcbiAgICBsZXQgYm4gPSAobiwgaSkgPT4ge1xyXG4gICAgICBsZXQgZmMgPSBJbnRlcnBvbGF0aW9uLl9fZmFjdG9yaWFsO1xyXG4gICAgICByZXR1cm4gZmMobikgLyBmYyhpKSAvIGZjKG4gLSBpKTtcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgIGIgKz0gcG93KDEgLSBrLCBuIC0gaSkgKiBwb3coaywgaSkgKiB2W2ldICogYm4obiwgaSk7XHJcblxyXG4gICAgcmV0dXJuIGI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gIHYgVGhlIGlucHV0IGFycmF5IG9mIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBrIFRoZSBwZXJjZW50YWdlIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMS5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICBUaGUgaW50ZXJwb2xhdGVkIHZhbHVlXHJcbiAgICovXHJcbiAgc3RhdGljIGNhdG11bGxSb20odiwgaykge1xyXG4gICAgbGV0IG0gPSB2Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgZiA9IG0gKiBrO1xyXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKGYpO1xyXG5cclxuICAgIGxldCBmbiA9IChwMCwgcDEsIHAyLCBwMywgdCkgPT4ge1xyXG4gICAgICBsZXQgdjAgPSAocDIgLSBwMCkgKiAwLjU7XHJcbiAgICAgIGxldCB2MSA9IChwMyAtIHAxKSAqIDAuNTtcclxuICAgICAgbGV0IHQyID0gdCAqIHQ7XHJcbiAgICAgIGxldCB0MyA9IHQgKiB0MjtcclxuXHJcbiAgICAgIHJldHVybiAoKHAxIC0gcDIpICogMiArIHYwICsgdjEpICogdDMgKyAoKHAyIC0gcDEpICogMyAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh2WzBdID09PSB2W21dKSB7XHJcbiAgICAgIGlmIChrIDwgMClcclxuICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xyXG5cclxuICAgICAgcmV0dXJuIGZuKHZbKGkgLSAxICsgbSkgJSBtXSwgdltpXSwgdlsoaSArIDEpICUgbV0sIHZbKGkgKyAyKSAlIG1dLCBmIC0gaSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoayA8IDApXHJcbiAgICAgICAgcmV0dXJuIHZbMF0gLSAoZm4odlswXSwgdlswXSwgdlsxXSwgdlsxXSwgLWYpIC0gdlswXSk7XHJcbiAgICAgIGVsc2UgaWYgKGsgPiAxKVxyXG4gICAgICAgIHJldHVybiB2W21dIC0gKGZuKHZbbV0sIHZbbV0sIHZbbSAtIDFdLCB2W20gLSAxXSwgZiAtIG0pIC0gdlttXSk7XHJcblxyXG4gICAgICByZXR1cm4gZm4odltpID8gaSAtIDEgOiAwXSwgdltpXSwgdlttIDwgaSArIDEgPyBtIDogaSArIDFdLCB2W20gPCBpICsgMiA/IG0gOiBpICsgMl0sIGYgLSBpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gblxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5JbnRlcnBvbGF0aW9uLl9fZmFjdG9yaWFsID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBhID0gWzFdO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24obikge1xyXG4gICAgaWYgKGFbbl0pXHJcbiAgICAgIHJldHVybiBhW25dO1xyXG5cclxuICAgIGxldCBzID0gbjtcclxuXHJcbiAgICB3aGlsZSAoLS1uKVxyXG4gICAgICBzICo9IG47XHJcblxyXG4gICAgYVtuXSA9IHM7XHJcbiAgICByZXR1cm4gcztcclxuICB9O1xyXG59KSgpO1xyXG5cclxudmFyIGRlZmF1bHRFYXNlID0gRWFzZS5zbW9vdGhlclN0ZXA7XHJcblxyXG4vKipcclxuICogQSB0d2VlbmluZyBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEBmaXJlcyBUd2VlbiNzdGFydFxyXG4gKiBAZmlyZXMgVHdlZW4jdXBkYXRlXHJcbiAqIEBmaXJlcyBUd2VlbiNsb29wXHJcbiAqIEBmaXJlcyBUd2VlbiNjb21wbGV0ZSBcclxuICogXHJcbiAqIEBjYXQgYW5pbWF0aW9uXHJcbiAqIEB1bnJlc3RyaWN0ZWRcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lfkNvbXBvbmVudFxyXG4gKi9cclxuY2xhc3MgVHdlZW4gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFR3ZWVuIENvbXBvbmVudC5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIHZhbHVlcyAgICAgICAgICAgIFRoZSB2YWx1ZXMgdG8gdHdlZW4uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICBbZHVyYXRpb249MC4yNV0gICBEdXJhY3Rpb24gaW4gc2Vjb25kcy5cclxuICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSAgIFtwcm9wZXJ0aWVzPW51bGxdIFR3ZWVuIHByb3BlcnRpZXMgT2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9ICAgW3BsdWdpbnM9bnVsbF0gICAgSW50ZXJwb2xhdGlvbiBwbHVnaW5zIG9iamVjdFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHZhbHVlcywgZHVyYXRpb24gPSAwLjI1MCwgcHJvcGVydGllcyA9IG51bGwsIHBsdWdpbnMgPSBudWxsKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQGRpY3QgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVZhbHVlcyA9IHZhbHVlcztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQGRpY3QgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQGRpY3QgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBsdWdpbnMgPSBwbHVnaW5zO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNQYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdGFydFRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBhdXNlZFRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQGRpY3QgXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVZhbHVlc1N0YXJ0ID0ge307XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRWxhcHNlZCA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24gKEFycmF5LCBudW1iZXIpOm51bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0aW9uLmxpbmVhcjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1EZWxheSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmVwZWF0RGVsYXkgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVJlcGVhdHMgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jbml0aWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZXZlcnNlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Zb3lvID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzWW95b0JhY2sgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUmV2ZXJzZU9uSW5pdCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1SZW1vdmVPbkNvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGxheU9uQWRkZWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRWFzZSA9IGRlZmF1bHRFYXNlO1xyXG5cclxuICAgIGlmICh0aGlzLm1Qcm9wZXJ0aWVzICE9PSBudWxsKSB7XHJcbiAgICAgIGZvciAobGV0IGYgaW4gdGhpcy5tUHJvcGVydGllcykge1xyXG4gICAgICAgIHRoaXNbZl0gPSAvKiogQGRpY3QgKi8gKHRoaXMubVByb3BlcnRpZXNbZl0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzL0dldHMgYWN0aXZlIGVhc2UgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn1cclxuICAgKi9cclxuICBnZXQgZWFzZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1FYXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn0gdmFsdWUgVGhlIGVhc2luZyBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBlYXNlKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1FYXNlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzL0dldHMgdGhlIGludGVycG9sYXRpb24gYWxnb3JpdGhtLiBQb3NzaWJsZSB2YWx1ZXMgSW50ZXJwb2xhdGlvbi5saW5lYXIsIEludGVycG9sYXRpb24uYmV6aWVyLCBJbnRlcnBvbGF0aW9uLmNhdG11bGxSb20gb3IgeW91ciBjdXN0b20gZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihBcnJheSwgbnVtYmVyKTpudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGludGVycG9sYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSW50ZXJwb2xhdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXksIG51bWJlcik6bnVtYmVyfSB2YWx1ZSBUaGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBpbnRlcnBvbGF0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1JbnRlcnBvbGF0aW9uID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaW1lIGVsYXBzZWQgc2luY2UgdHdlZW4gc3RhcnQgaW4gc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZWxhcHNlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1FbGFwc2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIGFtb3VudCBvZiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHR3ZWVuaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBkZWxheSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EZWxheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBTZWNvbmRzIHRvIHdhaXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZGVsYXkodmFsdWUpIHtcclxuICAgIHRoaXMubURlbGF5ID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgdHdlZW4gd2lsbCBiZSByZXBlYXRlZCBhZnRlciBmaXJzdCBleGVjdXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHJlcGVhdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUmVwZWF0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBOdW1iZXIgb2YgdGltZXMuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcmVwZWF0cyh2YWx1ZSkge1xyXG4gICAgdGhpcy5tUmVwZWF0cyA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIGFtb3VudCBvZiBzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiByZXBlYXRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCByZXBlYXREZWxheSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1SZXBlYXREZWxheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBTZWNvbmRzIHRvIHdhaXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcmVwZWF0RGVsYXkodmFsdWUpIHtcclxuICAgIHRoaXMubVJlcGVhdERlbGF5ID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgaWYgdHdlZW4gc2hvdWxkIGJlIGxvb3BlZCBvdmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgbG9vcCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1SZXBlYXRzID09PSBJbmZpbml0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBsb29wKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1SZXBlYXRzID0gdmFsdWUgPyBJbmZpbml0eSA6IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGVzL2Rpc2FibGVzIHJldmVyc2luZyBiZXR3ZWVuIHJlcGVhdHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCB5b3lvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVlveW87XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgeW95byh2YWx1ZSkge1xyXG4gICAgdGhpcy5tWW95byA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlcy9kaXNhYmxlcyByZXZlcnNlZCBwbGF5YmFjayBvbiBzdGFydC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHJldmVyc2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVJldmVyc2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHJldmVyc2VkKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1SZXZlcnNlZCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIHdoZXRoZXIgdGhlIFR3ZWVuIENvbXBvbmVudCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBkZXRhY2hlZCBmcm9tIG93bmVyIEdhbWVPYmplY3QgYWZ0ZXIgY29tcGxldGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHJlbW92ZU9uQ29tcGxldGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUmVtb3ZlT25Db21wbGV0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCByZW1vdmVPbkNvbXBsZXRlKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1SZW1vdmVPbkNvbXBsZXRlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzL0dldHMgd2hldGhlciB0aGUgdHdlZW4gc2hvdWxkIHN0YXJ0IHBsYXlpbmcgYXV0b21hdGljYWxseSB3aGVuIGFkZGVkIHRvIHRoZSByb290LlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHBsYXlPbkFkZGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBsYXlPbkFkZGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHBsYXlPbkFkZGVkKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1QbGF5T25BZGRlZCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIG9wdGlvbmFsIG9iamVjdCB3aXRoIGN1c3RvbSBpbnRlcnBvbGF0aW9uIGhhbmRsZXIgZnVuY3Rpb24gZm9yIHNwZWNpZmljIHRhcmdldCBwcm9wZXJ0aWVzLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXQgcGx1Z2lucygpIHtcclxuICAgIHJldHVybiB0aGlzLm1QbHVnaW5zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcGx1Z2lucyh2YWx1ZSkge1xyXG4gICAgdGhpcy5tUGx1Z2lucyA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGlzIHR3ZWVuIGR1cmF0aW9uLlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tRHVyYXRpb247XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZWQgd2hldGhlciB0aGUgdHdlZW4gaXMgcGxheWluZyBhbmQgbm90IHBhdXNlZC5cclxuICAgKiBcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc1BsYXlpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSXNQbGF5aW5nID09PSB0cnVlICYmIHRoaXMubUlzUGF1c2VkID09PSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fc3RhcnQodCkge1xyXG4gICAgdGhpcy5tSXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgIHRoaXMubVN0YXJ0VGltZSA9IHQgKyB0aGlzLm1EZWxheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyB0d2VlbmluZy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Ud2Vlbn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHBsYXkoKSB7XHJcbiAgICBpZiAoIXRoaXMubUlzUGF1c2VkKSB7XHJcbiAgICAgIHRoaXMuX19zdGFydChCbGFjay50aW1lLm5vdyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fcmVzdW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBjdXJyZW50IHR3ZWVuLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflR3ZWVufSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGlmICghdGhpcy5tSXNQbGF5aW5nKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB0aGlzLm1Jc1BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyBjdXJyZW50IHR3ZWVuLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflR3ZWVufSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLm1FbGFwc2VkID0gMDtcclxuICAgIGlmICh0aGlzLm1Jc1BsYXlpbmcpXHJcbiAgICAgIHRoaXMucGxheSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWVzIGZvciB0d2VlbmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgVmFsdWVzIHRvIHR3ZWVuLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MC4yNV0gRHVyYXRpb24gaW4gc2Vjb25kcy5cclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+VHdlZW59IFJldHVybnMgdGhpcy5cclxuICAgKi9cclxuICB0byh2YWx1ZXMgPSB7fSwgZHVyYXRpb24gPSAwLjI1MCkge1xyXG4gICAgdGhpcy5tVmFsdWVzID0gdmFsdWVzO1xyXG4gICAgdGhpcy5tRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIHRoaXMubUluaXRpYXRlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZXMgY3VycmVudCB0d2Vlbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Ud2Vlbn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgaWYgKCF0aGlzLm1Jc1BsYXlpbmcpXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHRoaXMubUlzUGF1c2VkID0gdHJ1ZTtcclxuICAgIHRoaXMubVBhdXNlZFRpbWUgPSBCbGFjay50aW1lLm5vdztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3Jlc3VtZSgpIHtcclxuICAgIGlmICghdGhpcy5tSXNQYXVzZWQpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1Jc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5tU3RhcnRUaW1lICs9IEJsYWNrLnRpbWUubm93IC0gdGhpcy5tUGF1c2VkVGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgcmVtb3ZlRnJvbVBhcmVudCgpIHtcclxuICAgIGlmICh0aGlzLm1Jc1BsYXlpbmcpXHJcbiAgICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgIHN1cGVyLnJlbW92ZUZyb21QYXJlbnQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBzcGVjaWZpZWQgdHdlZW4gb2JqZWN0IGludG8gdGhlIHF1ZXVlLiBUaGUgc3BlY2lmaWVkIHR3ZWVuIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgY29tcGxldGlvbiBvZiB0aGlzIHR3ZWVuLFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflR3ZWVufSBSZXR1cm5zIHR3ZWVuIHRvIGNoYWluLlxyXG4gICAqL1xyXG4gIGNoYWluKHR3ZWVuKSB7XHJcbiAgICBpZiAoIXR3ZWVuKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubVJlbW92ZU9uQ29tcGxldGUgPSBmYWxzZTtcclxuICAgIHR3ZWVuLnBsYXlPbkFkZGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5vbihNZXNzYWdlLkNPTVBMRVRFLCAoKSA9PiB7XHJcbiAgICAgIHR3ZWVuLnBsYXkoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0d2VlbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25BZGRlZChnYW1lT2JqZWN0KSB7XHJcbiAgICBpZiAodGhpcy5tUGxheU9uQWRkZWQpIHtcclxuICAgICAgdGhpcy5fX3N0YXJ0KEJsYWNrLnRpbWUubm93KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fdXBkYXRlKHQpIHtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHR3ZWVuIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgVGhlIE9iamVjdCB0byBnZXQgdmFsdWVzIGZyb20uXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQodmFsdWVzKSB7XHJcbiAgICB0aGlzLm1WYWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG4gICAgZm9yIChsZXQgZiBpbiB0aGlzLm1WYWx1ZXMpXHJcbiAgICAgIHRoaXMubVZhbHVlc1N0YXJ0W2ZdID0gcGFyc2VGbG9hdCh0aGlzLmdhbWVPYmplY3RbZl0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3dpdGNoZXMgZW5kIHZhbHVlcyB3aXRoIHN0YXJ0IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXNZb3lvIEluZGljYXRlcyB3ZXRoZXIgZWFzaW5nIGZ1bmN0aW9uIHNob3VsZCBiZSBhbHNvIHJldmVyc2VkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5Ud2Vlbn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHJldmVyc2UoYXNZb3lvID0gZmFsc2UpIHtcclxuICAgIGlmICh0aGlzLm1Jbml0aWF0ZWQpIHtcclxuICAgICAgdGhpcy5fX3JldmVyc2UoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubVJldmVyc2VPbkluaXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhc1lveW8pXHJcbiAgICAgIHRoaXMubUlzWW95b0JhY2sgPSAhdGhpcy5tSXNZb3lvQmFjaztcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3JldmVyc2UoKSB7XHJcbiAgICBmb3IgKGxldCBmIGluIHRoaXMubVZhbHVlcykge1xyXG4gICAgICBbdGhpcy5tVmFsdWVzW2ZdLCB0aGlzLm1WYWx1ZXNTdGFydFtmXV0gPSBbdGhpcy5tVmFsdWVzU3RhcnRbZl0sIHRoaXMubVZhbHVlc1tmXV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvblJlbmRlcigpIHtcclxuICAgIGlmIChCbGFjay5lbmdpbmUubnVtVXBkYXRlcyAhPT0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCB0aW1lID0gQmxhY2sudGltZS5ub3c7XHJcblxyXG4gICAgaWYgKHRpbWUgPCB0aGlzLm1TdGFydFRpbWUgfHwgdGhpcy5tSXNQbGF5aW5nID09PSBmYWxzZSB8fCB0aGlzLm1Jc1BhdXNlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0aGlzLm1TdGFydGVkID09PSBmYWxzZSB8fCB0aGlzLm1Jbml0aWF0ZWQgPT09IGZhbHNlKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgdGhpcy5tRWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5tU3RhcnRUaW1lKSAvIHRoaXMubUR1cmF0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLm1FbGFwc2VkID4gMSlcclxuICAgICAgdGhpcy5tRWxhcHNlZCA9IDE7XHJcblxyXG4gICAgbGV0IHQgPSB0aGlzLm1FYXNlKHRoaXMubUlzWW95b0JhY2sgPyAxIC0gdGhpcy5tRWxhcHNlZCA6IHRoaXMubUVsYXBzZWQpO1xyXG5cclxuICAgIGZvciAobGV0IGYgaW4gdGhpcy5tVmFsdWVzKSB7XHJcbiAgICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5tVmFsdWVzU3RhcnRbZl0pO1xyXG4gICAgICBsZXQgZW5kID0gLyoqIEB0eXBlIHtudW1iZXJ8QXJyYXl9ICovICh0aGlzLm1WYWx1ZXNbZl0pO1xyXG5cclxuICAgICAgaWYgKHRoaXMubVBsdWdpbnMgIT09IG51bGwgJiYgdGhpcy5tUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShmKSkge1xyXG4gICAgICAgIGxldCB0b0xlcnAgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmQgOiBbc3RhcnQsIGVuZF07XHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0W2ZdID0gSW50ZXJwb2xhdGlvbi5saW5lYXIodG9MZXJwLCB0LCB0aGlzLm1QbHVnaW5zW2ZdKTtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcclxuICAgICAgICB0aGlzLmdhbWVPYmplY3RbZl0gPSB0aGlzLm1JbnRlcnBvbGF0aW9uKGVuZCwgdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0W2ZdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzdGFydCArICgvKiogQHR5cGUge251bWJlcn0gKi8oZW5kKSAtIHN0YXJ0KSAqICh0aGlzLm1Jc1lveW9CYWNrID8gMSAtIHQgOiB0KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25VcGRhdGUoKSB7XHJcbiAgICBsZXQgdCA9IEJsYWNrLnRpbWUubm93O1xyXG5cclxuICAgIGlmICh0IDwgdGhpcy5tU3RhcnRUaW1lIHx8IHRoaXMubUlzUGxheWluZyA9PT0gZmFsc2UgfHwgdGhpcy5tSXNQYXVzZWQgPT09IHRydWUpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLl9fY29sbGVjdFN0YXJ0aW5nVmFsdWVzKCk7XHJcblxyXG4gICAgdGhpcy5tRWxhcHNlZCA9ICh0IC0gdGhpcy5tU3RhcnRUaW1lKSAvIHRoaXMubUR1cmF0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLm1FbGFwc2VkID4gMSlcclxuICAgICAgdGhpcy5tRWxhcHNlZCA9IDE7XHJcblxyXG4gICAgbGV0IHR0ID0gdGhpcy5tRWFzZSh0aGlzLm1Jc1lveW9CYWNrID8gMSAtIHRoaXMubUVsYXBzZWQgOiB0aGlzLm1FbGFwc2VkKTtcclxuXHJcbiAgICBmb3IgKGxldCBmIGluIHRoaXMubVZhbHVlcykge1xyXG4gICAgICBsZXQgc3RhcnQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMubVZhbHVlc1N0YXJ0W2ZdKTtcclxuICAgICAgbGV0IGVuZCA9IC8qKiBAdHlwZSB7bnVtYmVyfEFycmF5fSAqLyAodGhpcy5tVmFsdWVzW2ZdKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1QbHVnaW5zICE9PSBudWxsICYmIHRoaXMubVBsdWdpbnMuaGFzT3duUHJvcGVydHkoZikpIHtcclxuICAgICAgICBsZXQgdG9MZXJwID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kIDogW3N0YXJ0LCBlbmRdO1xyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdFtmXSA9IEludGVycG9sYXRpb24ubGluZWFyKHRvTGVycCwgdHQsIHRoaXMubVBsdWdpbnNbZl0pO1xyXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xyXG4gICAgICAgIHRoaXMuZ2FtZU9iamVjdFtmXSA9IHRoaXMubUludGVycG9sYXRpb24oZW5kLCB0dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5nYW1lT2JqZWN0W2ZdID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzdGFydCArICgvKiogQHR5cGUge251bWJlcn0gKi8oZW5kKSAtIHN0YXJ0KSAqICh0aGlzLm1Jc1lveW9CYWNrID8gMSAtIHR0IDogdHQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zdGVkIG9uIGV2ZXJ5IHR3ZWVuIHVwZGF0ZS4gXHJcbiAgICAgKiBOb3RlOiB0d2VlbiBjYW4gdXBkYXRlIG9iamVjdCB2YWx1ZXMgaW5zaWRlIGBvblJlbmRlcmAgbWV0aG9kIHdpdGhvdXQgcG9zdGluZyBgYmxhY2stZW5naW5lflR3ZWVuI3VwZGF0ZWAgbWVzc2FnZS5cclxuICAgICAqIEBldmVudCBUd2VlbiN1cGRhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3N0KE1lc3NhZ2UuVVBEQVRFLCB0aGlzLmdhbWVPYmplY3QpO1xyXG5cclxuICAgIGlmICh0aGlzLm1FbGFwc2VkID09PSAxKSB7XHJcbiAgICAgIGlmICh0aGlzLm1SZXBlYXRzLS0gPiAwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubVlveW8gPT09IHRydWUpIHtcclxuICAgICAgICAgIHRoaXMucmV2ZXJzZSh0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubVN0YXJ0VGltZSA9IHQgKyB0aGlzLm1SZXBlYXREZWxheTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9zdGVkIGV2ZXJ5dGltZSB0d2VlbiBpcyByZXBlYXRpbmcuXHJcbiAgICAgICAgICogQGV2ZW50IFR3ZWVuI2xvb3BcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvc3QoJ2xvb3AnLCB0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubUlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb3N0ZW4gd2hlbiB0d2VlbiBpcyBmaW5pc2hlZC5cclxuICAgICAgICAgKiBAZXZlbnQgVHdlZW4jY29tcGxldGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSwgdGhpcy5nYW1lT2JqZWN0KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubVJlbW92ZU9uQ29tcGxldGUpIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBmIGluIHRoaXMubVZhbHVlcykge1xyXG4gICAgICAgICAgICB0aGlzLm1WYWx1ZXNTdGFydFtmXSA9IHRoaXMubVZhbHVlc1tmXTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm1TdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX2NvbGxlY3RTdGFydGluZ1ZhbHVlcygpIHtcclxuICAgIGlmICh0aGlzLm1TdGFydGVkID09PSBmYWxzZSkge1xyXG4gICAgICB0aGlzLm1TdGFydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQb3N0ZWQgd2hlbiB0d2VlbiBzdGFydGVkLlxyXG4gICAgICAgKiBAZXZlbnQgVHdlZW4jc3RhcnRcclxuICAgICAgICovXHJcbiAgICAgIHRoaXMucG9zdCgnc3RhcnQnLCB0aGlzLmdhbWVPYmplY3QpO1xyXG5cclxuICAgICAgZm9yIChsZXQgZiBpbiB0aGlzLm1WYWx1ZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMubUluaXRpYXRlZCAmJiBBcnJheS5pc0FycmF5KHRoaXMubVZhbHVlc1tmXSkpIHtcclxuICAgICAgICAgIHRoaXMubVZhbHVlc1tmXSA9IFt0aGlzLmdhbWVPYmplY3RbZl1dLmNvbmNhdCh0aGlzLm1WYWx1ZXNbZl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1WYWx1ZXNTdGFydFtmXSA9IHBhcnNlRmxvYXQodGhpcy5nYW1lT2JqZWN0W2ZdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMubVJldmVyc2VkID09PSB0cnVlIHx8IHRoaXMubVJldmVyc2VPbkluaXQgPT09IHRydWUpXHJcbiAgICAgICAgdGhpcy5fX3JldmVyc2UoKTtcclxuXHJcbiAgICAgIHRoaXMubUluaXRpYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFYXNlIHRvIGJlIHVzZWQgaW4gYWxsIHR3ZWVucywgaWYgYW5vdGhlciBlYXNlIGlzIG5vdCBzcGVjaWZpZWQuIGBFYXNlLnNtb290aGVyU3RlcGAgaXMgdXNlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGRlZmF1bHRFYXNlKCkge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRFYXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOm51bWJlcn0gdmFsdWUgVGhlIGRlZmF5a3QgZWFzaW5nIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBzZXQgZGVmYXVsdEVhc2UodmFsdWUpIHtcclxuICAgIGRlZmF1bHRFYXNlID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogSG9sZHMgZGV0YWlscyBhYm91dCBzcHJpdGUgYW5pbWF0aW9uLlxyXG4gKlxyXG4gKiBAZmlyZXMgQW5pbWF0aW9uSW5mbyNjb21wbGV0ZVxyXG4gKiBAY2F0IGFuaW1hdGlvblxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uSW5mbyB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBbmltYXRpb24gY2xhc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkFuaW1hdGlvbkNvbnRyb2xsZXJ9ICAgIGNvbnRyb2xsZXIgIEFuaW1hdGlvbiBjb250cm9sbGVyXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBuYW1lICAgICAgICBUaGUgbmFtZSBvZiBhbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0FycmF5PGJsYWNrLWVuZ2luZX5UZXh0dXJlPn0gICAgICAgICBmcmFtZXMgICAgICBBcnJheSBvZiBUZXh0dXJlcyBmb3IgdGhpcyBhbmltYXRpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgIFtmcHM9MTRdICAgIEZyYW1lIHJhdGVcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgIFtsb29wPXRydWVdIElzIGFuaW1hdGlvbnMgc2hvdWxkIGJlIGxvb3BlZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRyb2xsZXIsIG5hbWUsIGZyYW1lcywgZnBzID0gMTQsIGxvb3AgPSB0cnVlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQoZnBzID4gMCwgJ0ZQUyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+QW5pbWF0aW9uQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTmFtZSA9IG5hbWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5UZXh0dXJlPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tRnJhbWVzID0gZnJhbWVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUN1cnJlbnRGcmFtZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTmV4dEZyYW1lQXQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUZQUyA9IGZwcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GcmFtZUR1cmF0aW9uID0gMSAvIHRoaXMubUZQUztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTG9vcCA9IGxvb3A7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUVsYXBzZWQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdG9wcGVkID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbXBsZXRlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheXMgYW5pbWF0aW9uLiBJZiBBbmltYXRpb24gaXMgY29tcGxldGVkLCBjdXJyZW50IGZyYW1lIGlzIHJlc2V0IHRvIDAuXHJcbiAgICogXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5UZXh0dXJlfSBSZXR1cm5zIHRoZSBjdXJyZW50IGZyYW1lIFRleHR1cmUuXHJcbiAgICovXHJcbiAgX19wbGF5KCkge1xyXG4gICAgaWYgKHRoaXMubUNvbXBsZXRlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLm1DdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICB0aGlzLm1FbGFwc2VkID0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1QYXVzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubVN0b3BwZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubUNvbXBsZXRlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMubU5leHRGcmFtZUF0ID0gQmxhY2sudGltZS5ub3cgKyB0aGlzLm1GcmFtZUR1cmF0aW9uIC0gdGhpcy5tRWxhcHNlZDtcclxuICAgIHRoaXMubUVsYXBzZWQgPSAwO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1GcmFtZXNbdGhpcy5tQ3VycmVudEZyYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIGFuaW1hdGlvbiBhbmQgcmVzZXRzIHRoZSB2YWx1ZSBvZiBjdXJyZW50IGZyYW1lLlxyXG4gICAqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19zdG9wKCkge1xyXG4gICAgdGhpcy5tU3RvcHBlZCA9IHRydWU7XHJcbiAgICB0aGlzLm1DdXJyZW50RnJhbWUgPSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fcGF1c2UoKSB7XHJcbiAgICB0aGlzLm1QYXVzZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5tRWxhcHNlZCA9IHRoaXMubU5leHRGcmFtZUF0IC0gQmxhY2sudGltZS5ub3c7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflRleHR1cmV8bnVsbH1cclxuICAgKi9cclxuICBfX3VwZGF0ZSgpIHtcclxuICAgIGxldCB0ID0gQmxhY2sudGltZS5ub3c7XHJcbiAgICBsZXQgZHQgPSBCbGFjay50aW1lLmR0O1xyXG4gICAgXHJcbiAgICBpZiAodCA8IHRoaXMubU5leHRGcmFtZUF0IHx8IHRoaXMubVBhdXNlZCA9PT0gdHJ1ZSB8fCB0aGlzLm1TdG9wcGVkID09PSB0cnVlIHx8IHRoaXMubUNvbXBsZXRlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdGhpcy5tQ3VycmVudEZyYW1lKys7XHJcblxyXG4gICAgaWYgKHRoaXMubUN1cnJlbnRGcmFtZSA+PSB0aGlzLm1GcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgIGlmICh0aGlzLm1Mb29wID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5tQ3VycmVudEZyYW1lID0gMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1DdXJyZW50RnJhbWUgPSB0aGlzLm1GcmFtZXMubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9zdCBtZXNzYWdlcyB3aGVuIGFuaW1hdGlvbiByZWFjaCBpdHMgZW5kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IEFuaW1hdGlvbkluZm8jY29tcGxldGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1Db250cm9sbGVyLnBvc3QoTWVzc2FnZS5DT01QTEVURSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5tQ29tcGxldGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubU5leHRGcmFtZUF0ID0gQmxhY2sudGltZS5ub3cgKyB0aGlzLm1GcmFtZUR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXMubUZyYW1lc1t0aGlzLm1DdXJyZW50RnJhbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldCBhbmltYXRpb24gc3BlZWQgaW4gZnJhbWVzIHBlciBzZWNvbmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGZwcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1GUFM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmcHModmFsdWUpIHtcclxuICAgIERlYnVnLmFzc2VydCh2YWx1ZSA+IDAsICdGUFMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcclxuXHJcbiAgICB0aGlzLm1GUFMgPSB2YWx1ZTtcclxuICAgIHRoaXMubUZyYW1lRHVyYXRpb24gPSAxIC8gdGhpcy5tRlBTO1xyXG5cclxuICAgIC8vIHVwZGF0ZSBuZXh0IGZyYW1lIHN0YXJ0IHRpbWVcclxuICAgIHRoaXMubU5leHRGcmFtZUF0ICs9IHRoaXMubU5leHRGcmFtZUF0IC0gQmxhY2sudGltZS5ub3c7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQvU2V0IGlmIGFuaW1hdGlvbiBzaG91bGQgYmUgbG9vcGVkLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGxvb3AoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tTG9vcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBsb29wKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1Mb29wID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFycmF5IG9mIFRleHR1cmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBcnJheTxibGFjay1lbmdpbmV+VGV4dHVyZT59XHJcbiAgICovXHJcbiAgZ2V0IGZyYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1GcmFtZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgQW5pbWF0aW9uIGlzIHBsYXlpbmcgKG5laXRoZXIgc3RvcHBlZCBub3IgcGF1c2VkKS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzUGxheWluZygpIHtcclxuICAgIHJldHVybiB0aGlzLm1QYXVzZWQgPT09IGZhbHNlICYmIHRoaXMubVN0b3BwZWQgPT09IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc0NvbXBsZXRlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUNvbXBsZXRlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbmFtZSBvZiB0aGlzIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgbmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1OYW1lO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgQ29tcG9uZW50IHdoaWNoIGFsbG93cyB0byBwbGF5IHNwcml0ZSBhbmltYXRpb25zLlxyXG4gKlxyXG4gKiBAY2F0IGFuaW1hdGlvblxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+Q29tcG9uZW50XHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25Db250cm9sbGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFuaW1hdGlvbkNvbnRyb2xsZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGJsYWNrLWVuZ2luZX5BbmltYXRpb25JbmZvPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQW5pbWF0aW9ucyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+QW5pbWF0aW9uSW5mb3xudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DdXJyZW50QW5pbSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBBbmltYXRpb25JbmZvIG9iamVjdCB0aGF0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+QW5pbWF0aW9uSW5mb30gQW5pbWF0aW9uIG9iamVjdCB0aGF0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgKi9cclxuICBnZXRCeU5hbWUobmFtZSkge1xyXG4gICAgRGVidWcuYXNzZXJ0KG5hbWUgIT09IG51bGwsICdBbmltYXRpb24gbXVzdCBiZSBzZXQgZmlyc3QuJyk7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodGhpcy5tQW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSwgJ0FuaW1hdGlvbiBtdXN0IGJlIHNldCBmaXJzdC4nKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tQW5pbWF0aW9uc1tuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgQW5pbWF0aW9uIG9iamVjdCB0aGF0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4gSWYgYW5pbWF0aW9uIGlzIHBsYXlpbmcgcmlnaHQgbm93IGl0IHdpbGwgYmUgc3RvcHBlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcmVtb3ZlLlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlbW92ZShuYW1lKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQobmFtZSAhPT0gbnVsbCwgJ0FuaW1hdGlvbiBuYW1lIHNoYWxsIG5vdCBiZSBudWxsLicpO1xyXG4gICAgRGVidWcuYXNzZXJ0KHRoaXMubUFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IHRydWUsICdVbmFibGUgdG8gZmluZCBhbmltYXRpb24uJyk7XHJcblxyXG4gICAgbGV0IGFuaW0gPSB0aGlzLm1BbmltYXRpb25zW25hbWVdO1xyXG5cclxuICAgIGlmICh0aGlzLm1DdXJyZW50QW5pbSAhPT0gbnVsbCAmJiB0aGlzLm1DdXJyZW50QW5pbSA9PT0gYW5pbSkge1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgZGVsZXRlIHRoaXMubUFuaW1hdGlvbnNbbmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tQ3VycmVudEFuaW0gPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIHRoZSBBbmltYXRpb24gb2JqZWN0IGludG8gdGhlIGxpc3Qgb2YgYW5pbWF0aW9ucy4gSWYgYW5pbWF0aW9uIHdpdGggZ2l2ZW4gbmFtZSBhbHJlYWR5IGV4aXN0cyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgbmFtZSAgICAgICAgVGhlIG5hbWUgb2YgYW5pbWF0aW9uIHRvIHVwZGF0ZVxyXG4gICAqIEBwYXJhbSB7QXJyYXk8YmxhY2stZW5naW5lflRleHR1cmU+fSAgdGV4dHVyZXMgICAgQXJyYXkgb2YgVGV4dHVyZXNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgW2Zwcz0xNF0gICAgRnJhbWVzIFBlciBTZWNvbmRcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW2xvb3A9dHJ1ZV0gSW5kaWNhdGVkIGlmIGFuaW1hdGlvbiBzaG91bGQgYmUgc3RhcnRlZCBvdmVyIGF0IHRoZSBlbmQuXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lfkFuaW1hdGlvbkluZm99IFRoZSBuZXdseSBjcmVhdGVkIEFuaW1hdGlvbiBPYmplY3QuXHJcbiAgICovXHJcbiAgYWRkKG5hbWUsIHRleHR1cmVzLCBmcHMgPSAxNCwgbG9vcCA9IHRydWUpIHtcclxuICAgIERlYnVnLmFzc2VydCh0ZXh0dXJlcy5sZW5ndGggPiAwLCAnQW5pbWF0aW9uIGNhbm5vdCBiZSBlbXB0eS4nKTtcclxuICAgIERlYnVnLmFzc2VydChmcHMgPiAwLCAnRlBTIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodGhpcy5tQW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA9PSBmYWxzZSwgJ0FuaW1hdGlvbiB3aXRoIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cycpO1xyXG5cclxuICAgIGxldCBhbmltID0gbmV3IEFuaW1hdGlvbkluZm8odGhpcywgbmFtZSwgdGV4dHVyZXMsIGZwcywgbG9vcCk7XHJcbiAgICB0aGlzLm1BbmltYXRpb25zW25hbWVdID0gYW5pbTtcclxuXHJcbiAgICByZXR1cm4gYW5pbTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBsYXlzIGFuaW1hdGlvbiB0aGF0IGV4aXN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIGFuaW1hdGlvbiB0byBwbGF5LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgcGxheShuYW1lKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodGhpcy5tQW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSwgJ0FuaW1hdGlvbiBtdXN0IGJlIHNldCBmaXJzdC4nKTtcclxuXHJcbiAgICB0aGlzLm1DdXJyZW50QW5pbSA9IHRoaXMubUFuaW1hdGlvbnNbbmFtZV07XHJcblxyXG4gICAgbGV0IHRleHR1cmUgPSB0aGlzLm1DdXJyZW50QW5pbS5fX3BsYXkoKTtcclxuXHJcbiAgICBsZXQgc3ByaXRlID0gLyoqIEB0eXBlIHtTcHJpdGV9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgaWYgKHNwcml0ZSA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGlmICh0ZXh0dXJlICE9PSBudWxsKVxyXG4gICAgICBzcHJpdGUudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBhY3RpdmUgYW5pbWF0aW9uLiBJZiBubyBhbmltYXRpb25zIGFyZSBwbGF5aW5nIGF0IHRoZSBtb21lbnQgbm90aGluZyB3aWxsIGhhcHBlbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGlmICh0aGlzLm1DdXJyZW50QW5pbSA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUN1cnJlbnRBbmltLl9fc3RvcCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIGFjdGl2ZSBhbmltYXRpb24uXHJcbiAgICogXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIGlmICh0aGlzLm1DdXJyZW50QW5pbSA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubUN1cnJlbnRBbmltLl9fcGF1c2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25SZW5kZXIoKSB7XHJcbiAgICBpZiAodGhpcy5tQ3VycmVudEFuaW0gPT09IG51bGwpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBsZXQgbmV3VGV4dHVyZSA9IHRoaXMubUN1cnJlbnRBbmltLl9fdXBkYXRlKCk7XHJcbiAgICBpZiAobmV3VGV4dHVyZSA9PT0gbnVsbClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBzcHJpdGUgPSAvKiogQHR5cGUge2JsYWNrLWVuZ2luZX5TcHJpdGV9ICovICh0aGlzLmdhbWVPYmplY3QpO1xyXG4gICAgc3ByaXRlLnRleHR1cmUgPSBuZXdUZXh0dXJlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGFjdGl2ZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lfkFuaW1hdGlvbkluZm98bnVsbH1cclxuICAgKi9cclxuICBnZXQgY3VycmVudEFuaW1hdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1DdXJyZW50QW5pbTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFRleHR1cmUobmFtZSwgdGV4dHVyZSkge1xyXG4gIGlmICghdGV4dHVyZSlcclxuICAgIHJldHVybiBudWxsO1xyXG5cclxuICBsZXQgcGFnZXMgPSB0aGlzLnBhZ2VzO1xyXG5cclxuICBsZXQgcGFnZSA9IG51bGw7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHBhZ2VzW2ldLmJhc2VUZXh0dXJlID09PSB0ZXh0dXJlLmJhc2VUZXh0dXJlKSB7XHJcbiAgICAgIHBhZ2UgPSBwYWdlc1tpXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAocGFnZSA9PT0gbnVsbCkge1xyXG4gICAgcGFnZSA9IG5ldyBzcGluZS5UZXh0dXJlQXRsYXNQYWdlKCk7XHJcbiAgICBwYWdlLm5hbWUgPSAndGV4dHVyZVBhZ2UnO1xyXG4gICAgcGFnZS5iYXNlVGV4dHVyZSA9IHRleHR1cmUubmF0aXZlO1xyXG4gICAgcGFnZXMucHVzaChwYWdlKTtcclxuICB9XHJcblxyXG4gIGxldCByZWdpb24gPSBuZXcgc3BpbmUuVGV4dHVyZUF0bGFzUmVnaW9uKCk7XHJcbiAgcmVnaW9uLm5hbWUgPSBuYW1lO1xyXG4gIHJlZ2lvbi5wYWdlID0gcGFnZTtcclxuICByZWdpb24udGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgcmVnaW9uLmluZGV4ID0gLTE7XHJcbiAgcmVnaW9uLndpZHRoID0gdGV4dHVyZS53aWR0aDtcclxuICByZWdpb24uaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQ7XHJcbiAgdGhpcy5yZWdpb25zLnB1c2gocmVnaW9uKTtcclxuICByZXR1cm4gcmVnaW9uO1xyXG59XHJcblxyXG4vKipcclxuICogRXNvdGVyaWMgU29mdHdhcmUgU1BJTkUgd3JhcHBlciBmb3IgQmxhY2sgRW5naW5lXHJcbiAqXHJcbiAqIEBjYXQgYW5pbWF0aW9uXHJcbiAqIEB1bnJlc3RyaWN0ZWRcclxuICogQG5vY29tcGlsZVxyXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XHJcbiAqL1xyXG5jbGFzcyBTcGluZSBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFNwaW5lLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWUsIHRleHR1cmVzUGF0aCA9ICcnKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIGxldCBqc29uID0gQmxhY2suYXNzZXRzLmdldEpTT04obmFtZSk7XHJcblxyXG4gICAgbGV0IGZha2VMb2FkZXIgPSBmdW5jdGlvbiAocGF0aCwgbG9hZGVyRnVuY3Rpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdGQUtFIExPQURFUicsIHBhdGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgc3BpbmVBdGxhcyA9IG5ldyBzcGluZS5UZXh0dXJlQXRsYXMoJycsIGZha2VMb2FkZXIpO1xyXG4gICAgc3BpbmVBdGxhcy5hZGRUZXh0dXJlID0gYWRkVGV4dHVyZTtcclxuXHJcbiAgICBsZXQgcmVnaW9ucyA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IHNraW5OYW1lIGluIGpzb24uc2tpbnMpIHtcclxuICAgICAgbGV0IHNraW4gPSBqc29uLnNraW5zW3NraW5OYW1lXTtcclxuXHJcbiAgICAgIGZvciAobGV0IHNsb3ROYW1lIGluIHNraW4pIHtcclxuICAgICAgICBsZXQgc2xvdCA9IHNraW5bc2xvdE5hbWVdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBlbnRyeU5hbWUgaW4gc2xvdCkge1xyXG4gICAgICAgICAgbGV0IGF0dGFjaG1lbnQgPSBzbG90W2VudHJ5TmFtZV07XHJcblxyXG4gICAgICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gJ3BvaW50JylcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gJ3BhdGgnKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gJ2NsaXBwaW5nJylcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgbGV0IHRleHR1cmVOYW1lID0gYXR0YWNobWVudC5wYXRoIHx8IGVudHJ5TmFtZTtcclxuXHJcbiAgICAgICAgICBpZiAoYXR0YWNobWVudC5uYW1lKVxyXG4gICAgICAgICAgICB0ZXh0dXJlTmFtZSA9IGF0dGFjaG1lbnQubmFtZTtcclxuXHJcbiAgICAgICAgICBpZiAocmVnaW9uc1t0ZXh0dXJlTmFtZV0pXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIHJlZ2lvbnNbdGV4dHVyZU5hbWVdID0gc3BpbmVBdGxhcy5hZGRUZXh0dXJlKHRleHR1cmVOYW1lLCBCbGFjay5hc3NldHMuZ2V0VGV4dHVyZSh0ZXh0dXJlc1BhdGggKyB0ZXh0dXJlTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBhdHRhY2htZW50UGFyc2VyID0gbmV3IHNwaW5lLkF0bGFzQXR0YWNobWVudExvYWRlcihzcGluZUF0bGFzKTtcclxuICAgIGxldCBzcGluZUpzb25QYXJzZXIgPSBuZXcgc3BpbmUuU2tlbGV0b25Kc29uKGF0dGFjaG1lbnRQYXJzZXIpO1xyXG4gICAgbGV0IHNrZWxldG9uRGF0YSA9IHNwaW5lSnNvblBhcnNlci5yZWFkU2tlbGV0b25EYXRhKGpzb24pO1xyXG5cclxuICAgIHRoaXMubVNrZWxldG9uID0gbmV3IHNwaW5lLlNrZWxldG9uKHNrZWxldG9uRGF0YSk7XHJcbiAgICB0aGlzLm1Ta2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG5cclxuICAgIHRoaXMubVN0YXRlRGF0YSA9IG5ldyBzcGluZS5BbmltYXRpb25TdGF0ZURhdGEoc2tlbGV0b25EYXRhKTtcclxuXHJcbiAgICB0aGlzLm1TdGF0ZSA9IG5ldyBzcGluZS5BbmltYXRpb25TdGF0ZSh0aGlzLm1TdGF0ZURhdGEpO1xyXG5cclxuICAgIHRoaXMubVRlbXBDbGlwQ29udGFpbmVycyA9IFtdO1xyXG4gICAgdGhpcy5tVGV4dHVyZXNQYXRoID0gdGV4dHVyZXNQYXRoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLm1Ta2VsZXRvbi5zbG90cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBsZXQgc2xvdCA9IHRoaXMubVNrZWxldG9uLnNsb3RzW2ldO1xyXG4gICAgICBsZXQgYXR0YWNobWVudCA9IHNsb3QuYXR0YWNobWVudDtcclxuXHJcbiAgICAgIGxldCBzbG90Q29udGFpbmVyID0gbmV3IERpc3BsYXlPYmplY3QoKTtcclxuICAgICAgc2xvdC5jb250YWluZXIgPSBzbG90Q29udGFpbmVyO1xyXG5cclxuICAgICAgdGhpcy5hZGRDaGlsZChzbG90Q29udGFpbmVyKTtcclxuICAgICAgdGhpcy5tVGVtcENsaXBDb250YWluZXJzLnB1c2gobnVsbCk7XHJcblxyXG4gICAgICBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQpIHtcclxuICAgICAgICBsZXQgc3ByaXRlTmFtZSA9IGF0dGFjaG1lbnQucmVnaW9uLm5hbWU7XHJcblxyXG4gICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLl9jcmVhdGVTcHJpdGUoc2xvdCwgYXR0YWNobWVudCwgc3ByaXRlTmFtZSk7XHJcbiAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc3ByaXRlO1xyXG4gICAgICAgIHNsb3QuY3VycmVudFNwcml0ZU5hbWUgPSBzcHJpdGVOYW1lO1xyXG4gICAgICAgIHNsb3RDb250YWluZXIuYWRkQ2hpbGQoc3ByaXRlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubVN0YXRlLmFkZExpc3RlbmVyKHsgY29tcGxldGU6IHggPT4gdGhpcy5wb3N0KCdhbmltYXRpb25Db21wbGV0ZScsIHguYW5pbWF0aW9uLm5hbWUpIH0pO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNrZWxldG9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVNrZWxldG9uO1xyXG4gIH1cclxuXHJcbiAgcGxheShuYW1lLCBsb29wID0gZmFsc2UpIHtcclxuICAgIHRoaXMubVN0YXRlLnNldEFuaW1hdGlvbigwLCBuYW1lLCBsb29wKTtcclxuICB9XHJcblxyXG4gIHNldE1peGluZyhmcm9tLCB0bywgZHVyKSB7XHJcbiAgICB0aGlzLm1TdGF0ZURhdGEuc2V0TWl4KGZyb20sIHRvLCBkdXIpO1xyXG4gIH1cclxuXHJcbiAgc2V0VHJhbnNpdGlvbihmcm9tLCB0bywgbG9vcCwgZHVyID0gMCwgdmlzZXZlcnNhRHVyID0gMCkge1xyXG4gICAgbGV0IGggPSAodCkgPT4ge1xyXG4gICAgICBpZiAodC5hbmltYXRpb24ubmFtZSA9PT0gZnJvbSlcclxuICAgICAgICB0aGlzLnBsYXkodG8sIGxvb3ApO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm1TdGF0ZS5hZGRMaXN0ZW5lcih7IGNvbXBsZXRlOiBoIH0pO1xyXG5cclxuICAgIGlmIChkdXIgPiAwKVxyXG4gICAgICB0aGlzLm1TdGF0ZURhdGEuc2V0TWl4KGZyb20sIHRvLCBkdXIpO1xyXG4gICAgaWYgKHZpc2V2ZXJzYUR1ciA+IDApXHJcbiAgICAgIHRoaXMubVN0YXRlRGF0YS5zZXRNaXgodG8sIGZyb20sIHZpc2V2ZXJzYUR1cik7XHJcbiAgfVxyXG5cclxuICBjaGFuZ2VTbG90QXR0YWNobWVudChzbG90TmFtZSwgYXR0YWNobWVudE5hbWUpIHtcclxuICAgIHRoaXMubVNrZWxldG9uLnNldEF0dGFjaG1lbnQoc2xvdE5hbWUsIGF0dGFjaG1lbnROYW1lKTtcclxuICB9XHJcblxyXG4gIG9uVXBkYXRlKCkge1xyXG4gICAgbGV0IGR0ID0gQmxhY2sudGltZS5kZWx0YTtcclxuICAgIHRoaXMubVN0YXRlLnVwZGF0ZShkdCk7XHJcbiAgICB0aGlzLm1TdGF0ZS5hcHBseSh0aGlzLm1Ta2VsZXRvbik7XHJcbiAgICB0aGlzLm1Ta2VsZXRvbi51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgbGV0IHNsb3RzID0gdGhpcy5tU2tlbGV0b24uc2xvdHM7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBzbG90cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgbGV0IHNsb3QgPSBzbG90c1tpXTtcclxuICAgICAgbGV0IGF0dGFjaG1lbnQgPSBzbG90LmF0dGFjaG1lbnQ7XHJcblxyXG4gICAgICBsZXQgc3ByaXRlID0gc2xvdC5jdXJyZW50U3ByaXRlO1xyXG4gICAgICBsZXQgd3JhcHBlciA9IHNsb3QuY29udGFpbmVyO1xyXG5cclxuICAgICAgaWYgKCFhdHRhY2htZW50KSB7XHJcbiAgICAgICAgd3JhcHBlci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdyYXBwZXIudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIHNwaW5lLlJlZ2lvbkF0dGFjaG1lbnQpIHtcclxuICAgICAgICBsZXQgcmVnaW9uID0gYXR0YWNobWVudC5yZWdpb247XHJcblxyXG4gICAgICAgIGlmIChyZWdpb24pIHtcclxuXHJcbiAgICAgICAgICBpZiAoIXNsb3QuY3VycmVudFNwcml0ZU5hbWUgfHwgc2xvdC5jdXJyZW50U3ByaXRlTmFtZSAhPT0gcmVnaW9uLm5hbWUpIHtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZU5hbWUgPSByZWdpb24ubmFtZTtcclxuICAgICAgICAgICAgaWYgKHNsb3QuY3VycmVudFNwcml0ZSkge1xyXG4gICAgICAgICAgICAgIHNsb3QuY3VycmVudFNwcml0ZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdC5zcHJpdGVzID0gc2xvdC5zcHJpdGVzIHx8IHt9O1xyXG4gICAgICAgICAgICBpZiAoc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBzbG90LnNwcml0ZXNbc3ByaXRlTmFtZV0udmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuX2NyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LCBzcHJpdGVOYW1lKTtcclxuICAgICAgICAgICAgICB3cmFwcGVyLmFkZENoaWxkKHNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdC5jdXJyZW50U3ByaXRlID0gc2xvdC5zcHJpdGVzW3Nwcml0ZU5hbWVdO1xyXG4gICAgICAgICAgICBzbG90LmN1cnJlbnRTcHJpdGVOYW1lID0gc3ByaXRlTmFtZTtcclxuICAgICAgICAgICAgc3ByaXRlID0gc2xvdC5jdXJyZW50U3ByaXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGJvbmUgPSBzbG90LmJvbmU7XHJcbiAgICAgICAgbGV0IHcgPSByZWdpb24ud2lkdGg7XHJcbiAgICAgICAgbGV0IGggPSByZWdpb24uaGVpZ2h0O1xyXG5cclxuICAgICAgICBsZXQgcmVnaW9uSGVpZ2h0ID0gcmVnaW9uLnJvdGF0ZSA/IHJlZ2lvbi53aWR0aCA6IHJlZ2lvbi5oZWlnaHQ7XHJcblxyXG4gICAgICAgIHNwcml0ZS5zY2FsZVggPSBhdHRhY2htZW50LnNjYWxlWCAqIChhdHRhY2htZW50LndpZHRoIC8gcmVnaW9uLndpZHRoKTtcclxuICAgICAgICBzcHJpdGUuc2NhbGVZID0gYXR0YWNobWVudC5zY2FsZVkgKiAoYXR0YWNobWVudC5oZWlnaHQgLyByZWdpb24uaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgbGV0IHJhZGlhbnMgPSAtYXR0YWNobWVudC5yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgc3ByaXRlLnJvdGF0aW9uID0gcmFkaWFucztcclxuXHJcbiAgICAgICAgbGV0IGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xyXG4gICAgICAgIGxldCBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcclxuICAgICAgICBsZXQgc2hpZnRYID0gLWF0dGFjaG1lbnQud2lkdGggLyAyICogYXR0YWNobWVudC5zY2FsZVg7XHJcbiAgICAgICAgbGV0IHNoaWZ0WSA9IC1hdHRhY2htZW50LmhlaWdodCAvIDIgKiBhdHRhY2htZW50LnNjYWxlWTtcclxuICAgICAgICBzcHJpdGUueCA9IGF0dGFjaG1lbnQueCArIHNoaWZ0WCAqIGNvcyAtIHNoaWZ0WSAqIHNpbjtcclxuICAgICAgICBzcHJpdGUueSA9IC1hdHRhY2htZW50LnkgKyBzaGlmdFggKiBzaW4gKyBzaGlmdFkgKiBjb3M7XHJcblxyXG4gICAgICAgIHdyYXBwZXIueCA9IGJvbmUud29ybGRYO1xyXG4gICAgICAgIHdyYXBwZXIueSA9IC1ib25lLndvcmxkWTtcclxuXHJcbiAgICAgICAgd3JhcHBlci5yb3RhdGlvbiA9IE1hdGguYXRhbjIoLWJvbmUuYywgYm9uZS5hKTtcclxuXHJcbiAgICAgICAgbGV0IGZsaXBYID0gMTtcclxuICAgICAgICBsZXQgZmxpcFkgPSAxO1xyXG5cclxuICAgICAgICBsZXQgd3N4ID0gTWF0aC5zcXJ0KGJvbmUuYSAqIGJvbmUuYSArIGJvbmUuYyAqIGJvbmUuYyk7XHJcbiAgICAgICAgbGV0IHdzeSA9IE1hdGguc3FydChib25lLmIgKiBib25lLmIgKyBib25lLmQgKiBib25lLmQpO1xyXG5cclxuICAgICAgICB3cmFwcGVyLnNjYWxlWCA9IHdzeCAqIGZsaXBYO1xyXG4gICAgICAgIHdyYXBwZXIuc2NhbGVZID0gd3N5ICogZmxpcFk7XHJcblxyXG4gICAgICAgIHdyYXBwZXIuYWxwaGEgPSB0aGlzLm1Ta2VsZXRvbi5jb2xvci5hICogc2xvdC5jb2xvci5hICogYXR0YWNobWVudC5jb2xvci5hO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2Ygc3BpbmUuUG9pbnRBdHRhY2htZW50KSB7XHJcbiAgICAgICAgd3JhcHBlci54ID0gc2xvdC5ib25lLndvcmxkWCArIGF0dGFjaG1lbnQueDtcclxuICAgICAgICB3cmFwcGVyLnkgPSAtc2xvdC5ib25lLndvcmxkWSAtIGF0dGFjaG1lbnQueTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZVNwcml0ZShzbG90LCBhdHRhY2htZW50LCBuYW1lKSB7XHJcbiAgICBsZXQgcmVnaW9uID0gYXR0YWNobWVudC5yZWdpb247XHJcbiAgICBcclxuICAgIGlmIChzbG90LnRlbXBBdHRhY2htZW50ID09PSBhdHRhY2htZW50KSB7XHJcbiAgICAgIHJlZ2lvbiA9IHNsb3QudGVtcFJlZ2lvbjtcclxuICAgICAgc2xvdC50ZW1wQXR0YWNobWVudCA9IG51bGw7XHJcbiAgICAgIHNsb3QudGVtcFJlZ2lvbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNwcml0ZSA9IG5ldyBTcHJpdGUodGhpcy5tVGV4dHVyZXNQYXRoICsgbmFtZSk7XHJcbiAgICBzcHJpdGUuYWxwaGEgPSBhdHRhY2htZW50LmNvbG9yLmE7XHJcbiAgICBzcHJpdGUucmVnaW9uID0gYXR0YWNobWVudC5yZWdpb247XHJcbiAgICB0aGlzLl9zZXRTcHJpdGVSZWdpb24oYXR0YWNobWVudCwgc3ByaXRlLCBhdHRhY2htZW50LnJlZ2lvbik7XHJcblxyXG4gICAgc2xvdC5zcHJpdGVzID0gc2xvdC5zcHJpdGVzIHx8IHt9O1xyXG4gICAgc2xvdC5zcHJpdGVzW25hbWVdID0gc3ByaXRlO1xyXG4gICAgcmV0dXJuIHNwcml0ZTtcclxuICB9XHJcblxyXG4gIF9zZXRTcHJpdGVSZWdpb24oYXR0YWNobWVudCwgc3ByaXRlLCByZWdpb24pIHtcclxuICAgIHNwcml0ZS5yZWdpb24gPSByZWdpb247XHJcbiAgICBpZiAoIXJlZ2lvbi5zaXplKSB7XHJcbiAgICAgIHNwcml0ZS5zY2FsZVggPSBhdHRhY2htZW50LnNjYWxlWCAqIGF0dGFjaG1lbnQud2lkdGggLyByZWdpb24ud2lkdGg7XHJcbiAgICAgIHNwcml0ZS5zY2FsZVkgPSAtYXR0YWNobWVudC5zY2FsZVkgKiBhdHRhY2htZW50LmhlaWdodCAvIHJlZ2lvbi5oZWlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvL2hhY2tlZCFcclxuICAgICAgc3ByaXRlLnNjYWxlWCA9IHJlZ2lvbi5zaXplLndpZHRoIC8gcmVnaW9uLndpZHRoO1xyXG4gICAgICBzcHJpdGUuc2NhbGVZID0gLXJlZ2lvbi5zaXplLmhlaWdodCAvIHJlZ2lvbi5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGlzdG9ydGlvbiBzb3VuZCBlZmZlY3QuXHJcbiAqIFxyXG4gKiBAY2F0IGF1ZGlvLmVmZmVjdHNcclxuICogQGV4dGVuZHMge2JsYWNrLWVuZ2luZX5Tb3VuZEVmZmVjdH1cclxuICovXHJcbmNsYXNzIERpc3RvcnRpb25FZmZlY3QgZXh0ZW5kcyBTb3VuZEVmZmVjdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIERpc3RvcnRpb25FZmZlY3RcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgTGV2ZWwgb2YgZGlzdG9ydGlvbi5cclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcih2YWx1ZSA9IDAuNSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVdhdmVTaGFwZXJOb2RlID0gQmxhY2suYXVkaW8uY29udGV4dC5jcmVhdGVXYXZlU2hhcGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnB1dE5vZGUgPSB0aGlzLm1XYXZlU2hhcGVyTm9kZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0F1ZGlvTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU91dHB1dE5vZGUgPSB0aGlzLm1XYXZlU2hhcGVyTm9kZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TYW1wbGVzID0gNDQxMDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7RmxvYXQzMkFycmF5fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ3VydmUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMubVNhbXBsZXMpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tVmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLmRpc3RvcnRpb24gPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZGlzdG9ydGlvbih2YWx1ZSkge1xyXG4gICAgdGhpcy5tVmFsdWUgPSBNYXRoRXguY2xhbXAodmFsdWUsIDAsIDEpO1xyXG4gICAgdGhpcy5fX21ha2VEaXN0b3J0aW9uQ3VydmUodGhpcy5tVmFsdWUsIHRoaXMubVNhbXBsZXMsIHRoaXMubUN1cnZlKTtcclxuICAgIHRoaXMubVdhdmVTaGFwZXJOb2RlLmN1cnZlID0gdGhpcy5tQ3VydmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgbGV2ZWwgb2YgZGlzdG9ydGlvblxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBkaXN0b3J0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyMzEzNDA4XHJcbiAgLyoqXHJcbiAgICogQGlnbm9yZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbl9zYW1wbGVzIFxyXG4gICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBjdXJ2ZSBcclxuICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fVxyXG4gICAqL1xyXG4gIF9fbWFrZURpc3RvcnRpb25DdXJ2ZShhbW91bnQsIG5fc2FtcGxlcywgY3VydmUpIHtcclxuICAgIGxldCBrID0gfn4oYW1vdW50ICogMTAwKTtcclxuICAgIGxldCBkZWcgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgbGV0IHggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuX3NhbXBsZXM7ICsraSkge1xyXG4gICAgICB4ID0gaSAqIDIgLyBuX3NhbXBsZXMgLSAxO1xyXG4gICAgICBjdXJ2ZVtpXSA9ICgzICsgaykgKiB4ICogMjAgKiBkZWcgLyAoTWF0aC5QSSArIGsgKiBNYXRoLmFicyh4KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VydmU7XHJcbiAgfTtcclxuXHJcbiAgLy8gdHVuYS5qc1xyXG5cclxuLy8gICBtYWtlRGlzdG9ydGlvbkN1cnZlMihhbW91bnQsIG5fc2FtcGxlcywgY3VydmUpIHtcclxuLy8gICAgIGFtb3VudCA9IE1hdGgubWluKGFtb3VudCwgMC45OTk5KTtcclxuLy8gICAgIGxldCBrID0gMiAqIGFtb3VudCAvICgxIC0gYW1vdW50KSxcclxuLy8gICAgICAgICBpLCB4O1xyXG4vLyAgICAgZm9yIChpID0gMDsgaSA8IG5fc2FtcGxlczsgaSsrKSB7XHJcbi8vICAgICAgICAgeCA9IGkgKiAyIC8gbl9zYW1wbGVzIC0gMTtcclxuLy8gICAgICAgICBjdXJ2ZVtpXSA9ICgxICsgaykgKiB4IC8gKDEgKyBrICogTWF0aC5hYnMoeCkpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuXHJcbi8vICAgbWFrZURpc3RvcnRpb25DdXJ2ZTMoYW1vdW50LCBuX3NhbXBsZXMsIGN1cnZlKSB7XHJcbi8vICAgICBsZXQgaSwgeCwgeTtcclxuLy8gICAgIGZvciAoaSA9IDA7IGkgPCBuX3NhbXBsZXM7IGkrKykge1xyXG4vLyAgICAgICAgIHggPSBpICogMiAvIG5fc2FtcGxlcyAtIDE7XHJcbi8vICAgICAgICAgeSA9ICgoMC41ICogTWF0aC5wb3coKHggKyAxLjQpLCAyKSkgLSAxKSAqIHkgPj0gMCA/IDUuOCA6IDEuMjtcclxuLy8gICAgICAgICBjdXJ2ZVtpXSA9IHRhbmgoeSk7XHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG5cclxuLy8gICBtYWtlRGlzdG9ydGlvbkN1cnZlNChhbW91bnQsIG5fc2FtcGxlcywgY3VydmUpIHtcclxuLy8gICAgIGxldCBpLCB4LCB5LCBhID0gMSAtIGFtb3VudDtcclxuLy8gICAgIGZvciAoaSA9IDA7IGkgPCBuX3NhbXBsZXM7IGkrKykge1xyXG4vLyAgICAgICAgIHggPSBpICogMiAvIG5fc2FtcGxlcyAtIDE7XHJcbi8vICAgICAgICAgeSA9IHggPCAwID8gLU1hdGgucG93KE1hdGguYWJzKHgpLCBhICsgMC4wNCkgOiBNYXRoLnBvdyh4LCBhKTtcclxuLy8gICAgICAgICBjdXJ2ZVtpXSA9IHRhbmgoeSAqIDIpO1xyXG4vLyAgICAgfVxyXG4vLyAgIH1cclxuXHJcbi8vICAgLy8gaXMgaXQgd29ya2luZz9cclxuLy8gICBtYWtlRGlzdG9ydGlvbkN1cnZlNShhbW91bnQsIG5fc2FtcGxlcywgY3VydmUpIHtcclxuLy8gICAgIGxldCBpLCB4LCB5LCBhYngsIGEgPSAxIC0gYW1vdW50ID4gMC45OSA/IDAuOTkgOiAxIC0gYW1vdW50O1xyXG4vLyAgICAgZm9yIChpID0gMDsgaSA8IG5fc2FtcGxlczsgaSsrKSB7XHJcbi8vICAgICAgICAgeCA9IGkgKiAyIC8gbl9zYW1wbGVzIC0gMTtcclxuLy8gICAgICAgICBhYnggPSBNYXRoLmFicyh4KTtcclxuLy8gICAgICAgICBpZiAoYWJ4IDwgYSkgeSA9IGFieDtcclxuLy8gICAgICAgICBlbHNlIGlmIChhYnggPiBhKSB5ID0gYSArIChhYnggLSBhKSAvICgxICsgTWF0aC5wb3coKGFieCAtIGEpIC8gKDEgLSBhKSwgMikpO1xyXG4vLyAgICAgICAgIGVsc2UgaWYgKGFieCA+IDEpIHkgPSBhYng7XHJcbi8vICAgICAgICAgY3VydmVbaV0gPSBzaWduKHgpICogeSAqICgxIC8gKChhICsgMSkgLyAyKSk7XHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG5cclxuLy8gICBtYWtlRGlzdG9ydGlvbkN1cnZlNihhbW91bnQsIG5fc2FtcGxlcywgY3VydmUpIHtcclxuLy8gICAgIGxldCBpLCB4O1xyXG4vLyAgICAgZm9yIChpID0gMDsgaSA8IG5fc2FtcGxlczsgaSsrKSB7XHJcbi8vICAgICAgICAgeCA9IGkgKiAyIC8gbl9zYW1wbGVzIC0gMTtcclxuLy8gICAgICAgICBpZiAoeCA8IC0wLjA4OTA1KSB7XHJcbi8vICAgICAgICAgICAgIGN1cnZlW2ldID0gKC0zIC8gNCkgKiAoMSAtIChNYXRoLnBvdygoMSAtIChNYXRoLmFicyh4KSAtIDAuMDMyODU3KSksIDEyKSkgKyAoMSAvIDMpICogKE1hdGguYWJzKHgpIC0gMC4wMzI4NDcpKSArIDAuMDE7XHJcbi8vICAgICAgICAgfSBlbHNlIGlmICh4ID49IC0wLjA4OTA1ICYmIHggPCAwLjMyMDAxOCkge1xyXG4vLyAgICAgICAgICAgICBjdXJ2ZVtpXSA9ICgtNi4xNTMgKiAoeCAqIHgpKSArIDMuOTM3NSAqIHg7XHJcbi8vICAgICAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgICAgICAgY3VydmVbaV0gPSAwLjYzMDAzNTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG5cclxuLy8gICAvLyBpcyBpdCB3b3JraW5nP1xyXG4vLyAgIG1ha2VEaXN0b3J0aW9uQ3VydmU3KGFtb3VudCwgbl9zYW1wbGVzLCBjdXJ2ZSkge1xyXG4vLyAgICAgbGV0IGEgPSAyICsgTWF0aC5yb3VuZChhbW91bnQgKiAxNCksXHJcbi8vICAgICBiaXRzID0gTWF0aC5yb3VuZChNYXRoLnBvdygyLCBhIC0gMSkpLFxyXG4vLyAgICAgaSwgeDtcclxuLy8gICAgIGZvciAoaSA9IDA7IGkgPCBuX3NhbXBsZXM7IGkrKykge1xyXG4vLyAgICAgICAgIHggPSBpICogMiAvIG5fc2FtcGxlcyAtIDE7XHJcbi8vICAgICAgICAgY3VydmVbaV0gPSBNYXRoLnJvdW5kKHggKiBiaXRzKSAvIGJpdHM7XHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG59XHJcblxyXG4vLyBmdW5jdGlvbiBzaWduKHgpIHtcclxuLy8gICBpZiAoeCA9PT0gMCkge1xyXG4vLyAgICAgICByZXR1cm4gMTtcclxuLy8gICB9IGVsc2Uge1xyXG4vLyAgICAgICByZXR1cm4gTWF0aC5hYnMoeCkgLyB4O1xyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuLy8gZnVuY3Rpb24gdGFuaChuKSB7XHJcbi8vICAgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpO1xyXG4vLyB9XHJcblxyXG4vKipcclxuICogRXF1YWxpemVyLlxyXG4gKiBcclxuICogQGNhdCBhdWRpby5lZmZlY3RzXHJcbiAqIEBleHRlbmRzIHtibGFjay1lbmdpbmV+U291bmRFZmZlY3R9XHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVFUSBleHRlbmRzIFNvdW5kRWZmZWN0IHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBlcXVhbGl6ZXIuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHsuLi5udW1iZXJ9IGZyZXF1ZW5jaWVzIExpc3Qgb2YgZnJlcXVlbmNpZXMgdG8gY29udHJvbCBzb3VuZCB3aXRoLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKC4uLmZyZXF1ZW5jaWVzKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgdmFsdWVzIGZyb20gd2luYW1wXHJcbiAgICBmcmVxdWVuY2llcyA9IGZyZXF1ZW5jaWVzIHx8IFs2MCwgMTcwLCAzMTAsIDYwMCwgMTAwMCwgMzAwMCwgNjAwMCwgMTIwMDAsIDE0MDAwLCAxNjAwMF07XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8QmlxdWFkRmlsdGVyTm9kZT59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1GaWx0ZXJzID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVxdWVuY2llcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0aGlzLm1GaWx0ZXJzLnB1c2godGhpcy5fX2NyZWF0ZUZpbHRlcihmcmVxdWVuY2llc1tpXSkpO1xyXG4gICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgdGhpcy5tRmlsdGVyc1tpIC0gMV0uY29ubmVjdCgvKiogQHR5cGUgeyFBdWRpb05vZGV9ICovICh0aGlzLm1GaWx0ZXJzW2ldKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnB1dE5vZGUgPSB0aGlzLm1GaWx0ZXJzWzBdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcm90ZWN0ZWQgXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9Ob2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tT3V0cHV0Tm9kZSA9IHRoaXMubUZpbHRlcnNbdGhpcy5tRmlsdGVycy5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAvLyB0b2RvOiBkZXRlcm1pbmUgY29ycmVjdCBtYXggdmFsdWVcclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU1heEdhaW5MZXZlbCA9IDE2OyAvLyAxOFxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheTxudW1iZXI+Pn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVByZXNldHMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpZ25vcmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcmVxIFxyXG4gICAqIEByZXR1cm5zIHtCaXF1YWRGaWx0ZXJOb2RlfVxyXG4gICAqL1xyXG4gIF9fY3JlYXRlRmlsdGVyKGZyZXEpIHtcclxuICAgIGxldCBmID0gQmxhY2suYXVkaW8uY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcclxuICAgIGYudHlwZSA9ICdwZWFraW5nJztcclxuICAgIGYuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKGZyZXEsIDApO1xyXG4gICAgZi5RLnNldFZhbHVlQXRUaW1lKDEsIDApO1xyXG4gICAgZi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xyXG4gICAgcmV0dXJuIGY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGxldmVsIGJ5IGluZGV4LlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJlcUluZGV4IEluZGV4IG9mIGZyZXF1ZW5jeSBmcm9tIHRoZSBsaXN0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAgICAgUmFuZ2luZyBmcm9tIC0xIHRvIDEuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0TGV2ZWxCeUluZGV4KGZyZXFJbmRleCwgdmFsdWUpIHtcclxuICAgIERlYnVnLmFzc2VydChmcmVxSW5kZXggPj0gMCAmJiBmcmVxSW5kZXggPCB0aGlzLm1GaWx0ZXJzLmxlbmd0aCwgJ0ZyZXF1ZW5jeSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UnKTtcclxuICAgIGlmIChmcmVxSW5kZXggPCAwIHx8IGZyZXFJbmRleCA+PSB0aGlzLm1GaWx0ZXJzLmxlbmd0aClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgdmFsdWUgPSBNYXRoRXguY2xhbXAodmFsdWUsIC0xLCAxKTtcclxuICAgIHZhbHVlICo9IHRoaXMubU1heEdhaW5MZXZlbDtcclxuICAgIHRoaXMubUZpbHRlcnNbZnJlcUluZGV4XS5nYWluLnNldFZhbHVlQXRUaW1lKHZhbHVlLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbGV2ZWwgYnkgZnJlcXVlbmN5IGlmIHRoZXJlIGlzIG9uZSBpbiB0aGUgbGlzdC5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyZXEgIENvbmNyZXRlIGZyZXF1ZW5jeSB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgUmFuZ2luZyBmcm9tIC0xIHRvIDEuXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0TGV2ZWxCeUZyZXF1ZW5jeShmcmVxLCB2YWx1ZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1GaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0aGlzLm1GaWx0ZXJzW2ldLmZyZXF1ZW5jeS52YWx1ZSA9PT0gZnJlcSkge1xyXG4gICAgICAgIHRoaXMuc2V0TGV2ZWxCeUluZGV4KGksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBuZXcgcHJlc2V0IG9mIGxldmVscy5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICBUaGUgbmFtZSBvZiBhIHByZXNldC5cclxuICAgKiBAcGFyYW0gey4uLm51bWJlcn0gdmFsdWVzIEZyZXF1ZW5jeSBsZXZlbHMuIFRoZWlyIG51bWJlciBtdXN0IGJlIGVxdWFsIHRvIGZyZXF1ZW5jaWVzIG51bWJlci5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBhZGRQcmVzZXQobmFtZSwgLi4udmFsdWVzKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodmFsdWVzLmxlbmd0aCAhPSB0aGlzLm1GaWx0ZXJzLmxlbmd0aCwgJ051bWJlciBvZiBwcmVzZXQgdmFsdWVzIG11c3QgYmUgZXF1YWwgdG8gZnJlcXVlbmNpZXMgbnVtYmVyJyk7XHJcbiAgICB0aGlzLm1QcmVzZXRzW25hbWVdID0gdmFsdWVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZXMgY3VycmVudCBsZXZlbHMgYXMgbmV3IHByZXNldCB3aXRoIGdpdmVuIG5hbWUuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIGEgcHJlc2V0LlxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNhdmVQcmVzZXQobmFtZSkge1xyXG4gICAgdGhpcy5tUHJlc2V0c1tuYW1lXSA9IFtdO1xyXG4gICAgdGhpcy5tRmlsdGVycy5mb3JFYWNoKHggPT4gdGhpcy5tUHJlc2V0c1tuYW1lXS5wdXNoKHguZnJlcXVlbmN5LnZhbHVlIC8gdGhpcy5tTWF4R2FpbkxldmVsKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIHByZXZpb3VzbHkgYWRkZWQgb3Igc2F2ZWQgcHJlc2V0LlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBhIHByZXNldC5cclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBhcHBseVByZXNldChuYW1lKSB7XHJcbiAgICBpZiAodGhpcy5tUHJlc2V0c1tuYW1lXSAhPT0gbnVsbCkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubVByZXNldHNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLnNldExldmVsQnlJbmRleChpLCB0aGlzLm1QcmVzZXRzW25hbWVdW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldmVyYmVyYXRpb24gc291bmQgZWZmZWN0LlxyXG4gKiBcclxuICogQGNhdCBhdWRpby5lZmZlY3RzXHJcbiAqIEBleHRlbmRzIHtibGFjay1lbmdpbmV+U291bmRFZmZlY3R9XHJcbiAqL1xyXG5jbGFzcyBSZXZlcmJFZmZlY3QgZXh0ZW5kcyBTb3VuZEVmZmVjdCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBSZXZlcmJFZmZlY3QuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gSVJCdWZmZXIgSW1wdWxzZSBSZXNwb25zZSBhdWRpbyBidWZmZXIuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoSVJCdWZmZXIpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByb3RlY3RlZCBcclxuICAgICAqIEB0eXBlIHtBdWRpb05vZGV9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnB1dE5vZGUgPSBCbGFjay5hdWRpby5fbmV3R2Fpbk5vZGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJvdGVjdGVkIFxyXG4gICAgICogQHR5cGUge0F1ZGlvTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubU91dHB1dE5vZGUgPSBCbGFjay5hdWRpby5fbmV3R2Fpbk5vZGUoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtDb252b2x2ZXJOb2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udm9sdmVyID0gQmxhY2suYXVkaW8uY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtHYWluTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubURyeSA9IEJsYWNrLmF1ZGlvLl9uZXdHYWluTm9kZSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0dhaW5Ob2RlfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tV2V0ID0gQmxhY2suYXVkaW8uX25ld0dhaW5Ob2RlKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QmlxdWFkRmlsdGVyTm9kZX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRvbmUgPSBCbGFjay5hdWRpby5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xyXG5cclxuICAgIHRoaXMubUNvbnZvbHZlci5idWZmZXIgPSBJUkJ1ZmZlcjtcclxuXHJcbiAgICB0aGlzLm1JbnB1dE5vZGUuY29ubmVjdCh0aGlzLm1EcnkpO1xyXG4gICAgdGhpcy5tRHJ5LmNvbm5lY3QodGhpcy5tT3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgdGhpcy5tSW5wdXROb2RlLmNvbm5lY3QodGhpcy5tVG9uZSk7XHJcbiAgICB0aGlzLm1Ub25lLmNvbm5lY3QodGhpcy5tQ29udm9sdmVyKTtcclxuICAgIHRoaXMubUNvbnZvbHZlci5jb25uZWN0KHRoaXMubVdldCk7XHJcbiAgICB0aGlzLm1XZXQuY29ubmVjdCh0aGlzLm1PdXRwdXROb2RlKTtcclxuXHJcbiAgICB0aGlzLm1EcnkuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCAwKTtcclxuICAgIHRoaXMubVdldC5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xyXG4gICAgdGhpcy5tVG9uZS50eXBlID0gJ2xvd3Bhc3MnO1xyXG4gICAgdGhpcy5tVG9uZS5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUoMzUwLCAwKTtcclxuICAgIHRoaXMubVRvbmUuUS5zZXRWYWx1ZUF0VGltZShNYXRoLlNRUlQxXzIsIDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB3ZXQodmFsdWUpIHtcclxuICAgIHZhbHVlID0gTWF0aEV4LmNsYW1wKHZhbHVlLCAwLCAxKTtcclxuICAgIHRoaXMubVdldC5nYWluLnNldFZhbHVlQXRUaW1lKHZhbHVlLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgZHJ5KHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IE1hdGhFeC5jbGFtcCh2YWx1ZSwgMCwgMSk7XHJcbiAgICB0aGlzLm1EcnkuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHRvbmUodmFsdWUpIHtcclxuICAgIHZhbHVlID0gTWF0aEV4LmNsYW1wKHZhbHVlLCAxMCwgQmxhY2suYXVkaW8uY29udGV4dC5zYW1wbGVSYXRlIC8gMik7XHJcbiAgICB0aGlzLm1Ub25lLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgbGV2ZWwgb2YgY29udm9sdmVkIHNvdW5kLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB3ZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tV2V0LmdhaW4udmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgbGV2ZWwgb2Ygb3JpZ2luYWwgc291bmQgd2l0aCBubyBlZmZlY3QuXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGRyeSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1EcnkuZ2Fpbi52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyBmcmVxdWVuY3kgZWZmZWN0IGlzIGFwcGxpZWQgb24uXHJcbiAgICogXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHRvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVG9uZS5mcmVxdWVuY3kudmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHNvdW5kIGNvbXBvbmVudC5cclxuICogXHJcbiAqIEBjYXQgYXVkaW9cclxuICogQGV4dGVuZHMge2JsYWNrLWVuZ2luZX5Db21wb25lbnR9XHJcbiAqL1xyXG5jbGFzcyBTb3VuZCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgU291bmRDb21wb25lbnQuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgICAgICAgICAgICAgIFRoZSBuYW1lIG9mIHNvdW5kLiBVc2VzIEJsYWNrLmFzc2V0cyBvbmx5LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gW2NoYW5uZWw9J21hc3RlciddICAgICBUaGUgbmFtZSBvZiBjaGFubmVsLCB0byBwbGF5IHNvdW5kIG9uLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtzcGF0aWFsRWZmZWN0PWZhbHNlXSBTcGVjaWZpZXMgaWYgc3BhdGlhbCBlZmZlY3QgaXMgZW5hYmxlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IFtyb2xsb2ZmPTEwMF0gICAgICAgICAgRGV0ZXJtaW5lcyBob3cgZmFyIGZyb20gdGhlIGxpc3RlbmVyIHRoZSB2b2x1bWUgcmVkdWNlcy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihuYW1lLCBjaGFubmVsID0gJ21hc3RlcicsIHNwYXRpYWxFZmZlY3QgPSBmYWxzZSwgcm9sbG9mZiA9IDEwMCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+U291bmRDbGlwfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU291bmRDbGlwID0gQmxhY2suYXNzZXRzLmdldFNvdW5kKG5hbWUpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVJvbGxvZmYgPSByb2xsb2ZmO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QbGF5T25BZGRlZCA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0b3BPblJlbW92ZSA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Tb3VuZEluc3RhbmNlID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+TWVzc2FnZUJpbmRpbmd8bnVsbH0gIFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db21wbGV0ZUJpbmRpbmcgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TcGF0aWFsRWZmZWN0ID0gc3BhdGlhbEVmZmVjdDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1DaGFubmVsTmFtZSA9IGNoYW5uZWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgcGxheWluZyBzb3VuZC5cclxuICAgKiBcclxuICAgKiBAcHVibGljXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbdm9sdW1lPTFdICAgICAgICAgVGhlIHZvbHVtZSBsZXZlbC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbbG9vcD1mYWxzZV0gICAgICBTcGVjaWZpZXMgaWYgc291bmQgcmVwZWF0cyBpbmZpbml0ZSB0aW1lcy5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbb3ZlcndyaXRlPWZhbHNlXSBJZiB0cnVlLCBzdG9wcyBwcmV2aW91c2x5IHN0YXJ0ZWQgc291bmQsIGlmIHRoZXJlIGlzIG9uZS5cclxuICAgKiBAcmV0dXJucyB7YmxhY2stZW5naW5lflNvdW5kSW5zdGFuY2V9ICAgICAgICAgICAgTmV3bHkgY3JlYXRlZCBzb3VuZCBpbnN0YW5jZSBvciBhbHJlYWR5IHBsYXlpbmcgc291bmQuXHJcbiAgICovXHJcbiAgcGxheSh2b2x1bWUgPSAxLCBsb29wID0gZmFsc2UsIG92ZXJ3cml0ZSA9IGZhbHNlKSB7XHJcbiAgICBvdmVyd3JpdGUgJiYgdGhpcy5tU291bmRJbnN0YW5jZSAmJiB0aGlzLnN0b3AoKTtcclxuICAgIGlmICghdGhpcy5tU291bmRJbnN0YW5jZSB8fCBvdmVyd3JpdGUpIHtcclxuICAgICAgdGhpcy5tU291bmRJbnN0YW5jZSA9IHRoaXMubVNvdW5kQ2xpcC5wbGF5KHRoaXMubUNoYW5uZWxOYW1lLCB2b2x1bWUsIGxvb3ApO1xyXG4gICAgICB0aGlzLm1Db21wbGV0ZUJpbmRpbmcgPSB0aGlzLm1Tb3VuZEluc3RhbmNlLm9uKE1lc3NhZ2UuQ09NUExFVEUsIHRoaXMuX19vblNvdW5kQ29tcGxldGUsIHRoaXMpO1xyXG4gICAgICB0aGlzLnNwYXRpYWxFZmZlY3QgPSB0aGlzLm1TcGF0aWFsRWZmZWN0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubVNvdW5kSW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBjdXJyZW50IHNvdW5kIGluc3RhbmNlIGlmIHRoZXJlIGlzIHBsYXlpbmcgb25lLlxyXG4gICAqIFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgaWYgKHRoaXMubVNvdW5kSW5zdGFuY2UpIHtcclxuICAgICAgdGhpcy5tQ29tcGxldGVCaW5kaW5nLm9mZigpO1xyXG4gICAgICB0aGlzLm1Tb3VuZEluc3RhbmNlLnN0b3AoKTtcclxuICAgICAgdGhpcy5tU291bmRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX29uU291bmRDb21wbGV0ZSgpIHtcclxuICAgIHRoaXMubVNvdW5kSW5zdGFuY2UgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkFkZGVkKGdhbWVPYmplY3QpIHtcclxuICAgIGlmICh0aGlzLm1QbGF5T25BZGRlZCkge1xyXG4gICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25SZW1vdmVkKGdhbWVPYmplY3QpIHtcclxuICAgIGlmICh0aGlzLm1TdG9wT25SZW1vdmUgJiYgdGhpcy5tU291bmRJbnN0YW5jZSkge1xyXG4gICAgICB0aGlzLm1Tb3VuZEluc3RhbmNlLnN0b3AoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25VcGRhdGUoKSB7XHJcbiAgICBpZiAodGhpcy5tU3BhdGlhbEVmZmVjdCAmJiB0aGlzLm1Tb3VuZEluc3RhbmNlICE9IG51bGwgJiYgdGhpcy5tU291bmRJbnN0YW5jZS5pc1BsYXlpbmcgPT09IHRydWUpIHtcclxuICAgICAgY29uc3Qgc3RhZ2UgPSBCbGFjay5zdGFnZTtcclxuICAgICAgY29uc3QgcG9zID0gdGhpcy5nYW1lT2JqZWN0LmxvY2FsVG9HbG9iYWwoc3RhZ2UuZ2xvYmFsVG9Mb2NhbChuZXcgVmVjdG9yKHRoaXMuZ2FtZU9iamVjdC5waXZvdFgsIHRoaXMuZ2FtZU9iamVjdC5waXZvdFkpKSk7XHJcbiAgICAgIGNvbnN0IHB4ID0gKHBvcy54IC0gc3RhZ2UuY2VudGVyWCkgLyBzdGFnZS53aWR0aCAqIDI7XHJcbiAgICAgIGNvbnN0IHB5ID0gKHBvcy55IC0gc3RhZ2UuY2VudGVyWSkgLyBzdGFnZS5oZWlnaHQgKiAyO1xyXG5cclxuICAgICAgdGhpcy5tU291bmRJbnN0YW5jZS5tU3BhdGlhbFBhbm5lci5zZXRQb3NpdGlvbihweCwgcHksIDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcblxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBwbGF5T25BZGRlZCh2YWx1ZSkge1xyXG4gICAgdGhpcy5tUGxheU9uQWRkZWQgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB3aGV0aGVyIHRoZSBzb3VuZCBzaG91bGQgc3RhcnQgcGxheWluZyB3aGVuIGFkZGVkIHRvIHN0YWdlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXHJcbiAgICogXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgcGxheU9uQWRkZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUGxheU9uQWRkZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc3RvcE9uUmVtb3ZlKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1TdG9wT25SZW1vdmUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMvR2V0cyB3aGV0aGVyIHRoZSBzb3VuZCBzaG91bGQgYmUgc3RvcHBlZCBpZiB0aGUgb3duZXIgR2FtZU9iamVjdCBpcyBiZWluZyByZW1vdmVkIGZvcm0gdGhlIHN0YWdlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBzdG9wT25SZW1vdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU3RvcE9uUmVtb3ZlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHNwYXRpYWxFZmZlY3QodmFsdWUpIHtcclxuICAgIHRoaXMubVNwYXRpYWxFZmZlY3QgPSB2YWx1ZTtcclxuXHJcbiAgICBpZiAodmFsdWUgJiYgdGhpcy5tU291bmRJbnN0YW5jZSAhPSBudWxsICYmIHRoaXMubVNvdW5kSW5zdGFuY2UuaXNQbGF5aW5nID09PSB0cnVlKSB7XHJcbiAgICAgIGxldCBwID0gdGhpcy5tU291bmRJbnN0YW5jZS5lbmFibGVTcGFjZVBhbigpO1xyXG4gICAgICBwLnJvbGxvZmZGYWN0b3IgPSB0aGlzLm1Sb2xsb2ZmO1xyXG4gICAgICBwLnJlZkRpc3RhbmNlID0gMTtcclxuICAgICAgcC5kaXN0YW5jZU1vZGVsID0gJ2ludmVyc2UnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXRzIHdoZXRoZXIgdGhlIHNvdW5kIHNob3VsZCBoYXZlIHNwYXRpYWwgZWZmZWN0LiBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgc3BhdGlhbEVmZmVjdCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1TcGF0aWFsRWZmZWN0O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBzb3VuZCBsaXN0ZW5lciBjb21wb25lbnQsIHdoaWNoIGNvbnRyb2xzIG9uZSBhbmQgb25seSBpbnN0YW5jZSBvZiBBdWRpb0NvbnRleHQubGlzdGVuZXIuXHJcbiAqIFxyXG4gKiBAY2F0IGF1ZGlvXHJcbiAqIEBleHRlbmRzIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fVxyXG4gKi9cclxuY2xhc3MgU291bmRMaXN0ZW5lciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgU291bmRMaXN0ZW5lci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uUmVtb3ZlZChnYW1lT2JqZWN0KSB7XHJcbiAgICB0aGlzLmxvb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgY29udHJvbGxpbmcgb25seSBpbnN0YW5jZSBvZiBBdWRpb0NvbnRleHQubGlzdGVuZXIuXHJcbiAgICovXHJcbiAgbGlzdGVuKCkge1xyXG4gICAgQmxhY2suYXVkaW8uY3VycmVudExpc3RlbmVyID0gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIGNvbnRyb2xsaW5nIEF1ZGlvQ29udGV4dC5saXN0ZW5lci5cclxuICAgKi9cclxuICBsb29zZSgpIHtcclxuICAgIEJsYWNrLmF1ZGlvLmxvb3NlTGlzdGVuZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgb25SZW5kZXIoKSB7XHJcbiAgICBpZiAoQmxhY2suYXVkaW8uY3VycmVudExpc3RlbmVyID09PSB0aGlzKSB7XHJcbiAgICAgIGxldCBsaXN0ZW5lciA9IEJsYWNrLmF1ZGlvLmNvbnRleHQubGlzdGVuZXI7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgc3RhZ2UgPSBCbGFjay5zdGFnZTtcclxuICAgICAgbGV0IHBvcyA9IHRoaXMuZ2FtZU9iamVjdC5sb2NhbFRvR2xvYmFsKHN0YWdlLmdsb2JhbFRvTG9jYWwobmV3IFZlY3Rvcih0aGlzLmdhbWVPYmplY3QucGl2b3RYLCB0aGlzLmdhbWVPYmplY3QucGl2b3RZKSkpO1xyXG4gICAgICBsZXQgcHggPSAocG9zLnggLSBzdGFnZS5jZW50ZXJYKSAvIHN0YWdlLndpZHRoICogMjtcclxuICAgICAgbGV0IHB5ID0gKHBvcy55IC0gc3RhZ2UuY2VudGVyWSkgLyBzdGFnZS5oZWlnaHQgKiAyO1xyXG4gICAgICBpZiAobGlzdGVuZXIucG9zaXRpb25YICE9IG51bGwpIHtcclxuICAgICAgICBsaXN0ZW5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUocHgsIDApO1xyXG4gICAgICAgIGxpc3RlbmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZShweSwgMCk7XHJcbiAgICAgICAgbGlzdGVuZXIucG9zaXRpb25aLnNldFZhbHVlQXRUaW1lKDEsIDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxpc3RlbmVyLnNldFBvc2l0aW9uKHB4ICxweSwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSaWdpZEJvZHkgaXMgdXNlZCB0byBkZXNjcmliZSBwaHlzaWNzIHByb3BlcnRpZXMgb2YgZ2FtZSBvYmplY3QgY29sbGlkZXJzXHJcbiAqXHJcbiAqIEBjYXQgcGh5c2ljc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+Q29tcG9uZW50XHJcbiAqL1xyXG5jbGFzcyBSaWdpZEJvZHkgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFJpZ2lkQm9keS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogRGVmYXVsdCBjb2xsaWRlci4gVXNlZCBpbiBjYXNlIG5vIGFueSBjdXN0b20gY29sbGlkZXJzIHByb3ZpZGVkIGJ5IHVzZXIuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+Qm94Q29sbGlkZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbGxpZGVyID0gbmV3IEJveENvbGxpZGVyKDAsIDAsIDAsIDApO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEZvciBpbnRlcm5hbCB1c2FnZS4gVG8gbWFyayB0aGlzIGJvZHkgaXMgaW4gaXNsYW5kLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tSW5Hcm91cCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmxhZyB0byBtYXJrIHRoaXMgYm9keSBpcyBpbiByZXN0LlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNTbGVlcGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEludGVybmFsIGNvdW50ZXIuIEhvdyBtYW55IHRpbWVzICh1cGRhdGVzKSB0aGlzIGJvZHkgaGFzIHZlbG9jaXR5IGxvd2VyIHRoYW4gYFBhaXIuc2xlZXBUaHJlc2hvbGRgLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TbGVlcFRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEFsbCBjb2xsaWRpbmcgcGFpcnMgdGhpcyBib2R5IHBhcnRpY2lwYXRlcyBpbi5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5QYWlyPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbnRhY3RzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHYW1lIG9iamVjdCBwaXZvdC4gVG8gdHJhY2sgY2hhbmdlcyBhbmQgdXBkYXRlIGRlZmF1bHQgY29sbGlkZXIgaWYgbmVlZGVkLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGl2b3QgPSBuZXcgVmVjdG9yKE51bWJlci5NQVhfVkFMVUUpO1xyXG5cclxuICAgIC8qKiAgXHJcbiAgICAgKiBHYW1lIGJvdW5kcyBwb3NpdGlvbi4gVG8gdHJhY2sgY2hhbmdlcyBhbmQgdXBkYXRlIHRoaXMgcG9zaXRpb24sIGlmIG9iamVjdCB3YXMgbW92ZWQgd2l0aG91dCBwaHlzaWNzLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2FjaGVkUG9zaXRpb24gPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQWxsIHBhaXJzIHRoaXMgYm9keSBwYXJ0aWNpcGF0ZXMgaW4uXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5QYWlyPn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGFpcnMgPSBbXTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBGbGFnIHRvIGluZGljYXRlIGltbW92YWJsZSBib2R5LlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNTdGF0aWMgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBUaGlzIHBvc2l0aW9uIGluIHN0YWdlIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tUG9zaXRpb24gPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVGhpcyB2ZWxvY2l0eSB0byBpbnRlZ3JhdGUuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1WZWxvY2l0eSA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBGb3JjZSBhY2N1bXVsYXRvci5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUZvcmNlID0gbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEdhbWUgb2JqZWN0IHRyYW5zZm9ybS4gVG8gdHJhY2sgY2hhbmdlcyBhbmQgdXBkYXRlIHRoaXMgY29sbGlkZXJzLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfk1hdHJpeH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tVHJhbnNmb3JtID0gbmV3IE1hdHJpeChOdW1iZXIuTUFYX1ZBTFVFKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBtYXNzXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubU1hc3MgPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0ZWQgbWFzcyBvciB6ZXJvIGlmIGJvZHkgaXMgc3RhdGljLiBcclxuICAgICAqIFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBpZ25vcmUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSW52TWFzcyA9IDE7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVmVsb2NpdHkgZGFtcGVyLlxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb25BaXIgPSAwLjAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnJpY3Rpb24gZm9yIGNvbGxpc2lvbiBzb2x2aW5nLlxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJpY3Rpb24gPSAwLjE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCb3VuY2UgZm9yIGNvbGxpc2lvbiBzb2x2aW5nLiBcclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvdW5jZSA9IDAuMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhpcyBjYWNoZWQgbWFzcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbWFzcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXNzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgbWFzcyBvZiB0aGlzIGJvZHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdiBNYXNzIHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBtYXNzKHYpIHtcclxuICAgIHRoaXMubU1hc3MgPSB2O1xyXG5cclxuICAgIGlmICh2ID09PSAwIHx8IHRoaXMubUlzU3RhdGljKSB7XHJcbiAgICAgIHRoaXMubUludk1hc3MgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5tSW52TWFzcyA9IDEgLyB2O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGlzIHN0YXRpYyBpbmRpY2F0b3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc1N0YXRpYygpIHtcclxuICAgIHJldHVybiB0aGlzLm1Jc1N0YXRpYztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhpcyBib2R5IG1vdmFibGUgc3RhdGUuIFJlZnJlc2ggaW52ZXJ0ZWQgbWFzc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB2IFZhbHVlIHRvIHNldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGlzU3RhdGljKHYpIHtcclxuICAgIHRoaXMubUlzU3RhdGljID0gdjtcclxuICAgIHRoaXMubWFzcyA9IHRoaXMubU1hc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBnbG9iYWwgcG9zaXRpb24geCBvZiB0aGlzIGJvZHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdiBQb3NpdGlvbiB0byBzZXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgeCh2KSB7XHJcbiAgICB0aGlzLm1Qb3NpdGlvbi54ID0gdjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhpcyBwb3NpdGlvbiB4LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBvc2l0aW9uLng7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBnbG9iYWwgcG9zaXRpb24geSBvZiB0aGlzIGJvZHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdiBQb3NpdGlvbiB0byBzZXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgeSh2KSB7XHJcbiAgICB0aGlzLm1Qb3NpdGlvbi55ID0gdjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhpcyBwb3NpdGlvbiB5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCB5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBvc2l0aW9uLnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBmb3JjZSB4IG9mIHRoaXMgYm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IEZvcmNlIHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmb3JjZVgodikge1xyXG4gICAgdGhpcy5tSXNTbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tRm9yY2UueCA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgZm9yY2UgeC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZm9yY2VYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUZvcmNlLng7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBmb3JjZSB5IG9mIHRoaXMgYm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IEZvcmNlIHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBmb3JjZVkodikge1xyXG4gICAgdGhpcy5tSXNTbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tRm9yY2UueSA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgZm9yY2UgeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZm9yY2VZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUZvcmNlLnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB4IG9mIHRoaXMgYm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IFZlbG9jaXR5IHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB2ZWxvY2l0eVgodikge1xyXG4gICAgdGhpcy5tVmVsb2NpdHkueCA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgdmVsb2NpdHkgeC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdmVsb2NpdHlYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVZlbG9jaXR5Lng7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB5IG9mIHRoaXMgYm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IFZlbG9jaXR5IHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB2ZWxvY2l0eVkodikge1xyXG4gICAgdGhpcy5tVmVsb2NpdHkueSA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgdmVsb2NpdHkgeS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdmVsb2NpdHlZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVZlbG9jaXR5Lnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIGdhbWUgb2JqZWN0IHBvc2l0aW9uLCBjb2xsaWRlcnNcclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IGdhbWVPYmplY3QgPSB0aGlzLmdhbWVPYmplY3Q7XHJcbiAgICBjb25zdCBjb2xsaWRlcnMgPSBnYW1lT2JqZWN0Lm1Db2xsaWRlcnNDYWNoZTtcclxuICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5tQ29sbGlkZXI7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMubVBvc2l0aW9uO1xyXG4gICAgY29uc3Qgd3QgPSBnYW1lT2JqZWN0LndvcmxkVHJhbnNmb3JtYXRpb247XHJcbiAgICBjb25zdCB3dERhdGEgPSB3dC5kYXRhO1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5tVHJhbnNmb3JtO1xyXG5cclxuICAgIC8vIENoZWNrIHNjYWxlIHgsIHkgYW5kIHJvdGF0aW9uIChza2V3IGlzIGZvcmJpZGRlbiBmb3IgYXJjYWRlIHBoeXNpY3MpXHJcbiAgICAvLyBBbHNvIGZvciBjaXJjbGUgd29ybGQgc2NhbGUgeCBhbmQgeSBzaG91bGQgYmUgdGhlIHNhbWVcclxuICAgIGlmICh0cmFuc2Zvcm0uZGF0YVswXSAhPT0gd3REYXRhWzBdIHx8IHRyYW5zZm9ybS5kYXRhWzJdICE9PSB3dERhdGFbMl0pIHtcclxuICAgICAgdHJhbnNmb3JtLnNldCh3dERhdGFbMF0sIHd0RGF0YVsxXSwgd3REYXRhWzJdLCB3dERhdGFbM10sIDAsIDApO1xyXG4gICAgICBjb2xsaWRlci5tQ2hhbmdlZCA9IHRydWU7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbGxpZGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBjb2xsaWRlcnNbaV0ubUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGdhbWVPYmplY3QgIT09IEJsYWNrLnN0YWdlKSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlZFBvc2l0aW9uID0gdGhpcy5tQ2FjaGVkUG9zaXRpb247XHJcbiAgICAgIGNvbnN0IHByZXZYID0gY2FjaGVkUG9zaXRpb24ueDtcclxuICAgICAgY29uc3QgcHJldlkgPSBjYWNoZWRQb3NpdGlvbi55O1xyXG5cclxuICAgICAgd3QudHJhbnNmb3JtWFkoZ2FtZU9iamVjdC5waXZvdFgsIGdhbWVPYmplY3QucGl2b3RZLCBjYWNoZWRQb3NpdGlvbik7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdGhpcyBwb3NpdGlvbiBpZiBnYW1lIG9iamVjdCBwb3NpdGlvbiB3YXMgY2hhbmdlZCBkdXJpbmcgZnJhbWVcclxuICAgICAgcG9zaXRpb24ueCArPSBjYWNoZWRQb3NpdGlvbi54IC0gcHJldlg7XHJcbiAgICAgIHBvc2l0aW9uLnkgKz0gY2FjaGVkUG9zaXRpb24ueSAtIHByZXZZO1xyXG5cclxuICAgICAgZ2FtZU9iamVjdC5wYXJlbnQuZ2xvYmFsVG9Mb2NhbChwb3NpdGlvbiwgY2FjaGVkUG9zaXRpb24pO1xyXG4gICAgICBnYW1lT2JqZWN0LnggPSBjYWNoZWRQb3NpdGlvbi54O1xyXG4gICAgICBnYW1lT2JqZWN0LnkgPSBjYWNoZWRQb3NpdGlvbi55O1xyXG4gICAgICBnYW1lT2JqZWN0LndvcmxkVHJhbnNmb3JtYXRpb24udHJhbnNmb3JtWFkoZ2FtZU9iamVjdC5waXZvdFgsIGdhbWVPYmplY3QucGl2b3RZLCBjYWNoZWRQb3NpdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVmcmVzaCBjb2xsaWRlcnNcclxuICAgIGlmIChjb2xsaWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIC8vIFRPRE87IGRvIHdlIG5lZWQgYSBib3VuZHNDaGFuZ2VkIGNhbGxiYWNrP1xyXG4gICAgICBsZXQgYm91bmRzID0gZ2FtZU9iamVjdC5sb2NhbEJvdW5kcztcclxuXHJcbiAgICAgIGlmIChnYW1lT2JqZWN0IGluc3RhbmNlb2YgRGlzcGxheU9iamVjdCkge1xyXG4gICAgICAgIGxldCBkaXNwID0gLyoqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fSAqLyhnYW1lT2JqZWN0KTtcclxuICAgICAgICBpZiAoZGlzcC5tQ2xpcFJlY3QgIT09IG51bGwpXHJcbiAgICAgICAgICBjb2xsaWRlci5zZXQoMCwgMCwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBjb2xsaWRlci5zZXQoLWdhbWVPYmplY3QucGl2b3RYLCAtZ2FtZU9iamVjdC5waXZvdFksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29sbGlkZXIuc2V0KC1nYW1lT2JqZWN0LnBpdm90WCwgLWdhbWVPYmplY3QucGl2b3RZLCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb2xsaWRlci5yZWZyZXNoKHRyYW5zZm9ybSwgcG9zaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjb2xsaWRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29sbGlkZXJzW2ldLnJlZnJlc2godHJhbnNmb3JtLCBwb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0cyBjb2xsaWRlcnMgZGlydHkgc3RhdGUgYWZ0ZXIgY29sbGlzaW9uIHRlc3QuIFN5bmMgd2l0aCB1cGRhdGVcclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNsZWFyRmxhZ3MoKSB7XHJcbiAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdhbWVPYmplY3QubUNvbGxpZGVyc0NhY2hlO1xyXG4gICAgdGhpcy5tQ29sbGlkZXIubUNoYW5nZWQgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbGxpZGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgY29sbGlkZXJzW2ldLm1DaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyAvKipcclxuICAvLyAgKiBEcmF3cyBhbGwgdGhlIGNvbGxpZGVyc1xyXG4gIC8vICAqXHJcbiAgLy8gICogQHB1YmxpY1xyXG4gIC8vICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgLy8gICovXHJcbiAgLy8gZGVidWcoKSB7XHJcbiAgLy8gICBpZiAoIXRoaXMuZ2FtZU9iamVjdCkgcmV0dXJuO1xyXG4gIC8vXHJcbiAgLy8gICBpZiAoUmlnaWRCb2R5Lm1EZWJ1Zy5ncmFwaGljcyA9PT0gbnVsbCkge1xyXG4gIC8vICAgICBSaWdpZEJvZHkubURlYnVnLmdyYXBoaWNzID0gbmV3IEdyYXBoaWNzKCk7XHJcbiAgLy8gICB9XHJcbiAgLy9cclxuICAvLyAgIGNvbnN0IGRlYnVnID0gUmlnaWRCb2R5Lm1EZWJ1ZztcclxuICAvLyAgIGNvbnN0IGdyYXBoaWNzID0gZGVidWcuZ3JhcGhpY3M7XHJcbiAgLy8gICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdhbWVPYmplY3QubUNvbGxpZGVyc0NhY2hlO1xyXG4gIC8vXHJcbiAgLy8gICBpZiAoZGVidWcudGltZSAhPT0gQmxhY2suaW5zdGFuY2UubUxhc3RGcmFtZVRpbWVNcykge1xyXG4gIC8vICAgICBkZWJ1Zy50aW1lID0gQmxhY2suaW5zdGFuY2UubUxhc3RGcmFtZVRpbWVNcztcclxuICAvLyAgICAgQmxhY2suc3RhZ2UuYWRkKGRlYnVnLmdyYXBoaWNzKTtcclxuICAvL1xyXG4gIC8vICAgICBkZWJ1Zy5ncmFwaGljcy5jbGVhcigpO1xyXG4gIC8vICAgfVxyXG4gIC8vXHJcbiAgLy8gICBkZWJ1Zy5ncmFwaGljcy5saW5lU3R5bGUoMiwgdGhpcy5tSXNTbGVlcGluZyA/IDB4MDBmZjAwIDogMHhmZjAwMDApO1xyXG4gIC8vXHJcbiAgLy8gICBpZiAoY29sbGlkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gIC8vICAgICB0aGlzLm1Db2xsaWRlci5kZWJ1ZyhncmFwaGljcywgdGhpcy5tQ2FjaGVkUG9zaXRpb24pO1xyXG4gIC8vICAgfSBlbHNlIHtcclxuICAvLyAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjb2xsaWRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgLy8gICAgICAgY29sbGlkZXJzW2ldLmRlYnVnKGdyYXBoaWNzLCB0aGlzLm1DYWNoZWRQb3NpdGlvbik7XHJcbiAgLy8gICAgIH1cclxuICAvLyAgIH1cclxuICAvLyB9XHJcbn1cclxuXHJcbi8vIC8qKiBAcHJpdmF0ZSBAdHlwZSB7T2JqZWN0fSBEZWJ1ZyBvcHRpb25zICovXHJcbi8vIFJpZ2lkQm9keS5tRGVidWcgPSB7XHJcbi8vICAgZ3JhcGhpY3M6IG51bGwsXHJcbi8vICAgdGltZSAgICA6IDAsXHJcbi8vIH07XHJcblxyXG4vKipcclxuICogUHJvamVjdGlvbiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSByYW5nZXMgZm9yIGNvbGxpc2lvbiB0ZXN0IHdpdGggU2VwYXJhdGUgQXhpcyBUaGVvcmVtLlxyXG4gKlxyXG4gKiBAY2F0IHBoeXNpY3MuYXJjYWRlLmhlbHBlcnNcclxuICovXHJcbmNsYXNzIFByb2plY3Rpb24ge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFByb2plY3Rpb24uXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZlY3RvcnxudWxsfSBCb3ggbm9ybWFsIFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF4aXMgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5WZWN0b3I+fG51bGx9IEJveCBhIHZlcnRpY2VzIFxyXG4gICAgICovXHJcbiAgICB0aGlzLnZlcnRpY2VzQSA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8YmxhY2stZW5naW5lflZlY3Rvcj58bnVsbH0gQm94IGIgdmVydGljZXMgXHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydGljZXNCID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmFuZ2V9IFJhbmdlIGZyb20gcHJvamVjdCBib3ggYSB2ZXJ0aWNlcyB0byBheGlzIFxyXG4gICAgICovXHJcbiAgICB0aGlzLnJhbmdlQSA9IG5ldyBSYW5nZSgpO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5SYW5nZX0gUmFuZ2UgZnJvbSBwcm9qZWN0IGJveCBiIHZlcnRpY2VzIHRvIGF4aXMgXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmFuZ2VCID0gbmV3IFJhbmdlKCk7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBib2R5IGEgdG8gYm9keSBiIG9mZnNldCBwcm9qZWN0ZWQgb24gdGhlIGF4aXMgXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlclxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheTxibGFjay1lbmdpbmV+VmVjdG9yPn0gdmVydGljZXNBIGJveCBhIHBvaW50c1xyXG4gICAqIEBwYXJhbSB7QXJyYXk8YmxhY2stZW5naW5lflZlY3Rvcj59IHZlcnRpY2VzQiBib3ggYiBwb2ludHNcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5WZWN0b3J9ICAgICAgICBheGlzIE9uZSBmcm9tIGJveCBub3JtYWxzXHJcbiAgICpcclxuICAgKiByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0KHZlcnRpY2VzQSwgdmVydGljZXNCLCBheGlzKSB7XHJcbiAgICB0aGlzLnZlcnRpY2VzQSA9IHZlcnRpY2VzQTtcclxuICAgIHRoaXMudmVydGljZXNCID0gdmVydGljZXNCO1xyXG4gICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjYWxjdWxhdGVzIHRoZSByYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIFByb2plY3Rpb24uX19wcm9qZWN0KHRoaXMudmVydGljZXNBLCB0aGlzLmF4aXMsIHRoaXMucmFuZ2VBKTtcclxuICAgIFByb2plY3Rpb24uX19wcm9qZWN0KHRoaXMudmVydGljZXNCLCB0aGlzLmF4aXMsIHRoaXMucmFuZ2VCKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY2FsY3VsYXRlcyByYW5nZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc3RhdGljIF9fcHJvamVjdChwb2ludHMsIGF4aXMsIHJhbmdlKSB7XHJcbiAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgY29uc3QgZG90ID0gcG9pbnRzW2ldLmRvdChheGlzKTtcclxuICAgICAgbWluID0gZG90IDwgbWluID8gZG90IDogbWluO1xyXG4gICAgICBtYXggPSBkb3QgPiBtYXggPyBkb3QgOiBtYXg7XHJcbiAgICB9XHJcblxyXG4gICAgcmFuZ2UubWluID0gbWluO1xyXG4gICAgcmFuZ2UubWF4ID0gbWF4O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbXBsZSByYW5nZSBoZWxwZXIgY2xhc3MuXHJcbiAqXHJcbiAqIEBjYXQgcGh5c2ljcy5hcmNhZGUuaGVscGVyc1xyXG4gKi9cclxuY2xhc3MgUmFuZ2Uge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFJhbmdlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIE1pbiB2YWx1ZS5cclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5taW4gPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIE1heCB2YWx1ZS5cclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXggPSAwO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdG8gc3RhcnQgc2xlZXAgaWYgdmVsb2NpdGllcyBpcyBsb3dlciwgdGhhbiBzbGVlcCB0aHJlc2hvbGQuXHJcbiAqXHJcbiAqIEBpZ25vcmUgXHJcbiAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gKi9cclxubGV0IHRpbWVUb1NsZWVwID0gNTsgLy9cclxuXHJcbi8qKlxyXG4gKiBIb3cgbWFueSBwaXhlbHMgY29sbGlkZXJzIGNhbiBvdmVybGFwIGVhY2ggb3RoZXIgd2l0aG91dCByZXNvbHZlLlxyXG4gKlxyXG4gKiBAaWdub3JlIFxyXG4gKiBAdHlwZSB7bnVtYmVyfSBcclxuICovXHJcbmxldCBzbG9wID0gMTtcclxuXHJcbi8qKlxyXG4gKiBQb3NpdGlvbiBjb3JyZWN0aW9uIGtvZWZmaWNpZW50LiBMb3dlciBpcyBzb2Z0ZXIgYW5kIHdpdGggbGVzcyB0d2l0Y2hlcy5cclxuICpcclxuICogQGlnbm9yZSBcclxuICogQHR5cGUge251bWJlcn0gXHJcbiAqL1xyXG5sZXQgYmF1bWdhcnRlID0gMC4yO1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlIGtvZWZmaWNpZW50IHRvIG5vcm1hbGl6ZSBwaHlzaWNzIGluIHNvbWUgbG9jYWwgY29vcmRpbmF0ZXMgb3IgZGlmZmVyZW50IHJlc29sdXRpb25zLlxyXG4gKlxyXG4gKiBAaWdub3JlIFxyXG4gKiBAdHlwZSB7bnVtYmVyfSBcclxuICovXHJcbmxldCB1bml0c1Blck1ldGVyID0gMTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIGJvZHkgc3BlZWQgdG8gYmVnaW4gc2xlZXAgcHJvY2VzcywgaWYgc2xlZXBpbmcgaXMgZW5hYmxlZC5cclxuICpcclxuICogQGlnbm9yZSBcclxuICogQHR5cGUge251bWJlcn0gXHJcbiAqL1xyXG5sZXQgc2xlZXBUaHJlc2hvbGQgPSAwLjE7XHJcblxyXG4vKipcclxuICogTWluaW1hbCByZWxhdGl2ZSB2ZWxvY2l0eSB3aXRoaW4gdHdvIGJvZGllcywgcmVxdWlyZWQgZm9yIGJvdW5jZSBlZmZlY3QuXHJcbiAqXHJcbiAqIEBpZ25vcmUgXHJcbiAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gKi9cclxubGV0IGJvdW5jZVRyZXNoaG9sZCA9IDE7XHJcblxyXG4vKipcclxuICogUGFpciBpcyB1c2VkIGZvciBuYXJyb3cgdGVzdCwgYW5kIHJlc29sdmUgY29sbGlzaW9uIHdpdGhpbiB0d28gY29sbGlkZXJzLlxyXG4gKlxyXG4gKiBAY2F0IHBoeXNpY3MuYXJjYWRlLnBhaXJzXHJcbiAqL1xyXG5cclxuY2xhc3MgUGFpciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgUGFpci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlkZXIgZnJvbSBib2R5IGEuXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge0NvbGxpZGVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsaWRlciBmcm9tIGJvZHkgYi5cclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkNvbGxpZGVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYiA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJlbnQgb2YgY29sbGlkZXIgYS5cclxuICAgICAqIEBwdWJsaWMgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJpZ2lkQm9keXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJvZHlBID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcmVudCBvZiBjb2xsaWRlciBiLlxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYm9keUIgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmxhZyB0byBpbmRpY2F0ZSBjb2xsaXNpb24gc3RhdGUuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbkNvbGxpc2lvbiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmxhZyB0byBkZXRlcm1pbmUgb25lIGZyb20gdHdvIGJvZGllcyBjYW4gbW92ZS4gaW52TWFzcyAhPT0gMCBhbmQgaXNTbGVlcGluZyA9PT0gZmFsc2UuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc1N0YXRpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIG5vcm1hbCBpbXB1bHNlIHRvIGFwcGx5IGluIG5leHQgaXRlcmF0aW9uIG9yIGZyYW1lIGlmIGNvbGxpc2lvbiBzdGlsbCBleGlzdC5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTm9ybWFsSW1wdWxzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgdGFuZ2VudCBpbXB1bHNlIHRvIGFwcGx5IGluIG5leHQgaXRlcmF0aW9uIG9yIGZyYW1lIGlmIGNvbGxpc2lvbiBzdGlsbCBleGlzdC5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGFuZ2VudEltcHVsc2UgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gaW1wdWxzZSBjYWNoZSB0byB1c2Ugd2l0aGluIGl0ZXJhdGlvbnMuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBvc2l0aW9uSW1wdWxzZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNvbGxpZGVycyBjYWNoZWQgZnJpY3Rpb24uXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUZyaWN0aW9uID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29sbGlkZXJzIGNhY2hlZCBib3VuY2UgZmFjdG9yLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1CaWFzID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY29sbGlkZXJzIGNhY2hlZCBpbnZlcnNlIG1hc3Mgc3VtLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1NYXNzID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldCB3aXRoaW4gdGhlIGNvbGxpZGVycyBvbiBwcmVTb2x2ZSB0byBjb3JyZWN0IG92ZXJsYXAgb24gZWFjaCBpdGVyYXRpb24uXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1PZmZzZXQgPSBuZXcgVmVjdG9yKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWwgY29sbGlzaW9uIGRpcmVjdGlvbiBmcm9tIGEgdG8gYi5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubU5vcm1hbCA9IG5ldyBWZWN0b3IoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aXZlIG51bWJlci4gUGVuZXRyYXRpb24gd2l0aGluIGNvbGxpZGVycy5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tT3ZlcmxhcCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGbGFnIHRvIGluZGljYXRlIHRoaXMgcGFpciBuZWVkcyByZWZyZXNoLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ2hhbmdlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdHMgdGhlIGNvbGxpc2lvbiBzdGF0ZS4gVXBkYXRlcyBub3JtYWwgYW5kIG92ZXJsYXAgZm9yIHNvbHZlLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhpcyBwYWlyIGluIGNvbGxpc2lvbiBmbGFnXHJcbiAgICovXHJcbiAgdGVzdCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1JbkNvbGxpc2lvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXBhcmVzIHRoZSBzb2x2ZSBwcm9wZXJ0aWVzIGRlcGVuZHMgb24gYm9kaWVzIHBoeXNpY3MgY2hhcmFjdGVyaXN0aWNzIGFuZCB0ZXN0IHJlc3VsdC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgcHJlU29sdmUoKSB7XHJcbiAgICBjb25zdCBub3JtYWxYID0gdGhpcy5tTm9ybWFsLng7XHJcbiAgICBjb25zdCBub3JtYWxZID0gdGhpcy5tTm9ybWFsLnk7XHJcbiAgICBjb25zdCB0YW5nZW50WCA9IC1ub3JtYWxZO1xyXG4gICAgY29uc3QgdGFuZ2VudFkgPSArbm9ybWFsWDtcclxuICAgIGNvbnN0IHBvc2l0aW9uQSA9IHRoaXMuYm9keUEubVBvc2l0aW9uO1xyXG4gICAgY29uc3QgcG9zaXRpb25CID0gdGhpcy5ib2R5Qi5tUG9zaXRpb247XHJcbiAgICBjb25zdCB2ZWxvY2l0eUEgPSB0aGlzLmJvZHlBLm1WZWxvY2l0eTtcclxuICAgIGNvbnN0IHZlbG9jaXR5QiA9IHRoaXMuYm9keUIubVZlbG9jaXR5O1xyXG4gICAgY29uc3QgaW52TWFzc0EgPSB0aGlzLmJvZHlBLm1JbnZNYXNzO1xyXG4gICAgY29uc3QgaW52TWFzc0IgPSB0aGlzLmJvZHlCLm1JbnZNYXNzO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5tT2Zmc2V0O1xyXG5cclxuICAgIGNvbnN0IGltcHVsc2VYID0gdGhpcy5tTm9ybWFsSW1wdWxzZSAqIG5vcm1hbFggKyB0aGlzLm1UYW5nZW50SW1wdWxzZSAqIHRhbmdlbnRYO1xyXG4gICAgY29uc3QgaW1wdWxzZVkgPSB0aGlzLm1Ob3JtYWxJbXB1bHNlICogbm9ybWFsWSArIHRoaXMubVRhbmdlbnRJbXB1bHNlICogdGFuZ2VudFk7XHJcblxyXG4gICAgb2Zmc2V0LnggPSBwb3NpdGlvbkIueCAtIHBvc2l0aW9uQS54O1xyXG4gICAgb2Zmc2V0LnkgPSBwb3NpdGlvbkIueSAtIHBvc2l0aW9uQS55O1xyXG5cclxuICAgIHZlbG9jaXR5QS54IC09IGltcHVsc2VYICogaW52TWFzc0E7XHJcbiAgICB2ZWxvY2l0eUEueSAtPSBpbXB1bHNlWSAqIGludk1hc3NBO1xyXG5cclxuICAgIHZlbG9jaXR5Qi54ICs9IGltcHVsc2VYICogaW52TWFzc0I7XHJcbiAgICB2ZWxvY2l0eUIueSArPSBpbXB1bHNlWSAqIGludk1hc3NCO1xyXG5cclxuICAgIGNvbnN0IHJlbFZlbFggPSB2ZWxvY2l0eUIueCAtIHZlbG9jaXR5QS54O1xyXG4gICAgY29uc3QgcmVsVmVsWSA9IHZlbG9jaXR5Qi55IC0gdmVsb2NpdHlBLnk7XHJcbiAgICBjb25zdCByZWxWZWwgPSByZWxWZWxYICogbm9ybWFsWCArIHJlbFZlbFkgKiBub3JtYWxZO1xyXG5cclxuICAgIGNvbnN0IGJvdW5jZVRocmVzaG9sZCA9IFBhaXIuYm91bmNlVHJlc2hob2xkICogUGFpci51bml0c1Blck1ldGVyICogQmxhY2suc3RhZ2UubVNjYWxlWDtcclxuICAgIHRoaXMubUJpYXMgPSByZWxWZWwgPCAtYm91bmNlVGhyZXNob2xkID8gLU1hdGgubWF4KHRoaXMuYm9keUEuYm91bmNlLCB0aGlzLmJvZHlCLmJvdW5jZSkgKiByZWxWZWwgOiAwO1xyXG4gICAgdGhpcy5tTWFzcyA9IDEgLyAoaW52TWFzc0EgKyBpbnZNYXNzQik7XHJcbiAgICB0aGlzLm1GcmljdGlvbiA9IE1hdGgubWluKHRoaXMuYm9keUEuZnJpY3Rpb24sIHRoaXMuYm9keUIuZnJpY3Rpb24pO1xyXG4gICAgdGhpcy5tUG9zaXRpb25JbXB1bHNlID0gMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGJvZGllcyB2ZWxvY2l0aWVzIHRvIHNvbHZlIGNvbGxpc2lvbi5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc29sdmVWZWxvY2l0eSgpIHtcclxuICAgIGNvbnN0IG5vcm1hbFggPSB0aGlzLm1Ob3JtYWwueDtcclxuICAgIGNvbnN0IG5vcm1hbFkgPSB0aGlzLm1Ob3JtYWwueTtcclxuICAgIGNvbnN0IHRhbmdlbnRYID0gLW5vcm1hbFk7XHJcbiAgICBjb25zdCB0YW5nZW50WSA9ICtub3JtYWxYO1xyXG4gICAgY29uc3QgdmVsb2NpdHlBID0gdGhpcy5ib2R5QS5tVmVsb2NpdHk7XHJcbiAgICBjb25zdCB2ZWxvY2l0eUIgPSB0aGlzLmJvZHlCLm1WZWxvY2l0eTtcclxuICAgIGNvbnN0IGludk1hc3NBID0gdGhpcy5ib2R5QS5tSW52TWFzcztcclxuICAgIGNvbnN0IGludk1hc3NCID0gdGhpcy5ib2R5Qi5tSW52TWFzcztcclxuXHJcbiAgICB7XHJcbiAgICAgIGNvbnN0IHJlbFZlbFggPSB2ZWxvY2l0eUIueCAtIHZlbG9jaXR5QS54O1xyXG4gICAgICBjb25zdCByZWxWZWxZID0gdmVsb2NpdHlCLnkgLSB2ZWxvY2l0eUEueTtcclxuICAgICAgY29uc3QgcmVsVmVsID0gcmVsVmVsWCAqIG5vcm1hbFggKyByZWxWZWxZICogbm9ybWFsWTtcclxuICAgICAgbGV0IGltcHVsc2UgPSAtKHJlbFZlbCAtIHRoaXMubUJpYXMpICogdGhpcy5tTWFzcztcclxuICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IE1hdGgubWF4KHRoaXMubU5vcm1hbEltcHVsc2UgKyBpbXB1bHNlLCAwKTtcclxuICAgICAgaW1wdWxzZSA9IG5ld0ltcHVsc2UgLSB0aGlzLm1Ob3JtYWxJbXB1bHNlO1xyXG4gICAgICB0aGlzLm1Ob3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcclxuXHJcbiAgICAgIGNvbnN0IGltcHVsc2VYID0gaW1wdWxzZSAqIG5vcm1hbFg7XHJcbiAgICAgIGNvbnN0IGltcHVsc2VZID0gaW1wdWxzZSAqIG5vcm1hbFk7XHJcblxyXG4gICAgICB2ZWxvY2l0eUEueCAtPSBpbXB1bHNlWCAqIGludk1hc3NBO1xyXG4gICAgICB2ZWxvY2l0eUEueSAtPSBpbXB1bHNlWSAqIGludk1hc3NBO1xyXG5cclxuICAgICAgdmVsb2NpdHlCLnggKz0gaW1wdWxzZVggKiBpbnZNYXNzQjtcclxuICAgICAgdmVsb2NpdHlCLnkgKz0gaW1wdWxzZVkgKiBpbnZNYXNzQjtcclxuICAgIH1cclxuXHJcbiAgICB7XHJcbiAgICAgIGNvbnN0IHJlbFZlbFggPSB2ZWxvY2l0eUIueCAtIHZlbG9jaXR5QS54O1xyXG4gICAgICBjb25zdCByZWxWZWxZID0gdmVsb2NpdHlCLnkgLSB2ZWxvY2l0eUEueTtcclxuICAgICAgY29uc3QgcmVsVmVsID0gcmVsVmVsWCAqIHRhbmdlbnRYICsgcmVsVmVsWSAqIHRhbmdlbnRZO1xyXG4gICAgICBsZXQgaW1wdWxzZSA9IC1yZWxWZWwgKiB0aGlzLm1NYXNzO1xyXG4gICAgICBjb25zdCBtYXhGcmljdGlvbiA9IHRoaXMubUZyaWN0aW9uICogdGhpcy5tTm9ybWFsSW1wdWxzZTtcclxuICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IE1hdGhFeC5jbGFtcCh0aGlzLm1UYW5nZW50SW1wdWxzZSArIGltcHVsc2UsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xyXG4gICAgICBpbXB1bHNlID0gbmV3SW1wdWxzZSAtIHRoaXMubVRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICB0aGlzLm1UYW5nZW50SW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcblxyXG4gICAgICBjb25zdCBpbXB1bHNlWCA9IGltcHVsc2UgKiB0YW5nZW50WDtcclxuICAgICAgY29uc3QgaW1wdWxzZVkgPSBpbXB1bHNlICogdGFuZ2VudFk7XHJcblxyXG4gICAgICB2ZWxvY2l0eUEueCAtPSBpbXB1bHNlWCAqIGludk1hc3NBO1xyXG4gICAgICB2ZWxvY2l0eUEueSAtPSBpbXB1bHNlWSAqIGludk1hc3NBO1xyXG5cclxuICAgICAgdmVsb2NpdHlCLnggKz0gaW1wdWxzZVggKiBpbnZNYXNzQjtcclxuICAgICAgdmVsb2NpdHlCLnkgKz0gaW1wdWxzZVkgKiBpbnZNYXNzQjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGJvZGllcyBwb3NpdGlvbnMgdG8gc29sdmUgY29sbGlzaW9uLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzb2x2ZVBvc2l0aW9uKCkge1xyXG4gICAgY29uc3Qgbm9ybWFsWCA9IHRoaXMubU5vcm1hbC54O1xyXG4gICAgY29uc3Qgbm9ybWFsWSA9IHRoaXMubU5vcm1hbC55O1xyXG4gICAgY29uc3QgaW52TWFzc0EgPSB0aGlzLmJvZHlBLm1JbnZNYXNzO1xyXG4gICAgY29uc3QgaW52TWFzc0IgPSB0aGlzLmJvZHlCLm1JbnZNYXNzO1xyXG4gICAgY29uc3QgcG9zaXRpb25BID0gdGhpcy5ib2R5QS5tUG9zaXRpb247XHJcbiAgICBjb25zdCBwb3NpdGlvbkIgPSB0aGlzLmJvZHlCLm1Qb3NpdGlvbjtcclxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubU9mZnNldDtcclxuXHJcbiAgICBjb25zdCBkeCA9IG9mZnNldC54IC0gcG9zaXRpb25CLnggKyBwb3NpdGlvbkEueDtcclxuICAgIGNvbnN0IGR5ID0gb2Zmc2V0LnkgLSBwb3NpdGlvbkIueSArIHBvc2l0aW9uQS55O1xyXG5cclxuICAgIGNvbnN0IG92ZXJsYXAgPSB0aGlzLm1PdmVybGFwICsgKGR4ICogbm9ybWFsWCArIGR5ICogbm9ybWFsWSk7XHJcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gKG92ZXJsYXAgLSBQYWlyLnNsb3ApICogUGFpci5iYXVtZ2FydGU7XHJcblxyXG4gICAgaWYgKGNvcnJlY3Rpb24gPD0gMClcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBub3JtYWxJbXB1bHNlID0gY29ycmVjdGlvbiAqIHRoaXMubU1hc3M7XHJcbiAgICBjb25zdCBpbXB1bHNlUHJldiA9IHRoaXMubVBvc2l0aW9uSW1wdWxzZTtcclxuICAgIHRoaXMubVBvc2l0aW9uSW1wdWxzZSA9IE1hdGgubWF4KGltcHVsc2VQcmV2ICsgbm9ybWFsSW1wdWxzZSwgMCk7XHJcbiAgICBub3JtYWxJbXB1bHNlID0gdGhpcy5tUG9zaXRpb25JbXB1bHNlIC0gaW1wdWxzZVByZXY7XHJcblxyXG4gICAgY29uc3QgaW1wdWxzZVggPSBub3JtYWxJbXB1bHNlICogbm9ybWFsWDtcclxuICAgIGNvbnN0IGltcHVsc2VZID0gbm9ybWFsSW1wdWxzZSAqIG5vcm1hbFk7XHJcblxyXG4gICAgcG9zaXRpb25BLnggLT0gaW1wdWxzZVggKiBpbnZNYXNzQTtcclxuICAgIHBvc2l0aW9uQS55IC09IGltcHVsc2VZICogaW52TWFzc0E7XHJcblxyXG4gICAgcG9zaXRpb25CLnggKz0gaW1wdWxzZVggKiBpbnZNYXNzQjtcclxuICAgIHBvc2l0aW9uQi55ICs9IGltcHVsc2VZICogaW52TWFzc0I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZXMgcGFpciBpZC5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Db2xsaWRlcn0gYSBQYWlyIGNvbGxpZGVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29sbGlkZXJ9IGIgUGFpciBjb2xsaWRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBQYWlyIHVuaXF1ZSBpZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBfX2lkKGEsIGIpIHtcclxuICAgIHJldHVybiBhLm1JZCA+IGIubUlkID8gYCR7YS5tSWR9JiR7Yi5tSWR9YCA6IGAke2IubUlkfSYke2EubUlkfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRvIHN0YXJ0IHNsZWVwIGlmIHZlbG9jaXRpZXMgaXMgbG93ZXIsIHRoYW4gc2xlZXAgdGhyZXNob2xkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCB0aW1lVG9TbGVlcCgpIHsgcmV0dXJuIHRpbWVUb1NsZWVwOyB9XHJcbiAgc3RhdGljIHNldCB0aW1lVG9TbGVlcCh2YWx1ZSkgeyB0aW1lVG9TbGVlcCA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvdyBtYW55IHBpeGVscyBjb2xsaWRlcnMgY2FuIG92ZXJsYXAgZWFjaCBvdGhlciB3aXRob3V0IHJlc29sdmUuXHJcbiAgICogIFxyXG4gICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgc2xvcCgpIHsgcmV0dXJuIHNsb3A7IH1cclxuICBzdGF0aWMgc2V0IHNsb3AodmFsdWUpIHsgc2xvcCA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvc2l0aW9uIGNvcnJlY3Rpb24ga29lZmZpY2llbnQuIExvd2VyIGlzIHNvZnRlciBhbmQgd2l0aCBsZXNzIHR3aXRjaGVzLlxyXG4gICAqICBcclxuICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IGJhdW1nYXJ0ZSgpIHsgcmV0dXJuIGJhdW1nYXJ0ZTsgfTtcclxuICBzdGF0aWMgc2V0IGJhdW1nYXJ0ZSh2YWx1ZSkgeyBiYXVtZ2FydGUgPSB2YWx1ZTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2NhbGUga29lZmZpY2llbnQgdG8gbm9ybWFsaXplIHBoeXNpY3MgaW4gc29tZSBsb2NhbCBjb29yZGluYXRlcyBvciBkaWZmZXJlbnQgcmVzb2x1dGlvbnMuXHJcbiAgICogIFxyXG4gICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXQgdW5pdHNQZXJNZXRlcigpIHsgcmV0dXJuIHVuaXRzUGVyTWV0ZXI7IH1cclxuICBzdGF0aWMgc2V0IHVuaXRzUGVyTWV0ZXIodmFsdWUpIHsgdW5pdHNQZXJNZXRlciA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1heGltdW0gYm9keSBzcGVlZCB0byBiZWdpbiBzbGVlcCBwcm9jZXNzLCBpZiBzbGVlcGluZyBpcyBlbmFibGVkLlxyXG4gICAqICBcclxuICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgKi9cclxuICBzdGF0aWMgZ2V0IHNsZWVwVGhyZXNob2xkKCkgeyByZXR1cm4gc2xlZXBUaHJlc2hvbGQ7IH07XHJcbiAgc3RhdGljIHNldCBzbGVlcFRocmVzaG9sZCh2YWx1ZSkgeyBzbGVlcFRocmVzaG9sZCA9IHZhbHVlOyB9O1xyXG5cclxuICAvKipcclxuICAgKiBNaW5pbWFsIHJlbGF0aXZlIHZlbG9jaXR5IHdpdGhpbiB0d28gYm9kaWVzLCByZXF1aXJlZCBmb3IgYm91bmNlIGVmZmVjdC5cclxuICAgKiAgXHJcbiAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBib3VuY2VUcmVzaGhvbGQoKSB7IHJldHVybiBib3VuY2VUcmVzaGhvbGQ7IH1cclxuICBzdGF0aWMgc2V0IGJvdW5jZVRyZXNoaG9sZCh2YWx1ZSkgeyBib3VuY2VUcmVzaGhvbGQgPSB2YWx1ZTsgfVxyXG59XHJcblxyXG52YXIgcG9vbCQxID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBCb3hUb0JveFBhaXIgaXMgdXNlZCB0byB0ZXN0IGNvbGxpc2lvbiB3aXRoaW4gYm94ZXNcclxuICpcclxuICogQGNhdCBwaHlzaWNzLmFyY2FkZS5wYWlyc1xyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+UGFpclxyXG4gKi9cclxuY2xhc3MgQm94VG9Cb3hQYWlyIGV4dGVuZHMgUGFpciB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgQm94VG9Cb3hQYWlyLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbGxpZGVyIGZyb20gYm9keSBhLlxyXG4gICAgICogXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Cb3hDb2xsaWRlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmEgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlkZXIgZnJvbSBib2R5IGIuIFxyXG4gICAgICogXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Cb3hDb2xsaWRlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmIgPSBudWxsO1xyXG5cclxuICAgIGNvbnN0IHByb2plY3Rpb25zID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgcHJvamVjdGlvbnMucHVzaChuZXcgUHJvamVjdGlvbigpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3Rpb24ga2VlcHMgcmFuZ2Ugb2YgcHJvamVjdGVkIHZlcnRpY2VzLiBGb3IgZWFjaCBub3JtYWwgZnJvbSBib3RoIHRoZSBjb2xsaWRlcnMuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+UHJvamVjdGlvbj59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubVByb2plY3Rpb25zID0gcHJvamVjdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoaXMgcGFpciB3aXRoIGEgbmV3IGdpdmVuIGNvbGxpZGVycyBhbmQgYm9kaWVzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Qm94Q29sbGlkZXJ9IGEgICBQYWlyIGNvbGxpZGVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Qm94Q29sbGlkZXJ9IGIgICBQYWlyIGNvbGxpZGVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fSBib2R5QSBQYWlyIGJvZHlcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SaWdpZEJvZHl9IGJvZHlCIFBhaXIgYm9keVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UGFpcn0gVGhpc1xyXG4gICAqL1xyXG4gIHNldChhLCBiLCBib2R5QSwgYm9keUIpIHtcclxuICAgIHRoaXMuYSA9IGE7XHJcbiAgICB0aGlzLmIgPSBiO1xyXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xyXG5cclxuICAgIGNvbnN0IHByb2plY3Rpb25zID0gdGhpcy5tUHJvamVjdGlvbnM7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgNDsgaSArPSAyLCBqICs9IDEpIHtcclxuICAgICAgcHJvamVjdGlvbnNbaV0uc2V0KGEubVZlcnRpY2VzLCBiLm1WZXJ0aWNlcywgYS5tTm9ybWFsc1tqXSk7XHJcbiAgICAgIHByb2plY3Rpb25zW2kgKyAxXS5zZXQoYS5tVmVydGljZXMsIGIubVZlcnRpY2VzLCBiLm1Ob3JtYWxzW2pdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZnJlc2hlcyBwcm9qZWN0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fcmVmcmVzaFByb2plY3Rpb25zUmFuZ2VzKCkge1xyXG4gICAgY29uc3QgcHJvamVjdGlvbnMgPSB0aGlzLm1Qcm9qZWN0aW9ucztcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICBwcm9qZWN0aW9uc1tpXS5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIHRlc3QoKSB7XHJcbiAgICBjb25zdCBhID0gdGhpcy5hO1xyXG4gICAgY29uc3QgYiA9IHRoaXMuYjtcclxuXHJcbiAgICBpZiAoYS5tQ2hhbmdlZCB8fCBiLm1DaGFuZ2VkKSB7XHJcbiAgICAgIHRoaXMubUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhLm1NYXgueCA8IGIubU1pbi54IHx8IGEubU1pbi54ID4gYi5tTWF4LnggfHwgYS5tTWF4LnkgPCBiLm1NaW4ueSB8fCBhLm1NaW4ueSA+IGIubU1heC55KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1JbkNvbGxpc2lvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb2plY3Rpb25zID0gdGhpcy5tUHJvamVjdGlvbnM7XHJcbiAgICBjb25zdCBub3JtYWwgPSB0aGlzLm1Ob3JtYWw7XHJcbiAgICBjb25zdCBvZmZzZXRYID0gdGhpcy5ib2R5Qi5tUG9zaXRpb24ueCAtIHRoaXMuYm9keUEubVBvc2l0aW9uLng7XHJcbiAgICBjb25zdCBvZmZzZXRZID0gdGhpcy5ib2R5Qi5tUG9zaXRpb24ueSAtIHRoaXMuYm9keUEubVBvc2l0aW9uLnk7XHJcblxyXG4gICAgaWYgKHRoaXMubUNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5tQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9fcmVmcmVzaFByb2plY3Rpb25zUmFuZ2VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHByb2plY3Rpb25zW2ldO1xyXG4gICAgICBwcm9qZWN0aW9uLm9mZnNldCA9IHByb2plY3Rpb24uYXhpcy54ICogb2Zmc2V0WCArIHByb2plY3Rpb24uYXhpcy55ICogb2Zmc2V0WTtcclxuICAgICAgY29uc3QgbWluQSA9IHByb2plY3Rpb24ucmFuZ2VBLm1pbjtcclxuICAgICAgY29uc3QgbWF4QSA9IHByb2plY3Rpb24ucmFuZ2VBLm1heDtcclxuICAgICAgY29uc3QgbWluQiA9IHByb2plY3Rpb24ucmFuZ2VCLm1pbiArIHByb2plY3Rpb24ub2Zmc2V0O1xyXG4gICAgICBjb25zdCBtYXhCID0gcHJvamVjdGlvbi5yYW5nZUIubWF4ICsgcHJvamVjdGlvbi5vZmZzZXQ7XHJcblxyXG4gICAgICBpZiAobWluQSA+IG1heEIgfHwgbWluQiA+IG1heEEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tSW5Db2xsaXNpb24gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHByb2plY3Rpb24gPSBwcm9qZWN0aW9uc1tpXTtcclxuICAgICAgY29uc3QgbWluQSA9IHByb2plY3Rpb24ucmFuZ2VBLm1pbjtcclxuICAgICAgY29uc3QgbWF4QSA9IHByb2plY3Rpb24ucmFuZ2VBLm1heDtcclxuICAgICAgY29uc3QgbWluQiA9IHByb2plY3Rpb24ucmFuZ2VCLm1pbiArIHByb2plY3Rpb24ub2Zmc2V0O1xyXG4gICAgICBjb25zdCBtYXhCID0gcHJvamVjdGlvbi5yYW5nZUIubWF4ICsgcHJvamVjdGlvbi5vZmZzZXQ7XHJcblxyXG4gICAgICBjb25zdCBvcHRpb25BID0gbWF4QSAtIG1pbkI7XHJcbiAgICAgIGNvbnN0IG9wdGlvbkIgPSBtYXhCIC0gbWluQTtcclxuICAgICAgbGV0IG92ZXJsYXAgPSBvcHRpb25BIDwgb3B0aW9uQiA/IG9wdGlvbkEgOiAtb3B0aW9uQjtcclxuXHJcbiAgICAgIGlmIChtaW5BIDwgbWluQiAmJiBtYXhBIDwgbWF4Qikge1xyXG4gICAgICAgIG92ZXJsYXAgPSBtYXhBIC0gbWluQjtcclxuICAgICAgfSBlbHNlIGlmIChtYXhBID4gbWF4Qikge1xyXG4gICAgICAgIG92ZXJsYXAgPSBtaW5BIC0gbWF4QjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgYWJzT3ZlcmxhcCA9IE1hdGguYWJzKG92ZXJsYXApO1xyXG5cclxuICAgICAgaWYgKGFic092ZXJsYXAgPCB0aGlzLm1PdmVybGFwKSB7XHJcbiAgICAgICAgdGhpcy5tT3ZlcmxhcCA9IGFic092ZXJsYXA7XHJcbiAgICAgICAgbm9ybWFsLmNvcHlGcm9tKHByb2plY3Rpb24uYXhpcyk7XHJcbiAgICAgICAgb3ZlcmxhcCA8IDAgJiYgbm9ybWFsLm11bHRpcGx5U2NhbGFyKC0xKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLm1JbkNvbGxpc2lvbiA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0IHBvb2woKSB7XHJcbiAgICBpZiAocG9vbCQxID09PSBudWxsKVxyXG4gICAgICBwb29sJDEgPSBuZXcgT2JqZWN0UG9vbChCb3hUb0JveFBhaXIsIDEwMCk7XHJcblxyXG4gICAgcmV0dXJuIHBvb2wkMTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBwb29sJDIgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEJveFRvQ2lyY2xlUGFpciBpcyB1c2VkIHRvIHRlc3QgY29sbGlzaW9uIHdpdGhpbiBib3ggLSBjaXJjbGUgY29sbGlkZXJzLlxyXG4gKlxyXG4gKiBAY2F0IHBoeXNpY3MuYXJjYWRlLnBhaXJzXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5QYWlyXHJcbiAqL1xyXG5cclxuY2xhc3MgQm94VG9DaXJjbGVQYWlyIGV4dGVuZHMgUGFpciB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIEJveFRvQm94UGFpci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsaWRlciBmcm9tIGJvZHkgYS4gXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge0JveENvbGxpZGVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsaWRlciBmcm9tIGJvZHkgYS4gXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge0NpcmNsZUNvbGxpZGVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYiA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQ2FjaGVkIGhhbGYgd2lkdGggb2YgYm94IGluIHN0YWdlIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Cb3hIYWxmV2lkdGggPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIENhY2hlZCBoYWxmIGhlaWdodCBvZiBib3ggaW4gc3RhZ2UgY29vcmRpbmF0ZXMsXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUJveEhhbGZIZWlnaHQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIGNvcyBhbmQgc2luIGZyb20gYm94IGdhbWUgb2JqZWN0IHdvcmxkIHRyYW5zZm9ybWF0aW9uIHdpdGhvdXQgc2NhbGUsIHRvIHJvdGF0ZS5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge1ZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tQm94Um90YXRlID0gbmV3IFZlY3RvcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVG1wIHBvaW50IHRvIHJvdGF0ZS4gXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtWZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNpcmNsZUNlbnRlciA9IG5ldyBWZWN0b3IoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFzc2lnbnMgY29sbGlkZXJzIGFuZCBib2RpZXMgdG8gdGhpcyBwYWlyLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtCb3hDb2xsaWRlcn0gYSAgICAgUGFpciBib3ggY29sbGlkZXJcclxuICAgKiBAcGFyYW0ge0NpcmNsZUNvbGxpZGVyfSBiICBQYWlyIGNpcmNsZSBjb2xsaWRlclxyXG4gICAqIEBwYXJhbSB7UmlnaWRCb2R5fSBib2R5QSAgIFBhaXIgYm9keVxyXG4gICAqIEBwYXJhbSB7UmlnaWRCb2R5fSBib2R5QiAgIFBhaXIgYm9keVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UGFpcn0gVGhpc1xyXG4gICAqL1xyXG4gIHNldChhLCBiLCBib2R5QSwgYm9keUIpIHtcclxuICAgIHRoaXMuYSA9IGE7XHJcbiAgICB0aGlzLmIgPSBiO1xyXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xyXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUm90YXRlcyBwb2ludCBhcm91bmQgYW5jaG9yXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3JvdGF0ZShwb2ludCwgYW5jaG9yWCwgYW5jaG9yWSwgY29zLCBzaW4pIHtcclxuICAgIGNvbnN0IHggPSBwb2ludC54IC0gYW5jaG9yWDtcclxuICAgIGNvbnN0IHkgPSBwb2ludC55IC0gYW5jaG9yWTtcclxuICAgIGNvbnN0IHR4ID0gY29zICogeCAtIHNpbiAqIHk7XHJcbiAgICBjb25zdCB0eSA9IHNpbiAqIHggKyBjb3MgKiB5O1xyXG5cclxuICAgIHBvaW50LnggPSB0eCArIGFuY2hvclg7XHJcbiAgICBwb2ludC55ID0gdHkgKyBhbmNob3JZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICB0ZXN0KCkge1xyXG4gICAgY29uc3QgYm94ID0gdGhpcy5hO1xyXG4gICAgY29uc3QgY2lyY2xlID0gdGhpcy5iO1xyXG5cclxuICAgIGlmIChib3gubUNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5tQ2hhbmdlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJveC5tTWF4LnggPCBjaXJjbGUubU1pbi54IHx8IGJveC5tTWluLnggPiBjaXJjbGUubU1heC54IHx8XHJcbiAgICAgIGJveC5tTWF4LnkgPCBjaXJjbGUubU1pbi55IHx8IGJveC5tTWluLnkgPiBjaXJjbGUubU1heC55KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1JbkNvbGxpc2lvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm1DaGFuZ2VkKSB7XHJcbiAgICAgIHRoaXMubUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgY29uc3QgdHJhbnNmb3JtRGF0YSA9IHRoaXMuYm9keUEubVRyYW5zZm9ybS5kYXRhO1xyXG4gICAgICBjb25zdCBzY2FsZVggPSBNYXRoLnNxcnQodHJhbnNmb3JtRGF0YVswXSAqIHRyYW5zZm9ybURhdGFbMF0gKyB0cmFuc2Zvcm1EYXRhWzFdICogdHJhbnNmb3JtRGF0YVsxXSk7XHJcbiAgICAgIGNvbnN0IHNjYWxlWSA9IE1hdGguc3FydCh0cmFuc2Zvcm1EYXRhWzJdICogdHJhbnNmb3JtRGF0YVsyXSArIHRyYW5zZm9ybURhdGFbM10gKiB0cmFuc2Zvcm1EYXRhWzNdKTtcclxuXHJcbiAgICAgIHRoaXMubUJveFJvdGF0ZS5zZXQodHJhbnNmb3JtRGF0YVswXSAvIHNjYWxlWCwgdHJhbnNmb3JtRGF0YVsxXSAvIHNjYWxlWCk7XHJcbiAgICAgIHRoaXMubUJveEhhbGZXaWR0aCA9IGJveC5tUmVjdC53aWR0aCAvIDIgKiBzY2FsZVg7XHJcbiAgICAgIHRoaXMubUJveEhhbGZIZWlnaHQgPSBib3gubVJlY3QuaGVpZ2h0IC8gMiAqIHNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib3hSb3RhdGUgPSB0aGlzLm1Cb3hSb3RhdGU7XHJcbiAgICBjb25zdCBub3JtYWwgPSB0aGlzLm1Ob3JtYWw7XHJcbiAgICBjb25zdCBjaXJjbGVDZW50ZXIgPSB0aGlzLm1DaXJjbGVDZW50ZXIuY29weUZyb20oY2lyY2xlLm1DZW50ZXIpO1xyXG4gICAgbGV0IGh3ID0gdGhpcy5tQm94SGFsZldpZHRoO1xyXG4gICAgbGV0IGhoID0gdGhpcy5tQm94SGFsZkhlaWdodDtcclxuXHJcbiAgICBjb25zdCByb3RhdGVkID0gYm94Um90YXRlLnkgIT09IDA7XHJcblxyXG4gICAgaWYgKHJvdGF0ZWQpIHtcclxuICAgICAgdGhpcy5fX3JvdGF0ZShjaXJjbGVDZW50ZXIsIGJveC5tQ2VudGVyLngsIGJveC5tQ2VudGVyLnksIGJveFJvdGF0ZS54LCAtYm94Um90YXRlLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGR4ID0gY2lyY2xlQ2VudGVyLnggLSBib3gubUNlbnRlci54O1xyXG4gICAgY29uc3QgZHkgPSBjaXJjbGVDZW50ZXIueSAtIGJveC5tQ2VudGVyLnk7XHJcblxyXG4gICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XHJcbiAgICAgIHRoaXMubU92ZXJsYXAgPSBjaXJjbGUubVJhZGl1cyArIGh3O1xyXG4gICAgICBub3JtYWwuc2V0KC0xLCAwKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLm1JbkNvbGxpc2lvbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNsb3Nlc3RYID0gTWF0aEV4LmNsYW1wKGR4LCAtaHcsIGh3KTtcclxuICAgIGxldCBjbG9zZXN0WSA9IE1hdGhFeC5jbGFtcChkeSwgLWhoLCBoaCk7XHJcbiAgICBjb25zdCBpbnNpZGUgPSBkeCA9PT0gY2xvc2VzdFggJiYgZHkgPT09IGNsb3Nlc3RZO1xyXG5cclxuICAgIGlmIChpbnNpZGUpIHtcclxuICAgICAgaWYgKE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSkge1xyXG4gICAgICAgIGNsb3Nlc3RYID0gY2xvc2VzdFggPiAwID8gaHcgOiAtaHc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xvc2VzdFkgPSBjbG9zZXN0WSA+IDAgPyBoaCA6IC1oaDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5vcm1hbFggPSBkeCAtIGNsb3Nlc3RYO1xyXG4gICAgY29uc3Qgbm9ybWFsWSA9IGR5IC0gY2xvc2VzdFk7XHJcbiAgICBjb25zdCBzcUxlbmd0aCA9IG5vcm1hbFggKiBub3JtYWxYICsgbm9ybWFsWSAqIG5vcm1hbFk7XHJcbiAgICBjb25zdCByID0gY2lyY2xlLm1SYWRpdXM7XHJcblxyXG4gICAgaWYgKHNxTGVuZ3RoID4gciAqIHIgJiYgIWluc2lkZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tSW5Db2xsaXNpb24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3FMZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5tT3ZlcmxhcCA9IHI7XHJcbiAgICAgIG5vcm1hbC5zZXQoMCwgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkID0gTWF0aC5zcXJ0KHNxTGVuZ3RoKTtcclxuICAgICAgdGhpcy5tT3ZlcmxhcCA9IHIgLSBkO1xyXG4gICAgICBpbnNpZGUgPyBub3JtYWwuc2V0KC1ub3JtYWxYIC8gZCwgLW5vcm1hbFkgLyBkKSA6IG5vcm1hbC5zZXQobm9ybWFsWCAvIGQsIG5vcm1hbFkgLyBkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocm90YXRlZCkge1xyXG4gICAgICB0aGlzLl9fcm90YXRlKG5vcm1hbCwgMCwgMCwgYm94Um90YXRlLngsIGJveFJvdGF0ZS55KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5tSW5Db2xsaXNpb24gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBwb29sKCkge1xyXG4gICAgaWYgKHBvb2wkMiA9PT0gbnVsbClcclxuICAgICAgcG9vbCQyID0gbmV3IE9iamVjdFBvb2woQm94VG9DaXJjbGVQYWlyLCAxMDApO1xyXG5cclxuICAgIHJldHVybiBwb29sJDI7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgcG9vbCQzID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDaXJjbGVUb0NpcmNsZVBhaXIgaXMgdXNlZCB0byB0ZXN0IGNvbGxpc2lvbiB3aXRoaW4gY2lyY2xlcyBjb2xsaWRlcnMuXHJcbiAqXHJcbiAqIEBjYXQgcGh5c2ljcy5hcmNhZGUucGFpcnNcclxuICogQGV4dGVuZHMgYmxhY2stZW5naW5lflBhaXJcclxuICovXHJcbmNsYXNzIENpcmNsZVRvQ2lyY2xlUGFpciBleHRlbmRzIFBhaXIge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIENpcmNsZVRvQ2lyY2xlUGFpci5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsaWRlciBmcm9tIGJvZHkgYS4gXHJcbiAgICAgKiBAcHVibGljIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5DaXJjbGVDb2xsaWRlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmEgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlkZXIgZnJvbSBib2R5IGIuIFxyXG4gICAgICogQHB1YmxpYyBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+Q2lyY2xlQ29sbGlkZXJ8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5iID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHRlclxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlQ29sbGlkZXJ9IGEgIFBhaXIgY2lyY2xlIGNvbGxpZGVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q2lyY2xlQ29sbGlkZXJ9IGIgIFBhaXIgY2lyY2xlIGNvbGxpZGVyXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fSBib2R5QSAgIFBhaXIgYm9keVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJpZ2lkQm9keX0gYm9keUIgICBQYWlyIGJvZHlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1BhaXJ9IFRoaXNcclxuICAgKi9cclxuICBzZXQoYSwgYiwgYm9keUEsIGJvZHlCKSB7XHJcbiAgICB0aGlzLmEgPSBhO1xyXG4gICAgdGhpcy5iID0gYjtcclxuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcclxuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbmhlcml0RG9jXHJcbiAgICovXHJcbiAgdGVzdCgpIHtcclxuICAgIGNvbnN0IGEgPSB0aGlzLmE7XHJcbiAgICBjb25zdCBiID0gdGhpcy5iO1xyXG4gICAgY29uc3Qgb2Zmc2V0WCA9IGIubUNlbnRlci54IC0gYS5tQ2VudGVyLng7XHJcbiAgICBjb25zdCBvZmZzZXRZID0gYi5tQ2VudGVyLnkgLSBhLm1DZW50ZXIueTtcclxuICAgIGNvbnN0IHRvdGFsUmFkaXVzID0gYS5tUmFkaXVzICsgYi5tUmFkaXVzO1xyXG5cclxuICAgIGlmIChvZmZzZXRYID09PSAwICYmIG9mZnNldFkgPT09IDApIHtcclxuICAgICAgdGhpcy5tT3ZlcmxhcCA9IHRvdGFsUmFkaXVzO1xyXG4gICAgICB0aGlzLm1Ob3JtYWwuc2V0KDEsIDApO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMubUluQ29sbGlzaW9uID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0b3RhbFJhZGl1c1NxID0gdG90YWxSYWRpdXMgKiB0b3RhbFJhZGl1cztcclxuICAgIGNvbnN0IGRpc3RhbmNlU3EgPSBvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZO1xyXG5cclxuICAgIGlmIChkaXN0YW5jZVNxID4gdG90YWxSYWRpdXNTcSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tSW5Db2xsaXNpb24gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3EpO1xyXG4gICAgdGhpcy5tT3ZlcmxhcCA9IHRvdGFsUmFkaXVzIC0gZGlzdDtcclxuICAgIHRoaXMubU5vcm1hbC5zZXQob2Zmc2V0WCAvIGRpc3QsIG9mZnNldFkgLyBkaXN0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tSW5Db2xsaXNpb24gPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldCBwb29sKCkge1xyXG4gICAgaWYgKHBvb2wkMyA9PT0gbnVsbClcclxuICAgICAgcG9vbCQzID0gbmV3IE9iamVjdFBvb2woQ2lyY2xlVG9DaXJjbGVQYWlyLCAxMDApO1xyXG5cclxuICAgIHJldHVybiBwb29sJDM7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQnJvYWQgY29sbGlzaW9uIGNoZWNrZXIgdXNpbmcgaGFzaCBhbGdvcml0aG0uXHJcbiAqXHJcbiAqIEBjYXQgcGh5c2ljcy5hcmNhZGUucGhhc2VzXHJcbiAqL1xyXG5jbGFzcyBCcm9hZFBoYXNlIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBCcm9hZFBoYXNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlc3QgY29sbGlzaW9uIGluIGVhY2ggcGFpci4gU2V0cyBpbkNvbGxpc2lvbiBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGlzIG5vIGNvbGxpc2lvbiBpbiBwYWlyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheTxibGFjay1lbmdpbmV+UGFpcj59IHBhaXJzIEFsbCB0aGUgYXJjYWRlIHdvcmxkIGNvbGxpZGVycyBwYWlycy5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHRlc3QocGFpcnMpIHsgfVxyXG59XHJcblxyXG4vKipcclxuICogU2ltcGxlIEFBQkIgcGh5c2ljcyBlbmdpbmUgKGJldGEpLlxyXG4gKlxyXG4gKiBAY2F0IHBoeXNpY3MuYXJjYWRlXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5TeXN0ZW1cclxuICovXHJcbmNsYXNzIEFyY2FkZSBleHRlbmRzIFN5c3RlbSB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBuZXcgQXJjYWRlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJvZGllcyB0aGF0IGFyZSBvbiBzdGFnZS5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5SaWdpZEJvZHk+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Cb2RpZXMgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhaXJzIHRvIGNoZWNrIGNvbGxpc2lvbnMgd2l0aGluLiBXaXRoIGNvbGxpZGVycyB3aGljaCBib2RpZXMgYXJlIG9uIHN0YWdlLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7QXJyYXk8YmxhY2stZW5naW5lflBhaXI+fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QYWlycyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFpcnMgd2hpY2ggYXJlIGluIGNvbGxpc2lvbiBwZXIgZnJhbWUuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxibGFjay1lbmdpbmV+UGFpcj59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUNvbnRhY3RzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZCBjb2xsaXNpb24gdGVzdCBpbnN0YW5jZS5cclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Ccm9hZFBoYXNlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Ccm9hZFBoYXNlID0gbmV3IEJyb2FkUGhhc2UoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCB0byBzdG9yZSBwYWlycyBieSB0aGVpciBpZC4gRm9yIHF1aWNrIHNlYXJjaCBpbiBjb2xsaXNpb24gY2FsbGJhY2tzLlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QYWlyc0hhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHdvcmxkIGJvdW5kcyBib2R5LlxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflJpZ2lkQm9keXxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Cb3VuZHNCb2R5ID0gbnVsbDtcclxuXHJcbiAgICAvKiogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkJveENvbGxpZGVyfSAqL1xyXG4gICAgdGhpcy5tQm91bmRzTGVmdCA9IG5ldyBCb3hDb2xsaWRlcigwLCAwLCAwLCAwKTtcclxuXHJcbiAgICAvKiogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkJveENvbGxpZGVyfSAqL1xyXG4gICAgdGhpcy5tQm91bmRzUmlnaHQgPSBuZXcgQm94Q29sbGlkZXIoMCwgMCwgMCwgMCk7XHJcblxyXG4gICAgLyoqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5Cb3hDb2xsaWRlcn0gKi9cclxuICAgIHRoaXMubUJvdW5kc1RvcCA9IG5ldyBCb3hDb2xsaWRlcigwLCAwLCAwLCAwKTtcclxuXHJcbiAgICAvKiogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lfkJveENvbGxpZGVyfSAqL1xyXG4gICAgdGhpcy5tQm91bmRzQm90dG9tID0gbmV3IEJveENvbGxpZGVyKDAsIDAsIDAsIDApO1xyXG5cclxuICAgIC8qKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+VmVjdG9yfSAqL1xyXG4gICAgdGhpcy5tR3Jhdml0eSA9IG5ldyBWZWN0b3IoMCwgMTAwMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCaWdnZXIgdmFsdWUgZ2l2ZXMgYmV0dGVyIHJlc29sdmVyIHJlc3VsdCwgYnV0IHJlcXVpcmUgbW9yZSBjYWxjdWxhdGlvbnMuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubUl0ZXJhdGlvbnMgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoIGZvciBzbGVlcCBjYWxjdWxhdGlvbnMuXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TbGVlcEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGRlbHRhIHRpbWUsIHNlY3MuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbHRhID0gMSAvIDYwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyBwYXNzZWQgY2FsbGJhY2sgaWYgZ2l2ZW4gY29sbGlkZXJzIGFyZSBpbiBjb2xsaXNpb24uXHJcbiAgICpcclxuICAgKiBDYWxsYmFjayBwYXJhbXM6XHJcbiAgICogbm9ybWFsWCAtIGNvbGxpc2lvbiBub3JtYWwgcHJvamVjdGVkIG9uIHggYXhpcy4gSW4gZGlyZWN0aW9uIGZyb20gY29sbGlkZXJBIHRvIGNvbGxpZGVyQi5cclxuICAgKiBub3JtYWxZIC0gY29sbGlzaW9uIG5vcm1hbCBwcm9qZWN0ZWQgb24geSBheGlzLiBJbiBkaXJlY3Rpb24gZnJvbSBjb2xsaWRlckEgdG8gY29sbGlkZXJCLlxyXG4gICAqIG92ZXJsYXAgLSBwb3NpdGl2ZSBudW1iZXIuXHJcbiAgICogW2FyZ3NdIC0gcmVzdCBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBAcHVibGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Db2xsaWRlcn0gY29sbGlkZXJBIENvbGxpZGVyIHRvIGNoZWNrXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+Q29sbGlkZXJ9IGNvbGxpZGVyQiBDb2xsaWRlciB0byBjaGVja1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiICAgICAgICBDYWxsYmFja1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdHggICAgICAgICBDYWxsYmFjayBjb250ZXh0XHJcbiAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gICAgICAgIFJlc3QgYXJndW1lbnRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIGNvbGxpc2lvbkluZm8oY29sbGlkZXJBLCBjb2xsaWRlckIsIGNiLCBjdHgsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHBhaXIgPSB0aGlzLm1QYWlyc0hhc2hbUGFpci5fX2lkKGNvbGxpZGVyQSwgY29sbGlkZXJCKV07XHJcblxyXG4gICAgaWYgKHBhaXIgJiYgcGFpci5tSW5Db2xsaXNpb24pIHtcclxuICAgICAgY29uc3Qgc2lnbiA9IHBhaXIuYSA9PT0gY29sbGlkZXJBID8gMSA6IC0xO1xyXG4gICAgICBjYi5jYWxsKGN0eCwgcGFpci5tTm9ybWFsLnggKiBzaWduLCBwYWlyLm1Ob3JtYWwueSAqIHNpZ24sIHBhaXIubU92ZXJsYXAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgY2FsbGJhY2sgcGFzc2VkIGFuZCBnaXZlbiBib2RpZXMgYXJlIGluIGNvbGxpc2lvbiBpbnZva2VzIGNhbGxiYWNrLlxyXG4gICAqIElmIG5vIGJvZHlCIHByb3ZpZGVkIHJlc3VsdCB3aWxsIHNob3cgdGhhdCBib2R5QSBpcyBpbiBjb2xsaXNpb24gd2l0aCBhbnkgb3RoZXIgYm9keSBpZiBzby5cclxuICAgKlxyXG4gICAqIE5vdGU6IGlmIG1vcmUgdGhhbiBvbmUgY29sbGlzaW9uIG9jY3VycmVkIHdpdGhpbiBib2RpZXMsIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBvbmx5IHdpdGggYSBmaXJzdCBmb3VuZC5cclxuICAgKlxyXG4gICAqIENhbGxiYWNrIHBhcmFtczpcclxuICAgKiBub3JtYWxYIC0gY29sbGlzaW9uIG5vcm1hbCBwcm9qZWN0ZWQgb24geCBheGlzLiBJbiBkaXJlY3Rpb24gZnJvbSBib2R5QSBjb2xsaWRlciB0byBib2R5QiBjb2xsaWRlci5cclxuICAgKiBub3JtYWxZIC0gY29sbGlzaW9uIG5vcm1hbCBwcm9qZWN0ZWQgb24geSBheGlzLiBJbiBkaXJlY3Rpb24gZnJvbSBib2R5QSBjb2xsaWRlciB0byBib2R5QiBjb2xsaWRlci5cclxuICAgKiBvdmVybGFwIC0gcG9zaXRpdmUgbnVtYmVyLlxyXG4gICAqIFthcmdzXSAtIHJlc3QgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fSBib2R5QSAgICAgICAgIEJvZHkgdG8gY2hlY2tcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SaWdpZEJvZHk9fSBbYm9keUI9bnVsbF0gQm9keSB0byBjaGVja1xyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBbY2I9bnVsbF0gICAgIENhbGxiYWNrXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBbY3R4PW51bGxdICAgICAgQ2FsbGJhY2sgY29udGV4dFxyXG4gICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdICAgICAgICAgICAgIFJlc3QgYXJndW1lbnRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJbmRpY2F0b3Igb2YgYm9kaWVzIGNvbGxpc2lvbi5cclxuICAgKi9cclxuICBpc0NvbGxpZGluZyhib2R5QSwgYm9keUIgPSBudWxsLCBjYiA9IG51bGwsIGN0eCA9IG51bGwsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHBhaXJzID0gYm9keUEubVBhaXJzO1xyXG5cclxuICAgIGlmIChib2R5QiA9PT0gbnVsbCkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChwYWlyc1tpXS5tSW5Db2xsaXNpb24pIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgIGlmIChwYWlyLm1JbkNvbGxpc2lvbiA9PT0gZmFsc2UpXHJcbiAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICBjb25zdCBzaWduID0gcGFpci5ib2R5QSA9PT0gYm9keUEgJiYgcGFpci5ib2R5QiA9PT0gYm9keUIgPyAxIDpcclxuICAgICAgICBwYWlyLmJvZHlBID09PSBib2R5QiAmJiBwYWlyLmJvZHlCID09PSBib2R5QSA/IC0xIDogMDtcclxuXHJcbiAgICAgIGlmIChzaWduID09PSAwKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgaWYgKGNiKVxyXG4gICAgICAgIGNiLmNhbGwoY3R4LCBwYWlyLm1Ob3JtYWwueCAqIHNpZ24sIHBhaXIubU5vcm1hbC55ICogc2lnbiwgcGFpci5tT3ZlcmxhcCwgLi4uYXJncyk7XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQ2hpbGRyZW5BZGRlZChnYW1lT2JqZWN0KSB7XHJcbiAgICBHYW1lT2JqZWN0LmZvckVhY2goZ2FtZU9iamVjdCwgb2JqZWN0ID0+IHtcclxuICAgICAgY29uc3QgYm9keSA9IG9iamVjdC5nZXRDb21wb25lbnQoUmlnaWRCb2R5KTtcclxuXHJcbiAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgdGhpcy5fX2FkZEJvZHkoLyoqIEB0eXBlIHtSaWdpZEJvZHl9ICovKGJvZHkpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQ2hpbGRyZW5SZW1vdmVkKGdhbWVPYmplY3QpIHtcclxuICAgIEdhbWVPYmplY3QuZm9yRWFjaChnYW1lT2JqZWN0LCBvYmplY3QgPT4ge1xyXG4gICAgICBjb25zdCBib2R5ID0gLyoqIEB0eXBlIHshUmlnaWRCb2R5fSAqLyAob2JqZWN0LmdldENvbXBvbmVudChSaWdpZEJvZHkpKTtcclxuXHJcbiAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgdGhpcy5fX3JlbW92ZUJvZHkoYm9keSwgZ2FtZU9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkNvbXBvbmVudEFkZGVkKGNoaWxkLCBjb21wb25lbnQpIHtcclxuICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBSaWdpZEJvZHkpIHtcclxuICAgICAgdGhpcy5fX2FkZEJvZHkoLyoqIEB0eXBlIHtSaWdpZEJvZHl9ICovKGNvbXBvbmVudCkpO1xyXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBDb2xsaWRlcikge1xyXG4gICAgICB0aGlzLl9fYWRkQ29sbGlkZXIoY2hpbGQsIC8qKiBAdHlwZSB7Q29sbGlkZXJ9ICovKGNvbXBvbmVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGluaGVyaXREb2NcclxuICAgKi9cclxuICBvbkNvbXBvbmVudFJlbW92ZWQoY2hpbGQsIGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIFJpZ2lkQm9keSkge1xyXG4gICAgICB0aGlzLl9fcmVtb3ZlQm9keSgvKiogQHR5cGUge1JpZ2lkQm9keX0gKi8oY29tcG9uZW50KSwgY2hpbGQpO1xyXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBDb2xsaWRlcikge1xyXG4gICAgICB0aGlzLl9fcmVtb3ZlQ29sbGlkZXIoY2hpbGQsIC8qKiBAdHlwZSB7Q29sbGlkZXJ9ICovKGNvbXBvbmVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBib2R5IHRvIGFyY2FkZSB3b3JsZC4gU3RhcnQgdHJhY2tpbmcgaXRzIGdhbWVPYmplY3QgY29sbGlkZXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SaWdpZEJvZHl9IGJvZHkgQm9keSB0byBhZGRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19hZGRCb2R5KGJvZHkpIHtcclxuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMubUJvZGllcztcclxuICAgIGNvbnN0IGNvbGxpZGVycyA9IGJvZHkuZ2FtZU9iamVjdC5tQ29sbGlkZXJzQ2FjaGU7XHJcbiAgICBib2R5Lm1QYWlycy5sZW5ndGggPSAwO1xyXG5cclxuICAgIGlmIChjb2xsaWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX19hZGRQYWlycyhib2R5Lm1Db2xsaWRlciwgYm9keSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbGxpZGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9fYWRkUGFpcnMoY29sbGlkZXJzW2ldLCBib2R5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJvZGllcy5wdXNoKGJvZHkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBib2R5IGZyb20gYXJjYWRlIHdvcmxkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5SaWdpZEJvZHl9IGJvZHkgICAgICAgIEJvZHkgdG8gcmVtb3ZlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gZ2FtZU9iamVjdCBCb2R5J3MgZ2FtZSBvYmplY3RcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19yZW1vdmVCb2R5KGJvZHksIGdhbWVPYmplY3QpIHtcclxuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMubUJvZGllcztcclxuICAgIGNvbnN0IGNvbGxpZGVycyA9IGdhbWVPYmplY3QubUNvbGxpZGVyc0NhY2hlO1xyXG5cclxuICAgIGlmIChjb2xsaWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRoaXMuX19yZW1vdmVQYWlycyhib2R5Lm1Db2xsaWRlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbGxpZGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9fcmVtb3ZlUGFpcnMoY29sbGlkZXJzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJvZHkubVBhaXJzLmxlbmd0aCA9IDA7XHJcbiAgICBib2RpZXMuc3BsaWNlKGJvZGllcy5pbmRleE9mKGJvZHkpLCAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgY29sbGlkZXIgdG8gYXJjYWRlIHdvcmxkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBjaGlsZCAgUGFyZW50IG9mIHRoZSBjb2xsaWRlclxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNvbGxpZGVyfSBjb2xsaWRlciBDb2xsaWRlciB0byBhZGRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19hZGRDb2xsaWRlcihjaGlsZCwgY29sbGlkZXIpIHtcclxuICAgIGNvbnN0IGJvZHkgPSAvKiogQHR5cGUge1JpZ2lkQm9keX0gKi8gKGNoaWxkLmdldENvbXBvbmVudChSaWdpZEJvZHkpKTtcclxuXHJcbiAgICBpZiAoYm9keSAmJiB0aGlzLm1Cb2RpZXMuaW5kZXhPZihib2R5KSAhPT0gLTEpIHtcclxuICAgICAgdGhpcy5fX2FkZFBhaXJzKGNvbGxpZGVyLCBib2R5KTtcclxuXHJcbiAgICAgIGlmIChjaGlsZC5tQ29sbGlkZXJzQ2FjaGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgdGhpcy5fX3JlbW92ZVBhaXJzKGJvZHkubUNvbGxpZGVyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb2xsaWRlciBmcm9tIGFyY2FkZSB3b3JsZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gY2hpbGQgIFBhcmVudCBvZiB0aGUgY29sbGlkZXJcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Db2xsaWRlcn0gY29sbGlkZXIgQ29sbGlkZXIgdG8gcmVtb3ZlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fcmVtb3ZlQ29sbGlkZXIoY2hpbGQsIGNvbGxpZGVyKSB7XHJcbiAgICBjb25zdCBib2R5ID0gLyoqIEB0eXBlIHtSaWdpZEJvZHl9ICovIChjaGlsZC5nZXRDb21wb25lbnQoUmlnaWRCb2R5KSk7XHJcblxyXG4gICAgaWYgKGJvZHkgJiYgdGhpcy5tQm9kaWVzLmluZGV4T2YoYm9keSkgIT09IC0xKSB7XHJcbiAgICAgIHRoaXMuX19yZW1vdmVQYWlycyhjb2xsaWRlcik7XHJcblxyXG4gICAgICBjb25zdCBwYWlycyA9IGJvZHkubVBhaXJzO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IHBhaXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgcGFpciA9IHBhaXJzW2ldO1xyXG5cclxuICAgICAgICBpZiAocGFpci5hID09PSBjb2xsaWRlciB8fCBwYWlyLmIgPT09IGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICBwYWlycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2hpbGQubUNvbGxpZGVyc0NhY2hlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX19hZGRDb2xsaWRlcihjaGlsZCwgYm9keS5tQ29sbGlkZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBwYWlycywgcGFzc2VkIGNvbGxpZGVyIHdpdGggYWxsIHByZXNlbnQgY29sbGlkZXJzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Db2xsaWRlcn0gY29sbGlkZXIgICBDb2xsaWRlciB0byBnZW5lcmF0ZSB3aXRoXHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fSBmcm9tQm9keSAgVGhlIGNvbGxpZGVyIGJvZHlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19hZGRQYWlycyhjb2xsaWRlciwgZnJvbUJvZHkpIHtcclxuICAgIGNvbnN0IGJvZGllcyA9IHRoaXMubUJvZGllcztcclxuICAgIGNvbGxpZGVyLm1DaGFuZ2VkID0gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgaUxlbiA9IGJvZGllcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcclxuICAgICAgY29uc3QgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgY29uc3QgY29sbGlkZXJzID0gYm9keS5nYW1lT2JqZWN0Lm1Db2xsaWRlcnNDYWNoZTtcclxuXHJcbiAgICAgIGlmIChib2R5ID09PSBmcm9tQm9keSlcclxuICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmIChjb2xsaWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fX2FkZFBhaXIoY29sbGlkZXIsIGJvZHkubUNvbGxpZGVyLCBmcm9tQm9keSwgYm9keSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGpMZW4gPSBjb2xsaWRlcnMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XHJcbiAgICAgICAgICB0aGlzLl9fYWRkUGFpcihjb2xsaWRlciwgY29sbGlkZXJzW2pdLCBmcm9tQm9keSwgYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHBhaXIgYW5kIGFkZHMgaXQgdG8gd29ybGQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNvbGxpZGVyfSBhICAgICAgUGFpciBjb2xsaWRlclxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkNvbGxpZGVyfSBiICAgICAgUGFpciBjb2xsaWRlclxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lflJpZ2lkQm9keX0gYm9keUEgUGFpciBib2R5XHJcbiAgICogQHBhcmFtIHtibGFjay1lbmdpbmV+UmlnaWRCb2R5fSBib2R5QiBQYWlyIGJvZHlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19hZGRQYWlyKGEsIGIsIGJvZHlBLCBib2R5Qikge1xyXG4gICAgY29uc3QgaXNCb3hBID0gYS5jb25zdHJ1Y3RvciA9PT0gQm94Q29sbGlkZXI7XHJcbiAgICBjb25zdCBpc0JveEIgPSBiLmNvbnN0cnVjdG9yID09PSBCb3hDb2xsaWRlcjtcclxuICAgIGxldCBwYWlyO1xyXG5cclxuICAgIGlmIChpc0JveEEgJiYgaXNCb3hCKSB7XHJcbiAgICAgIHBhaXIgPSBCb3hUb0JveFBhaXIucG9vbC5nZXQoKTtcclxuICAgIH0gZWxzZSBpZiAoIWlzQm94QSAmJiAhaXNCb3hCKSB7XHJcbiAgICAgIHBhaXIgPSBDaXJjbGVUb0NpcmNsZVBhaXIucG9vbC5nZXQoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhaXIgPSBCb3hUb0NpcmNsZVBhaXIucG9vbC5nZXQoKTtcclxuXHJcbiAgICAgIGlmIChpc0JveEIpIHtcclxuICAgICAgICBjb25zdCBib2R5ID0gYm9keUE7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSBhO1xyXG4gICAgICAgIGEgPSBiO1xyXG4gICAgICAgIGJvZHlBID0gYm9keUI7XHJcbiAgICAgICAgYiA9IGNvbGxpZGVyO1xyXG4gICAgICAgIGJvZHlCID0gYm9keTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhaXIubUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgcGFpci5zZXQoYSwgYiwgYm9keUEsIGJvZHlCKTtcclxuICAgIHBhaXIubUluQ29sbGlzaW9uID0gZmFsc2U7XHJcbiAgICB0aGlzLm1QYWlycy5wdXNoKHBhaXIpO1xyXG5cclxuICAgIHRoaXMubVBhaXJzSGFzaFtQYWlyLl9faWQoYSwgYildID0gcGFpcjtcclxuICAgIGJvZHlBLm1QYWlycy5wdXNoKHBhaXIpO1xyXG4gICAgYm9keUIubVBhaXJzLnB1c2gocGFpcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGFsbCBwYWlycyB3aXRoIGdpdmVuIGNvbGxpZGVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5Db2xsaWRlcn0gY29sbGlkZXIgUGFpcnMgY29sbGlkZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19yZW1vdmVQYWlycyhjb2xsaWRlcikge1xyXG4gICAgY29uc3QgcGFpcnMgPSB0aGlzLm1QYWlycztcclxuICAgIGNvbnN0IHBhaXJzSGFzaCA9IHRoaXMubVBhaXJzSGFzaDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gcGFpcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgY29uc3QgcGFpciA9IHBhaXJzW2ldO1xyXG5cclxuICAgICAgaWYgKHBhaXIuYSA9PT0gY29sbGlkZXIgfHwgcGFpci5iID09PSBjb2xsaWRlcikge1xyXG4gICAgICAgIHBhaXJzLnNwbGljZShpLCAxKTtcclxuXHJcbiAgICAgICAgaWYgKHBhaXIgaW5zdGFuY2VvZiBCb3hUb0JveFBhaXIpXHJcbiAgICAgICAgICBCb3hUb0JveFBhaXIucG9vbC5yZWxlYXNlKHBhaXIpO1xyXG4gICAgICAgIGVsc2UgaWYgKHBhaXIgaW5zdGFuY2VvZiBCb3hUb0NpcmNsZVBhaXIpXHJcbiAgICAgICAgICBCb3hUb0NpcmNsZVBhaXIucG9vbC5yZWxlYXNlKHBhaXIpO1xyXG4gICAgICAgIGVsc2UgaWYgKHBhaXIgaW5zdGFuY2VvZiBDaXJjbGVUb0NpcmNsZVBhaXIpXHJcbiAgICAgICAgICBDaXJjbGVUb0NpcmNsZVBhaXIucG9vbC5yZWxlYXNlKHBhaXIpO1xyXG5cclxuICAgICAgICAvL3BhaXIuY29uc3RydWN0b3IucG9vbC5yZWxlYXNlKHBhaXIpO1xyXG5cclxuICAgICAgICBkZWxldGUgcGFpcnNIYXNoW1BhaXIuX19pZChwYWlyLmEsIHBhaXIuYildO1xyXG5cclxuICAgICAgICBwYWlyLmJvZHlBLm1QYWlycy5zcGxpY2UocGFpci5ib2R5QS5tUGFpcnMuaW5kZXhPZihwYWlyKSwgMSk7XHJcbiAgICAgICAgcGFpci5ib2R5Qi5tUGFpcnMuc3BsaWNlKHBhaXIuYm9keUIubVBhaXJzLmluZGV4T2YocGFpciksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uUG9zdFVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IGR0ID0gdGhpcy5kZWx0YTtcclxuICAgIGNvbnN0IGNvbnRhY3RzID0gdGhpcy5tQ29udGFjdHM7XHJcbiAgICBjb25zdCBib2RpZXMgPSB0aGlzLm1Cb2RpZXM7XHJcbiAgICBjb25zdCBwYWlycyA9IHRoaXMubVBhaXJzO1xyXG4gICAgY29udGFjdHMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAvLyByZWZyZXNoIGJvZHkgY29sbGlkZXJzIGlmIHNjYWxlLCByb3RhdGlvbiBjaGFuZ2VkXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGJvZGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgY29uc3QgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgYm9keS51cGRhdGUoKTtcclxuICAgICAgYm9keS5tQ29udGFjdHMubGVuZ3RoID0gMDtcclxuICAgICAgYm9keS5tSW5Hcm91cCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlc2V0IGVhY2ggcGFpciB0byBkZWZhdWx0c1xyXG4gICAgLy8gc28gcGhhc2VzIHdpbGwga25vdywgaWYgcGFpciBpbiBjb2xsaXNpb24gaXMgdHJ1ZSwgdGhlbiBpdCBuZWVkcyBtb3JlIHByZWNpc2UgY2hlY2tcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgIHBhaXIubUlzU3RhdGljID0gKHBhaXIuYm9keUEubUlzU2xlZXBpbmcgfHwgcGFpci5ib2R5QS5tSW52TWFzcyA9PT0gMCkgJiZcclxuICAgICAgICAocGFpci5ib2R5Qi5tSXNTbGVlcGluZyB8fCBwYWlyLmJvZHlCLm1JbnZNYXNzID09PSAwKTtcclxuXHJcbiAgICAgIGlmIChwYWlyLm1Jc1N0YXRpYyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBwYWlyLm1JbkNvbGxpc2lvbiA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgcGFpcnMgaW4gY29sbGlzaW9uIGZsYWcgdG9kb1xyXG4gICAgLy8gdGhpcy5tQnJvYWRQaGFzZS50ZXN0KHBhaXJzKTtcclxuXHJcbiAgICAvLyBuYXJyb3cgY29sbGlzaW9uIHRlc3RcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgIGlmIChwYWlyLm1JbkNvbGxpc2lvbiAmJiBwYWlyLm1Jc1N0YXRpYyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBwYWlyLnRlc3QoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhaXIgPSBwYWlyc1tpXTtcclxuXHJcbiAgICAgIGlmIChwYWlyLm1JbkNvbGxpc2lvbikge1xyXG4gICAgICAgIHBhaXIubUlzU3RhdGljID09PSBmYWxzZSAmJiBjb250YWN0cy5wdXNoKHBhaXIpO1xyXG4gICAgICAgIHBhaXIuYm9keUEubUNvbnRhY3RzLnB1c2gocGFpcik7XHJcbiAgICAgICAgcGFpci5ib2R5Qi5tQ29udGFjdHMucHVzaChwYWlyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYWlyLm1Ob3JtYWxJbXB1bHNlID0gMDtcclxuICAgICAgICBwYWlyLm1UYW5nZW50SW1wdWxzZSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fc29sdmUoZHQpO1xyXG5cclxuICAgIGlmICghdGhpcy5tU2xlZXBFbmFibGVkKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgY29uc3QgZ3JvdXAgPSBbXTtcclxuICAgIGNvbnN0IHN0YWNrID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBib2RpZXNbaV07XHJcbiAgICAgIGJvZHkuY2xlYXJGbGFncygpOyAvLyBjbGVhciBjb2xsaWRlcnMgZGlydHkgZmxhZ3NcclxuXHJcbiAgICAgIGlmIChib2R5Lm1Jbkdyb3VwIHx8IGJvZHkubUlzU2xlZXBpbmcgfHwgYm9keS5tSW52TWFzcyA9PT0gMClcclxuICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgIGdyb3VwLmxlbmd0aCA9IDA7XHJcbiAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICBzdGFjay5wdXNoKGJvZHkpO1xyXG5cclxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICBjb25zdCBjb250YWN0cyA9IGJvZHkubUNvbnRhY3RzO1xyXG5cclxuICAgICAgICBncm91cC5wdXNoKGJvZHkpO1xyXG4gICAgICAgIGJvZHkubUluR3JvdXAgPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgY29udGFjdCA9IGNvbnRhY3RzW2ldO1xyXG4gICAgICAgICAgY29uc3Qgb3RoZXIgPSBjb250YWN0LmJvZHlBID09PSBib2R5ID8gY29udGFjdC5ib2R5QiA6IGNvbnRhY3QuYm9keUE7XHJcblxyXG4gICAgICAgICAgaWYgKG90aGVyLm1Jbkdyb3VwIHx8IG90aGVyLm1JbnZNYXNzID09PSAwKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICBzdGFjay5wdXNoKG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBpc1NsZWVwaW5nID0gdHJ1ZTtcclxuICAgICAgY29uc3Qgc2xlZXBUaHJlc2hvbGQgPSBQYWlyLnNsZWVwVGhyZXNob2xkICogUGFpci51bml0c1Blck1ldGVyICogQmxhY2suc3RhZ2UubVNjYWxlWDtcclxuXHJcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZ3JvdXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYm9keSA9IGdyb3VwW2ldO1xyXG4gICAgICAgIGNvbnN0IHZlbG9jaXR5ID0gYm9keS5tVmVsb2NpdHk7XHJcbiAgICAgICAgYm9keS5tU2xlZXBUaW1lID0gdmVsb2NpdHkueCAqIHZlbG9jaXR5LnggKyB2ZWxvY2l0eS55ICogdmVsb2NpdHkueSA8IHNsZWVwVGhyZXNob2xkID8gYm9keS5tU2xlZXBUaW1lICsgMSA6IDA7XHJcbiAgICAgICAgaXNTbGVlcGluZyA9IGlzU2xlZXBpbmcgJiYgYm9keS5tU2xlZXBUaW1lID4gUGFpci50aW1lVG9TbGVlcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBncm91cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBncm91cFtpXS5tSXNTbGVlcGluZyA9IGlzU2xlZXBpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvbHZlIGNvbnRhY3RzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHQgVGltZSBmcm9tIGxhc3QgdXBkYXRlLCBtcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19zb2x2ZShkdCkge1xyXG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IHRoaXMubUl0ZXJhdGlvbnM7XHJcbiAgICBjb25zdCBjb250YWN0cyA9IHRoaXMubUNvbnRhY3RzO1xyXG4gICAgY29uc3QgYm9kaWVzID0gdGhpcy5tQm9kaWVzO1xyXG4gICAgY29uc3QgZ3Jhdml0eSA9IHRoaXMubUdyYXZpdHk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGJvZHkgPSBib2RpZXNbaV07XHJcblxyXG4gICAgICBpZiAoYm9keS5tSW52TWFzcyA9PT0gMCB8fCBib2R5Lm1Jc1NsZWVwaW5nKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgY29uc3QgZm9yY2UgPSBib2R5Lm1Gb3JjZTtcclxuICAgICAgY29uc3QgdmVsb2NpdHkgPSBib2R5Lm1WZWxvY2l0eTtcclxuICAgICAgY29uc3QgaW52TWFzcyA9IGJvZHkubUludk1hc3M7XHJcbiAgICAgIGNvbnN0IGRhbXBpbmcgPSAxIC0gYm9keS5mcmljdGlvbkFpcjtcclxuXHJcbiAgICAgIHZlbG9jaXR5LnggPSAodmVsb2NpdHkueCArIChmb3JjZS54ICogaW52TWFzcyArIGdyYXZpdHkueCkgKiBkdCkgKiBkYW1waW5nO1xyXG4gICAgICB2ZWxvY2l0eS55ID0gKHZlbG9jaXR5LnkgKyAoZm9yY2UueSAqIGludk1hc3MgKyBncmF2aXR5LnkpICogZHQpICogZGFtcGluZztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNvbnRhY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBjb250YWN0c1tpXS5wcmVTb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gY29udGFjdHMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgY29udGFjdHNbal0uc29sdmVWZWxvY2l0eSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdW5pdHNQZXJNZXRlckR0ID0gQmxhY2suc3RhZ2UubVNjYWxlWCAqIFBhaXIudW5pdHNQZXJNZXRlciAqIGR0O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYm9kaWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBjb25zdCBib2R5ID0gYm9kaWVzW2ldO1xyXG4gICAgICBib2R5Lm1Gb3JjZS5zZXQoMCwgMCk7XHJcblxyXG4gICAgICBpZiAoYm9keS5tSW52TWFzcyA9PT0gMCB8fCBib2R5Lm1Jc1NsZWVwaW5nKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBib2R5Lm1Qb3NpdGlvbjtcclxuICAgICAgY29uc3QgdmVsb2NpdHkgPSBib2R5Lm1WZWxvY2l0eTtcclxuXHJcbiAgICAgIHBvc2l0aW9uLnggKz0gdmVsb2NpdHkueCAqIHVuaXRzUGVyTWV0ZXJEdDtcclxuICAgICAgcG9zaXRpb24ueSArPSB2ZWxvY2l0eS55ICogdW5pdHNQZXJNZXRlckR0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gY29udGFjdHMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgY29udGFjdHNbal0uc29sdmVQb3NpdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGJvdW5kcyB0byBkZWZhdWx0IHZhbHVlcy5cclxuICAgKiBTaG91bGQgYmUgY2FsbGVkIG9uIHN0YXJ0IGFuZCBvbiByZXNpemUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19zZXRCb3VuZHMoKSB7XHJcbiAgICBjb25zdCBib3VuZHMgPSBCbGFjay5zdGFnZS5ib3VuZHM7XHJcbiAgICBjb25zdCB0aGlja25lc3MgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbiAgICB0aGlzLm1Cb3VuZHNMZWZ0LnNldCgtdGhpY2tuZXNzLCAwLCB0aGlja25lc3MsIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgdGhpcy5tQm91bmRzUmlnaHQuc2V0KGJvdW5kcy53aWR0aCwgMCwgdGhpY2tuZXNzLCBib3VuZHMuaGVpZ2h0KTtcclxuICAgIHRoaXMubUJvdW5kc1RvcC5zZXQoLXRoaWNrbmVzcywgLXRoaWNrbmVzcywgYm91bmRzLndpZHRoICsgdGhpY2tuZXNzICogMiwgdGhpY2tuZXNzKTtcclxuICAgIHRoaXMubUJvdW5kc0JvdHRvbS5zZXQoLXRoaWNrbmVzcywgYm91bmRzLmhlaWdodCwgYm91bmRzLndpZHRoICsgdGhpY2tuZXNzICogMiwgdGhpY2tuZXNzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZWQgb3IgZGlzYWJsZXMgd29ybGQgY29sbGlkaW5nIGJvdW5kcy5cclxuICAgKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHYgVmFsdWUgdG8gc2V0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBib3VuZHNFbmFibGVkKHYpIHtcclxuICAgIGlmICh2KSB7XHJcbiAgICAgIGlmICghdGhpcy5tQm91bmRzQm9keSkge1xyXG4gICAgICAgIHRoaXMubUJvdW5kc0JvZHkgPSBuZXcgUmlnaWRCb2R5KCk7XHJcbiAgICAgICAgdGhpcy5tQm91bmRzQm9keS5pc1N0YXRpYyA9IHRydWU7XHJcblxyXG4gICAgICAgIEJsYWNrLnN0YWdlLmFkZENvbXBvbmVudCh0aGlzLm1Cb3VuZHNMZWZ0KTtcclxuICAgICAgICBCbGFjay5zdGFnZS5hZGRDb21wb25lbnQodGhpcy5tQm91bmRzUmlnaHQpO1xyXG4gICAgICAgIEJsYWNrLnN0YWdlLmFkZENvbXBvbmVudCh0aGlzLm1Cb3VuZHNUb3ApO1xyXG4gICAgICAgIEJsYWNrLnN0YWdlLmFkZENvbXBvbmVudCh0aGlzLm1Cb3VuZHNCb3R0b20pO1xyXG5cclxuICAgICAgICB0aGlzLl9fc2V0Qm91bmRzKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIEJsYWNrLnN0YWdlLmFkZENvbXBvbmVudCh0aGlzLm1Cb3VuZHNCb2R5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIEJsYWNrLnN0YWdlLnJlbW92ZUNvbXBvbmVudCh0aGlzLm1Cb3VuZHNCb2R5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGdyYXZpdHkgeC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2IFZhbHVlIHRvIHNldC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBncmF2aXR5WCh2KSB7XHJcbiAgICB0aGlzLm1HcmF2aXR5LnggPSB2O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGlzIGdyYXZpdHkgeC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZ3Jhdml0eVgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tR3Jhdml0eS54O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgZ3Jhdml0eSB5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHYgVmFsdWUgdG8gc2V0LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGdyYXZpdHlZKHYpIHtcclxuICAgIHRoaXMubUdyYXZpdHkueSA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgZ3Jhdml0eSB5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBncmF2aXR5WSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1HcmF2aXR5Lnk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBjb3VudCBvZiBzb2x2aW5nIGl0ZXJhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdiBWYWx1ZSB0byBzZXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgaXRlcmF0aW9ucyh2KSB7XHJcbiAgICB0aGlzLm1JdGVyYXRpb25zID0gdjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhpcyBjb3VudCBvZiBzb2x2aW5nIGl0ZXJhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGl0ZXJhdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tSXRlcmF0aW9ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHNsZWVwIGFsbG93ZWQgZmxhZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdiBWYWx1ZSB0byBzZXQuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc2xlZXBFbmFibGVkKHYpIHtcclxuICAgIHRoaXMubVNsZWVwRW5hYmxlZCA9IHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoaXMgc2xlZXBBbGxvd2VkIGZsYWcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBzbGVlcEVuYWJsZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tU2xlZXBFbmFibGVkO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5NZXNzYWdlRGlzcGF0Y2hlclxyXG4gKiBAY2F0IGNvcmVcclxuICovXHJcbmNsYXNzIFNwbGFzaFNjcmVlbiBleHRlbmRzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcclxuICBjb25zdHJ1Y3RvcihkdXJhdGlvbiA9IDQyMDApIHtcclxuICAgIHN1cGVyKGZhbHNlKTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3ZnTG9nbyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0MS44IDIyMC4yXCI+PGRlZnM+PHN0eWxlPi5ie2ZpbGw6I2Y1ZjVmNX0uY3tmaWxsOnVybCgjYSl9PC9zdHlsZT48cGF0dGVybiBpZD1cImFcIiB3aWR0aD1cIjE3LjZcIiBoZWlnaHQ9XCIxNC44N1wiIHBhdHRlcm5Vbml0cz1cInVzZXJTcGFjZU9uVXNlXCIgdmlld0JveD1cIjAgMCAxNy42IDE0LjlcIj48cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDE3LjZ2MTQuODdIMHpcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk0wIDEzLjR2MS41aDEuNUExLjUgMS41IDAgMCAxIDAgMTMuNHpcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk04LjggMGExLjUgMS41IDAgMCAxIDEuNSAxLjUgMS41IDEuNSAwIDEgMS0zIDBBMS41IDEuNSAwIDAgMSA4LjggMEgwdjEzLjRhMS41IDEuNSAwIDAgMSAxLjUtMS41QTEuNSAxLjUgMCAwIDEgMyAxMy40YTEuNSAxLjUgMCAwIDEtMS41IDEuNWg0LjNhMS41IDEuNSAwIDAgMS0xLjUtMS41IDEuNSAxLjUgMCAwIDEgMS41LTEuNSAxLjQgMS40IDAgMCAxIDEuNSAxLjUgMS41IDEuNSAwIDAgMS0xLjUgMS41aDZhMS41IDEuNSAwIDAgMS0xLjUtMS41IDEuNSAxLjUgMCAwIDEgMyAwIDEuNSAxLjUgMCAwIDEtMS41IDEuNWg1LjhWMHptNi42LjdhMS41IDEuNSAwIDAgMSAxLjUgMS41IDEuNSAxLjUgMCAwIDEtMS41IDEuNSAxLjQgMS40IDAgMCAxLTEuNS0xLjVBMS41IDEuNSAwIDAgMSAxNS40Ljd6TS40IDIuMkExLjUgMS41IDAgMCAxIDEuOS43YTEuNSAxLjUgMCAwIDEgMS41IDEuNSAxLjUgMS41IDAgMCAxLTEuNSAxLjVBMS41IDEuNSAwIDAgMSAuNCAyLjJ6bTEuNyA1LjdBMS41IDEuNSAwIDAgMSAuNiA2LjRhMS41IDEuNSAwIDAgMSAxLjUtMS41IDEuNSAxLjUgMCAwIDEgMCAzem0yIDMuOGExLjUgMS41IDAgMCAxLTEuNS0xLjUgMS41IDEuNSAwIDAgMSAxLjUtMS41IDEuNSAxLjUgMCAwIDEgMS41IDEuNSAxLjUgMS41IDAgMCAxLTEuNSAxLjV6bS4yLThhMS41IDEuNSAwIDAgMSAxLjUtMS41IDEuNSAxLjUgMCAwIDEgMS41IDEuNSAxLjQgMS40IDAgMCAxLTEuNSAxLjUgMS41IDEuNSAwIDAgMS0xLjUtMS41em0yLjIgMy41YTEuNSAxLjUgMCAxIDEgMyAwIDEuNSAxLjUgMCAwIDEtMyAwem0yLjIgNS4zYTEuNSAxLjUgMCAxIDEgMS41LTEuNSAxLjUgMS41IDAgMCAxLTEuNSAxLjV6bTEuNC04YTEuNSAxLjUgMCAwIDEgMyAwIDEuNSAxLjUgMCAxIDEtMyAwem0yLjUgNS43YTEuNSAxLjUgMCAwIDEtMS41LTEuNSAxLjUgMS41IDAgMCAxIDEuNS0xLjUgMS40IDEuNCAwIDAgMSAxLjUgMS41IDEuNSAxLjUgMCAwIDEtMS41IDEuNXptMyAzLjVhMS41IDEuNSAwIDAgMS0xLjUtMS41IDEuNSAxLjUgMCAwIDEgMS41LTEuNSAxLjUgMS41IDAgMCAxIDEuNSAxLjUgMS40IDEuNCAwIDAgMS0xLjUgMS41em0wLTUuNWExLjUgMS41IDAgMCAxLTEuNS0xLjUgMS41IDEuNSAwIDAgMSAxLjUtMS41IDEuNSAxLjUgMCAwIDEgMS41IDEuNSAxLjQgMS40IDAgMCAxLTEuNSAxLjV6XCIvPjwvcGF0dGVybj48L2RlZnM+PHBhdGggY2xhc3M9XCJjXCIgZD1cIk0yNS44IDEwNS4yYzEyLjEgOC44IDI5LjcgNi43IDU5LjggNi44LTcuOS03LjMtOS4xLTE4LjctNy4xLTI3LjMtNi42IDcuMy01LjEgMTkuMy0xMi44IDE5LjQtMy40LjEtNi45LTQuNy04LjMtMTAuOC01LjMgOS40LTEyIDEwLjctMTQuNy00LjUtMi4zIDItMy45IDguMi05LjUgNi4yUzI2LjggODEuOCAzMCA3MS4zQTI4LjMgMjguMyAwIDAgMSAxNC42IDYxYy0xLjQgMjAuOC41IDM2LjQgMTEuMiA0NC4yek01MS45IDM5LjljMjkuNy0zLjYgNTQtMjIuOCA2OS41LTI2LjMtLjEgMC00MC43LS4zLTcyLjMgMS45IDYuMiAzLjUgMTAuNSAxNi4zIDIuOCAyNC40ek0xNzAuNCAzNC4yYzUuNi0yIDMyLjEtOS41IDU0LjQtMi43LTMtMTMuNy0yMi45LTE3LTcxLjgtMTcuOGEzMi4yIDMyLjIgMCAwIDEgMTcuNCAyMC41ek0yMTEuMyAxMDkuM2MtMTIuMiAyLjEtMTIuOC04LjgtMzIuOS04LjktMTUuNSAwLTM1LjIgMTMuMi0zNi4xIDEzLjdoNDkuM2MxOS4xIDAgMzIuNS0uNiAzNS41LTcuM3MtMi43LTEyLjMtMTAuNy0xNS42YzUuMyA1LjYgNC4xIDE2LjUtNS4xIDE4LjF6TTY2IDE4OS4yYy01LjkgNS0yNiAxNy44LTQzLjYgNi4zIDMuNiA4LjQgMTMuNiAxMi43IDQ1LjEgMTItMS42LTIuNC01LjMtMTAuNC0xLjUtMTguM3pNMzIgMTYxLjVjNy4zIDcuOCAxOC4xIDIuNiAzMy43LTYuMiAxMC41LTYgMjcuNS05LjkgNDAuNi0xLjEgMy43LTguNyA1LjQtMTAuOSA2LjctMTAuNnMuNyAyLjcgNS42IDdjLjQtMSAzLjgtNy45IDMuOC0xMmwtNTkuOS0uOGMtMS41IDYuNi05LjkgMTktMjMuOSAxNy40LTIuNC0uMy0yLjUtMTEuNiAyLjQtMTYuOWEzNi43IDM2LjcgMCAwIDAtNy40LjljLTQuNCA1LjEtNyAxNi40LTEuNiAyMi4zek0xNTAuOSAxNDguMWMyMy42LS41IDI2IDE5LjkgNDEuMSAyMSAxMC45LjkgMTMuNi0xNi44IDM1LjctMTEuOC0xLjMtMTEuMS03LjctMTYuMi0yMi4yLTE3LjQgMyAxMC4zLTYuNiAyOC41LTE5LjMgMjEuNWExLjUgMS41IDAgMCAxLS44LTEuMWMtLjktMTEgMi44LTE1LjggNy41LTIwLjdsLTU1LjctLjdhMTguNSAxOC41IDAgMCAxIDMuNyAxMi40IDIwLjcgMjAuNyAwIDAgMSAxMC0zLjJ6TTE2MiAxOTUuOWMtMy45IDMuNi0zLjggOS41LTIuNSAxMi41aDQuMWMwLTE0LjggMTctMTIuOCAyMS4yLS44IDIyLjctMS41IDMwLjktMy4yIDM2LTguN3M2LjQtMTUuMyA2LjgtMjcuMWMtMi42IDMtOS44IDE0LjctMTAuOSAxNi40LTE3LjggMjYuMy0zOS45LTUuOS01NC43IDcuN3pcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk0xNTAgNDIuNmMtLjIgMTAuNC05LjggMTMuNi05LjQtLjctMTYuMiAxLjktMTQuNSA4LjUtMTMuNyA5LjUgNC40IDUuNiAyOSA0LjUgMjcuMy00LjNhNS43IDUuNyAwIDAgMC00LjItNC41elwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTE2Mi4yIDQ2LjRjLTEuNy0xNS43LTE3LjItMTguMi0yOC40LTE1LjZzLTIyLjMgMTIuNy0xNS42IDI1LjQgNDYuMiAxMC4zIDQ0LTkuOHptLTM3LjggNi43Yy01LjQtOS43IDEwLjYtMTMuNCAxMy4yLTEzLjggNy41LTEuMyAxOC4yLTEuMiAxOS42IDcuNiAyIDEzLjItMjguOCAxMy4zLTMyLjggNi4yek0xODQuNyA2OC44Yy0xLjEgMC0xLjEgMy4zLTUuNCAxMi41LjMgMCA1LjggMCA4LjYuMi0uNy05LjEtMi4xLTEyLjctMy4yLTEyLjd6TTE2Mi41IDgyLjlsNy0xLjFjLTIuNS00LjYtNS44LTguNi03IDEuMXpNMTUzLjEgNzQuNWE1NS44IDU1LjggMCAwIDAtNy44IDJjNi40IDkuNCA3LjQgMi4yIDcuOC0yek0xMzQuOCA5NC42Yy40LS4yIDQuOS0zLjEgNi45LTQuMS0xLjktMi04LjEtOS45LTYuOSA0LjF6TTE5MC45IDgxLjhhNTguMyA1OC4zIDAgMCAxIDkgMS41IDc3LjcgNzcuNyAwIDAgMCAuNC04LjhjLTEuNy0uMy03LjItMS4yLTEwLjMtMS41YTUyIDUyIDAgMCAxIC45IDguOHpcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk0yMTYuNSA3Ni4yYTM5LjEgMzkuMSAwIDAgMS01LjYgMTAuNGMxMyAzIDI1LjMgMTAuOCAxOC4xIDIzLjEtMy44IDYuNi0xNi40IDcuNS0zNy40IDcuNWwtNTUuNC0uMmEzMi4zIDMyLjMgMCAwIDEtMTguOCAxLjFjLTYuOCAxLjUtMTguMiAzLjctMjguMi0zLjEtMzAuOC0uNC00OS43IDMuMi02NC45LTcuMUM2LjQgOTUuNyAxMS42IDYwLjMgMTIgNTYuOGMtNi40LTEyLjUtLjgtMjkuNCAyLjMtMzQuMVMyOS40IDcuNSA0NC40IDEzYy4yLS4xIDI3LjUtMi40IDc2LTIuNCA3NC40IDAgMTA1LjIuOCAxMDcuNiAyMi4zIDYgMi40IDEzLjIgMTMgNi4yIDIxIDQuOCA5LjQuMSAxOS4xLTkuNyAyMS41YTM3LjQgMzcuNCAwIDAgMSAxMC43IDUuN2MxLjQtMi41IDguNS0xOS44IDQuOC00MS45LTQuNS0yNy4xLTE3LjktMzMuMi0zNS40LTM0LjlDMTU3LjkgMCA4OC41LjIgODEuNy4xIDM4LjEtLjMgMTguMi0uNSA4LjEgMjIuMi0zLjEgNDcuNi0yLjYgOTEuNyA5LjEgMTA4YzcuNyAxMC43IDE5LjEgMTUuMyAzNy45IDE1LjMgMzQuNSAwIDE0MS4zIDEuNCAxNjUuMyAxLjggMTEtLjMgMjcuOS0zLjQgMjkuMy0xOS43cy02LjgtMjUuMi0yNS4xLTI5LjJ6XCIvPjxwYXRoIGNsYXNzPVwiYlwiIGQ9XCJNMjAyLjcgODguNmMxLjMtLjIgNi41LTIgMTAuNy0xMi42LTMtLjItNi4zLS41LTEwLjEtMS4xLjggMTEuNC0zIDE0LS42IDEzLjd6XCIvPjxwYXRoIGNsYXNzPVwiYlwiIGQ9XCJNMjMxLjkgNTZjLTcuNiA1LjUtMTguMiAxLjgtMTkuOC0zLjQtMi42LTguNiA0LjQtMTAuOSA2LjctMTAuNiA3LjcuOCA3IDYuMSA0IDguMWExLjUgMS41IDAgMCAxLTEuOS0yLjRjMS44LTEuMyAwLTIuOC0yLjEtMi43cy01LjQgMS0zLjggNi43IDE3LjEgNy4zIDE4LjktNC40YzEtNi44LTUuOC0xNi40LTMyLjUtMTUuNGExMDguNSAxMDguNSAwIDAgMC0zMC40IDUuMmMxLjIgOC4zLTEuOSAxNS43LTguNSAyMC4xLTUuMyAxMS4yLTQxLjYgMTcuOS00OC40LTIuNy03LjUuOC0xMy4xIDEwLTEzLjkgMTQuOWExLjQgMS40IDAgMCAxLTEuNiAxLjJjLTYuNS0uNy0xNi43IDMuNi0xNy45IDIwLTEuMyAxOC4zIDE0LjkgMjkuMiAzMS43IDI1LjRhMjEuNyAyMS43IDAgMCAxLTUtMy41Yy01LjctLjItMTMuNy0xLjEtMTcuNC0xMi4xLS42LTEuNyAyLjEtMy4yIDIuOS0uOSAyLjUgNy44IDguMyA5LjYgMTEuOCAxMGEyMy4zIDIzLjMgMCAwIDEtNC40LTEzLjNjLS4xLTIuNSAzLTIgMy0uMi0uMSAxMi4zIDE0LjUgMjkuNCA0MiAxMyAzMy45LTIwLjIgNTAuOC04LjEgNTUuOC01IDEuNC45IDkuMiA1LjIgMTMuNy4xIDEuOC0yIDQuMS0xMC4zLTYuNC0xNC45LTQuMiAzLjctMTEuNSAzLjMtOC45LTMtMzIuMS01LjctNTAuMiAyLjctNjEuOCAxMC4ycy0xNi40LjMtMTctMi41Yy0xLjgtOC40IDE2LjYtMjYuMiA2MC4yLTI0LjYgMS4zLTMuOSA1LjMtNS43IDguMS42IDcuNC42IDE4IDMuMiAyOC45IDMuMnMxOC4yLTUuMyAxNC0xNy4xelwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTE3NiA4MS4zbDMuOC05LjFhMTA3LjcgMTA3LjcgMCAwIDAtMjMuNiAxLjZjLTEuMSAxNS43LTkuNiAxMC45LTEzLjggMy42LTI3LjMgMTAuNi0xOS4xIDIyLjctMTAuNSAxOC42LTEuNi0xNS43IDYtMTUgMTIuNS03YTc3LjQgNzcuNCAwIDAgMSAxNS4xLTUuNGMxLjQtMTUuNiAxMC05LjYgMTMuMy0yLjF6TTY1LjggMTAxLjFjNS4yLS40IDEuNC0xMC40IDE3LTI2LjIgMTMuMS0xMy4yLTcuOS0yNi42LTE3LjktMTNzLTQuNCAzOS42LjkgMzkuMnpcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk00OS44IDYzLjljLTQuNyA2LjItNi42IDIwLjItMi40IDMwLjYgMi45IDcgNi45LTEuNSA5LjMtNS40LTEuMi04LjggMC0yMC41IDUuMi0yOC4xLTUuNi0zLjUtMTAuMS4zLTEyLjEgMi45ek0zMi4zIDc0LjNjLTIuNCAxMC40LS42IDE3LjMgMi42IDE4LjFzNC43LTUuNCA3LjMtNy42Yy0uNi03LjcuOS0xNS44IDQuMi0yMS4yLTguNy0zLjEtMTIuOCA1LjMtMTQuMSAxMC43elwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTEyLjIgMzkuOWMtMS44IDIyLjEgMTUuMiAyOCAxOC45IDI4LjUgMS43LTMuNiA2LjgtMTEuNCAxNy4yLTcuMyA1LjUtNi40IDEyLTQuOCAxNS41LTIuNUM3My45IDQ4LjIgOTIgNTMuOCA4OS42IDY5LjNhMTYuNiAxNi42IDAgMCAxIDcuOS0xLjdjMS43LTUuOSA3LjctMTQuOSAxNS45LTE2LjFhMTguNiAxOC42IDAgMCAxIDUuMS0xNS4yYy00IDEuNi0yMC42IDEwLjYtMjguMSAxMi4zLTEuNC4zLTIuNC0yLjQtLjMtMyA5LjMtMi41IDI2LjktMTMuNSA0Mi44LTE3LjYgMTkuNS01LjIgMzQuNSA2LjcgMzIuMSAyMi44IDEwLjEtMTQuNS01LjQtMzQuNi0yMC43LTM2LjQtMzMuNC00LjEtNTMuMyAyNi41LTk4LjggMjguOS03IC40LTExLjktMi0xMy43LTZzLS45LTkgMy43LTEwLjZjMi4xLS43IDMuNSAyLjMgMS4xIDIuOHMtNC45IDkuMiA0LjggMTAuN2MxMi43IDIgMTQuNS0xNC4zIDcuMy0yMS4ycy0zNC05LjQtMzYuNSAyMC45ek0xMDguOCAxNTZhMzAuMSAzMC4xIDAgMCAxIDYuOCA4LjIgNDUuNSA0NS41IDAgMCAxIDItMTAuNiAxNy40IDE3LjQgMCAwIDEtNS01LjcgNDcuNSA0Ny41IDAgMCAwLTMuOCA4LjF6TTQwLjMgMTUyLjRjNy4yLjYgMTguNC02LjEgMTkuNy0xNy43LTIwLjMtLjMtMjAuNSAxMy0xOS43IDE3Ljd6TTEwNS41IDE4Mi44Yy05LjUtMjAuMS0zMC4yLTEzLjYtNDYuNy0yLjItMTQuOCAxMC4zLTI5LjQgNy43LTM1LjguMWEzMS41IDMxLjUgMCAwIDEtNC42LTMyLjRDNSAxNjggMTQuNiAxODcuOCAyNC44IDE5My41YzE4LjcgMTAuNSAzNy44LTUgNDEuNi04LjUgMTIuNC0xMS4yIDI4LjgtMTEuOCAzMy40IDIuMiA0IDEyLjItNy42IDIxLjYtMTUuOSAxOC4xLTEwLjctNC40LTYuNC0xMy41LTMuMS0xNS4xYTcuNCA3LjQgMCAwIDEgOC43IDEuOWMxLjIgMS4zLS41IDMuNi0yLjEgMi4xcy0zLjUtMi4xLTUuMS0xLjMtNC4zIDcuNiAyLjYgOS42YzguOSAyLjYgMTQuNy03LjEgMTItMTQuNC0zLjktMTAuNy0xNS4yLTguOS0xOS45LTYuNi0xNC41IDcuMi0xMi44IDMwIDYgMzAuNyAyMy4yLjkgMjctMTkuOCAyMi41LTI5LjR6TTE4OC40IDE1OS4yYzExLjYgNC41IDE4LjctMTUuOCAxMS43LTIzLjktNC4yIDcuNi0xMy4xIDEwLjItMTEuNyAyMy45elwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTE5MS45IDE3Mi4xYy0xNS42LS40LTIwLjgtMjMuMS00MS45LTIwLjktMjQgMi41LTI0LjggNDUuNi0xMy4xIDU3LjZoMy4xYy00LjEtOS40LTYuNy0yOC4xIDcuOC0zOC4yIDEuNy0xLjEgMy42IDEuMyAxLjcgMi41LTEzLjYgOS40LTEwLjIgMjcuNi02LjIgMzUuN2gzLjVjLTQuMi04LjQtMy42LTIxLjMgMi40LTI3LjMgMTguNS0xOC4zIDQ0LjkgMTYuNCA1Ny4xLS41IDgtMTEuMSAxMi43LTE3LjggMjYuOC0xNi45YTEzLjMgMTMuMyAwIDAgMC03LTRjLTE5LjctNC4xLTIwLjcgMTIuNC0zNC4yIDEyelwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTIwOC42IDE4Mi44Yy0xMy43IDE4LjgtNDAuNy0xNS44LTU3LjIuNy01LjQgNS40LTUuNiAxOC0xLjIgMjUuMWg2LjFjLTItNS42LjYtMTIuMSAzLjgtMTQuOSAxNy42LTE1IDM3LjYgMTcuNiA1NC4yLTcuMyAxLTEuNSA4LjMtMTQuNSAxMy45LTE5LjMtMTAuNS42LTE0LjQgOC42LTE5LjYgMTUuN3pcIi8+PHBhdGggY2xhc3M9XCJiXCIgZD1cIk0yMzguOCAxNTEuM2MtNC0xNC4xLTEzLjctMjMtMjUuMy0yMy4yLS4zIDAtMTIwLTEuOC0xNjMuNS0xLjgtNDAuOCAwLTQ0LjkgMjEuNC00Ny4zIDM0LjItMy44IDIwLjQgMy45IDQwLjEgOC45IDQ2LjEgOS40IDExLjQgMjUuMyAxMy42IDQ4IDEzLjZsMTI4LjQtLjNjMzUuOSAwIDQ0LjgtMTIuNiA0OC40LTIzLjYgNC43LTE0IDUuNy0zMy4zIDIuNC00NXptLTEuMyAxNS4yYy0xLjUgMS41LTMuMy0uNy02LjggMi4zLjEgMjYuNS02LjMgMzUuNC0xOSAzOC40LTE2LjEgMy44LTQzLjQgNC43LTExMi43IDQuNC01LjggMy44LTE5LjggNi42LTI5LTEuMi0yMy4xLjctNDguOC40LTUxLjctMTguMS00LjktNC44LTEyLjMtMTUuOS04LjItMzMuMiA1LjItMjEuMyAyMi4xLTI0LjMgMzQuNi0yMy45IDQuMi0yLjYgMTAtMy45IDE3LTMuNCAyIC4yIDEuNCAyLjUgMS4zIDNsNTkuMy44Yy4xLTItLjktMi41LjEtMy45czguOSAxLjcgMTEuOCA0LjFsNjEuMSAxYzQuMi00LjMgMy42LTEwIDkuMiAwIDEyLjQuOSAyNSA0LjMgMjYuMyAyMS44IDMuNyAxLjggOC4xIDYuNCA2LjcgNy45elwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTE2Ni42IDIwOC4zbDE1LjEtLjZjLTMuOC04LjQtMTUuNC0xMC4yLTE1LjEuNnpNMTEzLjMgMTY2LjJjLTExLjEtMTkuOS0zMy44LTE1LjItNDYuMS04LjMtMTYuNCA5LjEtMjguNiAxNS4xLTM3LjQgNS42LTUuNy02LjEtNC4zLTE2LjctLjUtMjMuNC0xMi44IDYuNi0xMy4zIDI4LjEtNCAzOC42IDUuNyA2LjUgMTguNSA4LjcgMzEuOC0uNSAxNi4yLTExLjQgMzYuNi0xOC4xIDQ4LjgtMS4xIDUuNSA3LjcgNi40IDIyLjktMyAzMS42aDcuMWM4LTcgMTEuMi0yOC40IDMuMy00Mi41elwiLz48cGF0aCBjbGFzcz1cImJcIiBkPVwiTTEzNy43IDE1My42YzEuNy0xMy4yLTcuNC0xNy40LTEyLjQtMTguOCAxLjYgMTEuNi04IDE3LTYuOCAzNiA0LjYgMTMuNyAyIDI5LjktNC40IDM4aDE5Yy04LjYtMTIuNi0xMC00MS44IDQuNi01NS4yelwiLz48L3N2Zz5gO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdmdUZXh0ID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjI4LjkgMjlcIj48ZGVmcz48c3R5bGU+LmF7ZmlsbDojZjVmNWY1fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPVwiYVwiIGQ9XCJNOS43IDE5YTMuNyAzLjcgMCAwIDEgMi45IDEuNCA2IDYgMCAwIDEgLjkgMy42IDQuNiA0LjYgMCAwIDEtMS40IDMuOGMtLjkuNy0yLjUgMS00LjcgMUwwIDI4LjdWMTAuMWw2LjYtLjJhOS40IDkuNCAwIDAgMSA0LjkgMWMuOS43IDEuNCAyIDEuNCAzLjlhNS4xIDUuMSAwIDAgMS0uNyAzQTMuMyAzLjMgMCAwIDEgOS43IDE5em0tNi40LTEuMWgzLjRhMy4zIDMuMyAwIDAgMCAyLjMtLjYgMi41IDIuNSAwIDAgMCAuNy0yLjEgMi45IDIuOSAwIDAgMC0uNy0yLjEgNS4xIDUuMSAwIDAgMC0yLjYtLjVIMy4zem0wIDguM2gzLjVhMy45IDMuOSAwIDAgMCAyLjYtLjZjLjUtLjMuNy0xLjEuNy0yLjJhMyAzIDAgMCAwLS43LTIuNCAzLjggMy44IDAgMCAwLTIuNy0uN0gzLjN6TTIyLjkgMTAuMXYxNC4zYTIuMSAyLjEgMCAwIDAgLjMgMS4yIDIuMyAyLjMgMCAwIDAgMS4zLjNoNi40bC4yIDIuNmMtMS44LjItNC4zLjItNy40LjJzLTQuMi0xLjItNC4yLTMuOFYxMC4xek00Ni4yIDIzLjRoLTYuOWwtMS41IDUuM2gtMy41TDM5LjkgMTFhMS4yIDEuMiAwIDAgMSAxLjItLjloMy4zYTEuMiAxLjIgMCAwIDEgMS4yLjlsNS42IDE3LjdoLTMuNXptLS44LTIuN2wtMS45LTYuNGMtLjItMS0uNC0xLjUtLjQtMS42aC0uN2wtLjQgMS42LTEuOSA2LjR6TTY4LjIgMjUuOGwuMyAyLjVhMTguNSAxOC41IDAgMCAxLTUuNy43Yy0yLjggMC00LjctLjctNS44LTIuMXMtMS43LTQtMS43LTcuNS41LTYgMS43LTcuNCAzLTIuMiA1LjgtMi4yYTE5LjggMTkuOCAwIDAgMSA1LjMuNmwtLjMgMi42YTM5LjQgMzkuNCAwIDAgMC01LS4yYy0xLjUgMC0yLjYuNC0zLjEgMS40cy0uOSAyLjctLjkgNS4yLjMgNC4zLjkgNS4yYTMuMiAzLjIgMCAwIDAgMy4xIDEuNSAzNy41IDM3LjUgMCAwIDAgNS40LS4zek03OS4xIDIwLjNoLTEuOGExMS4xIDExLjEgMCAwIDEgLjIgMS45djYuNWgtMy40VjEwLjFoMy40djUuNWExMi41IDEyLjUgMCAwIDEtLjIgMi4xaDEuOGw1LjEtNy42aDMuN2wtNSA3LjVhNC4zIDQuMyAwIDAgMS0xLjMgMS40IDQuNSA0LjUgMCAwIDEgMS41IDEuNmw1LjEgOGgtMy43ek0xMDAgMjEuNGwtMy44LTEuMmE1LjEgNS4xIDAgMCAxLTIuOC0yIDUuOSA1LjkgMCAwIDEtLjktMy40YzAtMiAuNS0zLjQgMS40LTRzMi42LTEgNS0xYTI0IDI0IDAgMCAxIDUuOC42bC0uMiAyLjRIOTlhNC43IDQuNyAwIDAgMC0yLjUuNGMtLjQuMi0uNi44LS42IDEuN2EyLjUgMi41IDAgMCAwIC40IDEuNyAzLjggMy44IDAgMCAwIDEuNy44bDMuNSAxLjFhNS4zIDUuMyAwIDAgMSAzIDIgNS45IDUuOSAwIDAgMSAuOSAzLjRjMCAyLjEtLjUgMy40LTEuNSA0LjJzLTIuNyAxLTUuMSAxYTMwLjggMzAuOCAwIDAgMS02LjEtLjZMOTMgMjZsNS44LjJhNC40IDQuNCAwIDAgMCAyLjUtLjUgMi4yIDIuMiAwIDAgMCAuNi0xLjggMi4yIDIuMiAwIDAgMC0uNC0xLjYgMy41IDMuNSAwIDAgMC0xLjUtLjl6TTEyNiAxMC4xaDMuNWExLjIgMS4yIDAgMCAxIDEuMyAxLjRsLjggMTcuMmgtMy4zbC0uNy0xNS44aC0uNWwtMy4yIDEyLjNhMS4zIDEuMyAwIDAgMS0xLjQgMS4xSDEyMGExLjQgMS40IDAgMCAxLTEuNS0xLjFsLTMuMi0xMi4zaC0uNWwtLjYgMTUuOGgtMy4zbC43LTE3LjJjLjEtLjkuNS0xLjQgMS40LTEuNGgzLjVhMS4yIDEuMiAwIDAgMSAxLjMgMS4ybDIuNyAxMCAuNSAyLjZoLjRhMjYuMSAyNi4xIDAgMCAxIC42LTIuNmwyLjYtMTBhMS40IDEuNCAwIDAgMSAxLjQtMS4yek0xNDEuNCAyOC43SDEzOFYxMC4xaDMuNHpNMTYxLjUgMTNoLTUuN3YxNS43aC0zLjRWMTNoLTUuN3YtMi45aDE0Ljh6TTE4MC45IDEwLjF2MTguNmgtMy40di04LjVoLTcuM3Y4LjVoLTMuNFYxMC4xaDMuNHY3LjNoNy4zdi03LjN6TTE5NiAxMy4xbC0uMi0yLjZhMjQuNCAyNC40IDAgMCAxIDUuOS0uNyA4LjkgOC45IDAgMCAxIDQuNS45IDMuNSAzLjUgMCAwIDEgMS41IDMuMyA2LjQgNi40IDAgMCAxLS43IDMuMSAxMy4zIDEzLjMgMCAwIDEtMi40IDMuM2wtNC45IDUuMyAyLjgtLjJoNS44djMuMmgtMTIuN3YtMmEyIDIgMCAwIDEgLjUtMS40bDQuOS01LjRjMi4yLTIuNCAzLjMtNC4yIDMuMy01LjZhMS4zIDEuMyAwIDAgMC0uNy0xLjMgNS43IDUuNyAwIDAgMC0yLjItLjMgNTIuOSA1Mi45IDAgMCAwLTUuNC40ek0yMTQuMyAyOC43VjEwLjFsNy0uMmMyLjggMCA0LjguNyA1LjkgMi4xczEuNyAzLjggMS43IDcuNC0uNiA2LjEtMS43IDcuNS0zLjEgMi01LjkgMi00LjUgMC03LS4yem0zLjQtMTZ2MTMuNGgzLjZhMy42IDMuNiAwIDAgMCAzLjItMS40IDEyLjYgMTIuNiAwIDAgMCAuOC01LjNjMC0yLjUtLjMtNC4zLS45LTUuM2EzLjMgMy4zIDAgMCAwLTMuMS0xLjRoLTMuNnpNLjEgOC4xdi04aDIuN2EyLjkgMi45IDAgMCAxIDIuMS41IDMgMyAwIDAgMSAuNSAyIDIuOSAyLjkgMCAwIDEtLjUgMS45IDIuNSAyLjUgMCAwIDEtMS45LjZIMS4ydjN6bTEuMS00aDEuNmExLjYgMS42IDAgMCAwIDEuMS0uMyAyLjEgMi4xIDAgMCAwIC4zLTEuMiAyLjMgMi4zIDAgMCAwLS4zLTEuM0ExLjYgMS42IDAgMCAwIDIuOCAxSDEuMnpNOS43IDBhMyAzIDAgMCAxIDIuNS45IDUuMiA1LjIgMCAwIDEgLjcgMy4yIDUgNSAwIDAgMS0uNyAzLjIgMyAzIDAgMCAxLTIuNS45IDIuOCAyLjggMCAwIDEtMi40LS45IDUgNSAwIDAgMS0uNy0zLjJBNS4yIDUuMiAwIDAgMSA3LjMuOSAyLjggMi44IDAgMCAxIDkuNyAwem0xLjYgMS43QTEuNyAxLjcgMCAwIDAgOS43IDFhMS42IDEuNiAwIDAgMC0xLjUuNyA0LjUgNC41IDAgMCAwLS40IDIuNCA0LjUgNC41IDAgMCAwIC40IDIuNCAxLjYgMS42IDAgMCAwIDEuNS43IDEuNyAxLjcgMCAwIDAgMS42LS43IDQuNSA0LjUgMCAwIDAgLjQtMi40IDQuNSA0LjUgMCAwIDAtLjQtMi40ek0yNC4yLjFsLTEuNiA3LjZhLjQuNCAwIDAgMS0uNC40aC0xLjNhLjQuNCAwIDAgMS0uNC0uNGwtMS4yLTUuOGEzLjQgMy40IDAgMCAxLS4xLS45aC0uM2wtLjIuOS0xLjEgNS44VjhoLTEuN2MtLjMgMC0uNC0uMS0uNS0uNEwxMy45LjFoMS4ybDEuMiA2LjFhNS4xIDUuMSAwIDAgMCAuMSAxaC4zYzAtLjMuMS0uNy4xLTFMMTggLjVhLjQuNCAwIDAgMSAuNC0uNGgxLjNhLjIuMiAwIDAgMSAuMi4yLjIuMiAwIDAgMSAuMi4ybDEuMSA1LjdjLjEuMy4xLjYuMiAxaC4zdi0uNWExLjEgMS4xIDAgMCAwIC4xLS41TDIyLjkuMXpNMzAuMyA3LjFWOEgyN2ExLjYgMS42IDAgMCAxLTEuMi0uNCAxLjIgMS4yIDAgMCAxLS40LTF2LTVhMS40IDEuNCAwIDAgMSAuNC0xLjFBMi4xIDIuMSAwIDAgMSAyNyAuMWgzLjRWMWgtMy4ybC0uNS4yYS43LjcgMCAwIDAtLjEuNXYxLjdoMy4zdjFoLTMuM3YyYTEuMSAxLjEgMCAwIDAgLjEuNmgzLjZ6TTM3LjYgOC4xaC0xLjJsLS43LTIuNWExLjEgMS4xIDAgMCAwLTEtLjhoLTEuNnYzLjNoLTEuMnYtOGgyLjhhMy40IDMuNCAwIDAgMSAyIC41IDIuNCAyLjQgMCAwIDEgLjYgMS44IDIuOCAyLjggMCAwIDEtLjMgMS40IDIgMiAwIDAgMS0xLjIuNiAxLjQgMS40IDAgMCAxIDEgMS4yem0tNC41LTQuM2gxLjZhMS42IDEuNiAwIDAgMCAxLjEtLjMgMS40IDEuNCAwIDAgMCAuMy0xLjEgMS42IDEuNiAwIDAgMC0uMy0xLjEgMS42IDEuNiAwIDAgMC0xLjEtLjNoLTEuNnpNNDMuOSA3LjFWOGgtMy4zYTEuNiAxLjYgMCAwIDEtMS4yLS40IDEuMiAxLjIgMCAwIDEtLjQtMXYtNWExLjQgMS40IDAgMCAxIC40LTEuMSAyLjEgMi4xIDAgMCAxIDEuMi0uNEg0NFYxaC0zLjJhLjYuNiAwIDAgMC0uNS4yLjguOCAwIDAgMC0uMi41djEuN2gzLjR2MWgtMy40djJhMS4xIDEuMSAwIDAgMCAuMi42aDMuNnpNNDUuNSA4LjF2LThoMi45YTMgMyAwIDAgMSAyLjQuOSA1LjIgNS4yIDAgMCAxIC43IDMuMiA1LjIgNS4yIDAgMCAxLS43IDMuMiAzIDMgMCAwIDEtMi40Ljl6bTEuMS03djZoMS44YTEuNiAxLjYgMCAwIDAgMS41LS43IDUuNyA1LjcgMCAwIDAgLjQtMi40IDYuNSA2LjUgMCAwIDAtLjQtMi40IDEuOCAxLjggMCAwIDAtMS41LS42aC0xLjh6TTU5LjYgMy45YTEuNSAxLjUgMCAwIDEgMS4zLjYgMi44IDIuOCAwIDAgMSAuMyAxLjUgMi4yIDIuMiAwIDAgMS0uNSAxLjYgMy40IDMuNCAwIDAgMS0yIC41aC0zdi04aDIuNmEzLjcgMy43IDAgMCAxIDIuMS40IDEuOCAxLjggMCAwIDEgLjYgMS42IDIuMyAyLjMgMCAwIDEtLjMgMS4zIDEuNCAxLjQgMCAwIDEtMS4xLjV6bS0yLjgtLjRoMS42YTIuOSAyLjkgMCAwIDAgMS4yLS4yIDEuMyAxLjMgMCAwIDAgLjMtMWMwLS41LS4xLS45LS40LTFhMS43IDEuNyAwIDAgMC0xLjItLjNoLTEuNXptMCAzLjdoMS43YTEuNyAxLjcgMCAwIDAgMS4yLS4zYy4zLS4xLjQtLjUuNC0xYTEuNyAxLjcgMCAwIDAtLjQtMS4yIDEuOSAxLjkgMCAwIDAtMS4zLS4zaC0xLjZ6TTY1LjYgNS4zdjIuOGgtMS4xVjUuM0w2MS44LjFoMS4zbDEuNiAzLjNhNC4yIDQuMiAwIDAgMCAuMy45aC4xYTguNSA4LjUgMCAwIDEgLjMtLjlMNjcgLjFoMS4yelwiLz48L3N2Zz5gO1xyXG4gIH1cclxuXHJcbiAgc2hvdygpIHtcclxuICAgIGxldCBkdXJhdGlvbiA9IHRoaXMubUR1cmF0aW9uICogMC4wMDE7XHJcbiAgICBsZXQgY3NzID0gYCNsb2dvLCNzcGxhc2gtc2NyZWVue3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveH0jbG9nby1pbm5lciwjbG9nby1uYW1le21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99I3NwbGFzaC1zY3JlZW57ei1pbmRleDo5OTk7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7ZGlzcGxheTpibG9jaztiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFRQUFBQUVDQVlBQUFDcDhaNStBQUFBSWtsRVFWUVlWMk9Va3BMNi8relpNd1lwS1NrR0VNM0l3TUR3bndFSk1CSlVBUUNMVWhBQlVHUlp6d0FBQUFCSlJVNUVya0pnZ2c9PSk7b3BhY2l0eToxO2FuaW1hdGlvbjpoaWRlIDBzIGVhc2UtaW4gJHtkdXJhdGlvbn1zIGZvcndhcmRzfUBrZXlmcmFtZXMgaGlkZXt0b3tvcGFjaXR5OjB9fSNsb2dve3RvcDoyMCU7bGVmdDo1MCU7YW5pbWF0aW9uOmZhZGVpbiAke2R1cmF0aW9ufXMgbGluZWFyIGZvcndhcmRzfUBrZXlmcmFtZXMgZmFkZWluezAle29wYWNpdHk6MH0xMDAlLDQwJXtvcGFjaXR5OjF9fSNsb2dvLW5hbWV7d2lkdGg6MTAwJTttYXJnaW4tdG9wOjEwOHB4fWA7XHJcblxyXG4gICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XHJcblxyXG4gICAgbGV0IGNvbnRhaW5lciA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChCbGFjay5lbmdpbmUuY29udGFpbmVyRWxlbWVudElkKSk7XHJcbiAgICBsZXQgb2xkT3ZlcmZsb3cgPSBjb250YWluZXIuc3R5bGUub3ZlcmZsb3c7XHJcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHJcbiAgICBsZXQgc3BsYXNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBzcGxhc2guaWQgPSAnc3BsYXNoLXNjcmVlbic7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3BsYXNoKTtcclxuXHJcbiAgICBsZXQgbG9nbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgbG9nby5pZCA9ICdsb2dvJztcclxuICAgIHNwbGFzaC5hcHBlbmRDaGlsZChsb2dvKTtcclxuXHJcbiAgICBsZXQgbG9nb0lubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBsb2dvSW5uZXIuaWQgPSAnbG9nby1pbm5lcic7XHJcbiAgICBsb2dvSW5uZXIuaW5uZXJIVE1MID0gdGhpcy5tU3ZnTG9nbztcclxuICAgIGxvZ28uYXBwZW5kQ2hpbGQobG9nb0lubmVyKTtcclxuXHJcbiAgICBsZXQgbG9nb05hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGxvZ29OYW1lLmlkID0gJ2xvZ28tbmFtZSc7XHJcbiAgICBsb2dvTmFtZS5pbm5lckhUTUwgPSB0aGlzLm1TdmdUZXh0O1xyXG4gICAgbG9nby5hcHBlbmRDaGlsZChsb2dvTmFtZSk7XHJcblxyXG4gICAgbGV0IHJlZnJlc2ggPSAoKSA9PiB7XHJcbiAgICAgIGxldCBtdyA9IHNwbGFzaC5vZmZzZXRXaWR0aDtcclxuICAgICAgbGV0IG1oID0gc3BsYXNoLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgIGxldCBzaXplID0gdGhpcy5jYWxjdWxhdGVBc3BlY3RSYXRpb0ZpdChtdywgbWgsIG13ICogMC41LCBtaCAqIDAuNSk7XHJcblxyXG4gICAgICBsb2dvLnN0eWxlLndpZHRoID0gYCR7c2l6ZS53aWR0aH1weGA7XHJcbiAgICAgIGxvZ28uc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZS5oZWlnaHR9cHhgO1xyXG4gICAgICBsb2dvLnN0eWxlLm1hcmdpbkxlZnQgPSBgJHstc2l6ZS53aWR0aCAqIDAuNX1weGA7XHJcblxyXG4gICAgICBsb2dvSW5uZXIuc3R5bGUud2lkdGggPSBgJHtNYXRoLm1pbihzaXplLndpZHRoLCBzaXplLmhlaWdodCl9cHhgO1xyXG4gICAgICBsb2dvSW5uZXIuc3R5bGUuaGVpZ2h0ID0gYCR7TWF0aC5taW4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpfXB4YDtcclxuXHJcbiAgICAgIGxvZ29OYW1lLnN0eWxlLndpZHRoID0gYCR7TWF0aC5taW4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpICogMC45fXB4YDtcclxuICAgICAgbG9nb05hbWUuc3R5bGUuaGVpZ2h0ID0gYCR7TWF0aC5taW4oc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpfXB4YDtcclxuICAgICAgbG9nb05hbWUuc3R5bGUubWFyZ2luVG9wID0gYCR7MTJ9cHhgO1xyXG4gICAgfTtcclxuXHJcbiAgICByZWZyZXNoKCk7XHJcblxyXG4gICAgbGV0IGN3ID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gICAgbGV0IGNoID0gY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuXHJcbiAgICBsZXQgaGFuZGxlID0gc2V0SW50ZXJ2YWwoeCA9PiB7XHJcbiAgICAgIGlmIChjdyAhPT0gY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IGNoICE9PSBjb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7XHJcbiAgICAgICAgY3cgPSBjb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgY2ggPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIHJlZnJlc2goKTtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwMCAvIDYwKTtcclxuXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcblxyXG4gICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcclxuICAgICAgc3BsYXNoLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3BsYXNoKTtcclxuXHJcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvdyA9IG9sZE92ZXJmbG93O1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFBvc3RzIHdoZW4gc3BsYXNoIHNjcmVlbiBpcyBoaWRkZW4uXHJcbiAgICAgICAqIEBldmVudCBTcGxhc2hTY3JlZW4jY29tcGxldGVcclxuICAgICAgICovXHJcbiAgICAgIHRoaXMucG9zdChNZXNzYWdlLkNPTVBMRVRFKTtcclxuICAgIH0sIHRoaXMubUR1cmF0aW9uKTtcclxuXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5DT01QTEVURSk7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVBc3BlY3RSYXRpb0ZpdChzcmNXaWR0aCwgc3JjSGVpZ2h0LCBtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XHJcbiAgICBsZXQgcmF0aW8gPSBNYXRoLm1pbihtYXhXaWR0aCAvIHNyY1dpZHRoLCBtYXhIZWlnaHQgLyBzcmNIZWlnaHQpO1xyXG4gICAgcmV0dXJuIHsgd2lkdGg6IHNyY1dpZHRoICogcmF0aW8sIGhlaWdodDogc3JjSGVpZ2h0ICogcmF0aW8gfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaW1lciBjb21wb25lbnQuXHJcbiAqXHJcbiAqIEBjYXQgdGltZXJzXHJcbiAqIFxyXG4gKiBAZmlyZXMgVGltZXIjY29tcGxldGVcclxuICogQGZpcmVzIFRpbWVyI3RpY2tcclxuICogXHJcbiAqIEBleHRlbmRzIGJsYWNrLWVuZ2luZX5Db21wb25lbnRcclxuICovXHJcbmNsYXNzIFRpbWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICBjb25zdHJ1Y3RvcihpbnRlcnZhbCA9IDEsIHRpY2tzQ291bnQgPSAxLCBzdGFydE9uQWRkZWQgPSB0cnVlKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgXHJcbiAgICBEZWJ1Zy5hc3NlcnQoaW50ZXJ2YWwgPiAwLCAndGhlIGludGVydmFsIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIERlYnVnLmFzc2VydCh0aWNrc0NvdW50ID4gMCwgJ3RoZSB0aWNrc0NvdW50IHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIFxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YXJ0T25BZGRlZCA9IHN0YXJ0T25BZGRlZDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1JbnRlcnZhbCA9IGludGVydmFsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVRpY2tzQ291bnQgPSB0aWNrc0NvdW50O1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc1J1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1UaWNrID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1FbGFwc2VkU2Vjb25kcyA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVG90YWxFbGFwc2VkU2Vjb25kcyA9IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uQWRkZWQoKSB7XHJcbiAgICBpZiAodGhpcy5tU3RhcnRPbkFkZGVkKVxyXG4gICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaW5oZXJpdERvY1xyXG4gICAqL1xyXG4gIG9uVXBkYXRlKCkge1xyXG4gICAgaWYgKHRoaXMubUlzUnVubmluZyA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICB0aGlzLm1FbGFwc2VkU2Vjb25kcyArPSBCbGFjay50aW1lLmRlbHRhO1xyXG4gICAgdGhpcy5tVG90YWxFbGFwc2VkU2Vjb25kcyArPSBCbGFjay50aW1lLmRlbHRhO1xyXG5cclxuICAgIGlmICh0aGlzLm1FbGFwc2VkU2Vjb25kcyA+PSB0aGlzLm1JbnRlcnZhbCkge1xyXG4gICAgICB0aGlzLm1FbGFwc2VkU2Vjb25kcyA9IDA7XHJcblxyXG4gICAgICBjb25zdCB0aWNrc1BlclVwZGF0ZSA9IE1hdGgubWF4KDEsIH5+KEJsYWNrLnRpbWUuZGVsdGEgLyB0aGlzLm1JbnRlcnZhbCkpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tzUGVyVXBkYXRlOyBpKyspIHtcclxuICAgICAgICB0aGlzLm1UaWNrKys7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogUG9zdGVkIG9uIGV2ZXJ5IHRpbWVyIHRpY2suXHJcbiAgICAgICAgKiBAZXZlbnQgVGltZXIjdGlja1xyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb3N0KCd0aWNrJywgdGhpcy5tVGljayk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1UaWNrID49IHRoaXMubVRpY2tzQ291bnQpIHtcclxuICAgICAgICAgIHRoaXMubUlzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogUG9zdGVkIG9uIHRpbWVyIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICogQGV2ZW50IFRpbWVyI2NvbXBsZXRlXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHRoaXMucG9zdCgnY29tcGxldGUnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRpbWVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflRpbWVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgc3RhcnQoKSB7XHJcbiAgICB0aGlzLm1Jc1J1bm5pbmcgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGFuZCByZXNldCB0aW1lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5UaW1lcn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLm1Jc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgIHRoaXMucmVzZXQoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIHRoZSB0aW1lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5UaW1lcn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5tSXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRpbWVyLlxyXG4gICAqXHJcbiAgICogc2V0cyB0aWNrcyBlbGFwc2VkU2Vjb25kcyBhbmQgdG90YWxFbGFwc2VkU2Vjb25kcyB0byAwXHJcbiAgICogQHJldHVybiB7YmxhY2stZW5naW5lflRpbWVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLm1UaWNrID0gMDtcclxuICAgIHRoaXMubUVsYXBzZWRTZWNvbmRzID0gMDtcclxuICAgIHRoaXMubVRvdGFsRWxhcHNlZFNlY29uZHMgPSAwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKiogSG93IG1hbnkgdGlja3MgbGVmdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIGdldCB0aWNrc0xlZnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVGlja3NDb3VudCAtIHRoaXMubVRpY2s7XHJcbiAgfVxyXG5cclxuICAvKiogY3VycmVudCB0aWNrIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaWNrKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVRpY2s7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBlbGFwc2VkIHNlY29uZHMgZnJvbSBwcmV2aW91cyB0aWNrLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBlbGFwc2VkU2Vjb25kcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1FbGFwc2VkU2Vjb25kcztcclxuICB9XHJcblxyXG4gIC8qKiBob3cgbWFueSBzZWNvbmRzIGxlZnQgdG8gdGhlIG5leHQgdGljay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJucyB0aGlzLlxyXG4gICAqL1xyXG4gIGdldCBzZWNvbmRzVG9OZXh0VGljaygpIHtcclxuICAgIHJldHVybiB0aGlzLm1JbnRlcnZhbCAtIHRoaXMubUVsYXBzZWRTZWNvbmRzO1xyXG4gIH1cclxuXHJcbiAgLyoqIElmIHRoZSB0aW1lciBpcyBydW5uaW5nLCByZXR1cm5zIHRydWUsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdGhpcy5cclxuICAgKi9cclxuICBnZXQgaXNSdW5uaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUlzUnVubmluZyA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKiBJZiB0aGUgbnVtYmVyIG9mIHRpY2tzIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIG51bWJlciwgcmV0dXJucyBmYWxzZSwgb3RoZXJ3aXNlIHRydWUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRoaXMuXHJcbiAgICovXHJcbiAgZ2V0IGlzQ29tcGxldGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVGljayA+PSB0aGlzLm1UaWNrc0NvdW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cy9HZXQgdGhlIG51bWJlciBvZiB0aW1lciB0aWNrcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdGlja3NDb3VudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1UaWNrc0NvdW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgdGlja3NDb3VudCh2YWx1ZSkge1xyXG4gICAgRGVidWcuYXNzZXJ0KHZhbHVlID4gMCwgJ3RoZSB0aWNrc0NvdW50IHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIHRoaXMubVRpY2tzQ291bnQgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMvR2V0IHRoZSB0aW1lciBpbnRlcnZhbCBpbiBzZWNvbmRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBpbnRlcnZhbCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1JbnRlcnZhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IGludGVydmFsKHZhbHVlKSB7XHJcbiAgICBEZWJ1Zy5hc3NlcnQodmFsdWUgPiAwLCAndGhlIGludGVydmFsIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgIHRoaXMubUludGVydmFsID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiB0b3RhbCBlbGFwc2VkIHNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHRvdGFsRWxhcHNlZFNlY29uZHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVG90YWxFbGFwc2VkU2Vjb25kcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMvR2V0cyB3aGV0aGVyIHRoZSB0aW1lciBzaG91bGQgc3RhcnQgYXV0b21hdGljYWxseSB3aGVuIGFkZGVkIHRvIHRoZSByb290LlxyXG4gICAqIFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHN0YXJ0T25BZGRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1TdGFydE9uQWRkZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgc3RhcnRPbkFkZGVkKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1TdGFydE9uQWRkZWQgPSB2YWx1ZTtcclxuICB9XHJcbn1cclxuXHJcbmxldCBJRCQzID0gMDtcclxuLyoqXHJcbiAqIFRoZSBCbGFjayBjbGFzcyByZXByZXNlbnRzIHRoZSBjb3JlIG9mIHRoZSBCbGFjayBFbmdpbmUuXHJcbiAqXHJcbiAqIEBmaXJlcyBFbmdpbmUjcGF1c2VkXHJcbiAqIEBmaXJlcyBFbmdpbmUjdW5wYXVzZWRcclxuICogQGZpcmVzIEVuZ2luZSNyZWFkeVxyXG4gKiBAZmlyZXMgRW5naW5lI2xvb3BlZFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBibGFjay1lbmdpbmV+TWVzc2FnZURpc3BhdGNoZXJcclxuICovXHJcbmNsYXNzIEVuZ2luZSBleHRlbmRzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IEJsYWNrIGluc3RhbmNlLlxyXG4gICAqIFxyXG4gICAqIEZpcnN0IHBhcmFtZXRlciBoYXMgdG8gYmUgYSBpZCBvZiB0aGUgSFRNTCBkaXYgZWxlbWVudCB0aGUgZ2FtZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gICAqIFNlY29uZCBwYXJhbWV0ZXIgaGFzIHRvIGJlIGBHYW1lT2JqZWN0YCBjbGFzcyB3aGljaCB3aWxsIGJlIHRoZSByb290IG9iamVjdCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAqIFRoaXJkIHBhcmFtZXRlciBoYXMgdG8gYmUgYSBjbGFzcyBuYW1lIG9mIGBWaWRlb051bGxEcml2ZXJgIHN1YmNsYXNzIGVnIGBDYW52YXNEcml2ZXJgLlxyXG4gICAqIEZvdXJ0aCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwgYXJyYXkgb2YgU3lzdGVtIHRvIHVzZSxcclxuICAgKiBcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIC8vIENyZWF0ZXMgbmV3IEJsYWNrIGluc3RhbmNlIHdpdGggTXlHYW1lIGFzIGEgcm9vdCBjbGFzcywgQ2FudmFzRHJpdmVyIGFzIHJlbmRlcmVyIGFuZCBBcmNhZGUgcGh5c2ljcyBhcyBhIHN5c3RlbS5cclxuICAgKiBuZXcgQmxhY2soJ2dhbWUtY29udGFpbmVyJywgTXlHYW1lLCBDYW52YXNEcml2ZXIsIFtBcmNhZGVdKTtcclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudElkIFRoZSBpZCBvZiBhbiBET00gZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogYmxhY2stZW5naW5lfkdhbWVPYmplY3QpfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWVDbGFzcyAgICAgICAgICBUeXBlIG5hbWUgb2YgYW4gR2FtZU9iamVjdCB0byBzdGFydCBleGVjdXRpb24gZnJvbS5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogYmxhY2stZW5naW5lflZpZGVvTnVsbERyaXZlciwgSFRNTEVsZW1lbnQsIG51bWJlciwgbnVtYmVyKX0gIHZpZGVvRHJpdmVyQ2xhc3MgICBUeXBlIG5hbWUgb2YgYW4gVmlkZW9Ecml2ZXIgKFZpZGVvTnVsbERyaXZlciwgRE9NRHJpdmVyIG9yIENhbnZhc0RyaXZlcilcclxuICAgKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG5ldzogYmxhY2stZW5naW5lflN5c3RlbSk+ICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5c3RlbUNsYXNzZXMgICAgICBUaGUgbGlzdCBvZiBzeXN0ZW1zIHRvIGJlIGluaXRpYWxpemVkIHdpdGggQmxhY2sgZW5naW5lLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckVsZW1lbnRJZCwgZ2FtZUNsYXNzLCB2aWRlb0RyaXZlckNsYXNzLCBzeXN0ZW1DbGFzc2VzID0gbnVsbCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmlkID0gKytJRCQzO1xyXG5cclxuICAgIEJsYWNrLmVuZ2luZSA9IHRoaXM7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tQ29udGFpbmVyRWxlbWVudElkID0gY29udGFpbmVyRWxlbWVudElkO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Db250YWluZXJFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IGJsYWNrLWVuZ2luZX5WaWRlb051bGxEcml2ZXIsIEhUTUxFbGVtZW50LCBudW1iZXIsIG51bWJlcil9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1WaWRlb0RyaXZlckNsYXNzID0gdmlkZW9Ecml2ZXJDbGFzcztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihuZXc6IGJsYWNrLWVuZ2luZX5TeXN0ZW0pPn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN5c3RlbUNsYXNzZXMgPSBzeXN0ZW1DbGFzc2VzO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YWdlV2lkdGggPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVN0YWdlSGVpZ2h0ID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1MYXN0VXBkYXRlVGltZSA9IDA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRnJhbWVOdW0gPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1OdW1VcGRhdGVzID0gMDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5tTWF4VXBkYXRlc1BlckZyYW1lID0gNjA7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tTGFzdFJlbmRlclRpbWUgPSAwO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge0FycmF5PGJsYWNrLWVuZ2luZX5TeXN0ZW0+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tU3lzdGVtcyA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fG51bGx9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1HYW1lT2JqZWN0ID0gbnVsbDtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tSXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUlzU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Jc1BhbmljID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUkFGSGFuZGxlID0gLTE7IC8vIG5vdCBzdXJlXHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7YmxhY2stZW5naW5lflZpZXdwb3J0fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVmlld3BvcnQgPSBudWxsO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2JsYWNrLWVuZ2luZX5WaWRlb051bGxEcml2ZXJ9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1WaWRlbyA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1VbnBhdXNpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtib29sZWFufSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tUGF1c2VPbkhpZGUgPSB0cnVlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QYXVzZU9uQmx1ciA9IHRydWU7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tVGFnQ2FjaGUgPSB7fTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IGJsYWNrLWVuZ2luZX5HYW1lT2JqZWN0KX0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubUdhbWVDbGFzcyA9IGdhbWVDbGFzcztcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtibGFjay1lbmdpbmV+U3RhZ2V9IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1TdGFnZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogQHByaXZhdGUgXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gXHJcbiAgICAgKi9cclxuICAgIHRoaXMubVdhc1N0b3BwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBAcHJpdmF0ZSBcclxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fSBcclxuICAgICAqL1xyXG4gICAgdGhpcy5tRnJhbWVUaW1lcyA9IFtdO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1Vc2VIaURQUiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEBwcml2YXRlIFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59IFxyXG4gICAgICovXHJcbiAgICB0aGlzLm1QZW5kaW5nRGlzcG9zZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX19pbml0aWFsaXplKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAaWdub3JlXHJcbiAgICovXHJcbiAgX19pbml0aWFsaXplKCkge1xyXG4gICAgY29uc29sZS5sb2coJyVjICAgICAgICAgICAgICAgICAgICAgICAgID4+PiBCTEFDSyA8PDwgICAgICAgICAgICAgICAgICAgICAgICAgJywgJ2JhY2tncm91bmQ6ICMwMDA7IGNvbG9yOiAjZmZmOycpO1xyXG5cclxuICAgIHRoaXMubUNvbnRhaW5lckVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMubUNvbnRhaW5lckVsZW1lbnRJZCkpO1xyXG5cclxuICAgIGlmICghdGhpcy5tQ29udGFpbmVyRWxlbWVudClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250YWluZXIgZWxlbWVudCB3YXMgbm90IGZvdW5kJyk7XHJcblxyXG4gICAgQmxhY2suZGV2aWNlID0gbmV3IERldmljZSgpO1xyXG5cclxuICAgIHRoaXMubVN0YWdlV2lkdGggPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgdGhpcy5tU3RhZ2VIZWlnaHQgPSB0aGlzLm1Db250YWluZXJFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIHRoaXMubVVzZUhpRFBSID0gQmxhY2suZGV2aWNlLmlzTW9iaWxlO1xyXG5cclxuICAgIHRoaXMuX19ib290Vmlld3BvcnQoKTtcclxuICAgIHRoaXMuX191cGRhdGUgPSB0aGlzLl9fdXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZXMgYWxsIGVuZ2luZSB1cGRhdGUgbG9naWMuIE5vdGU6IFJBRiBpcyBub3QgZ29pbmcgdG8gYmUgcGF1c2VkIGFuZCB3aWxsIHdvcmsgaW4gYmFja2dyb3VuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLm1QYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tU3lzdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy5tU3lzdGVtc1tpXS5vblBhdXNlKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0ZWQgYWZ0ZXIgZW5naW5lIGVudGVyZWQgcGF1c2VkIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBFbmdpbmUjcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zdCgncGF1c2VkJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWVzIHVwZGF0ZSBleGVjdXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHJlc3VtZSgpIHtcclxuICAgIGlmICh0aGlzLm1QYXVzZWQgPT09IHRydWUpXHJcbiAgICAgIHRoaXMubVVucGF1c2luZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBfX3NldFVucGF1c2VkKCkge1xyXG4gICAgdGhpcy5tUGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uUmVzdW1lKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3N0ZWQgYWZ0ZXIgZW5naW5lIGlzIHVucGF1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBFbmdpbmUjdW5wYXVzZWRcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3N0KCd1bnBhdXNlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX2Jvb3RWaWV3cG9ydCgpIHtcclxuICAgIHRoaXMubVZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KHRoaXMubUNvbnRhaW5lckVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX2Jvb3RTeXN0ZW1zKCkge1xyXG4gICAgaWYgKHRoaXMubVN5c3RlbUNsYXNzZXMgPT09IG51bGwpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubVN5c3RlbUNsYXNzZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgIHRoaXMuX19hZGRTeXN0ZW0obmV3IHRoaXMubVN5c3RlbUNsYXNzZXNbaV0oKSk7XHJcbiAgfVxyXG5cclxuICBfX2NoZWNrVmlzaWJpbGl0eSgpIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAvLyBsZXRzIGZha2UgaGlkZGVuIGlmIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIFBhZ2UgVmlzaWJpbGl0eSBBUElcclxuICAgICAgZG9jdW1lbnQuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9ICd2aXNpYmxlJztcclxuXHJcbiAgICAgIHdpbmRvdy5vbnBhZ2VoaWRlID0gZXZlbnQgPT4gdGhpcy5fX29uVmlzaWJpbGl0eUNoYW5nZUZhbGxiYWNrKGV2ZW50KTtcclxuICAgICAgd2luZG93Lm9ucGFnZXNob3cgPSBldmVudCA9PiB0aGlzLl9fb25WaXNpYmlsaXR5Q2hhbmdlRmFsbGJhY2soZXZlbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGV2ZW50ID0+IHRoaXMuX19vblZpc2liaWxpdHlDaGFuZ2UoZXZlbnQpLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93Lm9uYmx1ciA9IGV2ZW50ID0+IHRoaXMuX19vblZpc2liaWxpdHlDaGFuZ2VGYWxsYmFjayhldmVudCk7XHJcbiAgICB3aW5kb3cub25mb2N1cyA9IGV2ZW50ID0+IHRoaXMuX19vblZpc2liaWxpdHlDaGFuZ2VGYWxsYmFjayhldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAqL1xyXG4gIF9fYm9vdFN0YWdlKCkge1xyXG4gICAgdGhpcy5tU3RhZ2UgPSBuZXcgU3RhZ2UoKTtcclxuXHJcbiAgICB0aGlzLl9fY2hlY2tWaXNpYmlsaXR5KCk7XHJcblxyXG4gICAgaWYgKGRvY3VtZW50LmhpZGRlbiAmJiB0aGlzLm1QYXVzZU9uSGlkZSA9PT0gdHJ1ZSlcclxuICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgKi9cclxuICBfX29uVmlzaWJpbGl0eUNoYW5nZUZhbGxiYWNrKGV2ZW50KSB7XHJcbiAgICBsZXQgdHlwZSA9IGV2ZW50LnR5cGU7XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdibHVyJyAmJiB0aGlzLm1QYXVzZU9uQmx1ciA9PT0gdHJ1ZSlcclxuICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3BhZ2VoaWRlJyAmJiB0aGlzLm1QYXVzZU9uSGlkZSA9PT0gdHJ1ZSlcclxuICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2ZvY3VzJyB8fCB0eXBlID09PSAncGFnZXNob3cnKSB7XHJcbiAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlKVxyXG4gICAgICAgIHRoaXMucmVzdW1lKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX29uVmlzaWJpbGl0eUNoYW5nZSgpIHtcclxuICAgIGlmICh0aGlzLm1QYXVzZU9uSGlkZSA9PT0gdHJ1ZSAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKVxyXG4gICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJylcclxuICAgICAgdGhpcy5yZXN1bWUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBzeXN0ZW0gZXhpc3RzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3lzdGVtVHlwZU5hbWVcclxuICAgKi9cclxuICBoYXNTeXN0ZW0oc3lzdGVtVHlwZU5hbWUpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tU3lzdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgYyA9IHRoaXMubVN5c3RlbXNbaV07XHJcbiAgICAgIGlmIChjIGluc3RhbmNlb2Ygc3lzdGVtVHlwZU5hbWUpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+U3lzdGVtfSBzeXN0ZW0gVGhlIFN5c3RlbSBvYmplY3QgeW91IHdhbnQgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5TeXN0ZW19XHJcbiAgICovXHJcbiAgX19hZGRTeXN0ZW0oc3lzdGVtKSB7XHJcbiAgICB0aGlzLm1TeXN0ZW1zLnB1c2goc3lzdGVtKTtcclxuICAgIHJldHVybiBzeXN0ZW07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHN5c3RlbSBieSB0eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZU5hbWUgVGhlIHN5c3RlbSB0eXBlLlxyXG4gICAqIEByZXR1cm4ge2JsYWNrLWVuZ2luZX5TeXN0ZW18bnVsbH0gVGhlIGBTeXN0ZW1gIGluc3RhbmNlIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAqL1xyXG4gIGdldFN5c3RlbSh0eXBlTmFtZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxldCBzID0gdGhpcy5tU3lzdGVtc1tpXTtcclxuICAgICAgaWYgKHMgaW5zdGFuY2VvZiB0eXBlTmFtZSlcclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgX19ib290VmlkZW8oKSB7XHJcbiAgICB0aGlzLm1WaWRlbyA9IG5ldyB0aGlzLm1WaWRlb0RyaXZlckNsYXNzKHRoaXMubVZpZXdwb3J0Lm1WaWV3cG9ydEVsZW1lbnQsIHRoaXMubVN0YWdlV2lkdGgsIHRoaXMubVN0YWdlSGVpZ2h0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJvb3RzIHVwIHRoZSBlbmdpbmUhXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHN0YXJ0KCkge1xyXG4gICAgaWYgKHRoaXMubVdhc1N0b3BwZWQgPT09IHRydWUpIHtcclxuICAgICAgRGVidWcuZXJyb3IoJ0JsYWNrIGVuZ2luZSBjYW5ub3QgYmUgcmUtc3RhcnRlZC4nKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIEJsYWNrLmVuZ2luZSA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHRoaXMubUlzU3RhcnRlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIEJsYWNrLnRpbWUgPSBuZXcgVGltZSgpO1xyXG5cclxuICAgIHRoaXMuX19ib290U3lzdGVtcygpO1xyXG4gICAgdGhpcy5fX2Jvb3RTdGFnZSgpO1xyXG4gICAgdGhpcy5fX2Jvb3RWaWRlbygpO1xyXG5cclxuICAgIHRoaXMubVN0YWdlLl9fcmVmcmVzaCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9zdGVkIHdoZW4gYWxsIHN5c3RlbXMsIHN0YWdlIGFuZCBkcml2ZXIgcmVhZHkgdG8gYmUgdXNlZC4gXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IEVuZ2luZSNyZWFkeVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc3QoTWVzc2FnZS5SRUFEWSk7XHJcblxyXG4gICAgdGhpcy5tR2FtZU9iamVjdCA9IG5ldyB0aGlzLm1HYW1lQ2xhc3MoKTtcclxuICAgIHRoaXMubVN0YWdlLmFkZENoaWxkKHRoaXMubUdhbWVPYmplY3QpO1xyXG5cclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMubUlzU3RhcnRlZCA9IHRydWU7XHJcbiAgICB0aGlzLm1WaWRlby5zdGFydCgpO1xyXG5cclxuICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgd2F5IHRvIGNhbmNlbCBmaXJzdCByYWY/IG5vISBlZyBwYXVzZSB3aWxsIG5vdCB3b3JrXHJcbiAgICB0aGlzLm1SQUZIYW5kbGUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcclxuICAgICAgLy8gVE9ETzogZG8gZmlyc3QgdXBkYXRlIGhlcmVcclxuICAgICAgc2VsZi5tSXNSdW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIHNlbGYubUxhc3RVcGRhdGVUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICBzZWxmLm1MYXN0UmVuZGVyVGltZSA9IHNlbGYubUxhc3RVcGRhdGVUaW1lO1xyXG5cclxuICAgICAgLy8gU3RhcnQgdGhlIG1haW4gbG9vcC5cclxuICAgICAgc2VsZi5fX3VwZGF0ZSh0aW1lc3RhbXAsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBhbnkgZXhlY3V0aW9ucywgZGVzdHJveXMgcmVzb3VyY2VzIGFuZCBzY2VuZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMubUlzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5tSXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tUkFGSGFuZGxlKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgICAgICAgICA8PDwgQllFIEJZRSA+Pj4gICAgICAgICAgICAgICAgICAgICAgICAnLCAnYmFja2dyb3VuZDogIzAwMDsgY29sb3I6ICNmZmY7Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyB0aGUgd2hvbGUgdGhpbmchXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMubVBlbmRpbmdEaXNwb3NlID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIF9fZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuc3RvcCgpO1xyXG5cclxuICAgIHRoaXMubVZpZGVvLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMubVZpZXdwb3J0LmRpc3Bvc2UoKTtcclxuXHJcbiAgICBCbGFjay5hc3NldHMuZGlzcG9zZSgpO1xyXG4gICAgQmxhY2suYXNzZXRzID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubVN5c3RlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgIHRoaXMubVN5c3RlbXNbaV0uZGlzcG9zZSgpO1xyXG5cclxuICAgIE1lc3NhZ2VEaXNwYXRjaGVyLmRpc3Bvc2UoKTtcclxuXHJcbiAgICB0aGlzLm1OdW1VcGRhdGVzID0gMDtcclxuICAgIHRoaXMubUZyYW1lTnVtID0gMDtcclxuICAgIEJsYWNrLmVuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXBcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX3VwZGF0ZSh0aW1lc3RhbXAsIGZvcmNlVXBkYXRlKSB7XHJcbiAgICBsZXQgdGltZSA9IEJsYWNrLnRpbWU7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIEZQU1xyXG4gICAgaWYgKHRoaXMubVBhdXNlZCA9PT0gdHJ1ZSAmJiB0aGlzLm1VbnBhdXNpbmcgPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5tVW5wYXVzaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICB0aGlzLm1MYXN0VXBkYXRlVGltZSA9IHRpbWVzdGFtcDtcclxuICAgICAgdGhpcy5tTGFzdFJlbmRlclRpbWUgPSB0aGlzLm1MYXN0VXBkYXRlVGltZTtcclxuXHJcbiAgICAgIHRoaXMuX19zZXRVbnBhdXNlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubVJBRkhhbmRsZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpfSAqLyh0aGlzLl9fdXBkYXRlKSk7XHJcblxyXG4gICAgaWYgKHRoaXMubVBhdXNlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGxldCBudW1UaWNrcyA9IE1hdGguZmxvb3IoKHRpbWVzdGFtcCAtIHRoaXMubUxhc3RVcGRhdGVUaW1lKSAvIHRpbWUubURlbHRhVGltZU1zKTtcclxuXHJcbiAgICBpZiAoZm9yY2VVcGRhdGUgPT09IHRydWUpXHJcbiAgICAgIG51bVRpY2tzID0gMTtcclxuXHJcbiAgICBpZiAobnVtVGlja3MgPiB0aGlzLm1NYXhVcGRhdGVzUGVyRnJhbWUpIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFBvc3RlZCB3aGVuIGVuZ2luZSBpcyBub3QgYWJsZSB0byBhY2hpZXZlIGRlc2lyZWQgYW1vdW50IG9mIHVwZGF0ZXMgcGVyIHNlY29uZC4gXHJcbiAgICAgICAqIFxyXG4gICAgICAgKiBVc3VhbGx5IGhhcHBlbnMgd2hlbiB1c2VyIHN3aXRjaGVzIHRvIGFub3RoZXIgdGFiIGluIGJyb3dzZXIgb3IgdXBkYXRlIGxvZ2ljIGlzIHRvbyBoZWF2eSB0byBiZSBleGVjdXRlZCBcclxuICAgICAgICogd2l0aGluZyBvbmUgdXBkYXRlIGxvb3AuIExvd2VyaW5nIGBCbGFjay51cHNgIHZhbHVlIGNhbiBoZWxwIGlmIHVwZGF0ZSBpcyBoZWF2eS4gXHJcbiAgICAgICAqIEluY3JlYXNpbmcgYEJsYWNrLm1heFVwZGF0ZXNQZXJGcmFtZWAgY2FuIGxlYWQgdG8gZGVhZCBsb2NrLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgRW5naW5lI2xvb3BlZFxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy5wb3N0KCdsb29wZWQnLCBudW1UaWNrcyk7XHJcbiAgICAgIERlYnVnLndhcm4oYFVuYWJsZSB0byBjYXRjaCB1cCAke251bVRpY2tzfSB1cGRhdGUocykuYCk7XHJcblxyXG4gICAgICBudW1UaWNrcyA9IHRoaXMubU1heFVwZGF0ZXNQZXJGcmFtZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1OdW1VcGRhdGVzID0gbnVtVGlja3M7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpY2tzOyBpKyspIHtcclxuICAgICAgdGltZS5tQWN0dWFsVGltZSArPSB0aW1lLmRlbHRhO1xyXG4gICAgICB0aW1lLm1UaW1lID0gdGltZS5tQWN0dWFsVGltZTtcclxuXHJcbiAgICAgIHRoaXMuX19pbnRlcm5hbFVwZGF0ZSgpO1xyXG4gICAgICB0aGlzLl9faW50ZXJuYWxTeXN0ZW1Qb3N0VXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgbCA9IHRpbWVzdGFtcCAtIHRpbWUubURlbHRhVGltZU1zOyB0aGlzLm1MYXN0VXBkYXRlVGltZSA8IGw7KVxyXG4gICAgICB0aGlzLm1MYXN0VXBkYXRlVGltZSArPSB0aW1lLm1EZWx0YVRpbWVNcztcclxuXHJcbiAgICBpZiAobnVtVGlja3MgPT09IDApXHJcbiAgICAgIHRpbWUubUFscGhhVGltZSA9ICh0aW1lc3RhbXAgLSB0aGlzLm1MYXN0VXBkYXRlVGltZSkgLyB0aW1lLm1EZWx0YVRpbWVNcztcclxuICAgIGVsc2VcclxuICAgICAgdGltZS5tQWxwaGFUaW1lID0gMDtcclxuXHJcbiAgICB0aW1lLm1UaW1lID0gdGltZS5tQWN0dWFsVGltZSArICgodGltZXN0YW1wIC0gdGhpcy5tTGFzdFVwZGF0ZVRpbWUpICogMC4wMDEpICogdGltZS5tU2NhbGU7XHJcblxyXG4gICAgdGhpcy5fX2ludGVybmFsU3lzdGVtUmVuZGVyKCk7XHJcbiAgICB0aGlzLm1WaWRlby5iZWdpbkZyYW1lKCk7XHJcbiAgICB0aGlzLm1WaWRlby5yZW5kZXIodGhpcy5tU3RhZ2UpO1xyXG4gICAgdGhpcy5tVmlkZW8uZW5kRnJhbWUoKTtcclxuXHJcbiAgICB0aGlzLm1GcmFtZU51bSsrO1xyXG5cclxuICAgIHRoaXMubUlzUGFuaWMgPSBmYWxzZTtcclxuICAgIFJlbmRlcmVyLl9fZGlydHkgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzLm1MYXN0UmVuZGVyVGltZSA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICBpZiAodGhpcy5tUGVuZGluZ0Rpc3Bvc2UgPT09IHRydWUpXHJcbiAgICAgIHRoaXMuX19kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgX19pbnRlcm5hbFVwZGF0ZSgpIHtcclxuICAgIHRoaXMubVZpZXdwb3J0Ll9fdXBkYXRlKCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uVXBkYXRlKCk7XHJcblxyXG4gICAgdGhpcy5tU3RhZ2UuX191cGRhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX2ludGVybmFsU3lzdGVtUG9zdFVwZGF0ZSgpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tU3lzdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy5tU3lzdGVtc1tpXS5vblBvc3RVcGRhdGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBfX2ludGVybmFsU3lzdGVtUmVuZGVyKCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uUmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiB0YWcgY2hhbmdlZCBmb3Igc3BlY2lmaWMgYEdhbWVPYmplY3RgLlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkICAgQSBnYW1lIG9iamVjdCBmaXJlZCB0aGUgZXZlbnQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gb2xkVGFnIE9sZCB0YWcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gbmV3VGFnIE5ldyB0YWcuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvblRhZ1VwZGF0ZWQoY2hpbGQsIG9sZFRhZywgbmV3VGFnKSB7XHJcbiAgICBpZiAob2xkVGFnICE9PSBudWxsKSB7XHJcbiAgICAgIGxldCBhcnIgPSB0aGlzLm1UYWdDYWNoZVtvbGRUYWddO1xyXG4gICAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGNoaWxkKSwgMSk7XHJcblxyXG4gICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICBkZWxldGUgdGhpcy5tVGFnQ2FjaGVbb2xkVGFnXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV3VGFnICE9PSBudWxsKSB7XHJcbiAgICAgIGlmICh0aGlzLm1UYWdDYWNoZS5oYXNPd25Qcm9wZXJ0eShuZXdUYWcpID09PSBmYWxzZSlcclxuICAgICAgICB0aGlzLm1UYWdDYWNoZVtuZXdUYWddID0gW107XHJcblxyXG4gICAgICB0aGlzLm1UYWdDYWNoZVtuZXdUYWddLnB1c2goY2hpbGQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gc3BlY2lmaWMgZ2FtZSBvYmplY3QgaXMgYWRkZWQgdG8gZGlzcGxheSBsaXN0LlxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqIEBwYXJhbSAge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBjaGlsZCBJbnN0YW5jZSBvZiBHYW1lT2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgb25DaGlsZHJlbkFkZGVkKGNoaWxkLCBwYXJlbnQpIHtcclxuICAgIGlmICghKHBhcmVudC5yb290IGluc3RhbmNlb2YgU3RhZ2UpKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgUmVuZGVyZXIuX19kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uQ2hpbGRyZW5BZGRlZChjaGlsZCk7XHJcblxyXG4gICAgR2FtZU9iamVjdC5mb3JFYWNoKGNoaWxkLCAoeCkgPT4ge1xyXG4gICAgICBpZiAoeC5tQWRkZWQgPT09IHRydWUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdGhpcy5vblRhZ1VwZGF0ZWQoeCwgbnVsbCwgeC5tVGFnKTtcclxuXHJcbiAgICAgIHgubUFkZGVkID0gdHJ1ZTtcclxuICAgICAgeC5vbkFkZGVkKCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHgubUNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHgubUNvbXBvbmVudHNbaV07XHJcblxyXG4gICAgICAgIGlmIChjLm1BZGRlZCA9PT0gdHJ1ZSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBjLm1BZGRlZCA9IHRydWU7XHJcbiAgICAgICAgYy5vbkFkZGVkKHgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHNwZWNpZmljIGdhbWUgb2JqZWN0IGlzIGNoYW5nZWQgaXRzIGluZGV4IGluIGRpc3BsYXkgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0ge2JsYWNrLWVuZ2luZX5HYW1lT2JqZWN0fSBjaGlsZCBJbnN0YW5jZSBvZiBHYW1lT2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgb25DaGlsZHJlbkNoYW5nZWQoY2hpbGQpIHtcclxuICAgIFJlbmRlcmVyLl9fZGlydHkgPSB0cnVlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tU3lzdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgdGhpcy5tU3lzdGVtc1tpXS5vbkNoaWxkcmVuQ2hhbmdlZChjaGlsZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBzcGVjaWZpYyBnYW1lIG9iamVjdCBpcyBhZGRlZCB0byBkaXNwbGF5IGxpc3QuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIEluc3RhbmNlIG9mIEdhbWVPYmplY3QuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvbkNoaWxkcmVuUmVtb3ZlZChjaGlsZCkge1xyXG4gICAgUmVuZGVyZXIuX19kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uQ2hpbGRyZW5SZW1vdmVkKGNoaWxkKTtcclxuXHJcbiAgICBHYW1lT2JqZWN0LmZvckVhY2goY2hpbGQsICh4KSA9PiB7XHJcbiAgICAgIGlmICh4Lm1BZGRlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMub25UYWdVcGRhdGVkKHgsIG51bGwsIHgubVRhZyk7XHJcblxyXG4gICAgICAgIHgubUFkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgeC5vblJlbW92ZWQoKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lm1Db21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgYyA9IHgubUNvbXBvbmVudHNbaV07XHJcblxyXG4gICAgICAgICAgaWYgKGMubUFkZGVkID09PSBmYWxzZSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgYy5tQWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGMub25SZW1vdmVkKHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBzcGVjaWZpYyBjb21wb25lbnQgaXMgYWRkZWQgdG8gR2FtZU9iamVjdCBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+R2FtZU9iamVjdH0gY2hpbGQgSW5zdGFuY2Ugb2YgR2FtZU9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtibGFjay1lbmdpbmV+Q29tcG9uZW50fSBjb21wb25lbnQgSW5zdGFuY2Ugb2YgQ29tcG9uZW50IGFkZGVkIHRvIGdhbWUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXHJcbiAgb25Db21wb25lbnRBZGRlZChjaGlsZCwgY29tcG9uZW50KSB7XHJcbiAgICBSZW5kZXJlci5fX2RpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubVN5c3RlbXMubGVuZ3RoOyBpKyspXHJcbiAgICAgIHRoaXMubVN5c3RlbXNbaV0ub25Db21wb25lbnRBZGRlZChjaGlsZCwgY29tcG9uZW50KTtcclxuXHJcbiAgICBpZiAoY29tcG9uZW50Lm1BZGRlZCA9PT0gdHJ1ZSlcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGNvbXBvbmVudC5tQWRkZWQgPSB0cnVlO1xyXG4gICAgY29tcG9uZW50Lm9uQWRkZWQoY2hpbGQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gc3BlY2lmaWMgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSBpdHMgb3duZXIuXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkdhbWVPYmplY3R9IGNoaWxkIEluc3RhbmNlIG9mIEdhbWVPYmplY3QuXHJcbiAgICogQHBhcmFtICB7YmxhY2stZW5naW5lfkNvbXBvbmVudH0gY29tcG9uZW50IEluc3RhbmNlIG9mIENvbXBvbmVudCByZW1vdmVkIGZyb20gZ2FtZSBvYmplY3QuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBvbkNvbXBvbmVudFJlbW92ZWQoY2hpbGQsIGNvbXBvbmVudCkge1xyXG4gICAgUmVuZGVyZXIuX19kaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1TeXN0ZW1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICB0aGlzLm1TeXN0ZW1zW2ldLm9uQ29tcG9uZW50UmVtb3ZlZChjaGlsZCwgY29tcG9uZW50KTtcclxuXHJcbiAgICBpZiAoY29tcG9uZW50Lm1BZGRlZCA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybjtcclxuXHJcbiAgICBjb21wb25lbnQubUFkZGVkID0gZmFsc2U7XHJcbiAgICBjb21wb25lbnQub25SZW1vdmVkKGNoaWxkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMvU2V0cyB0aGUgbnVtYmVyIG9mIHVwZGF0ZXMgc2hvdWxkIGJlIGRvbmUgcGVyIHNlY29uZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdXBzKCkge1xyXG4gICAgcmV0dXJuIEJsYWNrLnRpbWUubURlbHRhVGltZU1zICogMC4wMDE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCB1cHModmFsdWUpIHtcclxuICAgIERlYnVnLmlzTnVtYmVyKHZhbHVlKTtcclxuICAgIERlYnVnLmFzc2VydCh2YWx1ZSA+IDApO1xyXG5cclxuICAgIEJsYWNrLnRpbWUubURlbHRhVGltZU1zID0gMTAwMCAvIHZhbHVlO1xyXG4gICAgQmxhY2sudGltZS5tRGVsdGFUaW1lID0gQmxhY2sudGltZS5tRGVsdGFUaW1lTXMgKiAwLjAwMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmlld3BvcnQgaW5zdGFuY2UuIFVzZWQgdG8gZ2V0IHNpemUgb2YgYSBnYW1lIHNjcmVlbiwgb3IgbGlzdGVuIGZvciByZXNpemUgbWVzc2FnZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtibGFjay1lbmdpbmV+Vmlld3BvcnR9XHJcbiAgICovXHJcbiAgZ2V0IHZpZXdwb3J0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVZpZXdwb3J0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgRE9NIGVsZW1lbnQgdGhlIGVuZ2luZSBydW5zIGluLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKi9cclxuICBnZXQgY29udGFpbmVyRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1Db250YWluZXJFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cy9TZXRzIGlmIGVuZ2luZSBzaG91bGQgYmUgYXV0b21hdGljYWxseSBwYXVzZWQgd2hlbiB3aW5kb3cgaXMgaGlkZGVuLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgcGF1c2VPbkhpZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tUGF1c2VPbkhpZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cclxuICBzZXQgcGF1c2VPbkhpZGUodmFsdWUpIHtcclxuICAgIHRoaXMubVBhdXNlT25IaWRlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL1NldHMgaWYgZW5naW5lIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IHBhdXNlZCB3aGVuIGNvbnRhaW5lciBlbGVtZW50IGlzIGJsdXJyZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBwYXVzZU9uQmx1cigpIHtcclxuICAgIHJldHVybiB0aGlzLm1QYXVzZU9uQmx1cjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xyXG4gIHNldCBwYXVzZU9uQmx1cih2YWx1ZSkge1xyXG4gICAgdGhpcy5tUGF1c2VPbkJsdXIgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgVHJ1ZSBpZiBlbmdpbmUgaXMgcGF1c2VkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IGlzUGF1c2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY3VycmVudCBzdGFnZS5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtibGFjay1lbmdpbmV+U3RhZ2V9XHJcbiAgICovXHJcbiAgZ2V0IHN0YWdlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubVN0YWdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBIVE1MIGNvbnRhaW5lciBlbGVtZW50IGlkLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0IGNvbnRhaW5lckVsZW1lbnRJZCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1Db250YWluZXJFbGVtZW50SWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzL3NldHMgd2hlbmV2ZXIgZHJpdmVyIHNob3VsZCBiZSBjcmVhdGVkIHdpdGggaGlnaCBEUFIgc3VwcG9ydC4gXHJcbiAgICogTk9URTogQ2Fubm90IGJlIGNoYW5nZWQgYXQgcnVudGltZS5cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgdXNlSGlEUFIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tVXNlSGlEUFI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IHVzZUhpRFBSKHZhbHVlKSB7XHJcbiAgICB0aGlzLm1Vc2VIaURQUiA9IHZhbHVlO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIGZyYW1lIHNpbmNlIGVuZ2luZSBzdGFydC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGZyYW1lTnVtKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubUZyYW1lTnVtO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIGhvdyBtYW55IHVwZGF0ZXMgd2lsbCBiZSBkb25lIGR1cmluZyB0aGlzIGZyYW1lLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbnVtVXBkYXRlcygpIHtcclxuICAgIHJldHVybiB0aGlzLm1OdW1VcGRhdGVzO1xyXG4gIH1cclxuXHJcbiAgLyoqIFxyXG4gICAqIExpbWl0IGZvciBudW1iZXIgb2YgdXBkYXRlcyB0byBiZSBkb25lIHBlciBvbmUgUkFGLlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IG1heFVwZGF0ZXNQZXJGcmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1NYXhVcGRhdGVzUGVyRnJhbWU7XHJcbiAgfVxyXG5cclxuICAvKiogXHJcbiAgICogTGltaXQgZm9yIG51bWJlciBvZiB1cGRhdGVzIHRvIGJlIGRvbmUgcGVyIG9uZSBSQUYuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICovXHJcbiAgc2V0IG1heFVwZGF0ZXNQZXJGcmFtZSh2YWx1ZSkge1xyXG4gICAgdGhpcy5tTWF4VXBkYXRlc1BlckZyYW1lID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBBY2NlbGVyYXRpb24sIEFscGhhT3ZlckxpZmUsIEFuY2hvck92ZXJMaWZlLCBBbmltYXRpb25Db250cm9sbGVyLCBBbmltYXRpb25JbmZvLCBBcmNhZGUsIEFzc2V0LCBBc3NldExvYWRlciwgQXNzZXRNYW5hZ2VyLCBBc3NldE1hbmFnZXJTdGF0ZSwgQXNzZXRUeXBlLCBBdGxhc1RleHR1cmUsIEF0bGFzVGV4dHVyZUFzc2V0LCBCVkdBc3NldCwgQlZHUGFyc2VyLCBCVkdTdHlsZSwgQmluZGluZ1R5cGUsIEJpdG1hcEZvbnRBc3NldCwgQml0bWFwRm9udENoYXJEYXRhLCBCaXRtYXBGb250RGF0YSwgQml0bWFwVGV4dEZpZWxkLCBCaXRtYXBUZXh0UmVuZGVyZXIsIEJpdG1hcFRleHRSZW5kZXJlckNhbnZhcywgQmxhY2ssIEJsZW5kTW9kZSwgQm94Q29sbGlkZXIsIEJveFRvQm94UGFpciwgQm94VG9DaXJjbGVQYWlyLCBCcm9hZFBoYXNlLCBDYW1lcmEsIENhbnZhc0RyaXZlciwgQ2FudmFzUmVuZGVyVGV4dHVyZSwgQ2Fwc1N0eWxlLCBDaXJjbGUsIENpcmNsZUNvbGxpZGVyLCBDaXJjbGVUb0NpcmNsZVBhaXIsIENvbGxpZGVyLCBDb2xvckhlbHBlciwgQ29sb3JPdmVyTGlmZSwgQ29sb3JTY2F0dGVyLCBDb2xvclNjYXR0ZXJCYXNlLCBDb21wb25lbnQsIEN1cnZlLCBEZWJ1ZywgRGV2aWNlLCBEaXNwbGF5T2JqZWN0LCBEaXNwbGF5T2JqZWN0UmVuZGVyZXJDYW52YXMsIERpc3RvcnRpb25FZmZlY3QsIEVhc2UsIEVtaXR0ZXIsIEVtaXR0ZXJSZW5kZXJlckNhbnZhcywgRW1pdHRlclNvcnRPcmRlciwgRW1pdHRlclN0YXRlLCBFbmdpbmUsIEZpbGxSdWxlLCBGbG9hdEN1cnZlU2NhdHRlciwgRmxvYXRTY2F0dGVyLCBGbG9hdFNjYXR0ZXJCYXNlLCBGb250QWxpZ24sIEZvbnRBc3NldCwgRm9udEZhY2VBc3NldExvYWRlciwgRm9udE1ldHJpY3MsIEZvbnRTdHlsZSwgRm9udFZlcnRpY2FsQWxpZ24sIEZvbnRXZWlnaHQsIEdhbWVPYmplY3QsIEdsb2IsIEdyYXBoaWNzLCBHcmFwaGljc0NvbW1hbmQsIEdyYXBoaWNzQ29tbWFuZFR5cGUsIEdyYXBoaWNzRGF0YSwgR3JhcGhpY3NHcmFkaWVudCwgR3JhcGhpY3NMaW5lYXJHcmFkaWVudCwgR3JhcGhpY3NQYXRoLCBHcmFwaGljc1BhdHRlcm4sIEdyYXBoaWNzUmVuZGVyZXIsIEdyYXBoaWNzUmVuZGVyZXJDYW52YXMsIEhTViwgSW1hZ2VBc3NldExvYWRlciwgSW5pdGlhbEFuY2hvciwgSW5pdGlhbENvbG9yLCBJbml0aWFsTGlmZSwgSW5pdGlhbE1hc3MsIEluaXRpYWxQb3NpdGlvbiwgSW5pdGlhbFJvdGF0aW9uLCBJbml0aWFsU2NhbGUsIEluaXRpYWxUZXh0dXJlLCBJbml0aWFsVmVsb2NpdHksIElucHV0LCBJbnB1dENvbXBvbmVudCwgSW50ZXJwb2xhdGlvbiwgSlNPTkFzc2V0LCBKb2ludFN0eWxlLCBLZXksIEtleUluZm8sIExpbmUsIExvYWRlclR5cGUsIE1hcE1hcCwgTWFzdGVyQXVkaW8sIE1hdGhFeCwgTWF0cml4LCBNZXNzYWdlLCBNZXNzYWdlQmluZGluZywgTWVzc2FnZURpc3BhdGNoZXIsIE1lc3NhZ2VUeXBlLCBNb2RpZmllciwgT2JqZWN0UG9vbCwgT3JpZW50YXRpb24sIE9yaWVudGVkLCBQYWlyLCBQYXJzZXJCYXNlLCBQYXJ0aWNsZSwgUGVybGluLCBQb2x5Z29uLCBQcm9qZWN0aW9uLCBSR0IsIFJhZGlhbFNjYXR0ZXIsIFJhbmdlLCBSZWN0YW5nbGUsIFJlbmRlclNlc3Npb24sIFJlbmRlclRhcmdldCwgUmVuZGVyVGFyZ2V0Q2FudmFzLCBSZW5kZXJlciwgUmV2ZXJiRWZmZWN0LCBSaWdpZEJvZHksIFJvdGF0aW9uT3ZlckxpZmUsIFNjYWxlT3ZlckxpZmUsIFNjYXR0ZXIsIFNpbXBsZUVRLCBTb3VuZCwgU291bmRBc3NldCwgU291bmRBdGxhc0Fzc2V0LCBTb3VuZEF0bGFzQ2xpcCwgU291bmRDaGFubmVsLCBTb3VuZENsaXAsIFNvdW5kRWZmZWN0LCBTb3VuZEluc3RhbmNlLCBTb3VuZExpc3RlbmVyLCBTb3VuZFN0YXRlLCBTcGluZSwgU3BsYXNoU2NyZWVuLCBTcHJpdGUsIFNwcml0ZVJlbmRlcmVyQ2FudmFzLCBTdGFnZSwgU3RhZ2VTY2FsZU1vZGUsIFN0ZXJlb1Bhbm5lciwgU3lzdGVtLCBUZXh0RmllbGQsIFRleHRNZXRyaWNzRGF0YSwgVGV4dE1ldHJpY3NFeCwgVGV4dFJlbmRlcmVyLCBUZXh0UmVuZGVyZXJDYW52YXMsIFRleHRTZWdtZW50TWV0cmljc0RhdGEsIFRleHRTdHlsZSwgVGV4dHVyZSwgVGV4dHVyZUFzc2V0LCBUZXh0dXJlT3ZlckxpZmUsIFRpbGluZ0luZm8sIFRpbWUsIFRpbWVyLCBUd2VlbiwgVmVjdG9yLCBWZWN0b3JDdXJ2ZVNjYXR0ZXIsIFZlY3RvckZpZWxkLCBWZWN0b3JTY2F0dGVyLCBWZWN0b3JTY2F0dGVyQmFzZSwgVmVjdG9yVGV4dHVyZUFzc2V0LCBWaWRlb051bGxEcml2ZXIsIFZpZXdwb3J0LCBYSFJBc3NldExvYWRlciwgWE1MQXNzZXQgfTtcclxuIiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcInBhcnRpY2xlLWRhMDc0NDA4LnBuZ1wiOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJwb3BhcnRfYW52aWwtZmYyZTUzMmIucG5nXCI7IiwiaW1wb3J0IHsgRW5naW5lLCBBY2NlbGVyYXRpb24sIEFzc2V0TWFuYWdlciwgQmxhY2ssIEJsZW5kTW9kZSwgQ29sb3JIZWxwZXIsIENvbG9yT3ZlckxpZmUsIEVhc2UsIEVtaXR0ZXIsIEZsb2F0U2NhdHRlciwgRm9udFN0eWxlLCBGb250V2VpZ2h0LCBHYW1lT2JqZWN0LCBJbml0aWFsTGlmZSwgSW5pdGlhbFZlbG9jaXR5LCBTY2FsZU92ZXJMaWZlLCBTcHJpdGUsIFRleHRGaWVsZCwgVHdlZW4gfSBmcm9tICdibGFjay1lbmdpbmUnO1xyXG5pbXBvcnQgcGFydGljbGUgZnJvbSAnLi9hc3NldHMvdGV4dHVyZXMvcGFydGljbGUucG5nJztcclxuaW1wb3J0IGFudmlsIGZyb20gJy4vYXNzZXRzL3RleHR1cmVzL3BvcGFydF9hbnZpbC5wbmcnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEdhbWUgZXh0ZW5kcyBHYW1lT2JqZWN0IHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgLy8gUGljayBkZWZhdWx0IEFzc2V0TWFuYWdlclxyXG4gICAgdmFyIGFzc2V0cyA9IG5ldyBBc3NldE1hbmFnZXIoKTtcclxuXHJcbiAgICAvLyBsb2FkIGltYWdlcywgbWFrZSBzdXJlIHRvIGltcG9ydCB0aGVtIGZpcnN0XHJcbiAgICBhc3NldHMuZW5xdWV1ZUltYWdlKCdhbnZpbCcsIGFudmlsKTtcclxuICAgIGFzc2V0cy5lbnF1ZXVlSW1hZ2UoJ3N0YXInLCBwYXJ0aWNsZSk7XHJcblxyXG4gICAgLy8gbG9hZCBmb250XHJcbiAgICBhc3NldHMuZW5xdWV1ZUdvb2dsZUZvbnQoJ1RpdGlsbGl1bSBXZWInKTtcclxuXHJcbiAgICAvLyBMaXN0ZW4gZm9yIGEgY29tcGxldGUgbWVzc2FnZVxyXG4gICAgYXNzZXRzLm9uKCdjb21wbGV0ZScsIHRoaXMub25Bc3NldHNMb2FkZGVkLCB0aGlzKTtcclxuXHJcbiAgICAvLyBTdGFydCBwcmVsb2FkaW5nIGFsbCBlbnF1ZXVlZCBhc3NldHNcclxuICAgIGFzc2V0cy5sb2FkUXVldWUoKTtcclxuICB9XHJcblxyXG4gIG9uQXNzZXRzTG9hZGRlZChtKSB7XHJcbiAgICAvLyBDcmVhdGUgYSBzcHJpdGVcclxuICAgIGxldCBzcHJpdGUgPSBuZXcgU3ByaXRlKCdhbnZpbCcpO1xyXG4gICAgc3ByaXRlLmFsaWduUGl2b3RPZmZzZXQoMC41LCAxKTtcclxuXHJcbiAgICBzcHJpdGUueCA9IHRoaXMuc3RhZ2UuY2VudGVyWDtcclxuICAgIHNwcml0ZS55ID0gdGhpcy5zdGFnZS5jZW50ZXJZICsgMjAwO1xyXG5cclxuICAgIC8vIG1ha2UgdGhpcyBnYW1lIG9iamVjdCB0b3VjaGFibGUgc28gY2hpbGRyZW4gZWxlbWVudHMgY2FuIGJlIGFibGUgdG8gcmVjZWl2ZSBpbnB1dCB0b29cclxuICAgIHRoaXMudG91Y2hhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBzcHJpdGUgYWxzbyBuZWVkcyB0byBiZSB0b3VjaGFibGVcclxuICAgIHNwcml0ZS50b3VjaGFibGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGVtaXR0ZXJcclxuICAgIGxldCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgIGVtaXR0ZXIuc3BhY2UgPSB0aGlzLnBhcmVudDtcclxuICAgIGVtaXR0ZXIuYmxlbmRNb2RlID0gQmxlbmRNb2RlLkFERDtcclxuICAgIGVtaXR0ZXIueCA9IHRoaXMuc3RhZ2UuY2VudGVyWCArIDEwO1xyXG5cclxuICAgIGVtaXR0ZXIuZW1pdENvdW50ID0gbmV3IEZsb2F0U2NhdHRlcigzMCk7XHJcbiAgICBlbWl0dGVyLmVtaXREZWxheSA9IG5ldyBGbG9hdFNjYXR0ZXIoMCk7XHJcbiAgICBlbWl0dGVyLmVtaXRJbnRlcnZhbCA9IG5ldyBGbG9hdFNjYXR0ZXIoMCk7XHJcbiAgICBlbWl0dGVyLmVtaXREdXJhdGlvbiA9IG5ldyBGbG9hdFNjYXR0ZXIoSW5maW5pdHkpO1xyXG4gICAgZW1pdHRlci5lbWl0TnVtUmVwZWF0cyA9IG5ldyBGbG9hdFNjYXR0ZXIoSW5maW5pdHkpO1xyXG4gICAgZW1pdHRlci50ZXh0dXJlcyA9IFtCbGFjay5hc3NldHMuZ2V0VGV4dHVyZSgnc3RhcicpXTtcclxuXHJcbiAgICBlbWl0dGVyLmFkZChuZXcgSW5pdGlhbExpZmUoMC4zLCAwLjkpKTtcclxuICAgIGVtaXR0ZXIuYWRkKG5ldyBJbml0aWFsVmVsb2NpdHkoLTUwLCAwLCA1MCwgLTIwMCkpO1xyXG4gICAgZW1pdHRlci5hZGQobmV3IEFjY2VsZXJhdGlvbigtNTAwLCAtNTAwLCA1MDAsIDgwMCkpO1xyXG4gICAgZW1pdHRlci5hZGQobmV3IENvbG9yT3ZlckxpZmUoMHhmMTZjMjAsIDB4ZmMzYWE0KSk7XHJcbiAgICBlbWl0dGVyLmFkZChuZXcgU2NhbGVPdmVyTGlmZShuZXcgRmxvYXRTY2F0dGVyKDEuMiwgMCwgRWFzZS5leHBvbmVudGlhbEluKSkpO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKHRoaXMuc3RhZ2UpO1xyXG5cclxuICAgIGVtaXR0ZXIueSA9IHRoaXMuc3RhZ2UuYm91bmRzLnkgLSA1MDA7XHJcblxyXG4gICAgbGV0IHR3ZWVuID0gbmV3IFR3ZWVuKHsgeTogWzAsIHNwcml0ZS55IC0gMTEwXSB9LCAxLCB7IGxvb3A6IHRydWUsIHJlcGVhdERlbGF5OiAxIH0pO1xyXG4gICAgZW1pdHRlci5hZGQodHdlZW4pO1xyXG5cclxuICAgIC8vIFR3ZWVuIHNwcml0ZSBjb2xvclxyXG4gICAgc3ByaXRlLmNvbG9yID0gMHhmZmZmZmY7XHJcbiAgICBzcHJpdGUuYWRkKG5ldyBUd2Vlbih7IGNvbG9yOiBbMHhmZmZmYWEsIDB4ZmYwMDAwLCAweGZmZmZhYV0gfSwgMC41LCB7IGRlbGF5OiAwLjcsIGxvb3A6IHRydWUsIHJlcGVhdERlbGF5OiAxLjUgfSwgeyBjb2xvcjogQ29sb3JIZWxwZXIubGVycEhTViB9KSk7XHJcbiAgICBzcHJpdGUuYWRkKG5ldyBUd2Vlbih7IHNjYWxlWTogWzEsIDAuOSwgMV0gfSwgMC41LCB7IGRlbGF5OiAwLjY5LCBsb29wOiB0cnVlLCByZXBlYXREZWxheTogMS41IH0pKTtcclxuXHJcbiAgICBsZXQgdGV4dEZpZWxkID0gbmV3IFRleHRGaWVsZCgnQmxhY2sgRW5naW5lIHYwLjUuMTAnLCAnVGl0aWxsaXVtIFdlYicsIDB4ZmZmZmZmLCAxNSwgRm9udFN0eWxlLk5PUk1BTCwgRm9udFdlaWdodC5CT0xEKTtcclxuICAgIHRleHRGaWVsZC5oaWdoUXVhbGl0eSA9IHRydWU7XHJcbiAgICB0ZXh0RmllbGQueCA9IHRoaXMuc3RhZ2UuYm91bmRzLng7XHJcbiAgICB0ZXh0RmllbGQueSA9IHRoaXMuc3RhZ2UuYm91bmRzLnk7XHJcblxyXG4gICAgLy8gQWRkIHNwcml0ZSwgdGV4dCBhbmQgZW1pdHRlciBvbnRvIHRoZSBzdGFnZVxyXG4gICAgdGhpcy5hZGQoZW1pdHRlciwgc3ByaXRlLCB0ZXh0RmllbGQpO1xyXG5cclxuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xyXG4gICAgdGhpcy5lbWl0dGVyID0gZW1pdHRlcjtcclxuICAgIHRoaXMudGV4dCA9IHRleHRGaWVsZDtcclxuXHJcbiAgICB0aGlzLnN0YWdlLm9uKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCB0aGlzKTtcclxuICB9XHJcblxyXG4gIG9uUmVzaXplKCkge1xyXG4gICAgdGhpcy50ZXh0LnggPSB0aGlzLnN0YWdlLmJvdW5kcy54O1xyXG4gICAgdGhpcy50ZXh0LnkgPSB0aGlzLnN0YWdlLmJvdW5kcy55O1xyXG4gIH1cclxufSIsImltcG9ydCB7IEJsYWNrLCBDYW52YXNEcml2ZXIsIElucHV0LCBFbmdpbmUsIFN0YWdlU2NhbGVNb2RlIH0gZnJvbSBcImJsYWNrLWVuZ2luZVwiO1xuaW1wb3J0IHsgR2FtZSB9IGZyb20gXCIuL2dhbWVcIjtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvbkRldmljZVJlYWR5LCBmYWxzZSk7XG5cbmZ1bmN0aW9uIG9uRGV2aWNlUmVhZHkoKSB7XG4gICAgLy8gQ29yZG92YSBpcyBub3cgaW5pdGlhbGl6ZWQuIEhhdmUgZnVuIVxuICAgIG1haW4oKTtcbn1cblxuZnVuY3Rpb24gbWFpbigpIHtcblx0Ly8gR2FtZSB3aWxsIGJlIG91ciBzdGFydGluZyBjbGFzcyBhbmQgcmVuZGVyaW5nIHdpbGwgYmUgZG9uZSBvbiBDYW52YXNcblx0Y29uc3QgZW5naW5lID0gbmV3IEVuZ2luZSgnYXBwJywgR2FtZSwgQ2FudmFzRHJpdmVyLCBbSW5wdXRdKTtcblxuXHQvLyBQYXVzZSBzaW11bGF0aW9uIHdoZW4gYXBwIGxvc2VzIGZvY3VzXG5cdGVuZ2luZS5wYXVzZU9uQmx1ciA9IGZhbHNlO1xuXG5cdC8vIFBhdXNlIHNpbXVsYXRpb24gd2hlbiBwYWdlIGlzIGdldHRpbmcgaGlkZGVuXG5cdGVuZ2luZS5wYXVzZU9uSGlkZSA9IGZhbHNlO1xuXG5cdC8vIFdyb29tLCB3cm9vbSFcblx0ZW5naW5lLnN0YXJ0KCk7XG5cblx0Ly8gLy8gU2V0IGRlZmF1bHQgc3RhZ2Ugc2l6ZVxuXHRlbmdpbmUuc3RhZ2Uuc2V0U2l6ZSg5MDAsIDUwMCk7XG5cblx0Ly8gLy8gTWFrZXMgc3RhZ2UgYWx3YXlzIGNlbnRlcmVkXG5cdGVuZ2luZS5zdGFnZS5zY2FsZU1vZGUgPSBTdGFnZVNjYWxlTW9kZS5MRVRURVJCT1g7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9